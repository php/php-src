/*
   +----------------------------------------------------------------------+
   | Zend Engine                                                          |
   +----------------------------------------------------------------------+
   | Copyright (c) Zend Technologies Ltd. (http://www.zend.com)           |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.00 of the Zend license,     |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.zend.com/license/2_00.txt.                                |
   | If you did not receive a copy of the Zend license and are unable to  |
   | obtain it through the world-wide-web, please send a note to          |
   | license@zend.com so we can mail you a copy immediately.              |
   +----------------------------------------------------------------------+
   | Authors: Andi Gutmans <andi@php.net>                                 |
   |          Zeev Suraski <zeev@php.net>                                 |
   |          Dmitry Stogov <dmitry@php.net>                              |
   +----------------------------------------------------------------------+
*/

#ifdef ZEND_WIN32
# pragma warning(disable : 4101)
# pragma warning(once : 6235)
# pragma warning(once : 6237)
# pragma warning(once : 6239)
# pragma warning(once : 6240)
# pragma warning(once : 6285)
# pragma warning(once : 6286)
# pragma warning(once : 6326)
#endif
static user_opcode_handler_t zend_user_opcode_handlers[256] = {
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL
};

static zend_uchar zend_user_opcodes[256] = {0,
	1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,
	17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,
	33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,
	49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,
	65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,
	81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,
	97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,
	113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,
	129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,
	145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,
	161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,
	177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,
	193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,
	209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,
	225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,
	241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
};

#define SPEC_START_MASK        0x0000ffff
#define SPEC_EXTRA_MASK        0xfffc0000
#define SPEC_RULE_OP1          0x00010000
#define SPEC_RULE_OP2          0x00020000
#define SPEC_RULE_OP_DATA      0x00040000
#define SPEC_RULE_RETVAL       0x00080000
#define SPEC_RULE_QUICK_ARG    0x00100000
#define SPEC_RULE_SMART_BRANCH 0x00200000
#define SPEC_RULE_COMMUTATIVE  0x00800000
#define SPEC_RULE_ISSET        0x01000000
#define SPEC_RULE_OBSERVER     0x02000000

static const uint32_t *zend_spec_handlers;
static const void * const *zend_opcode_handlers;
static int zend_handlers_count;
#if (ZEND_VM_KIND == ZEND_VM_KIND_HYBRID)
static const void * const * zend_opcode_handler_funcs;
static zend_op hybrid_halt_op;
#endif
#if (ZEND_VM_KIND != ZEND_VM_KIND_HYBRID) || !ZEND_VM_SPEC
static const void *zend_vm_get_opcode_handler(zend_uchar opcode, const zend_op* op);
#endif

#if (ZEND_VM_KIND == ZEND_VM_KIND_HYBRID)
static const void *zend_vm_get_opcode_handler_func(zend_uchar opcode, const zend_op* op);
#else
# define zend_vm_get_opcode_handler_func zend_vm_get_opcode_handler
#endif

#ifndef VM_TRACE
# define VM_TRACE(op)
#endif
#ifndef VM_TRACE_START
# define VM_TRACE_START()
#endif
#ifndef VM_TRACE_END
# define VM_TRACE_END()
#endif
#if (ZEND_VM_KIND == ZEND_VM_KIND_HYBRID)
#define HYBRID_NEXT()     goto *(void**)(OPLINE->handler)
#define HYBRID_SWITCH()   HYBRID_NEXT();
#define HYBRID_CASE(op)   op ## _LABEL
#define HYBRID_BREAK()    HYBRID_NEXT()
#define HYBRID_DEFAULT    ZEND_NULL_LABEL
#endif

#ifdef ZEND_VM_FP_GLOBAL_REG
# define ZEND_OPCODE_HANDLER_ARGS void
# define ZEND_OPCODE_HANDLER_ARGS_PASSTHRU
# define ZEND_OPCODE_HANDLER_ARGS_DC
# define ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC
#else
# define ZEND_OPCODE_HANDLER_ARGS zend_execute_data *execute_data
# define ZEND_OPCODE_HANDLER_ARGS_PASSTHRU execute_data
# define ZEND_OPCODE_HANDLER_ARGS_DC , ZEND_OPCODE_HANDLER_ARGS
# define ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC , ZEND_OPCODE_HANDLER_ARGS_PASSTHRU
#endif

#if defined(ZEND_VM_FP_GLOBAL_REG) && defined(ZEND_VM_IP_GLOBAL_REG)
# define ZEND_OPCODE_HANDLER_RET void
# define ZEND_VM_TAIL_CALL(call) call; return
# ifdef ZEND_VM_TAIL_CALL_DISPATCH
#  define ZEND_VM_CONTINUE()     ((opcode_handler_t)OPLINE->handler)(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU); return
# else
#  define ZEND_VM_CONTINUE()     return
# endif
# if (ZEND_VM_KIND == ZEND_VM_KIND_HYBRID)
#  define ZEND_VM_RETURN()        opline = &hybrid_halt_op; return
#  define ZEND_VM_HOT             zend_always_inline ZEND_COLD ZEND_OPT_SIZE
#  define ZEND_VM_COLD            ZEND_COLD ZEND_OPT_SIZE
# else
#  define ZEND_VM_RETURN()        opline = NULL; return
#  define ZEND_VM_HOT
#  define ZEND_VM_COLD            ZEND_COLD ZEND_OPT_SIZE
# endif
#else
# define ZEND_OPCODE_HANDLER_RET int
# define ZEND_VM_TAIL_CALL(call) return call
# define ZEND_VM_CONTINUE()      return  0
# define ZEND_VM_RETURN()        return -1
# define ZEND_VM_HOT
# define ZEND_VM_COLD            ZEND_COLD ZEND_OPT_SIZE
#endif

typedef ZEND_OPCODE_HANDLER_RET (ZEND_FASTCALL *opcode_handler_t) (ZEND_OPCODE_HANDLER_ARGS);

#define DCL_OPLINE
#ifdef ZEND_VM_IP_GLOBAL_REG
# define OPLINE opline
# define USE_OPLINE
# define LOAD_OPLINE() opline = EX(opline)
# define LOAD_OPLINE_EX()
# define LOAD_NEXT_OPLINE() opline = EX(opline) + 1
# define SAVE_OPLINE() EX(opline) = opline
# define SAVE_OPLINE_EX() SAVE_OPLINE()
#else
# define OPLINE EX(opline)
# define USE_OPLINE const zend_op *opline = EX(opline);
# define LOAD_OPLINE()
# define LOAD_OPLINE_EX()
# define LOAD_NEXT_OPLINE() ZEND_VM_INC_OPCODE()
# define SAVE_OPLINE()
# define SAVE_OPLINE_EX()
#endif
#define HANDLE_EXCEPTION() ZEND_ASSERT(EG(exception)); LOAD_OPLINE(); ZEND_VM_CONTINUE()
#define HANDLE_EXCEPTION_LEAVE() ZEND_ASSERT(EG(exception)); LOAD_OPLINE(); ZEND_VM_LEAVE()
#if defined(ZEND_VM_FP_GLOBAL_REG)
# define ZEND_VM_ENTER_EX()        ZEND_VM_INTERRUPT_CHECK(); ZEND_VM_CONTINUE()
# define ZEND_VM_ENTER()           execute_data = EG(current_execute_data); LOAD_OPLINE(); ZEND_VM_ENTER_EX()
# define ZEND_VM_LEAVE()           ZEND_VM_CONTINUE()
#elif defined(ZEND_VM_IP_GLOBAL_REG)
# define ZEND_VM_ENTER_EX()        return  1
# define ZEND_VM_ENTER()           opline = EG(current_execute_data)->opline; ZEND_VM_ENTER_EX()
# define ZEND_VM_LEAVE()           return  2
#else
# define ZEND_VM_ENTER_EX()        return  1
# define ZEND_VM_ENTER()           return  1
# define ZEND_VM_LEAVE()           return  2
#endif
#define ZEND_VM_INTERRUPT()      ZEND_VM_TAIL_CALL(zend_interrupt_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
#define ZEND_VM_LOOP_INTERRUPT() zend_interrupt_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#define ZEND_VM_DISPATCH(opcode, opline) ZEND_VM_TAIL_CALL(((opcode_handler_t)zend_vm_get_opcode_handler_func(opcode, opline))(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_interrupt_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS);
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS);

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_add_helper_SPEC(zval *op_1, zval *op_2 ZEND_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(Z_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(Z_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	add_function(EX_VAR(opline->result.var), op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_sub_helper_SPEC(zval *op_1, zval *op_2 ZEND_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(Z_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(Z_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	sub_function(EX_VAR(opline->result.var), op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_mul_helper_SPEC(zval *op_1, zval *op_2 ZEND_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(Z_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(Z_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	mul_function(EX_VAR(opline->result.var), op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static zend_never_inline ZEND_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_mod_by_zero_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	zend_throw_exception_ex(zend_ce_division_by_zero_error, 0, "Modulo by zero");
	ZVAL_UNDEF(EX_VAR(opline->result.var));
	HANDLE_EXCEPTION();
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_mod_helper_SPEC(zval *op_1, zval *op_2 ZEND_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(Z_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(Z_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	mod_function(EX_VAR(opline->result.var), op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_shift_left_helper_SPEC(zval *op_1, zval *op_2 ZEND_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(Z_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(Z_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	shift_left_function(EX_VAR(opline->result.var), op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_shift_right_helper_SPEC(zval *op_1, zval *op_2 ZEND_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(Z_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(Z_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	shift_right_function(EX_VAR(opline->result.var), op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_is_equal_helper_SPEC(zval *op_1, zval *op_2 ZEND_OPCODE_HANDLER_ARGS_DC)
{
	int ret;
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(Z_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(Z_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	ret = zend_compare(op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	ZEND_VM_SMART_BRANCH(ret == 0, 1);
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_is_not_equal_helper_SPEC(zval *op_1, zval *op_2 ZEND_OPCODE_HANDLER_ARGS_DC)
{
	int ret;
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(Z_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(Z_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	ret = zend_compare(op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	ZEND_VM_SMART_BRANCH(ret != 0, 1);
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_is_smaller_helper_SPEC(zval *op_1, zval *op_2 ZEND_OPCODE_HANDLER_ARGS_DC)
{
	int ret;
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(Z_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(Z_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	ret = zend_compare(op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	ZEND_VM_SMART_BRANCH(ret < 0, 1);
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_is_smaller_or_equal_helper_SPEC(zval *op_1, zval *op_2 ZEND_OPCODE_HANDLER_ARGS_DC)
{
	int ret;
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(Z_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(Z_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	ret = zend_compare(op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	ZEND_VM_SMART_BRANCH(ret <= 0, 1);
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_bw_or_helper_SPEC(zval *op_1, zval *op_2 ZEND_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(Z_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(Z_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	bitwise_or_function(EX_VAR(opline->result.var), op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_bw_and_helper_SPEC(zval *op_1, zval *op_2 ZEND_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(Z_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(Z_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	bitwise_and_function(EX_VAR(opline->result.var), op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_bw_xor_helper_SPEC(zval *op_1, zval *op_2 ZEND_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(Z_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(Z_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	bitwise_xor_function(EX_VAR(opline->result.var), op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_bw_not_helper_SPEC(zval *op_1 ZEND_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(Z_TYPE_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	bitwise_not_function(EX_VAR(opline->result.var), op_1);
	FREE_OP(opline->op1_type, opline->op1.var);
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static zend_never_inline ZEND_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_this_not_in_object_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	zend_throw_error(NULL, "Using $this when not in object context");
	UNDEF_RESULT();
	HANDLE_EXCEPTION();
}

static zend_never_inline ZEND_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_undefined_function_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;

	SAVE_OPLINE();
	function_name = RT_CONSTANT(opline, opline->op2);
	zend_throw_error(NULL, "Call to undefined function %s()", Z_STRVAL_P(function_name));
	HANDLE_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_STATIC_PROP_OP_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	/* This helper actually never will receive IS_VAR as second op, and has the same handling for VAR and TMP in the first op, but for interoperability with the other binary_assign_op helpers, it is necessary to "include" it */

	USE_OPLINE
	zval *prop, *value;
	zend_property_info *prop_info;
	zend_reference *ref;

	SAVE_OPLINE();

	if (UNEXPECTED(zend_fetch_static_property_address(&prop, &prop_info, (opline+1)->extended_value, BP_VAR_RW, 0 OPLINE_CC EXECUTE_DATA_CC) != SUCCESS)) {
		UNDEF_RESULT();
		FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
		HANDLE_EXCEPTION();
	}

	value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

	do {
		if (UNEXPECTED(Z_ISREF_P(prop))) {
			ref = Z_REF_P(prop);
			prop = Z_REFVAL_P(prop);
			if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
				zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}

		if (UNEXPECTED(ZEND_TYPE_IS_SET(prop_info->type))) {
			/* special case for typed properties */
			zend_binary_assign_op_typed_prop(prop_info, prop, value OPLINE_CC EXECUTE_DATA_CC);
		} else {
			zend_binary_op(prop, prop, value OPLINE_CC);
		}
	} while (0);

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), prop);
	}

	FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	/* assign_static_prop has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_INC_STATIC_PROP_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *prop;
	zend_property_info *prop_info;

	SAVE_OPLINE();

	if (zend_fetch_static_property_address(&prop, &prop_info, opline->extended_value, BP_VAR_RW, 0 OPLINE_CC EXECUTE_DATA_CC) != SUCCESS) {
		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

	zend_pre_incdec_property_zval(prop,
		ZEND_TYPE_IS_SET(prop_info->type) ? prop_info : NULL OPLINE_CC EXECUTE_DATA_CC);

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POST_INC_STATIC_PROP_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *prop;
	zend_property_info *prop_info;

	SAVE_OPLINE();

	if (zend_fetch_static_property_address(&prop, &prop_info, opline->extended_value, BP_VAR_RW, 0 OPLINE_CC EXECUTE_DATA_CC) != SUCCESS) {
		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

	zend_post_incdec_property_zval(prop,
		ZEND_TYPE_IS_SET(prop_info->type) ? prop_info : NULL OPLINE_CC EXECUTE_DATA_CC);

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_fetch_static_prop_helper_SPEC(int type ZEND_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE
	zval *prop;

	SAVE_OPLINE();

	if (UNEXPECTED(zend_fetch_static_property_address(&prop, NULL, opline->extended_value & ~ZEND_FETCH_OBJ_FLAGS, type, opline->extended_value & ZEND_FETCH_OBJ_FLAGS OPLINE_CC EXECUTE_DATA_CC) != SUCCESS)) {
		ZEND_ASSERT(EG(exception) || (type == BP_VAR_IS));
		prop = &EG(uninitialized_zval);
	}

	if (type == BP_VAR_R || type == BP_VAR_IS) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), prop);
	} else {
		ZVAL_INDIRECT(EX_VAR(opline->result.var), prop);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_STATIC_PROP_R_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_TAIL_CALL(zend_fetch_static_prop_helper_SPEC(BP_VAR_R ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_STATIC_PROP_W_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_TAIL_CALL(zend_fetch_static_prop_helper_SPEC(BP_VAR_W ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_STATIC_PROP_RW_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_TAIL_CALL(zend_fetch_static_prop_helper_SPEC(BP_VAR_RW ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_STATIC_PROP_FUNC_ARG_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	int fetch_type =
		(UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) ?
			BP_VAR_W : BP_VAR_R;
	ZEND_VM_TAIL_CALL(zend_fetch_static_prop_helper_SPEC(fetch_type ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_STATIC_PROP_UNSET_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_TAIL_CALL(zend_fetch_static_prop_helper_SPEC(BP_VAR_UNSET ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_STATIC_PROP_IS_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_TAIL_CALL(zend_fetch_static_prop_helper_SPEC(BP_VAR_IS ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static zend_never_inline ZEND_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	zend_throw_error(NULL, "Cannot use temporary expression in write context");
	FREE_OP(opline->op2_type, opline->op2.var);
	FREE_OP(opline->op1_type, opline->op1.var);
	ZVAL_UNDEF(EX_VAR(opline->result.var));
	HANDLE_EXCEPTION();
}

static zend_never_inline ZEND_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_use_undef_in_read_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	zend_throw_error(NULL, "Cannot use [] for reading");
	FREE_OP(opline->op2_type, opline->op2.var);
	FREE_OP(opline->op1_type, opline->op1.var);
	ZVAL_UNDEF(EX_VAR(opline->result.var));
	HANDLE_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *prop, *value;
	zend_property_info *prop_info;

	SAVE_OPLINE();

	if (zend_fetch_static_property_address(&prop, &prop_info, opline->extended_value, BP_VAR_W, 0 OPLINE_CC EXECUTE_DATA_CC) != SUCCESS) {

		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

	value = RT_CONSTANT((opline+1), (opline+1)->op1);

	if (UNEXPECTED(ZEND_TYPE_IS_SET(prop_info->type))) {
		value = zend_assign_to_typed_prop(prop_info, prop, value EXECUTE_DATA_CC);

	} else {
		value = zend_assign_to_variable(prop, value, IS_CONST, EX_USES_STRICT_TYPES());
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}

	/* assign_static_prop has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *prop, *value;
	zend_property_info *prop_info;

	SAVE_OPLINE();

	if (zend_fetch_static_property_address(&prop, &prop_info, opline->extended_value, BP_VAR_W, 0 OPLINE_CC EXECUTE_DATA_CC) != SUCCESS) {
		zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

	value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

	if (UNEXPECTED(ZEND_TYPE_IS_SET(prop_info->type))) {
		value = zend_assign_to_typed_prop(prop_info, prop, value EXECUTE_DATA_CC);
		zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
	} else {
		value = zend_assign_to_variable(prop, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}

	/* assign_static_prop has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *prop, *value;
	zend_property_info *prop_info;

	SAVE_OPLINE();

	if (zend_fetch_static_property_address(&prop, &prop_info, opline->extended_value, BP_VAR_W, 0 OPLINE_CC EXECUTE_DATA_CC) != SUCCESS) {
		zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

	value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (UNEXPECTED(ZEND_TYPE_IS_SET(prop_info->type))) {
		value = zend_assign_to_typed_prop(prop_info, prop, value EXECUTE_DATA_CC);
		zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
	} else {
		value = zend_assign_to_variable(prop, value, IS_VAR, EX_USES_STRICT_TYPES());
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}

	/* assign_static_prop has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *prop, *value;
	zend_property_info *prop_info;

	SAVE_OPLINE();

	if (zend_fetch_static_property_address(&prop, &prop_info, opline->extended_value, BP_VAR_W, 0 OPLINE_CC EXECUTE_DATA_CC) != SUCCESS) {

		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

	value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

	if (UNEXPECTED(ZEND_TYPE_IS_SET(prop_info->type))) {
		value = zend_assign_to_typed_prop(prop_info, prop, value EXECUTE_DATA_CC);

	} else {
		value = zend_assign_to_variable(prop, value, IS_CV, EX_USES_STRICT_TYPES());
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}

	/* assign_static_prop has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_STATIC_PROP_REF_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *prop, *value_ptr;
	zend_property_info *prop_info;

	SAVE_OPLINE();

	if (zend_fetch_static_property_address(&prop, &prop_info, opline->extended_value & ~ZEND_RETURNS_FUNCTION, BP_VAR_W, 0 OPLINE_CC EXECUTE_DATA_CC) != SUCCESS) {
		FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

	value_ptr = get_zval_ptr_ptr((opline+1)->op1_type, (opline+1)->op1, BP_VAR_W);

	if ((opline+1)->op1_type == IS_VAR && (opline->extended_value & ZEND_RETURNS_FUNCTION) && UNEXPECTED(!Z_ISREF_P(value_ptr))) {
		if (UNEXPECTED(!zend_wrong_assign_to_variable_reference(prop, value_ptr OPLINE_CC EXECUTE_DATA_CC))) {
			prop = &EG(uninitialized_zval);
		}
	} else if (UNEXPECTED(ZEND_TYPE_IS_SET(prop_info->type))) {
		prop = zend_assign_to_typed_property_reference(prop_info, prop, value_ptr EXECUTE_DATA_CC);
	} else {
		zend_assign_to_variable_reference(prop, value_ptr);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), prop);
	}

	if ((opline+1)->op1_type == IS_VAR) {zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));};
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_execute_data *old_execute_data;
	uint32_t call_info = EX_CALL_INFO();
	SAVE_OPLINE();

	if (EXPECTED((call_info & (ZEND_CALL_CODE|ZEND_CALL_TOP|ZEND_CALL_HAS_SYMBOL_TABLE|ZEND_CALL_FREE_EXTRA_ARGS|ZEND_CALL_ALLOCATED|ZEND_CALL_HAS_EXTRA_NAMED_PARAMS)) == 0)) {
		EG(current_execute_data) = EX(prev_execute_data);
		i_free_compiled_variables(execute_data);

#ifdef ZEND_PREFER_RELOAD
		call_info = EX_CALL_INFO();
#endif
		if (UNEXPECTED(call_info & ZEND_CALL_RELEASE_THIS)) {
			OBJ_RELEASE(Z_OBJ(execute_data->This));
		} else if (UNEXPECTED(call_info & ZEND_CALL_CLOSURE)) {
			OBJ_RELEASE(ZEND_CLOSURE_OBJECT(EX(func)));
		}
		EG(vm_stack_top) = (zval*)execute_data;
		execute_data = EX(prev_execute_data);

		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_rethrow_exception(execute_data);
			HANDLE_EXCEPTION_LEAVE();
		}

		LOAD_NEXT_OPLINE();
		ZEND_VM_LEAVE();
	} else if (EXPECTED((call_info & (ZEND_CALL_CODE|ZEND_CALL_TOP)) == 0)) {
		EG(current_execute_data) = EX(prev_execute_data);
		i_free_compiled_variables(execute_data);

#ifdef ZEND_PREFER_RELOAD
		call_info = EX_CALL_INFO();
#endif
		if (UNEXPECTED(call_info & ZEND_CALL_HAS_SYMBOL_TABLE)) {
			zend_clean_and_cache_symbol_table(EX(symbol_table));
		}

		if (UNEXPECTED(call_info & ZEND_CALL_HAS_EXTRA_NAMED_PARAMS)) {
			zend_free_extra_named_params(EX(extra_named_params));
		}

		/* Free extra args before releasing the closure,
		 * as that may free the op_array. */
		zend_vm_stack_free_extra_args_ex(call_info, execute_data);

		if (UNEXPECTED(call_info & ZEND_CALL_RELEASE_THIS)) {
			OBJ_RELEASE(Z_OBJ(execute_data->This));
		} else if (UNEXPECTED(call_info & ZEND_CALL_CLOSURE)) {
			OBJ_RELEASE(ZEND_CLOSURE_OBJECT(EX(func)));
		}

		old_execute_data = execute_data;
		execute_data = EX(prev_execute_data);
		zend_vm_stack_free_call_frame_ex(call_info, old_execute_data);

		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_rethrow_exception(execute_data);
			HANDLE_EXCEPTION_LEAVE();
		}

		LOAD_NEXT_OPLINE();
		ZEND_VM_LEAVE();
	} else if (EXPECTED((call_info & ZEND_CALL_TOP) == 0)) {
		zend_detach_symbol_table(execute_data);
		destroy_op_array(&EX(func)->op_array);
		efree_size(EX(func), sizeof(zend_op_array));
#ifdef ZEND_PREFER_RELOAD
		call_info = EX_CALL_INFO();
#endif
		old_execute_data = execute_data;
		execute_data = EG(current_execute_data) = EX(prev_execute_data);
		zend_vm_stack_free_call_frame_ex(call_info, old_execute_data);

		zend_attach_symbol_table(execute_data);
		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_rethrow_exception(execute_data);
			HANDLE_EXCEPTION_LEAVE();
		}

		LOAD_NEXT_OPLINE();
		ZEND_VM_LEAVE();
	} else {
		if (EXPECTED((call_info & ZEND_CALL_CODE) == 0)) {
			EG(current_execute_data) = EX(prev_execute_data);
			i_free_compiled_variables(execute_data);
#ifdef ZEND_PREFER_RELOAD
			call_info = EX_CALL_INFO();
#endif
			if (UNEXPECTED(call_info & (ZEND_CALL_HAS_SYMBOL_TABLE|ZEND_CALL_FREE_EXTRA_ARGS|ZEND_CALL_HAS_EXTRA_NAMED_PARAMS))) {
				if (UNEXPECTED(call_info & ZEND_CALL_HAS_SYMBOL_TABLE)) {
					zend_clean_and_cache_symbol_table(EX(symbol_table));
				}
				zend_vm_stack_free_extra_args_ex(call_info, execute_data);
				if (UNEXPECTED(call_info & ZEND_CALL_HAS_EXTRA_NAMED_PARAMS)) {
					zend_free_extra_named_params(EX(extra_named_params));
				}
			}
			if (UNEXPECTED(call_info & ZEND_CALL_CLOSURE)) {
				OBJ_RELEASE(ZEND_CLOSURE_OBJECT(EX(func)));
			}
			ZEND_VM_RETURN();
		} else /* if (call_kind == ZEND_CALL_TOP_CODE) */ {
			zend_array *symbol_table = EX(symbol_table);

			zend_detach_symbol_table(execute_data);
			old_execute_data = EX(prev_execute_data);
			while (old_execute_data) {
				if (old_execute_data->func && (ZEND_CALL_INFO(old_execute_data) & ZEND_CALL_HAS_SYMBOL_TABLE)) {
					if (old_execute_data->symbol_table == symbol_table) {
						zend_attach_symbol_table(old_execute_data);
					}
					break;
				}
				old_execute_data = old_execute_data->prev_execute_data;
			}
			EG(current_execute_data) = EX(prev_execute_data);
			ZEND_VM_RETURN();
		}
	}
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMP_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op1), 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DO_ICALL_SPEC_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_execute_data *call = EX(call);
	zend_function *fbc = call->func;
	zval *ret;
	zval retval;

	SAVE_OPLINE();
	EX(call) = call->prev_execute_data;

	call->prev_execute_data = execute_data;
	EG(current_execute_data) = call;

#if ZEND_DEBUG
	zend_bool should_throw = zend_internal_call_should_throw(fbc, call);
#endif

	ret = 0 ? EX_VAR(opline->result.var) : &retval;
	ZVAL_NULL(ret);

	fbc->internal_function.handler(call, ret);

#if ZEND_DEBUG
	if (!EG(exception) && call->func) {
		if (should_throw) {
			zend_internal_call_arginfo_violation(call->func);
		}
		ZEND_ASSERT(!(call->func->common.fn_flags & ZEND_ACC_HAS_RETURN_TYPE) ||
			zend_verify_internal_return_type(call->func, ret));
		ZEND_ASSERT((call->func->common.fn_flags & ZEND_ACC_RETURN_REFERENCE)
			? Z_ISREF_P(ret) : !Z_ISREF_P(ret));
	}
#endif

	EG(current_execute_data) = execute_data;
	zend_vm_stack_free_args(call);

	uint32_t call_info = ZEND_CALL_INFO(call);
	if (UNEXPECTED(call_info & (ZEND_CALL_HAS_EXTRA_NAMED_PARAMS|ZEND_CALL_ALLOCATED))) {
		if (call_info & ZEND_CALL_HAS_EXTRA_NAMED_PARAMS) {
			zend_free_extra_named_params(call->extra_named_params);
		}
		zend_vm_stack_free_call_frame_ex(call_info, call);
	} else {
		EG(vm_stack_top) = (zval*)call;
	}

	if (!0) {
		i_zval_ptr_dtor(ret);
	}

	if (UNEXPECTED(EG(exception) != NULL)) {
		zend_rethrow_exception(execute_data);
		HANDLE_EXCEPTION();
	}

	ZEND_VM_SET_OPCODE(opline + 1);
	ZEND_VM_CONTINUE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DO_ICALL_SPEC_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_execute_data *call = EX(call);
	zend_function *fbc = call->func;
	zval *ret;
	zval retval;

	SAVE_OPLINE();
	EX(call) = call->prev_execute_data;

	call->prev_execute_data = execute_data;
	EG(current_execute_data) = call;

#if ZEND_DEBUG
	zend_bool should_throw = zend_internal_call_should_throw(fbc, call);
#endif

	ret = 1 ? EX_VAR(opline->result.var) : &retval;
	ZVAL_NULL(ret);

	fbc->internal_function.handler(call, ret);

#if ZEND_DEBUG
	if (!EG(exception) && call->func) {
		if (should_throw) {
			zend_internal_call_arginfo_violation(call->func);
		}
		ZEND_ASSERT(!(call->func->common.fn_flags & ZEND_ACC_HAS_RETURN_TYPE) ||
			zend_verify_internal_return_type(call->func, ret));
		ZEND_ASSERT((call->func->common.fn_flags & ZEND_ACC_RETURN_REFERENCE)
			? Z_ISREF_P(ret) : !Z_ISREF_P(ret));
	}
#endif

	EG(current_execute_data) = execute_data;
	zend_vm_stack_free_args(call);

	uint32_t call_info = ZEND_CALL_INFO(call);
	if (UNEXPECTED(call_info & (ZEND_CALL_HAS_EXTRA_NAMED_PARAMS|ZEND_CALL_ALLOCATED))) {
		if (call_info & ZEND_CALL_HAS_EXTRA_NAMED_PARAMS) {
			zend_free_extra_named_params(call->extra_named_params);
		}
		zend_vm_stack_free_call_frame_ex(call_info, call);
	} else {
		EG(vm_stack_top) = (zval*)call;
	}

	if (!1) {
		i_zval_ptr_dtor(ret);
	}

	if (UNEXPECTED(EG(exception) != NULL)) {
		zend_rethrow_exception(execute_data);
		HANDLE_EXCEPTION();
	}

	ZEND_VM_SET_OPCODE(opline + 1);
	ZEND_VM_CONTINUE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DO_UCALL_SPEC_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_execute_data *call = EX(call);
	zend_function *fbc = call->func;
	zval *ret;

	SAVE_OPLINE();
	EX(call) = call->prev_execute_data;

	ret = NULL;
	if (0) {
		ret = EX_VAR(opline->result.var);
	}

	call->prev_execute_data = execute_data;
	execute_data = call;
	i_init_func_execute_data(&fbc->op_array, ret, 0 EXECUTE_DATA_CC);

	LOAD_OPLINE_EX();

	ZEND_VM_ENTER_EX();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DO_UCALL_SPEC_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_execute_data *call = EX(call);
	zend_function *fbc = call->func;
	zval *ret;

	SAVE_OPLINE();
	EX(call) = call->prev_execute_data;

	ret = NULL;
	if (1) {
		ret = EX_VAR(opline->result.var);
	}

	call->prev_execute_data = execute_data;
	execute_data = call;
	i_init_func_execute_data(&fbc->op_array, ret, 0 EXECUTE_DATA_CC);

	LOAD_OPLINE_EX();

	ZEND_VM_ENTER_EX();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DO_UCALL_SPEC_OBSERVER_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_execute_data *call = EX(call);
	zend_function *fbc = call->func;
	zval *ret;

	SAVE_OPLINE();
	EX(call) = call->prev_execute_data;

	ret = NULL;
	if (RETURN_VALUE_USED(opline)) {
		ret = EX_VAR(opline->result.var);
	}

	call->prev_execute_data = execute_data;
	execute_data = call;
	i_init_func_execute_data(&fbc->op_array, ret, 0 EXECUTE_DATA_CC);
	zend_observer_fcall_begin(execute_data);
	LOAD_OPLINE_EX();

	ZEND_VM_ENTER_EX();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DO_FCALL_BY_NAME_SPEC_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_execute_data *call = EX(call);
	zend_function *fbc = call->func;
	zval *ret;

	SAVE_OPLINE();
	EX(call) = call->prev_execute_data;

	if (EXPECTED(fbc->type == ZEND_USER_FUNCTION)) {
		ret = NULL;
		if (0) {
			ret = EX_VAR(opline->result.var);
		}

		call->prev_execute_data = execute_data;
		execute_data = call;
		i_init_func_execute_data(&fbc->op_array, ret, 0 EXECUTE_DATA_CC);

		LOAD_OPLINE_EX();

		ZEND_VM_ENTER_EX();
	} else {
		zval retval;
		ZEND_ASSERT(fbc->type == ZEND_INTERNAL_FUNCTION);
		if (0) {
			ret = NULL;
		}

		if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_DEPRECATED) != 0)) {
			zend_deprecated_function(fbc);
			if (UNEXPECTED(EG(exception) != NULL)) {
				UNDEF_RESULT();
				if (!0) {
					ret = &retval;
					ZVAL_UNDEF(ret);
				}
				goto fcall_by_name_end;
			}
		}

		call->prev_execute_data = execute_data;
		EG(current_execute_data) = call;

#if ZEND_DEBUG
		zend_bool should_throw = zend_internal_call_should_throw(fbc, call);
#endif

		ret = 0 ? EX_VAR(opline->result.var) : &retval;
		ZVAL_NULL(ret);

		fbc->internal_function.handler(call, ret);

#if ZEND_DEBUG
		if (!EG(exception) && call->func) {
			if (should_throw) {
				zend_internal_call_arginfo_violation(call->func);
			}
			ZEND_ASSERT(!(call->func->common.fn_flags & ZEND_ACC_HAS_RETURN_TYPE) ||
				zend_verify_internal_return_type(call->func, ret));
			ZEND_ASSERT((call->func->common.fn_flags & ZEND_ACC_RETURN_REFERENCE)
				? Z_ISREF_P(ret) : !Z_ISREF_P(ret));
		}
#endif

		EG(current_execute_data) = execute_data;

fcall_by_name_end:
		zend_vm_stack_free_args(call);

		uint32_t call_info = ZEND_CALL_INFO(call);
		if (UNEXPECTED(call_info & (ZEND_CALL_HAS_EXTRA_NAMED_PARAMS|ZEND_CALL_ALLOCATED))) {
			if (call_info & ZEND_CALL_HAS_EXTRA_NAMED_PARAMS) {
				zend_free_extra_named_params(call->extra_named_params);
			}
			zend_vm_stack_free_call_frame_ex(call_info, call);
		} else {
			EG(vm_stack_top) = (zval*)call;
		}

		if (!0) {
			i_zval_ptr_dtor(ret);
		}
	}

	if (UNEXPECTED(EG(exception) != NULL)) {
		zend_rethrow_exception(execute_data);
		HANDLE_EXCEPTION();
	}
	ZEND_VM_SET_OPCODE(opline + 1);
	ZEND_VM_CONTINUE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DO_FCALL_BY_NAME_SPEC_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_execute_data *call = EX(call);
	zend_function *fbc = call->func;
	zval *ret;

	SAVE_OPLINE();
	EX(call) = call->prev_execute_data;

	if (EXPECTED(fbc->type == ZEND_USER_FUNCTION)) {
		ret = NULL;
		if (1) {
			ret = EX_VAR(opline->result.var);
		}

		call->prev_execute_data = execute_data;
		execute_data = call;
		i_init_func_execute_data(&fbc->op_array, ret, 0 EXECUTE_DATA_CC);

		LOAD_OPLINE_EX();

		ZEND_VM_ENTER_EX();
	} else {
		zval retval;
		ZEND_ASSERT(fbc->type == ZEND_INTERNAL_FUNCTION);
		if (0) {
			ret = NULL;
		}

		if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_DEPRECATED) != 0)) {
			zend_deprecated_function(fbc);
			if (UNEXPECTED(EG(exception) != NULL)) {
				UNDEF_RESULT();
				if (!1) {
					ret = &retval;
					ZVAL_UNDEF(ret);
				}
				goto fcall_by_name_end;
			}
		}

		call->prev_execute_data = execute_data;
		EG(current_execute_data) = call;

#if ZEND_DEBUG
		zend_bool should_throw = zend_internal_call_should_throw(fbc, call);
#endif

		ret = 1 ? EX_VAR(opline->result.var) : &retval;
		ZVAL_NULL(ret);

		fbc->internal_function.handler(call, ret);

#if ZEND_DEBUG
		if (!EG(exception) && call->func) {
			if (should_throw) {
				zend_internal_call_arginfo_violation(call->func);
			}
			ZEND_ASSERT(!(call->func->common.fn_flags & ZEND_ACC_HAS_RETURN_TYPE) ||
				zend_verify_internal_return_type(call->func, ret));
			ZEND_ASSERT((call->func->common.fn_flags & ZEND_ACC_RETURN_REFERENCE)
				? Z_ISREF_P(ret) : !Z_ISREF_P(ret));
		}
#endif

		EG(current_execute_data) = execute_data;

fcall_by_name_end:
		zend_vm_stack_free_args(call);

		uint32_t call_info = ZEND_CALL_INFO(call);
		if (UNEXPECTED(call_info & (ZEND_CALL_HAS_EXTRA_NAMED_PARAMS|ZEND_CALL_ALLOCATED))) {
			if (call_info & ZEND_CALL_HAS_EXTRA_NAMED_PARAMS) {
				zend_free_extra_named_params(call->extra_named_params);
			}
			zend_vm_stack_free_call_frame_ex(call_info, call);
		} else {
			EG(vm_stack_top) = (zval*)call;
		}

		if (!1) {
			i_zval_ptr_dtor(ret);
		}
	}

	if (UNEXPECTED(EG(exception) != NULL)) {
		zend_rethrow_exception(execute_data);
		HANDLE_EXCEPTION();
	}
	ZEND_VM_SET_OPCODE(opline + 1);
	ZEND_VM_CONTINUE();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DO_FCALL_BY_NAME_SPEC_OBSERVER_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_execute_data *call = EX(call);
	zend_function *fbc = call->func;
	zval *ret;

	SAVE_OPLINE();
	EX(call) = call->prev_execute_data;

	if (EXPECTED(fbc->type == ZEND_USER_FUNCTION)) {
		ret = NULL;
		if (RETURN_VALUE_USED(opline)) {
			ret = EX_VAR(opline->result.var);
		}

		call->prev_execute_data = execute_data;
		execute_data = call;
		i_init_func_execute_data(&fbc->op_array, ret, 0 EXECUTE_DATA_CC);
		zend_observer_fcall_begin(execute_data);
		LOAD_OPLINE_EX();

		ZEND_VM_ENTER_EX();
	} else {
		zval retval;
		ZEND_ASSERT(fbc->type == ZEND_INTERNAL_FUNCTION);
		if (1) {
			ret = NULL;
		}

		if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_DEPRECATED) != 0)) {
			zend_deprecated_function(fbc);
			if (UNEXPECTED(EG(exception) != NULL)) {
				UNDEF_RESULT();
				if (!RETURN_VALUE_USED(opline)) {
					ret = &retval;
					ZVAL_UNDEF(ret);
				}
				goto fcall_by_name_end;
			}
		}

		call->prev_execute_data = execute_data;
		EG(current_execute_data) = call;

#if ZEND_DEBUG
		zend_bool should_throw = zend_internal_call_should_throw(fbc, call);
#endif

		ret = RETURN_VALUE_USED(opline) ? EX_VAR(opline->result.var) : &retval;
		ZVAL_NULL(ret);

		fbc->internal_function.handler(call, ret);

#if ZEND_DEBUG
		if (!EG(exception) && call->func) {
			if (should_throw) {
				zend_internal_call_arginfo_violation(call->func);
			}
			ZEND_ASSERT(!(call->func->common.fn_flags & ZEND_ACC_HAS_RETURN_TYPE) ||
				zend_verify_internal_return_type(call->func, ret));
			ZEND_ASSERT((call->func->common.fn_flags & ZEND_ACC_RETURN_REFERENCE)
				? Z_ISREF_P(ret) : !Z_ISREF_P(ret));
		}
#endif

		EG(current_execute_data) = execute_data;

fcall_by_name_end:
		zend_vm_stack_free_args(call);

		uint32_t call_info = ZEND_CALL_INFO(call);
		if (UNEXPECTED(call_info & (ZEND_CALL_HAS_EXTRA_NAMED_PARAMS|ZEND_CALL_ALLOCATED))) {
			if (call_info & ZEND_CALL_HAS_EXTRA_NAMED_PARAMS) {
				zend_free_extra_named_params(call->extra_named_params);
			}
			zend_vm_stack_free_call_frame_ex(call_info, call);
		} else {
			EG(vm_stack_top) = (zval*)call;
		}

		if (!RETURN_VALUE_USED(opline)) {
			i_zval_ptr_dtor(ret);
		}
	}

	if (UNEXPECTED(EG(exception) != NULL)) {
		zend_rethrow_exception(execute_data);
		HANDLE_EXCEPTION();
	}
	ZEND_VM_SET_OPCODE(opline + 1);
	ZEND_VM_CONTINUE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DO_FCALL_SPEC_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_execute_data *call = EX(call);
	zend_function *fbc = call->func;
	zval *ret;

	SAVE_OPLINE();
	EX(call) = call->prev_execute_data;

	if (EXPECTED(fbc->type == ZEND_USER_FUNCTION)) {
		ret = NULL;
		if (0) {
			ret = EX_VAR(opline->result.var);
		}

		call->prev_execute_data = execute_data;
		execute_data = call;
		i_init_func_execute_data(&fbc->op_array, ret, 1 EXECUTE_DATA_CC);

		if (EXPECTED(zend_execute_ex == execute_ex)) {
			LOAD_OPLINE_EX();
			ZEND_VM_ENTER_EX();
		} else {
			SAVE_OPLINE_EX();
			execute_data = EX(prev_execute_data);
			LOAD_OPLINE();
			ZEND_ADD_CALL_FLAG(call, ZEND_CALL_TOP);
			zend_execute_ex(call);
		}
	} else {
		zval retval;
		ZEND_ASSERT(fbc->type == ZEND_INTERNAL_FUNCTION);
		if (0) {
			ret = NULL;
		}

		if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_DEPRECATED) != 0)) {
			zend_deprecated_function(fbc);
			if (UNEXPECTED(EG(exception) != NULL)) {
				UNDEF_RESULT();
				if (!0) {
					ret = &retval;
					ZVAL_UNDEF(ret);
				}
				goto fcall_end;
			}
		}

		call->prev_execute_data = execute_data;
		EG(current_execute_data) = call;

#if ZEND_DEBUG
		zend_bool should_throw = zend_internal_call_should_throw(fbc, call);
#endif

		ret = 0 ? EX_VAR(opline->result.var) : &retval;
		ZVAL_NULL(ret);

		if (!zend_execute_internal) {
			/* saves one function call if zend_execute_internal is not used */
			fbc->internal_function.handler(call, ret);
		} else {
			zend_execute_internal(call, ret);
		}

#if ZEND_DEBUG
		if (!EG(exception) && call->func) {
			if (should_throw) {
				zend_internal_call_arginfo_violation(call->func);
			}
			ZEND_ASSERT(!(call->func->common.fn_flags & ZEND_ACC_HAS_RETURN_TYPE) ||
				zend_verify_internal_return_type(call->func, ret));
			ZEND_ASSERT((call->func->common.fn_flags & ZEND_ACC_RETURN_REFERENCE)
				? Z_ISREF_P(ret) : !Z_ISREF_P(ret));
		}
#endif

		EG(current_execute_data) = execute_data;

fcall_end:
		zend_vm_stack_free_args(call);
		if (UNEXPECTED(ZEND_CALL_INFO(call) & ZEND_CALL_HAS_EXTRA_NAMED_PARAMS)) {
			zend_free_extra_named_params(call->extra_named_params);
		}

		if (!0) {
			i_zval_ptr_dtor(ret);
		}
	}

	if (UNEXPECTED(ZEND_CALL_INFO(call) & ZEND_CALL_RELEASE_THIS)) {
		OBJ_RELEASE(Z_OBJ(call->This));
	}

	zend_vm_stack_free_call_frame(call);
	if (UNEXPECTED(EG(exception) != NULL)) {
		zend_rethrow_exception(execute_data);
		HANDLE_EXCEPTION();
	}

	ZEND_VM_SET_OPCODE(opline + 1);
	ZEND_VM_CONTINUE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DO_FCALL_SPEC_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_execute_data *call = EX(call);
	zend_function *fbc = call->func;
	zval *ret;

	SAVE_OPLINE();
	EX(call) = call->prev_execute_data;

	if (EXPECTED(fbc->type == ZEND_USER_FUNCTION)) {
		ret = NULL;
		if (1) {
			ret = EX_VAR(opline->result.var);
		}

		call->prev_execute_data = execute_data;
		execute_data = call;
		i_init_func_execute_data(&fbc->op_array, ret, 1 EXECUTE_DATA_CC);

		if (EXPECTED(zend_execute_ex == execute_ex)) {
			LOAD_OPLINE_EX();
			ZEND_VM_ENTER_EX();
		} else {
			SAVE_OPLINE_EX();
			execute_data = EX(prev_execute_data);
			LOAD_OPLINE();
			ZEND_ADD_CALL_FLAG(call, ZEND_CALL_TOP);
			zend_execute_ex(call);
		}
	} else {
		zval retval;
		ZEND_ASSERT(fbc->type == ZEND_INTERNAL_FUNCTION);
		if (0) {
			ret = NULL;
		}

		if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_DEPRECATED) != 0)) {
			zend_deprecated_function(fbc);
			if (UNEXPECTED(EG(exception) != NULL)) {
				UNDEF_RESULT();
				if (!1) {
					ret = &retval;
					ZVAL_UNDEF(ret);
				}
				goto fcall_end;
			}
		}

		call->prev_execute_data = execute_data;
		EG(current_execute_data) = call;

#if ZEND_DEBUG
		zend_bool should_throw = zend_internal_call_should_throw(fbc, call);
#endif

		ret = 1 ? EX_VAR(opline->result.var) : &retval;
		ZVAL_NULL(ret);

		if (!zend_execute_internal) {
			/* saves one function call if zend_execute_internal is not used */
			fbc->internal_function.handler(call, ret);
		} else {
			zend_execute_internal(call, ret);
		}

#if ZEND_DEBUG
		if (!EG(exception) && call->func) {
			if (should_throw) {
				zend_internal_call_arginfo_violation(call->func);
			}
			ZEND_ASSERT(!(call->func->common.fn_flags & ZEND_ACC_HAS_RETURN_TYPE) ||
				zend_verify_internal_return_type(call->func, ret));
			ZEND_ASSERT((call->func->common.fn_flags & ZEND_ACC_RETURN_REFERENCE)
				? Z_ISREF_P(ret) : !Z_ISREF_P(ret));
		}
#endif

		EG(current_execute_data) = execute_data;

fcall_end:
		zend_vm_stack_free_args(call);
		if (UNEXPECTED(ZEND_CALL_INFO(call) & ZEND_CALL_HAS_EXTRA_NAMED_PARAMS)) {
			zend_free_extra_named_params(call->extra_named_params);
		}

		if (!1) {
			i_zval_ptr_dtor(ret);
		}
	}

	if (UNEXPECTED(ZEND_CALL_INFO(call) & ZEND_CALL_RELEASE_THIS)) {
		OBJ_RELEASE(Z_OBJ(call->This));
	}

	zend_vm_stack_free_call_frame(call);
	if (UNEXPECTED(EG(exception) != NULL)) {
		zend_rethrow_exception(execute_data);
		HANDLE_EXCEPTION();
	}

	ZEND_VM_SET_OPCODE(opline + 1);
	ZEND_VM_CONTINUE();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DO_FCALL_SPEC_OBSERVER_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_execute_data *call = EX(call);
	zend_function *fbc = call->func;
	zval *ret;

	SAVE_OPLINE();
	EX(call) = call->prev_execute_data;

	if (EXPECTED(fbc->type == ZEND_USER_FUNCTION)) {
		ret = NULL;
		if (RETURN_VALUE_USED(opline)) {
			ret = EX_VAR(opline->result.var);
		}

		call->prev_execute_data = execute_data;
		execute_data = call;
		i_init_func_execute_data(&fbc->op_array, ret, 1 EXECUTE_DATA_CC);
		zend_observer_fcall_begin(execute_data);

		if (EXPECTED(zend_execute_ex == execute_ex)) {
			LOAD_OPLINE_EX();
			ZEND_VM_ENTER_EX();
		} else {
			SAVE_OPLINE_EX();
			execute_data = EX(prev_execute_data);
			LOAD_OPLINE();
			ZEND_ADD_CALL_FLAG(call, ZEND_CALL_TOP);
			zend_execute_ex(call);
		}
	} else {
		zval retval;
		ZEND_ASSERT(fbc->type == ZEND_INTERNAL_FUNCTION);
		if (1) {
			ret = NULL;
		}

		if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_DEPRECATED) != 0)) {
			zend_deprecated_function(fbc);
			if (UNEXPECTED(EG(exception) != NULL)) {
				UNDEF_RESULT();
				if (!RETURN_VALUE_USED(opline)) {
					ret = &retval;
					ZVAL_UNDEF(ret);
				}
				goto fcall_end;
			}
		}

		call->prev_execute_data = execute_data;
		EG(current_execute_data) = call;

#if ZEND_DEBUG
		zend_bool should_throw = zend_internal_call_should_throw(fbc, call);
#endif

		ret = RETURN_VALUE_USED(opline) ? EX_VAR(opline->result.var) : &retval;
		ZVAL_NULL(ret);

		if (!zend_execute_internal) {
			/* saves one function call if zend_execute_internal is not used */
			fbc->internal_function.handler(call, ret);
		} else {
			zend_execute_internal(call, ret);
		}

#if ZEND_DEBUG
		if (!EG(exception) && call->func) {
			if (should_throw) {
				zend_internal_call_arginfo_violation(call->func);
			}
			ZEND_ASSERT(!(call->func->common.fn_flags & ZEND_ACC_HAS_RETURN_TYPE) ||
				zend_verify_internal_return_type(call->func, ret));
			ZEND_ASSERT((call->func->common.fn_flags & ZEND_ACC_RETURN_REFERENCE)
				? Z_ISREF_P(ret) : !Z_ISREF_P(ret));
		}
#endif

		EG(current_execute_data) = execute_data;

fcall_end:
		zend_vm_stack_free_args(call);
		if (UNEXPECTED(ZEND_CALL_INFO(call) & ZEND_CALL_HAS_EXTRA_NAMED_PARAMS)) {
			zend_free_extra_named_params(call->extra_named_params);
		}

		if (!RETURN_VALUE_USED(opline)) {
			i_zval_ptr_dtor(ret);
		}
	}

	if (UNEXPECTED(ZEND_CALL_INFO(call) & ZEND_CALL_RELEASE_THIS)) {
		OBJ_RELEASE(Z_OBJ(call->This));
	}

	zend_vm_stack_free_call_frame(call);
	if (UNEXPECTED(EG(exception) != NULL)) {
		zend_rethrow_exception(execute_data);
		HANDLE_EXCEPTION();
	}

	ZEND_VM_SET_OPCODE(opline + 1);
	ZEND_VM_CONTINUE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_GENERATOR_CREATE_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *return_value = EX(return_value);

	if (EXPECTED(return_value)) {
		USE_OPLINE
		zend_generator *generator;
		zend_execute_data *gen_execute_data;
		uint32_t num_args, used_stack, call_info;

		object_init_ex(return_value, zend_ce_generator);

		/*
		 * Normally the execute_data is allocated on the VM stack (because it does
		 * not actually do any allocation and thus is faster). For generators
		 * though this behavior would be suboptimal, because the (rather large)
		 * structure would have to be copied back and forth every time execution is
		 * suspended or resumed. That's why for generators the execution context
		 * is allocated on heap.
		 */
		num_args = EX_NUM_ARGS();
		if (EXPECTED(num_args <= EX(func)->op_array.num_args)) {
			used_stack = (ZEND_CALL_FRAME_SLOT + EX(func)->op_array.last_var + EX(func)->op_array.T) * sizeof(zval);
			gen_execute_data = (zend_execute_data*)emalloc(used_stack);
			used_stack = (ZEND_CALL_FRAME_SLOT + EX(func)->op_array.last_var) * sizeof(zval);
		} else {
			used_stack = (ZEND_CALL_FRAME_SLOT + num_args + EX(func)->op_array.last_var + EX(func)->op_array.T - EX(func)->op_array.num_args) * sizeof(zval);
			gen_execute_data = (zend_execute_data*)emalloc(used_stack);
		}
		memcpy(gen_execute_data, execute_data, used_stack);

		/* Save execution context in generator object. */
		generator = (zend_generator *) Z_OBJ_P(EX(return_value));
		generator->execute_data = gen_execute_data;
		generator->frozen_call_stack = NULL;
		generator->execute_fake.opline = NULL;
		generator->execute_fake.func = NULL;
		generator->execute_fake.prev_execute_data = NULL;
		ZVAL_OBJ(&generator->execute_fake.This, (zend_object *) generator);

		gen_execute_data->opline = opline + 1;
		/* EX(return_value) keeps pointer to zend_object (not a real zval) */
		gen_execute_data->return_value = (zval*)generator;
		call_info = Z_TYPE_INFO(EX(This));
		if ((call_info & Z_TYPE_MASK) == IS_OBJECT
		 && (!(call_info & (ZEND_CALL_CLOSURE|ZEND_CALL_RELEASE_THIS))
			 /* Bug #72523 */
			|| UNEXPECTED(zend_execute_ex != execute_ex))) {
			ZEND_ADD_CALL_FLAG_EX(call_info, ZEND_CALL_RELEASE_THIS);
			Z_ADDREF(gen_execute_data->This);
		}
		ZEND_ADD_CALL_FLAG_EX(call_info, (ZEND_CALL_TOP_FUNCTION | ZEND_CALL_ALLOCATED | ZEND_CALL_GENERATOR));
		Z_TYPE_INFO(gen_execute_data->This) = call_info;
		gen_execute_data->prev_execute_data = NULL;

		call_info = EX_CALL_INFO();
		EG(current_execute_data) = EX(prev_execute_data);
		if (EXPECTED(!(call_info & (ZEND_CALL_TOP|ZEND_CALL_ALLOCATED)))) {
			EG(vm_stack_top) = (zval*)execute_data;
			execute_data = EX(prev_execute_data);
			LOAD_NEXT_OPLINE();
			ZEND_VM_LEAVE();
		} else if (EXPECTED(!(call_info & ZEND_CALL_TOP))) {
			zend_execute_data *old_execute_data = execute_data;
			execute_data = EX(prev_execute_data);
			zend_vm_stack_free_call_frame_ex(call_info, old_execute_data);
			LOAD_NEXT_OPLINE();
			ZEND_VM_LEAVE();
		} else {
			ZEND_VM_RETURN();
		}
	} else {
		ZEND_VM_TAIL_CALL(zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static zend_never_inline ZEND_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_cannot_pass_by_ref_helper_SPEC(uint32_t _arg_num, zval *_arg ZEND_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();

	zend_cannot_pass_by_reference(_arg_num);
	FREE_OP(opline->op1_type, opline->op1.var);
	ZVAL_UNDEF(_arg);
	HANDLE_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_UNPACK_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *args;
	uint32_t arg_num;

	SAVE_OPLINE();
	args = get_zval_ptr_undef(opline->op1_type, opline->op1, BP_VAR_R);
	arg_num = ZEND_CALL_NUM_ARGS(EX(call)) + 1;

send_again:
	if (EXPECTED(Z_TYPE_P(args) == IS_ARRAY)) {
		HashTable *ht = Z_ARRVAL_P(args);
		zval *arg, *top;
		zend_string *name;
		zend_bool have_named_params = 0;

		zend_vm_stack_extend_call_frame(&EX(call), arg_num - 1, zend_hash_num_elements(ht));

		// TODO: Speed this up using a flag that specifies whether there are any ref parameters.
		if ((opline->op1_type & (IS_VAR|IS_CV)) && Z_REFCOUNT_P(args) > 1) {
			uint32_t tmp_arg_num = arg_num;
			bool separate = 0;

			/* check if any of arguments are going to be passed by reference */
			ZEND_HASH_FOREACH_STR_KEY_VAL(ht, name, arg) {
				if (UNEXPECTED(name)) {
					void *cache_slot[2] = {NULL, NULL};
					tmp_arg_num = zend_get_arg_offset_by_name(
						EX(call)->func, name, cache_slot) + 1;
				}
				if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, tmp_arg_num)) {
					separate = 1;
					break;
				}
				tmp_arg_num++;
			} ZEND_HASH_FOREACH_END();
			if (separate) {
				SEPARATE_ARRAY(args);
				ht = Z_ARRVAL_P(args);
			}
		}

		ZEND_HASH_FOREACH_STR_KEY_VAL(ht, name, arg) {
			if (UNEXPECTED(name)) {
				void *cache_slot[2] = {NULL, NULL};
				have_named_params = 1;
				top = zend_handle_named_arg(&EX(call), name, &arg_num, cache_slot);
				if (UNEXPECTED(!top)) {
					FREE_OP(opline->op1_type, opline->op1.var);
					HANDLE_EXCEPTION();
				}
			} else {
				if (have_named_params) {
					zend_throw_error(NULL,
						"Cannot use positional argument after named argument during unpacking");
					FREE_OP(opline->op1_type, opline->op1.var);
					HANDLE_EXCEPTION();
				}

				top = ZEND_CALL_ARG(EX(call), arg_num);
				ZEND_CALL_NUM_ARGS(EX(call))++;
			}

			if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
				if (Z_ISREF_P(arg)) {
					Z_ADDREF_P(arg);
					ZVAL_REF(top, Z_REF_P(arg));
				} else if (opline->op1_type & (IS_VAR|IS_CV)) {
					/* array is already separated above */
					ZVAL_MAKE_REF_EX(arg, 2);
					ZVAL_REF(top, Z_REF_P(arg));
				} else {
					Z_TRY_ADDREF_P(arg);
					ZVAL_NEW_REF(top, arg);
				}
			} else {
				ZVAL_COPY_DEREF(top, arg);
			}

			arg_num++;
		} ZEND_HASH_FOREACH_END();

	} else if (EXPECTED(Z_TYPE_P(args) == IS_OBJECT)) {
		zend_class_entry *ce = Z_OBJCE_P(args);
		zend_object_iterator *iter;
		zend_bool have_named_params = 0;

		if (!ce || !ce->get_iterator) {
			zend_type_error("Only arrays and Traversables can be unpacked");
		} else {

			iter = ce->get_iterator(ce, args, 0);
			if (UNEXPECTED(!iter)) {
				FREE_OP(opline->op1_type, opline->op1.var);
				if (!EG(exception)) {
					zend_throw_exception_ex(
						NULL, 0, "Object of type %s did not create an Iterator", ZSTR_VAL(ce->name)
					);
				}
				HANDLE_EXCEPTION();
			}

			if (iter->funcs->rewind) {
				iter->funcs->rewind(iter);
			}

			for (; iter->funcs->valid(iter) == SUCCESS; ++arg_num) {
				zval *arg, *top;

				if (UNEXPECTED(EG(exception) != NULL)) {
					break;
				}

				arg = iter->funcs->get_current_data(iter);
				if (UNEXPECTED(EG(exception) != NULL)) {
					break;
				}

				zend_string *name = NULL;
				if (iter->funcs->get_current_key) {
					zval key;
					iter->funcs->get_current_key(iter, &key);
					if (UNEXPECTED(EG(exception) != NULL)) {
						break;
					}

					if (UNEXPECTED(Z_TYPE(key) != IS_LONG)) {
						if (UNEXPECTED(Z_TYPE(key) != IS_STRING)) {
							zend_throw_error(NULL,
								"Keys must be of type int|string during argument unpacking");
							zval_ptr_dtor(&key);
							break;
						}

						name = Z_STR_P(&key);
					}
				}

				if (UNEXPECTED(name)) {
					void *cache_slot[2] = {NULL, NULL};
					have_named_params = 1;
					top = zend_handle_named_arg(&EX(call), name, &arg_num, cache_slot);
					if (UNEXPECTED(!top)) {
						zend_string_release(name);
						break;
					}

					if (ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
						zend_error(
							E_WARNING, "Cannot pass by-reference argument %d of %s%s%s()"
							" by unpacking a Traversable, passing by-value instead", arg_num,
							EX(call)->func->common.scope ? ZSTR_VAL(EX(call)->func->common.scope->name) : "",
							EX(call)->func->common.scope ? "::" : "",
							ZSTR_VAL(EX(call)->func->common.function_name)
						);
					}

					ZVAL_COPY_DEREF(top, arg);
					zend_string_release(name);
				} else {
					if (have_named_params) {
						zend_throw_error(NULL,
							"Cannot use positional argument after named argument during unpacking");
						break;
					}

					if (ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
						zend_error(
							E_WARNING, "Cannot pass by-reference argument %d of %s%s%s()"
							" by unpacking a Traversable, passing by-value instead", arg_num,
							EX(call)->func->common.scope ? ZSTR_VAL(EX(call)->func->common.scope->name) : "",
							EX(call)->func->common.scope ? "::" : "",
							ZSTR_VAL(EX(call)->func->common.function_name)
						);
					}


					zend_vm_stack_extend_call_frame(&EX(call), arg_num - 1, 1);
					top = ZEND_CALL_ARG(EX(call), arg_num);
					ZVAL_COPY_DEREF(top, arg);
					ZEND_CALL_NUM_ARGS(EX(call))++;
				}

				iter->funcs->move_forward(iter);
			}

			zend_iterator_dtor(iter);
		}
	} else if (EXPECTED(Z_ISREF_P(args))) {
		args = Z_REFVAL_P(args);
		goto send_again;
	} else {
		if (opline->op1_type == IS_CV && UNEXPECTED(Z_TYPE_P(args) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		zend_type_error("Only arrays and Traversables can be unpacked");
	}

	FREE_OP(opline->op1_type, opline->op1.var);
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_ARRAY_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *args;

	SAVE_OPLINE();
	args = get_zval_ptr(opline->op1_type, opline->op1, BP_VAR_R);

	if (UNEXPECTED(Z_TYPE_P(args) != IS_ARRAY)) {
		if ((opline->op1_type & (IS_VAR|IS_CV)) && Z_ISREF_P(args)) {
			args = Z_REFVAL_P(args);
			if (EXPECTED(Z_TYPE_P(args) == IS_ARRAY)) {
				goto send_array;
			}
		}
		zend_type_error("call_user_func_array(): Argument #2 ($args) must be of type array, %s given", zend_zval_type_name(args));
		FREE_OP(opline->op2_type, opline->op2.var);
		FREE_OP(opline->op1_type, opline->op1.var);
		HANDLE_EXCEPTION();
	} else {
		uint32_t arg_num;
		HashTable *ht;
		zval *arg, *param;

send_array:
		ht = Z_ARRVAL_P(args);
		if (opline->op2_type != IS_UNUSED) {
			/* We don't need to handle named params in this case,
			 * because array_slice() is called with $preserve_keys == false. */
			zval *op2 = get_zval_ptr(opline->op2_type, opline->op2, BP_VAR_R);
			uint32_t skip = opline->extended_value;
			uint32_t count = zend_hash_num_elements(ht);
			zend_long len = zval_get_long(op2);

			if (len < 0) {
				len += (zend_long)(count - skip);
			}
			if (skip < count && len > 0) {
				if (len > (zend_long)(count - skip)) {
					len = (zend_long)(count - skip);
				}
				zend_vm_stack_extend_call_frame(&EX(call), 0, len);
				arg_num = 1;
				param = ZEND_CALL_ARG(EX(call), 1);
				ZEND_HASH_FOREACH_VAL(ht, arg) {
					zend_bool must_wrap = 0;
					if (skip > 0) {
						skip--;
						continue;
					} else if ((zend_long)(arg_num - 1) >= len) {
						break;
					} else if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
						if (UNEXPECTED(!Z_ISREF_P(arg))) {
							if (!ARG_MAY_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
								/* By-value send is not allowed -- emit a warning,
								 * but still perform the call. */
								zend_param_must_be_ref(EX(call)->func, arg_num);
								must_wrap = 1;
							}
						}
					} else {
						if (Z_ISREF_P(arg) &&
						    !(EX(call)->func->common.fn_flags & ZEND_ACC_CALL_VIA_TRAMPOLINE)) {
							/* don't separate references for __call */
							arg = Z_REFVAL_P(arg);
						}
					}
					if (EXPECTED(!must_wrap)) {
						ZVAL_COPY(param, arg);
					} else {
						Z_TRY_ADDREF_P(arg);
						ZVAL_NEW_REF(param, arg);
					}
					ZEND_CALL_NUM_ARGS(EX(call))++;
					arg_num++;
					param++;
				} ZEND_HASH_FOREACH_END();
			}
			FREE_OP(opline->op2_type, opline->op2.var);
		} else {
			zend_string *name;
			zend_bool have_named_params;
			zend_vm_stack_extend_call_frame(&EX(call), 0, zend_hash_num_elements(ht));
			arg_num = 1;
			param = ZEND_CALL_ARG(EX(call), 1);
			have_named_params = 0;
			ZEND_HASH_FOREACH_STR_KEY_VAL(ht, name, arg) {
				if (name) {
					void *cache_slot[2] = {NULL, NULL};
					have_named_params = 1;
					param = zend_handle_named_arg(&EX(call), name, &arg_num, cache_slot);
					if (!param) {
						FREE_OP(opline->op1_type, opline->op1.var);
						HANDLE_EXCEPTION();
					}
				} else if (have_named_params) {
					zend_throw_error(NULL,
						"Cannot use positional argument after named argument");
					FREE_OP(opline->op1_type, opline->op1.var);
					HANDLE_EXCEPTION();
				}

				zend_bool must_wrap = 0;
				if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
					if (UNEXPECTED(!Z_ISREF_P(arg))) {
						if (!ARG_MAY_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
							/* By-value send is not allowed -- emit a warning,
							 * but still perform the call. */
							zend_param_must_be_ref(EX(call)->func, arg_num);
							must_wrap = 1;
						}
					}
				} else {
					if (Z_ISREF_P(arg) &&
					    !(EX(call)->func->common.fn_flags & ZEND_ACC_CALL_VIA_TRAMPOLINE)) {
						/* don't separate references for __call */
						arg = Z_REFVAL_P(arg);
					}
				}

				if (EXPECTED(!must_wrap)) {
					ZVAL_COPY(param, arg);
				} else {
					Z_TRY_ADDREF_P(arg);
					ZVAL_NEW_REF(param, arg);
				}
				if (!name) {
					ZEND_CALL_NUM_ARGS(EX(call))++;
					arg_num++;
					param++;
				}
			} ZEND_HASH_FOREACH_END();
		}
	}
	FREE_OP(opline->op1_type, opline->op1.var);
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static zend_never_inline ZEND_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_missing_arg_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS)
{
#ifdef ZEND_VM_IP_GLOBAL_REG
	USE_OPLINE

	SAVE_OPLINE();
#endif
	zend_missing_arg_error(execute_data);
	HANDLE_EXCEPTION();
}

static zend_never_inline ZEND_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_verify_recv_arg_type_helper_SPEC(zval *op_1 ZEND_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(!zend_verify_recv_arg_type(EX(func), opline->op1.num, op_1, CACHE_ADDR(opline->extended_value)))) {
		HANDLE_EXCEPTION();
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_RECV_NOTYPE_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	uint32_t arg_num = opline->op1.num;

	if (UNEXPECTED(arg_num > EX_NUM_ARGS())) {
		ZEND_VM_TAIL_CALL(zend_missing_arg_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	ZEND_VM_NEXT_OPCODE();
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_case_helper_SPEC(zval *op_1, zval *op_2 ZEND_OPCODE_HANDLER_ARGS_DC)
{
	int ret;
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(Z_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(Z_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	ret = zend_compare(op_1, op_2);
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	ZEND_VM_SMART_BRANCH(ret == 0, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_ARRAY_UNPACK_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;

	SAVE_OPLINE();
	op1 = get_zval_ptr(opline->op1_type, opline->op1, BP_VAR_R);

add_unpack_again:
	if (EXPECTED(Z_TYPE_P(op1) == IS_ARRAY)) {
		HashTable *ht = Z_ARRVAL_P(op1);
		zval *val;
		zend_string *key;

		ZEND_HASH_FOREACH_STR_KEY_VAL(ht, key, val) {
			if (key) {
				zend_throw_error(NULL, "Cannot unpack array with string keys");
				FREE_OP(opline->op1_type, opline->op1.var);
				HANDLE_EXCEPTION();
			} else {
				if (Z_ISREF_P(val) && Z_REFCOUNT_P(val) == 1) {
					val = Z_REFVAL_P(val);
				}
				Z_TRY_ADDREF_P(val);
				if (!zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), val)) {
					zend_cannot_add_element();
					zval_ptr_dtor_nogc(val);
					break;
				}
			}
		} ZEND_HASH_FOREACH_END();
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_OBJECT)) {
		zend_class_entry *ce = Z_OBJCE_P(op1);
		zend_object_iterator *iter;

		if (!ce || !ce->get_iterator) {
			zend_type_error("Only arrays and Traversables can be unpacked");
		} else {
			iter = ce->get_iterator(ce, op1, 0);
			if (UNEXPECTED(!iter)) {
				FREE_OP(opline->op1_type, opline->op1.var);
				if (!EG(exception)) {
					zend_throw_exception_ex(
						NULL, 0, "Object of type %s did not create an Iterator", ZSTR_VAL(ce->name)
					);
				}
				HANDLE_EXCEPTION();
			}

			if (iter->funcs->rewind) {
				iter->funcs->rewind(iter);
			}

			for (; iter->funcs->valid(iter) == SUCCESS; ) {
				zval *val;

				if (UNEXPECTED(EG(exception) != NULL)) {
					break;
				}

				val = iter->funcs->get_current_data(iter);
				if (UNEXPECTED(EG(exception) != NULL)) {
					break;
				}

				if (iter->funcs->get_current_key) {
					zval key;
					iter->funcs->get_current_key(iter, &key);
					if (UNEXPECTED(EG(exception) != NULL)) {
						break;
					}

					if (UNEXPECTED(Z_TYPE(key) != IS_LONG)) {
						zend_throw_error(NULL,
							(Z_TYPE(key) == IS_STRING) ?
								"Cannot unpack Traversable with string keys" :
								"Cannot unpack Traversable with non-integer keys");
						zval_ptr_dtor(&key);
						break;
					}
				}

				ZVAL_DEREF(val);
				Z_TRY_ADDREF_P(val);

				if (!zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), val)) {
					zend_cannot_add_element();
					zval_ptr_dtor_nogc(val);
				}

				iter->funcs->move_forward(iter);
			}

			zend_iterator_dtor(iter);
		}
	} else if (EXPECTED(Z_ISREF_P(op1))) {
		op1 = Z_REFVAL_P(op1);
		goto add_unpack_again;
	} else {
		zend_throw_error(NULL, "Only arrays and Traversables can be unpacked");
	}

	FREE_OP(opline->op1_type, opline->op1.var);
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_UNSET_STATIC_PROP_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varname;
	zend_string *name, *tmp_name = NULL;
	zend_class_entry *ce;

	SAVE_OPLINE();

	if (opline->op2_type == IS_CONST) {
		ce = CACHED_PTR(opline->extended_value);
		if (UNEXPECTED(ce == NULL)) {
			ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op2)), Z_STR_P(RT_CONSTANT(opline, opline->op2) + 1), ZEND_FETCH_CLASS_DEFAULT | ZEND_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {
				FREE_OP(opline->op1_type, opline->op1.var);
				HANDLE_EXCEPTION();
			}
			/*CACHE_PTR(opline->extended_value, ce);*/
		}
	} else if (opline->op2_type == IS_UNUSED) {
		ce = zend_fetch_class(NULL, opline->op2.num);
		if (UNEXPECTED(ce == NULL)) {
			FREE_OP(opline->op1_type, opline->op1.var);
			HANDLE_EXCEPTION();
		}
	} else {
		ce = Z_CE_P(EX_VAR(opline->op2.var));
	}

	varname = get_zval_ptr_undef(opline->op1_type, opline->op1, BP_VAR_R);
	if (opline->op1_type == IS_CONST) {
		name = Z_STR_P(varname);
	} else if (EXPECTED(Z_TYPE_P(varname) == IS_STRING)) {
		name = Z_STR_P(varname);
	} else {
		if (opline->op1_type == IS_CV && UNEXPECTED(Z_TYPE_P(varname) == IS_UNDEF)) {
			varname = ZVAL_UNDEFINED_OP1();
		}
		name = zval_try_get_tmp_string(varname, &tmp_name);
		if (UNEXPECTED(!name)) {
			FREE_OP(opline->op1_type, opline->op1.var);
			HANDLE_EXCEPTION();
		}
	}

	zend_std_unset_static_property(ce, name);

	zend_tmp_string_release(tmp_name);
	FREE_OP(opline->op1_type, opline->op1.var);
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_STATIC_PROP_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zend_result fetch_result;
	bool result;

	SAVE_OPLINE();

	fetch_result = zend_fetch_static_property_address(&value, NULL, opline->extended_value & ~ZEND_ISEMPTY, BP_VAR_IS, 0 OPLINE_CC EXECUTE_DATA_CC);

	if (!(opline->extended_value & ZEND_ISEMPTY)) {
		result = fetch_result == SUCCESS && Z_TYPE_P(value) > IS_NULL &&
		    (!Z_ISREF_P(value) || Z_TYPE_P(Z_REFVAL_P(value)) != IS_NULL);
	} else {
		result = fetch_result != SUCCESS || !i_zend_is_true(value);
	}

	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_EXIT_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (opline->op1_type != IS_UNUSED) {
		zval *ptr = get_zval_ptr(opline->op1_type, opline->op1, BP_VAR_R);

		do {
			if (Z_TYPE_P(ptr) == IS_LONG) {
				EG(exit_status) = Z_LVAL_P(ptr);
			} else {
				if ((opline->op1_type & (IS_VAR|IS_CV)) && Z_ISREF_P(ptr)) {
					ptr = Z_REFVAL_P(ptr);
					if (Z_TYPE_P(ptr) == IS_LONG) {
						EG(exit_status) = Z_LVAL_P(ptr);
						break;
					}
				}
				zend_print_zval(ptr, 0);
			}
		} while (0);
		FREE_OP(opline->op1_type, opline->op1.var);
	}

	if (!EG(exception)) {
		zend_throw_unwind_exit();
	}
	HANDLE_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BEGIN_SILENCE_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	ZVAL_LONG(EX_VAR(opline->result.var), EG(error_reporting));

	if (!E_HAS_ONLY_FATAL_ERRORS(EG(error_reporting))) {
		do {
			/* Do not silence fatal errors */
			EG(error_reporting) &= E_FATAL_ERRORS;
			if (!EG(error_reporting_ini_entry)) {
				zval *zv = zend_hash_find_ex(EG(ini_directives), ZSTR_KNOWN(ZEND_STR_ERROR_REPORTING), 1);
				if (zv) {
					EG(error_reporting_ini_entry) = (zend_ini_entry *)Z_PTR_P(zv);
				} else {
					break;
				}
			}
			if (!EG(error_reporting_ini_entry)->modified) {
				if (!EG(modified_ini_directives)) {
					ALLOC_HASHTABLE(EG(modified_ini_directives));
					zend_hash_init(EG(modified_ini_directives), 8, NULL, NULL, 0);
				}
				if (EXPECTED(zend_hash_add_ptr(EG(modified_ini_directives), ZSTR_KNOWN(ZEND_STR_ERROR_REPORTING), EG(error_reporting_ini_entry)) != NULL)) {
					EG(error_reporting_ini_entry)->orig_value = EG(error_reporting_ini_entry)->value;
					EG(error_reporting_ini_entry)->orig_modifiable = EG(error_reporting_ini_entry)->modifiable;
					EG(error_reporting_ini_entry)->modified = 1;
				}
			}
		} while (0);
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_EXT_STMT_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (!EG(no_extensions)) {
		SAVE_OPLINE();
		zend_llist_apply_with_argument(&zend_extensions, (llist_apply_with_arg_func_t) zend_extension_statement_handler, execute_data);
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (!EG(no_extensions)) {
		SAVE_OPLINE();
		zend_llist_apply_with_argument(&zend_extensions, (llist_apply_with_arg_func_t) zend_extension_fcall_begin_handler, execute_data);
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_EXT_FCALL_END_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (!EG(no_extensions)) {
		SAVE_OPLINE();
		zend_llist_apply_with_argument(&zend_extensions, (llist_apply_with_arg_func_t) zend_extension_fcall_end_handler, execute_data);
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *zv;
	zend_class_entry *ce;
	USE_OPLINE

	ce = CACHED_PTR(opline->extended_value);
	if (UNEXPECTED(ce == NULL)) {
		zend_string *rtd_key = Z_STR_P(RT_CONSTANT(opline, opline->op1));
		zv = zend_hash_find_ex(EG(class_table), rtd_key, 1);
		if (UNEXPECTED(zv == NULL)) {
			SAVE_OPLINE();
			do {
				ZEND_ASSERT(EX(func)->op_array.fn_flags & ZEND_ACC_PRELOADED);
				if (zend_preload_autoload
				  && zend_preload_autoload(EX(func)->op_array.filename) == SUCCESS) {
					zv = zend_hash_find_ex(EG(class_table), rtd_key, 1);
					if (EXPECTED(zv != NULL)) {
						break;
					}
				}
				zend_error_noreturn(E_ERROR, "Anonymous class wasn't preloaded");
			} while (0);
		}
		ZEND_ASSERT(zv != NULL);
		ce = Z_CE_P(zv);
		if (!(ce->ce_flags & ZEND_ACC_LINKED)) {
			SAVE_OPLINE();
			if (zend_do_link_class(ce, (opline->op2_type == IS_CONST) ? Z_STR_P(RT_CONSTANT(opline, opline->op2)) : NULL) == FAILURE) {
				HANDLE_EXCEPTION();
			}
		}
		CACHE_PTR(opline->extended_value, ce);
	}
	Z_CE_P(EX_VAR(opline->result.var)) = ce;
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DECLARE_FUNCTION_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	do_bind_function(RT_CONSTANT(opline, opline->op1));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_TICKS_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if ((uint32_t)++EG(ticks_count) >= opline->extended_value) {
		EG(ticks_count) = 0;
		if (zend_ticks_function) {
			SAVE_OPLINE();
			zend_ticks_function(opline->extended_value);
			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_EXT_NOP_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_NOP_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	ZEND_VM_NEXT_OPCODE();
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_dispatch_try_catch_finally_helper_SPEC(uint32_t try_catch_offset, uint32_t op_num ZEND_OPCODE_HANDLER_ARGS_DC)
{
	/* May be NULL during generator closing (only finally blocks are executed) */
	zend_object *ex = EG(exception);

	/* Walk try/catch/finally structures upwards, performing the necessary actions */
	for (; try_catch_offset != (uint32_t) -1; try_catch_offset--) {
		zend_try_catch_element *try_catch =
			&EX(func)->op_array.try_catch_array[try_catch_offset];

		if (op_num < try_catch->catch_op && ex) {
			/* Go to catch block */
			cleanup_live_vars(execute_data, op_num, try_catch->catch_op);
			ZEND_VM_JMP_EX(&EX(func)->op_array.opcodes[try_catch->catch_op], 0);

		} else if (op_num < try_catch->finally_op) {
			if (ex && zend_is_unwind_exit(ex)) {
				/* Don't execute finally blocks on exit (for now) */
				continue;
			}

			/* Go to finally block */
			zval *fast_call = EX_VAR(EX(func)->op_array.opcodes[try_catch->finally_end].op1.var);
			cleanup_live_vars(execute_data, op_num, try_catch->finally_op);
			Z_OBJ_P(fast_call) = EG(exception);
			EG(exception) = NULL;
			Z_OPLINE_NUM_P(fast_call) = (uint32_t)-1;
			ZEND_VM_JMP_EX(&EX(func)->op_array.opcodes[try_catch->finally_op], 0);

		} else if (op_num < try_catch->finally_end) {
			zval *fast_call = EX_VAR(EX(func)->op_array.opcodes[try_catch->finally_end].op1.var);

			/* cleanup incomplete RETURN statement */
			if (Z_OPLINE_NUM_P(fast_call) != (uint32_t)-1
			 && (EX(func)->op_array.opcodes[Z_OPLINE_NUM_P(fast_call)].op2_type & (IS_TMP_VAR | IS_VAR))) {
				zval *return_value = EX_VAR(EX(func)->op_array.opcodes[Z_OPLINE_NUM_P(fast_call)].op2.var);

				zval_ptr_dtor(return_value);
			}

			/* Chain potential exception from wrapping finally block */
			if (Z_OBJ_P(fast_call)) {
				if (ex) {
					zend_exception_set_previous(ex, Z_OBJ_P(fast_call));
				} else {
					EG(exception) = Z_OBJ_P(fast_call);
				}
				ex = Z_OBJ_P(fast_call);
			}
		}
	}

	/* Uncaught exception */
	cleanup_live_vars(execute_data, op_num, 0);
	if (UNEXPECTED((EX_CALL_INFO() & ZEND_CALL_GENERATOR) != 0)) {
		zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);
		zend_generator_close(generator, 1);
		ZEND_VM_RETURN();
	} else {
		/* We didn't execute RETURN, and have to initialize return_value */
		if (EX(return_value)) {
			ZVAL_UNDEF(EX(return_value));
		}
		ZEND_VM_TAIL_CALL(zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_HANDLE_EXCEPTION_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	const zend_op *throw_op = EG(opline_before_exception);
	uint32_t throw_op_num = throw_op - EX(func)->op_array.opcodes;
	int i, current_try_catch_offset = -1;

	if ((throw_op->opcode == ZEND_FREE || throw_op->opcode == ZEND_FE_FREE)
		&& throw_op->extended_value & ZEND_FREE_ON_RETURN) {
		/* exceptions thrown because of loop var destruction on return/break/...
		 * are logically thrown at the end of the foreach loop, so adjust the
		 * throw_op_num.
		 */
		const zend_live_range *range = find_live_range(
			&EX(func)->op_array, throw_op_num, throw_op->op1.var);
		throw_op_num = range->end;
	}

	/* Find the innermost try/catch/finally the exception was thrown in */
	for (i = 0; i < EX(func)->op_array.last_try_catch; i++) {
		zend_try_catch_element *try_catch = &EX(func)->op_array.try_catch_array[i];
		if (try_catch->try_op > throw_op_num) {
			/* further blocks will not be relevant... */
			break;
		}
		if (throw_op_num < try_catch->catch_op || throw_op_num < try_catch->finally_end) {
			current_try_catch_offset = i;
		}
	}

	cleanup_unfinished_calls(execute_data, throw_op_num);

	if (throw_op->result_type & (IS_VAR | IS_TMP_VAR)) {
		switch (throw_op->opcode) {
			case ZEND_ADD_ARRAY_ELEMENT:
			case ZEND_ADD_ARRAY_UNPACK:
			case ZEND_ROPE_INIT:
			case ZEND_ROPE_ADD:
				break; /* exception while building structures, live range handling will free those */

			case ZEND_FETCH_CLASS:
			case ZEND_DECLARE_ANON_CLASS:
				break; /* return value is zend_class_entry pointer */

			default:
				/* smart branch opcodes may not initialize result */
				if (!zend_is_smart_branch(throw_op)) {
					zval_ptr_dtor_nogc(EX_VAR(throw_op->result.var));
				}
		}
	}

	ZEND_VM_TAIL_CALL(zend_dispatch_try_catch_finally_helper_SPEC(current_try_catch_offset, throw_op_num ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_HANDLE_EXCEPTION_SPEC_OBSERVER_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	const zend_op *throw_op = EG(opline_before_exception);
	uint32_t throw_op_num = throw_op - EX(func)->op_array.opcodes;
	int i, current_try_catch_offset = -1;

	if ((throw_op->opcode == ZEND_FREE || throw_op->opcode == ZEND_FE_FREE)
		&& throw_op->extended_value & ZEND_FREE_ON_RETURN) {
		/* exceptions thrown because of loop var destruction on return/break/...
		 * are logically thrown at the end of the foreach loop, so adjust the
		 * throw_op_num.
		 */
		const zend_live_range *range = find_live_range(
			&EX(func)->op_array, throw_op_num, throw_op->op1.var);
		throw_op_num = range->end;
	}

	/* Find the innermost try/catch/finally the exception was thrown in */
	for (i = 0; i < EX(func)->op_array.last_try_catch; i++) {
		zend_try_catch_element *try_catch = &EX(func)->op_array.try_catch_array[i];
		if (try_catch->try_op > throw_op_num) {
			/* further blocks will not be relevant... */
			break;
		}
		if (throw_op_num < try_catch->catch_op || throw_op_num < try_catch->finally_end) {
			current_try_catch_offset = i;
		}
	}

	zend_observer_fcall_end(execute_data, EX(return_value));
	cleanup_unfinished_calls(execute_data, throw_op_num);

	if (throw_op->result_type & (IS_VAR | IS_TMP_VAR)) {
		switch (throw_op->opcode) {
			case ZEND_ADD_ARRAY_ELEMENT:
			case ZEND_ADD_ARRAY_UNPACK:
			case ZEND_ROPE_INIT:
			case ZEND_ROPE_ADD:
				break; /* exception while building structures, live range handling will free those */

			case ZEND_FETCH_CLASS:
			case ZEND_DECLARE_ANON_CLASS:
				break; /* return value is zend_class_entry pointer */

			default:
				/* smart branch opcodes may not initialize result */
				if (!zend_is_smart_branch(throw_op)) {
					zval_ptr_dtor_nogc(EX_VAR(throw_op->result.var));
				}
		}
	}

	ZEND_VM_TAIL_CALL(zend_dispatch_try_catch_finally_helper_SPEC(current_try_catch_offset, throw_op_num ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_USER_OPCODE_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	int ret;

	SAVE_OPLINE();
	ret = zend_user_opcode_handlers[opline->opcode](execute_data);
	opline = EX(opline);

	switch (ret) {
		case ZEND_USER_OPCODE_CONTINUE:
			ZEND_VM_CONTINUE();
		case ZEND_USER_OPCODE_RETURN:
			if (UNEXPECTED((EX_CALL_INFO() & ZEND_CALL_GENERATOR) != 0)) {
				zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);
				zend_generator_close(generator, 1);
				ZEND_VM_RETURN();
			} else {
				ZEND_VM_TAIL_CALL(zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
			}
		case ZEND_USER_OPCODE_ENTER:
			ZEND_VM_ENTER();
		case ZEND_USER_OPCODE_LEAVE:
			ZEND_VM_LEAVE();
		case ZEND_USER_OPCODE_DISPATCH:
			ZEND_VM_DISPATCH(opline->opcode, opline);
		default:
			ZEND_VM_DISPATCH((zend_uchar)(ret & 0xff), opline);
	}
}

static zend_never_inline ZEND_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_yield_in_closed_generator_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	zend_throw_error(NULL, "Cannot yield from finally in a force-closed generator");
	FREE_OP(opline->op2_type, opline->op2.var);
	FREE_OP(opline->op1_type, opline->op1.var);
	UNDEF_RESULT();
	HANDLE_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DISCARD_EXCEPTION_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *fast_call = EX_VAR(opline->op1.var);
	SAVE_OPLINE();

	/* cleanup incomplete RETURN statement */
	if (Z_OPLINE_NUM_P(fast_call) != (uint32_t)-1
	 && (EX(func)->op_array.opcodes[Z_OPLINE_NUM_P(fast_call)].op2_type & (IS_TMP_VAR | IS_VAR))) {
		zval *return_value = EX_VAR(EX(func)->op_array.opcodes[Z_OPLINE_NUM_P(fast_call)].op2.var);

		zval_ptr_dtor(return_value);
	}

	/* cleanup delayed exception */
	if (Z_OBJ_P(fast_call) != NULL) {
		/* discard the previously thrown exception */
		OBJ_RELEASE(Z_OBJ_P(fast_call));
		Z_OBJ_P(fast_call) = NULL;
	}

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CALL_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *fast_call = EX_VAR(opline->result.var);

	Z_OBJ_P(fast_call) = NULL;
	/* set return address */
	Z_OPLINE_NUM_P(fast_call) = opline - EX(func)->op_array.opcodes;
	ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op1), 0);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_RET_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *fast_call = EX_VAR(opline->op1.var);
	uint32_t current_try_catch_offset, current_op_num;

	if (Z_OPLINE_NUM_P(fast_call) != (uint32_t)-1) {
		const zend_op *fast_ret = EX(func)->op_array.opcodes + Z_OPLINE_NUM_P(fast_call);

		ZEND_VM_JMP_EX(fast_ret + 1, 0);
	}

	/* special case for unhandled exceptions */
	EG(exception) = Z_OBJ_P(fast_call);
	Z_OBJ_P(fast_call) = NULL;
	current_try_catch_offset = opline->op2.num;
	current_op_num = opline - EX(func)->op_array.opcodes;
	ZEND_VM_TAIL_CALL(zend_dispatch_try_catch_finally_helper_SPEC(current_try_catch_offset, current_op_num ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSERT_CHECK_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EG(assertions) <= 0) {
		zend_op *target = OP_JMP_ADDR(opline, opline->op2);
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_TRUE(EX_VAR(opline->result.var));
		}
		ZEND_VM_JMP_EX(target, 0);
	} else {
		ZEND_VM_NEXT_OPCODE();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CALL_TRAMPOLINE_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_array *args = NULL;
	zend_function *fbc = EX(func);
	zval *ret = EX(return_value);
	uint32_t call_info = EX_CALL_INFO() & (ZEND_CALL_NESTED | ZEND_CALL_TOP | ZEND_CALL_RELEASE_THIS | ZEND_CALL_HAS_EXTRA_NAMED_PARAMS);
	uint32_t num_args = EX_NUM_ARGS();
	zend_execute_data *call;

	SAVE_OPLINE();

	if (num_args) {
		zval *p = ZEND_CALL_ARG(execute_data, 1);
		zval *end = p + num_args;

		args = zend_new_array(num_args);
		zend_hash_real_init_packed(args);
		ZEND_HASH_FILL_PACKED(args) {
			do {
				ZEND_HASH_FILL_ADD(p);
				p++;
			} while (p != end);
		} ZEND_HASH_FILL_END();
	}

	call = execute_data;
	execute_data = EG(current_execute_data) = EX(prev_execute_data);

	call->func = (fbc->op_array.fn_flags & ZEND_ACC_STATIC) ? fbc->op_array.scope->__callstatic : fbc->op_array.scope->__call;
	ZEND_ASSERT(zend_vm_calc_used_stack(2, call->func) <= (size_t)(((char*)EG(vm_stack_end)) - (char*)call));
	ZEND_CALL_NUM_ARGS(call) = 2;

	ZVAL_STR(ZEND_CALL_ARG(call, 1), fbc->common.function_name);

	zval *call_args = ZEND_CALL_ARG(call, 2);
	if (args) {
		ZVAL_ARR(call_args, args);
	} else {
		ZVAL_EMPTY_ARRAY(call_args);
	}
	if (UNEXPECTED(call_info & ZEND_CALL_HAS_EXTRA_NAMED_PARAMS)) {
		if (zend_hash_num_elements(Z_ARRVAL_P(call_args)) == 0) {
			GC_ADDREF(call->extra_named_params);
			ZVAL_ARR(call_args, call->extra_named_params);
		} else {
			SEPARATE_ARRAY(call_args);
			zend_hash_copy(Z_ARRVAL_P(call_args), call->extra_named_params, zval_add_ref);
		}
	}
	zend_free_trampoline(fbc);
	fbc = call->func;

	if (EXPECTED(fbc->type == ZEND_USER_FUNCTION)) {
		if (UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		execute_data = call;
		i_init_func_execute_data(&fbc->op_array, ret, 0 EXECUTE_DATA_CC);

		if (EXPECTED(zend_execute_ex == execute_ex)) {
			LOAD_OPLINE_EX();
			ZEND_VM_ENTER_EX();
		} else {
			SAVE_OPLINE_EX();
			execute_data = EX(prev_execute_data);
			LOAD_OPLINE();
			ZEND_ADD_CALL_FLAG(call, ZEND_CALL_TOP);
			zend_execute_ex(call);
		}
	} else {
		zval retval;

		ZEND_ASSERT(fbc->type == ZEND_INTERNAL_FUNCTION);

		EG(current_execute_data) = call;

#if ZEND_DEBUG
		zend_bool should_throw = zend_internal_call_should_throw(fbc, call);
#endif

		if (ret == NULL) {
			ret = &retval;
		}

		ZVAL_NULL(ret);
		if (!zend_execute_internal) {
			/* saves one function call if zend_execute_internal is not used */
			fbc->internal_function.handler(call, ret);
		} else {
			zend_execute_internal(call, ret);
		}

#if ZEND_DEBUG
		if (!EG(exception) && call->func) {
			if (should_throw) {
				zend_internal_call_arginfo_violation(call->func);
			}
			ZEND_ASSERT(!(call->func->common.fn_flags & ZEND_ACC_HAS_RETURN_TYPE) ||
				zend_verify_internal_return_type(call->func, ret));
			ZEND_ASSERT((call->func->common.fn_flags & ZEND_ACC_RETURN_REFERENCE)
				? Z_ISREF_P(ret) : !Z_ISREF_P(ret));
		}
#endif

		EG(current_execute_data) = call->prev_execute_data;

		zend_vm_stack_free_args(call);
		if (ret == &retval) {
			zval_ptr_dtor(ret);
		}
	}

	execute_data = EG(current_execute_data);

	if (!EX(func) || !ZEND_USER_CODE(EX(func)->type) || (call_info & ZEND_CALL_TOP)) {
		ZEND_VM_RETURN();
	}

	if (UNEXPECTED(call_info & ZEND_CALL_RELEASE_THIS)) {
		zend_object *object = Z_OBJ(call->This);
		OBJ_RELEASE(object);
	}
	zend_vm_stack_free_call_frame(call);

	if (UNEXPECTED(EG(exception) != NULL)) {
		zend_rethrow_exception(execute_data);
		HANDLE_EXCEPTION_LEAVE();
	}

	LOAD_OPLINE();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_LEAVE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CALL_TRAMPOLINE_SPEC_OBSERVER_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_array *args = NULL;
	zend_function *fbc = EX(func);
	zval *ret = EX(return_value);
	uint32_t call_info = EX_CALL_INFO() & (ZEND_CALL_NESTED | ZEND_CALL_TOP | ZEND_CALL_RELEASE_THIS | ZEND_CALL_HAS_EXTRA_NAMED_PARAMS);
	uint32_t num_args = EX_NUM_ARGS();
	zend_execute_data *call;

	SAVE_OPLINE();

	if (num_args) {
		zval *p = ZEND_CALL_ARG(execute_data, 1);
		zval *end = p + num_args;

		args = zend_new_array(num_args);
		zend_hash_real_init_packed(args);
		ZEND_HASH_FILL_PACKED(args) {
			do {
				ZEND_HASH_FILL_ADD(p);
				p++;
			} while (p != end);
		} ZEND_HASH_FILL_END();
	}

	call = execute_data;
	execute_data = EG(current_execute_data) = EX(prev_execute_data);

	call->func = (fbc->op_array.fn_flags & ZEND_ACC_STATIC) ? fbc->op_array.scope->__callstatic : fbc->op_array.scope->__call;
	ZEND_ASSERT(zend_vm_calc_used_stack(2, call->func) <= (size_t)(((char*)EG(vm_stack_end)) - (char*)call));
	ZEND_CALL_NUM_ARGS(call) = 2;

	ZVAL_STR(ZEND_CALL_ARG(call, 1), fbc->common.function_name);

	zval *call_args = ZEND_CALL_ARG(call, 2);
	if (args) {
		ZVAL_ARR(call_args, args);
	} else {
		ZVAL_EMPTY_ARRAY(call_args);
	}
	if (UNEXPECTED(call_info & ZEND_CALL_HAS_EXTRA_NAMED_PARAMS)) {
		if (zend_hash_num_elements(Z_ARRVAL_P(call_args)) == 0) {
			GC_ADDREF(call->extra_named_params);
			ZVAL_ARR(call_args, call->extra_named_params);
		} else {
			SEPARATE_ARRAY(call_args);
			zend_hash_copy(Z_ARRVAL_P(call_args), call->extra_named_params, zval_add_ref);
		}
	}
	zend_free_trampoline(fbc);
	fbc = call->func;

	if (EXPECTED(fbc->type == ZEND_USER_FUNCTION)) {
		if (UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		execute_data = call;
		i_init_func_execute_data(&fbc->op_array, ret, 0 EXECUTE_DATA_CC);
		zend_observer_fcall_begin(execute_data);
		if (EXPECTED(zend_execute_ex == execute_ex)) {
			LOAD_OPLINE_EX();
			ZEND_VM_ENTER_EX();
		} else {
			SAVE_OPLINE_EX();
			execute_data = EX(prev_execute_data);
			LOAD_OPLINE();
			ZEND_ADD_CALL_FLAG(call, ZEND_CALL_TOP);
			zend_execute_ex(call);
		}
	} else {
		zval retval;

		ZEND_ASSERT(fbc->type == ZEND_INTERNAL_FUNCTION);

		EG(current_execute_data) = call;

#if ZEND_DEBUG
		zend_bool should_throw = zend_internal_call_should_throw(fbc, call);
#endif

		if (ret == NULL) {
			ret = &retval;
		}

		ZVAL_NULL(ret);
		if (!zend_execute_internal) {
			/* saves one function call if zend_execute_internal is not used */
			fbc->internal_function.handler(call, ret);
		} else {
			zend_execute_internal(call, ret);
		}

#if ZEND_DEBUG
		if (!EG(exception) && call->func) {
			if (should_throw) {
				zend_internal_call_arginfo_violation(call->func);
			}
			ZEND_ASSERT(!(call->func->common.fn_flags & ZEND_ACC_HAS_RETURN_TYPE) ||
				zend_verify_internal_return_type(call->func, ret));
			ZEND_ASSERT((call->func->common.fn_flags & ZEND_ACC_RETURN_REFERENCE)
				? Z_ISREF_P(ret) : !Z_ISREF_P(ret));
		}
#endif

		EG(current_execute_data) = call->prev_execute_data;

		zend_vm_stack_free_args(call);
		if (ret == &retval) {
			zval_ptr_dtor(ret);
		}
	}

	execute_data = EG(current_execute_data);

	if (!EX(func) || !ZEND_USER_CODE(EX(func)->type) || (call_info & ZEND_CALL_TOP)) {
		ZEND_VM_RETURN();
	}

	if (UNEXPECTED(call_info & ZEND_CALL_RELEASE_THIS)) {
		zend_object *object = Z_OBJ(call->This);
		OBJ_RELEASE(object);
	}
	zend_vm_stack_free_call_frame(call);

	if (UNEXPECTED(EG(exception) != NULL)) {
		zend_rethrow_exception(execute_data);
		HANDLE_EXCEPTION_LEAVE();
	}

	LOAD_OPLINE();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_LEAVE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMP_FORWARD_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	OPLINE = OP_JMP_ADDR(opline, opline->op1);
	ZEND_VM_CONTINUE();
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_interrupt_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS)
{
	EG(vm_interrupt) = 0;
	SAVE_OPLINE();
	if (EG(timed_out)) {
		zend_timeout();
	} else if (zend_interrupt_function) {
		zend_interrupt_function(execute_data);
		ZEND_VM_ENTER();
	}
	ZEND_VM_CONTINUE();
}
static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_function *fbc;
	zval *function_name, *func;
	zend_execute_data *call;

	fbc = CACHED_PTR(opline->result.num);
	if (UNEXPECTED(fbc == NULL)) {
		function_name = (zval*)RT_CONSTANT(opline, opline->op2);
		func = zend_hash_find_ex(EG(function_table), Z_STR_P(function_name+1), 1);
		if (UNEXPECTED(func == NULL)) {
			ZEND_VM_TAIL_CALL(zend_undefined_function_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		fbc = Z_FUNC_P(func);
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		CACHE_PTR(opline->result.num, fbc);
	}
	call = _zend_vm_stack_push_call_frame(ZEND_CALL_NESTED_FUNCTION,
		fbc, opline->extended_value, NULL);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_DYNAMIC_CALL_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_execute_data *call;

	SAVE_OPLINE();
	function_name = RT_CONSTANT(opline, opline->op2);

try_function_name:
	if (IS_CONST != IS_CONST && EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
		call = zend_init_dynamic_call_string(Z_STR_P(function_name), opline->extended_value);
	} else if (IS_CONST != IS_CONST && EXPECTED(Z_TYPE_P(function_name) == IS_OBJECT)) {
		call = zend_init_dynamic_call_object(Z_OBJ_P(function_name), opline->extended_value);
	} else if (EXPECTED(Z_TYPE_P(function_name) == IS_ARRAY)) {
		call = zend_init_dynamic_call_array(Z_ARRVAL_P(function_name), opline->extended_value);
	} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(function_name) == IS_REFERENCE)) {
		function_name = Z_REFVAL_P(function_name);
		goto try_function_name;
	} else {
		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
			function_name = ZVAL_UNDEFINED_OP2();
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
		}
		zend_throw_error(NULL, "Value of type %s is not callable",
			zend_zval_type_name(function_name));
		call = NULL;
	}

	if (IS_CONST & (IS_VAR|IS_TMP_VAR)) {

		if (UNEXPECTED(EG(exception))) {
			if (call) {
				 if (call->func->common.fn_flags & ZEND_ACC_CALL_VIA_TRAMPOLINE) {
					zend_string_release_ex(call->func->common.function_name, 0);
					zend_free_trampoline(call->func);
				}
				zend_vm_stack_free_call_frame(call);
			}
			HANDLE_EXCEPTION();
		}
	} else if (!call) {
		HANDLE_EXCEPTION();
	}

	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *func_name;
	zval *func;
	zend_function *fbc;
	zend_execute_data *call;

	fbc = CACHED_PTR(opline->result.num);
	if (UNEXPECTED(fbc == NULL)) {
		func_name = (zval *)RT_CONSTANT(opline, opline->op2);
		func = zend_hash_find_ex(EG(function_table), Z_STR_P(func_name + 1), 1);
		if (func == NULL) {
			func = zend_hash_find_ex(EG(function_table), Z_STR_P(func_name + 2), 1);
			if (UNEXPECTED(func == NULL)) {
				ZEND_VM_TAIL_CALL(zend_undefined_function_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
			}
		}
		fbc = Z_FUNC_P(func);
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		CACHE_PTR(opline->result.num, fbc);
	}

	call = _zend_vm_stack_push_call_frame(ZEND_CALL_NESTED_FUNCTION,
		fbc, opline->extended_value, NULL);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_FCALL_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *fname;
	zval *func;
	zend_function *fbc;
	zend_execute_data *call;

	fbc = CACHED_PTR(opline->result.num);
	if (UNEXPECTED(fbc == NULL)) {
		fname = (zval*)RT_CONSTANT(opline, opline->op2);
		func = zend_hash_find_ex(EG(function_table), Z_STR_P(fname), 1);
		if (UNEXPECTED(func == NULL)) {
			ZEND_VM_TAIL_CALL(zend_undefined_function_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		fbc = Z_FUNC_P(func);
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		CACHE_PTR(opline->result.num, fbc);
	}

	call = _zend_vm_stack_push_call_frame_ex(
		opline->op1.num, ZEND_CALL_NESTED_FUNCTION,
		fbc, opline->extended_value, NULL);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_RECV_INIT_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	uint32_t arg_num;
	zval *param;

	ZEND_VM_REPEATABLE_OPCODE

	arg_num = opline->op1.num;
	param = EX_VAR(opline->result.var);
	if (arg_num > EX_NUM_ARGS()) {
		zval *default_value = RT_CONSTANT(opline, opline->op2);

		if (Z_OPT_TYPE_P(default_value) == IS_CONSTANT_AST) {
			zval *cache_val = (zval*)CACHE_ADDR(Z_CACHE_SLOT_P(default_value));

			/* we keep in cache only not refcounted values */
			if (Z_TYPE_P(cache_val) != IS_UNDEF) {
				ZVAL_COPY_VALUE(param, cache_val);
			} else {
				SAVE_OPLINE();
				ZVAL_COPY(param, default_value);
				if (UNEXPECTED(zval_update_constant_ex(param, EX(func)->op_array.scope) != SUCCESS)) {
					zval_ptr_dtor_nogc(param);
					ZVAL_UNDEF(param);
					HANDLE_EXCEPTION();
				}
				if (!Z_REFCOUNTED_P(param)) {
					ZVAL_COPY_VALUE(cache_val, param);
				}
			}
			goto recv_init_check_type;
		} else {
			ZVAL_COPY(param, default_value);
		}
	} else {
recv_init_check_type:
		if (UNEXPECTED((EX(func)->op_array.fn_flags & ZEND_ACC_HAS_TYPE_HINTS) != 0)) {
			SAVE_OPLINE();
			if (UNEXPECTED(!zend_verify_recv_arg_type(EX(func), arg_num, param, CACHE_ADDR(opline->extended_value)))) {
				HANDLE_EXCEPTION();
			}
		}
	}

	ZEND_VM_REPEAT_OPCODE(ZEND_RECV_INIT);
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_DYNAMIC_CALL_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_execute_data *call;

	SAVE_OPLINE();
	function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

try_function_name:
	if ((IS_TMP_VAR|IS_VAR) != IS_CONST && EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
		call = zend_init_dynamic_call_string(Z_STR_P(function_name), opline->extended_value);
	} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && EXPECTED(Z_TYPE_P(function_name) == IS_OBJECT)) {
		call = zend_init_dynamic_call_object(Z_OBJ_P(function_name), opline->extended_value);
	} else if (EXPECTED(Z_TYPE_P(function_name) == IS_ARRAY)) {
		call = zend_init_dynamic_call_array(Z_ARRVAL_P(function_name), opline->extended_value);
	} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(function_name) == IS_REFERENCE)) {
		function_name = Z_REFVAL_P(function_name);
		goto try_function_name;
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
			function_name = ZVAL_UNDEFINED_OP2();
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
		}
		zend_throw_error(NULL, "Value of type %s is not callable",
			zend_zval_type_name(function_name));
		call = NULL;
	}

	if ((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR)) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
		if (UNEXPECTED(EG(exception))) {
			if (call) {
				 if (call->func->common.fn_flags & ZEND_ACC_CALL_VIA_TRAMPOLINE) {
					zend_string_release_ex(call->func->common.function_name, 0);
					zend_free_trampoline(call->func);
				}
				zend_vm_stack_free_call_frame(call);
			}
			HANDLE_EXCEPTION();
		}
	} else if (!call) {
		HANDLE_EXCEPTION();
	}

	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_RECV_SPEC_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	uint32_t arg_num = opline->op1.num;
	zval *param;

	if (UNEXPECTED(arg_num > EX_NUM_ARGS())) {
		ZEND_VM_TAIL_CALL(zend_missing_arg_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	param = EX_VAR(opline->result.var);

	if (UNEXPECTED(!(opline->op2.num & (1u << Z_TYPE_P(param))))) {
		ZEND_VM_TAIL_CALL(zend_verify_recv_arg_type_helper_SPEC(param ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_RECV_VARIADIC_SPEC_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	uint32_t arg_num = opline->op1.num;
	uint32_t arg_count = EX_NUM_ARGS();
	zval *params;

	SAVE_OPLINE();

	params = EX_VAR(opline->result.var);

	if (arg_num <= arg_count) {
		ZEND_ASSERT(EX(func)->common.fn_flags & ZEND_ACC_VARIADIC);
		ZEND_ASSERT(EX(func)->common.num_args == arg_num - 1);
		zend_arg_info *arg_info = &EX(func)->common.arg_info[arg_num - 1];

		array_init_size(params, arg_count - arg_num + 1);
		zend_hash_real_init_packed(Z_ARRVAL_P(params));
		ZEND_HASH_FILL_PACKED(Z_ARRVAL_P(params)) {
			zval *param = EX_VAR_NUM(EX(func)->op_array.last_var + EX(func)->op_array.T);
			if (UNEXPECTED(ZEND_TYPE_IS_SET(arg_info->type))) {
				ZEND_ADD_CALL_FLAG(execute_data, ZEND_CALL_FREE_EXTRA_ARGS);
				do {
					if (UNEXPECTED(!zend_verify_variadic_arg_type(EX(func), arg_info, arg_num, param, CACHE_ADDR(opline->extended_value)))) {
						ZEND_HASH_FILL_FINISH();
						HANDLE_EXCEPTION();
					}

					if (Z_OPT_REFCOUNTED_P(param)) Z_ADDREF_P(param);
					ZEND_HASH_FILL_ADD(param);
					param++;
				} while (++arg_num <= arg_count);
			} else {
				do {
					if (Z_OPT_REFCOUNTED_P(param)) Z_ADDREF_P(param);
					ZEND_HASH_FILL_ADD(param);
					param++;
				} while (++arg_num <= arg_count);
			}
		} ZEND_HASH_FILL_END();
	} else {
		ZVAL_EMPTY_ARRAY(params);
	}

	if (EX_CALL_INFO() & ZEND_CALL_HAS_EXTRA_NAMED_PARAMS) {
		zend_string *name;
		zval *param;
		zend_arg_info *arg_info = &EX(func)->common.arg_info[EX(func)->common.num_args];
		if (ZEND_TYPE_IS_SET(arg_info->type)) {
			SEPARATE_ARRAY(params);
			ZEND_HASH_FOREACH_STR_KEY_VAL(EX(extra_named_params), name, param) {
				if (UNEXPECTED(!zend_verify_variadic_arg_type(EX(func), arg_info, arg_num, param, CACHE_ADDR(opline->extended_value)))) {
					HANDLE_EXCEPTION();
				}
				Z_TRY_ADDREF_P(param);
				zend_hash_add_new(Z_ARRVAL_P(params), name, param);
			} ZEND_HASH_FOREACH_END();
		} else if (zend_hash_num_elements(Z_ARRVAL_P(params)) == 0) {
			GC_ADDREF(EX(extra_named_params));
			ZVAL_ARR(params, EX(extra_named_params));
		} else {
			SEPARATE_ARRAY(params);
			ZEND_HASH_FOREACH_STR_KEY_VAL(EX(extra_named_params), name, param) {
				Z_TRY_ADDREF_P(param);
				zend_hash_add_new(Z_ARRVAL_P(params), name, param);
			} ZEND_HASH_FOREACH_END();
		}
	}

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_DYNAMIC_CALL_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_execute_data *call;

	SAVE_OPLINE();
	function_name = EX_VAR(opline->op2.var);

try_function_name:
	if (IS_CV != IS_CONST && EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
		call = zend_init_dynamic_call_string(Z_STR_P(function_name), opline->extended_value);
	} else if (IS_CV != IS_CONST && EXPECTED(Z_TYPE_P(function_name) == IS_OBJECT)) {
		call = zend_init_dynamic_call_object(Z_OBJ_P(function_name), opline->extended_value);
	} else if (EXPECTED(Z_TYPE_P(function_name) == IS_ARRAY)) {
		call = zend_init_dynamic_call_array(Z_ARRVAL_P(function_name), opline->extended_value);
	} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(function_name) == IS_REFERENCE)) {
		function_name = Z_REFVAL_P(function_name);
		goto try_function_name;
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
			function_name = ZVAL_UNDEFINED_OP2();
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
		}
		zend_throw_error(NULL, "Value of type %s is not callable",
			zend_zval_type_name(function_name));
		call = NULL;
	}

	if (IS_CV & (IS_VAR|IS_TMP_VAR)) {

		if (UNEXPECTED(EG(exception))) {
			if (call) {
				 if (call->func->common.fn_flags & ZEND_ACC_CALL_VIA_TRAMPOLINE) {
					zend_string_release_ex(call->func->common.function_name, 0);
					zend_free_trampoline(call->func);
				}
				zend_vm_stack_free_call_frame(call);
			}
			HANDLE_EXCEPTION();
		}
	} else if (!call) {
		HANDLE_EXCEPTION();
	}

	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BW_NOT_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;

	op1 = RT_CONSTANT(opline, opline->op1);
	if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), ~Z_LVAL_P(op1));
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_bw_not_helper_SPEC(op1 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BOOL_NOT_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;

	val = RT_CONSTANT(opline, opline->op1);
	if (Z_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_FALSE(EX_VAR(opline->result.var));
	} else if (EXPECTED(Z_TYPE_INFO_P(val) <= IS_TRUE)) {
		/* The result and op1 can be the same cv zval */
		const uint32_t orig_val_type = Z_TYPE_INFO_P(val);
		ZVAL_TRUE(EX_VAR(opline->result.var));
		if (IS_CONST == IS_CV && UNEXPECTED(orig_val_type == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	} else {
		SAVE_OPLINE();
		ZVAL_BOOL(EX_VAR(opline->result.var), !i_zend_is_true(val));

		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ECHO_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *z;

	SAVE_OPLINE();
	z = RT_CONSTANT(opline, opline->op1);

	if (Z_TYPE_P(z) == IS_STRING) {
		zend_string *str = Z_STR_P(z);

		if (ZSTR_LEN(str) != 0) {
			zend_write(ZSTR_VAL(str), ZSTR_LEN(str));
		}
	} else {
		zend_string *str = zval_get_string_func(z);

		if (ZSTR_LEN(str) != 0) {
			zend_write(ZSTR_VAL(str), ZSTR_LEN(str));
		} else if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(z) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		zend_string_release_ex(str, 0);
	}

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMPZ_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	zend_uchar op1_type;

	val = RT_CONSTANT(opline, opline->op1);

	if (Z_TYPE_INFO_P(val) == IS_TRUE) {
		ZEND_VM_NEXT_OPCODE();
	} else if (EXPECTED(Z_TYPE_INFO_P(val) <= IS_TRUE)) {
		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	SAVE_OPLINE();
	op1_type = IS_CONST;
	if (i_zend_is_true(val)) {
		opline++;
	} else {
		opline = OP_JMP_ADDR(opline, opline->op2);
	}
	if (op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(val);
	}
	ZEND_VM_JMP(opline);
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMPNZ_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	zend_uchar op1_type;

	val = RT_CONSTANT(opline, opline->op1);

	if (Z_TYPE_INFO_P(val) == IS_TRUE) {
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	} else if (EXPECTED(Z_TYPE_INFO_P(val) <= IS_TRUE)) {
		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	op1_type = IS_CONST;
	if (i_zend_is_true(val)) {
		opline = OP_JMP_ADDR(opline, opline->op2);
	} else {
		opline++;
	}
	if (op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(val);
	}
	ZEND_VM_JMP(opline);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMPZNZ_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	zend_uchar op1_type;

	val = RT_CONSTANT(opline, opline->op1);

	if (EXPECTED(Z_TYPE_INFO_P(val) == IS_TRUE)) {
		ZEND_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
		ZEND_VM_CONTINUE();
	} else if (EXPECTED(Z_TYPE_INFO_P(val) <= IS_TRUE)) {
		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	SAVE_OPLINE();
	op1_type = IS_CONST;
	if (i_zend_is_true(val)) {
		opline = ZEND_OFFSET_TO_OPLINE(opline, opline->extended_value);
	} else {
		opline = OP_JMP_ADDR(opline, opline->op2);
	}
	if (op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(val);
	}
	ZEND_VM_JMP(opline);
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMPZ_EX_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	bool ret;

	val = RT_CONSTANT(opline, opline->op1);

	if (Z_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		ZEND_VM_NEXT_OPCODE();
	} else if (EXPECTED(Z_TYPE_INFO_P(val) <= IS_TRUE)) {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	SAVE_OPLINE();
	ret = i_zend_is_true(val);

	if (ret) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		opline++;
	} else {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		opline = OP_JMP_ADDR(opline, opline->op2);
	}
	ZEND_VM_JMP(opline);
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMPNZ_EX_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	bool ret;

	val = RT_CONSTANT(opline, opline->op1);

	if (Z_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	} else if (EXPECTED(Z_TYPE_INFO_P(val) <= IS_TRUE)) {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			ZEND_VM_NEXT_OPCODE();
		}
	}

	SAVE_OPLINE();
	ret = i_zend_is_true(val);

	if (ret) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		opline = OP_JMP_ADDR(opline, opline->op2);
	} else {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		opline++;
	}
	ZEND_VM_JMP(opline);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_RETURN_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;

	retval_ptr = RT_CONSTANT(opline, opline->op1);
	return_value = EX(return_value);
	if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(retval_ptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		retval_ptr = ZVAL_UNDEFINED_OP1();
		if (return_value) {
			ZVAL_NULL(return_value);
		}
	} else if (!return_value) {
		if (IS_CONST & (IS_VAR|IS_TMP_VAR)) {
			if (Z_REFCOUNTED_P(retval_ptr) && !Z_DELREF_P(retval_ptr)) {
				SAVE_OPLINE();
				rc_dtor_func(Z_COUNTED_P(retval_ptr));
			}
		}
	} else {
		if ((IS_CONST & (IS_CONST|IS_TMP_VAR))) {
			ZVAL_COPY_VALUE(return_value, retval_ptr);
			if (IS_CONST == IS_CONST) {
				if (UNEXPECTED(Z_OPT_REFCOUNTED_P(return_value))) {
					Z_ADDREF_P(return_value);
				}
			}
		} else if (IS_CONST == IS_CV) {
			do {
				if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
					if (EXPECTED(!Z_OPT_ISREF_P(retval_ptr))) {
						if (EXPECTED(!(EX_CALL_INFO() & ZEND_CALL_CODE))) {
							zend_refcounted *ref = Z_COUNTED_P(retval_ptr);
							ZVAL_COPY_VALUE(return_value, retval_ptr);
							if (GC_MAY_LEAK(ref)) {
								gc_possible_root(ref);
							}
							ZVAL_NULL(retval_ptr);
							break;
						} else {
							Z_ADDREF_P(retval_ptr);
						}
					} else {
						retval_ptr = Z_REFVAL_P(retval_ptr);
						if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
							Z_ADDREF_P(retval_ptr);
						}
					}
				}
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			} while (0);
		} else /* if (IS_CONST == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(retval_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(retval_ptr);

				retval_ptr = Z_REFVAL_P(retval_ptr);
				ZVAL_COPY_VALUE(return_value, retval_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
					Z_ADDREF_P(retval_ptr);
				}
			} else {
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			}
		}
	}

	ZEND_VM_TAIL_CALL(zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_RETURN_SPEC_OBSERVER_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;

	retval_ptr = get_zval_ptr_undef(opline->op1_type, opline->op1, BP_VAR_R);
	return_value = EX(return_value);
	if (opline->op1_type == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(retval_ptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		retval_ptr = ZVAL_UNDEFINED_OP1();
		if (return_value) {
			ZVAL_NULL(return_value);
		}
	} else if (!return_value) {
		if (opline->op1_type & (IS_VAR|IS_TMP_VAR)) {
			if (Z_REFCOUNTED_P(retval_ptr) && !Z_DELREF_P(retval_ptr)) {
				SAVE_OPLINE();
				rc_dtor_func(Z_COUNTED_P(retval_ptr));
			}
		}
	} else {
		if ((opline->op1_type & (IS_CONST|IS_TMP_VAR))) {
			ZVAL_COPY_VALUE(return_value, retval_ptr);
			if (opline->op1_type == IS_CONST) {
				if (UNEXPECTED(Z_OPT_REFCOUNTED_P(return_value))) {
					Z_ADDREF_P(return_value);
				}
			}
		} else if (opline->op1_type == IS_CV) {
			do {
				if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
					if (EXPECTED(!Z_OPT_ISREF_P(retval_ptr))) {
						if (EXPECTED(!(EX_CALL_INFO() & ZEND_CALL_CODE))) {
							zend_refcounted *ref = Z_COUNTED_P(retval_ptr);
							ZVAL_COPY_VALUE(return_value, retval_ptr);
							if (GC_MAY_LEAK(ref)) {
								gc_possible_root(ref);
							}
							ZVAL_NULL(retval_ptr);
							break;
						} else {
							Z_ADDREF_P(retval_ptr);
						}
					} else {
						retval_ptr = Z_REFVAL_P(retval_ptr);
						if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
							Z_ADDREF_P(retval_ptr);
						}
					}
				}
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			} while (0);
		} else /* if (opline->op1_type == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(retval_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(retval_ptr);

				retval_ptr = Z_REFVAL_P(retval_ptr);
				ZVAL_COPY_VALUE(return_value, retval_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
					Z_ADDREF_P(retval_ptr);
				}
			} else {
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			}
		}
	}
	zend_observer_fcall_end(execute_data, return_value);
	ZEND_VM_TAIL_CALL(zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;

	SAVE_OPLINE();

	do {
		if ((IS_CONST & (IS_CONST|IS_TMP_VAR)) ||
		    (IS_CONST == IS_VAR && opline->extended_value == ZEND_RETURNS_VALUE)) {
			/* Not supposed to happen, but we'll allow it */
			zend_error(E_NOTICE, "Only variable references should be returned by reference");

			retval_ptr = RT_CONSTANT(opline, opline->op1);
			if (!EX(return_value)) {

			} else {
				if (IS_CONST == IS_VAR && UNEXPECTED(Z_ISREF_P(retval_ptr))) {
					ZVAL_COPY_VALUE(EX(return_value), retval_ptr);
					break;
				}

				ZVAL_NEW_REF(EX(return_value), retval_ptr);
				if (IS_CONST == IS_CONST) {
					Z_TRY_ADDREF_P(retval_ptr);
				}
			}
			break;
		}

		retval_ptr = NULL;

		if (IS_CONST == IS_VAR) {
			ZEND_ASSERT(retval_ptr != &EG(uninitialized_zval));
			if (opline->extended_value == ZEND_RETURNS_FUNCTION && !Z_ISREF_P(retval_ptr)) {
				zend_error(E_NOTICE, "Only variable references should be returned by reference");
				if (EX(return_value)) {
					ZVAL_NEW_REF(EX(return_value), retval_ptr);
				} else {

				}
				break;
			}
		}

		if (EX(return_value)) {
			if (Z_ISREF_P(retval_ptr)) {
				Z_ADDREF_P(retval_ptr);
			} else {
				ZVAL_MAKE_REF_EX(retval_ptr, 2);
			}
			ZVAL_REF(EX(return_value), Z_REF_P(retval_ptr));
		}

	} while (0);

	ZEND_VM_TAIL_CALL(zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_RETURN_BY_REF_SPEC_OBSERVER_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;

	SAVE_OPLINE();

	do {
		if ((opline->op1_type & (IS_CONST|IS_TMP_VAR)) ||
		    (opline->op1_type == IS_VAR && opline->extended_value == ZEND_RETURNS_VALUE)) {
			/* Not supposed to happen, but we'll allow it */
			zend_error(E_NOTICE, "Only variable references should be returned by reference");

			retval_ptr = get_zval_ptr(opline->op1_type, opline->op1, BP_VAR_R);
			if (!EX(return_value)) {
				FREE_OP(opline->op1_type, opline->op1.var);
			} else {
				if (opline->op1_type == IS_VAR && UNEXPECTED(Z_ISREF_P(retval_ptr))) {
					ZVAL_COPY_VALUE(EX(return_value), retval_ptr);
					break;
				}

				ZVAL_NEW_REF(EX(return_value), retval_ptr);
				if (opline->op1_type == IS_CONST) {
					Z_TRY_ADDREF_P(retval_ptr);
				}
			}
			break;
		}

		retval_ptr = get_zval_ptr_ptr(opline->op1_type, opline->op1, BP_VAR_W);

		if (opline->op1_type == IS_VAR) {
			ZEND_ASSERT(retval_ptr != &EG(uninitialized_zval));
			if (opline->extended_value == ZEND_RETURNS_FUNCTION && !Z_ISREF_P(retval_ptr)) {
				zend_error(E_NOTICE, "Only variable references should be returned by reference");
				if (EX(return_value)) {
					ZVAL_NEW_REF(EX(return_value), retval_ptr);
				} else {
					if (opline->op1_type == IS_VAR) {zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));};
				}
				break;
			}
		}

		if (EX(return_value)) {
			if (Z_ISREF_P(retval_ptr)) {
				Z_ADDREF_P(retval_ptr);
			} else {
				ZVAL_MAKE_REF_EX(retval_ptr, 2);
			}
			ZVAL_REF(EX(return_value), Z_REF_P(retval_ptr));
		}

		if (opline->op1_type == IS_VAR) {zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));};
	} while (0);

	zend_observer_fcall_end(execute_data, EX(return_value));
	ZEND_VM_TAIL_CALL(zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_GENERATOR_RETURN_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval;

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	retval = RT_CONSTANT(opline, opline->op1);

	/* Copy return value into generator->retval */
	if ((IS_CONST & (IS_CONST|IS_TMP_VAR))) {
		ZVAL_COPY_VALUE(&generator->retval, retval);
		if (IS_CONST == IS_CONST) {
			if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->retval))) {
				Z_ADDREF(generator->retval);
			}
		}
	} else if (IS_CONST == IS_CV) {
		ZVAL_COPY_DEREF(&generator->retval, retval);
	} else /* if (IS_CONST == IS_VAR) */ {
		if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_refcounted *ref = Z_COUNTED_P(retval);

			retval = Z_REFVAL_P(retval);
			ZVAL_COPY_VALUE(&generator->retval, retval);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(retval)) {
				Z_ADDREF_P(retval);
			}
		} else {
			ZVAL_COPY_VALUE(&generator->retval, retval);
		}
	}

	/* Close the generator to free up resources */
	zend_generator_close(generator, 1);

	/* Pass execution back to handling code */
	ZEND_VM_RETURN();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_GENERATOR_RETURN_SPEC_OBSERVER_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval;

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	retval = get_zval_ptr(opline->op1_type, opline->op1, BP_VAR_R);

	/* Copy return value into generator->retval */
	if ((opline->op1_type & (IS_CONST|IS_TMP_VAR))) {
		ZVAL_COPY_VALUE(&generator->retval, retval);
		if (opline->op1_type == IS_CONST) {
			if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->retval))) {
				Z_ADDREF(generator->retval);
			}
		}
	} else if (opline->op1_type == IS_CV) {
		ZVAL_COPY_DEREF(&generator->retval, retval);
	} else /* if (opline->op1_type == IS_VAR) */ {
		if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_refcounted *ref = Z_COUNTED_P(retval);

			retval = Z_REFVAL_P(retval);
			ZVAL_COPY_VALUE(&generator->retval, retval);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(retval)) {
				Z_ADDREF_P(retval);
			}
		} else {
			ZVAL_COPY_VALUE(&generator->retval, retval);
		}
	}

	zend_observer_fcall_end(generator->execute_data, &generator->retval);

	/* Close the generator to free up resources */
	zend_generator_close(generator, 1);

	/* Pass execution back to handling code */
	ZEND_VM_RETURN();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_THROW_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	SAVE_OPLINE();
	value = RT_CONSTANT(opline, opline->op1);

	do {
		if (IS_CONST == IS_CONST || UNEXPECTED(Z_TYPE_P(value) != IS_OBJECT)) {
			if ((IS_CONST & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
				value = Z_REFVAL_P(value);
				if (EXPECTED(Z_TYPE_P(value) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(value) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
			zend_throw_error(NULL, "Can only throw objects");

			HANDLE_EXCEPTION();
		}
	} while (0);

	zend_exception_save();
	Z_TRY_ADDREF_P(value);
	zend_throw_exception_object(value);
	zend_exception_restore();

	HANDLE_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CATCH_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_class_entry *ce, *catch_ce;
	zend_object *exception;

	SAVE_OPLINE();
	/* Check whether an exception has been thrown, if not, jump over code */
	zend_exception_restore();
	if (EG(exception) == NULL) {
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}
	catch_ce = CACHED_PTR(opline->extended_value & ~ZEND_LAST_CATCH);
	if (UNEXPECTED(catch_ce == NULL)) {
		catch_ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op1)), Z_STR_P(RT_CONSTANT(opline, opline->op1) + 1), ZEND_FETCH_CLASS_NO_AUTOLOAD);

		CACHE_PTR(opline->extended_value & ~ZEND_LAST_CATCH, catch_ce);
	}
	ce = EG(exception)->ce;

#ifdef HAVE_DTRACE
	if (DTRACE_EXCEPTION_CAUGHT_ENABLED()) {
		DTRACE_EXCEPTION_CAUGHT((char *)ce->name);
	}
#endif /* HAVE_DTRACE */

	if (ce != catch_ce) {
		if (!catch_ce || !instanceof_function(ce, catch_ce)) {
			if (opline->extended_value & ZEND_LAST_CATCH) {
				zend_rethrow_exception(execute_data);
				HANDLE_EXCEPTION();
			}
			ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
		}
	}

	exception = EG(exception);
	EG(exception) = NULL;
	if (RETURN_VALUE_USED(opline)) {
		/* Always perform a strict assignment. There is a reasonable expectation that if you
		 * write "catch (Exception $e)" then $e will actually be instanceof Exception. As such,
		 * we should not permit coercion to string here. */
		zval tmp;
		ZVAL_OBJ(&tmp, exception);
		zend_assign_to_variable(EX_VAR(opline->result.var), &tmp, IS_TMP_VAR, /* strict */ 1);
	} else {
		OBJ_RELEASE(exception);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_USER_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *arg, *param;

	SAVE_OPLINE();

	if (UNEXPECTED(ARG_MUST_BE_SENT_BY_REF(EX(call)->func, opline->op2.num))) {
		zend_param_must_be_ref(EX(call)->func, opline->op2.num);
	}

	arg = RT_CONSTANT(opline, opline->op1);
	param = ZEND_CALL_VAR(EX(call), opline->result.var);
	ZVAL_COPY(param, arg);

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BOOL_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;

	val = RT_CONSTANT(opline, opline->op1);
	if (Z_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
	} else if (EXPECTED(Z_TYPE_INFO_P(val) <= IS_TRUE)) {
		/* The result and op1 can be the same cv zval */
		const uint32_t orig_val_type = Z_TYPE_INFO_P(val);
		ZVAL_FALSE(EX_VAR(opline->result.var));
		if (IS_CONST == IS_CV && UNEXPECTED(orig_val_type == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	} else {
		SAVE_OPLINE();
		ZVAL_BOOL(EX_VAR(opline->result.var), i_zend_is_true(val));

		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CLONE_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *obj;
	zend_object *zobj;
	zend_class_entry *ce, *scope;
	zend_function *clone;
	zend_object_clone_obj_t clone_call;

	SAVE_OPLINE();
	obj = RT_CONSTANT(opline, opline->op1);

	do {
		if (IS_CONST == IS_CONST ||
		    (IS_CONST != IS_UNUSED && UNEXPECTED(Z_TYPE_P(obj) != IS_OBJECT))) {
		    if ((IS_CONST & (IS_VAR|IS_CV)) && Z_ISREF_P(obj)) {
				obj = Z_REFVAL_P(obj);
				if (EXPECTED(Z_TYPE_P(obj) == IS_OBJECT)) {
					break;
				}
			}
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(obj) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
			zend_throw_error(NULL, "__clone method called on non-object");

			HANDLE_EXCEPTION();
		}
	} while (0);

	zobj = Z_OBJ_P(obj);
	ce = zobj->ce;
	clone = ce->clone;
	clone_call = zobj->handlers->clone_obj;
	if (UNEXPECTED(clone_call == NULL)) {
		zend_throw_error(NULL, "Trying to clone an uncloneable object of class %s", ZSTR_VAL(ce->name));

		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}

	if (clone && !(clone->common.fn_flags & ZEND_ACC_PUBLIC)) {
		scope = EX(func)->op_array.scope;
		if (clone->common.scope != scope) {
			if (UNEXPECTED(clone->common.fn_flags & ZEND_ACC_PRIVATE)
			 || UNEXPECTED(!zend_check_protected(zend_get_function_root_class(clone), scope))) {
				zend_wrong_clone_call(clone, scope);

				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		}
	}

	ZVAL_OBJ(EX_VAR(opline->result.var), clone_call(zobj));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CAST_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr;
	zval *result = EX_VAR(opline->result.var);
	HashTable *ht;

	SAVE_OPLINE();
	expr = RT_CONSTANT(opline, opline->op1);

	switch (opline->extended_value) {
		case IS_LONG:
			ZVAL_LONG(result, zval_get_long(expr));
			break;
		case IS_DOUBLE:
			ZVAL_DOUBLE(result, zval_get_double(expr));
			break;
		case IS_STRING:
			ZVAL_STR(result, zval_get_string(expr));
			break;
		default:
			ZEND_ASSERT(opline->extended_value != _IS_BOOL && "Must use ZEND_BOOL instead");
			if (IS_CONST & (IS_VAR|IS_CV)) {
				ZVAL_DEREF(expr);
			}
			/* If value is already of correct type, return it directly */
			if (Z_TYPE_P(expr) == opline->extended_value) {
				ZVAL_COPY_VALUE(result, expr);
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(result))) Z_ADDREF_P(result);
				} else if (IS_CONST != IS_TMP_VAR) {
					if (Z_OPT_REFCOUNTED_P(result)) Z_ADDREF_P(result);
				}

				ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
			}

			if (opline->extended_value == IS_ARRAY) {
				if (IS_CONST == IS_CONST || Z_TYPE_P(expr) != IS_OBJECT || Z_OBJCE_P(expr) == zend_ce_closure) {
					if (Z_TYPE_P(expr) != IS_NULL) {
						ZVAL_ARR(result, zend_new_array(1));
						expr = zend_hash_index_add_new(Z_ARRVAL_P(result), 0, expr);
						if (IS_CONST == IS_CONST) {
							if (UNEXPECTED(Z_OPT_REFCOUNTED_P(expr))) Z_ADDREF_P(expr);
						} else {
							if (Z_OPT_REFCOUNTED_P(expr)) Z_ADDREF_P(expr);
						}
					} else {
						ZVAL_EMPTY_ARRAY(result);
					}
				} else {
					HashTable *obj_ht = zend_get_properties_for(expr, ZEND_PROP_PURPOSE_ARRAY_CAST);
					if (obj_ht) {
						/* fast copy */
						ZVAL_ARR(result, zend_proptable_to_symtable(obj_ht,
							(Z_OBJCE_P(expr)->default_properties_count ||
							 Z_OBJ_P(expr)->handlers != &std_object_handlers ||
							 GC_IS_RECURSIVE(obj_ht))));
						zend_release_properties(obj_ht);
					} else {
						ZVAL_EMPTY_ARRAY(result);
					}
				}
			} else {
				ZEND_ASSERT(opline->extended_value == IS_OBJECT);
				ZVAL_OBJ(result, zend_objects_new(zend_standard_class_def));
				if (Z_TYPE_P(expr) == IS_ARRAY) {
					ht = zend_symtable_to_proptable(Z_ARR_P(expr));
					if (GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) {
						/* TODO: try not to duplicate immutable arrays as well ??? */
						ht = zend_array_dup(ht);
					}
					Z_OBJ_P(result)->properties = ht;
				} else if (Z_TYPE_P(expr) != IS_NULL) {
					Z_OBJ_P(result)->properties = ht = zend_new_array(1);
					expr = zend_hash_add_new(ht, ZSTR_KNOWN(ZEND_STR_SCALAR), expr);
					if (IS_CONST == IS_CONST) {
						if (UNEXPECTED(Z_OPT_REFCOUNTED_P(expr))) Z_ADDREF_P(expr);
					} else {
						if (Z_OPT_REFCOUNTED_P(expr)) Z_ADDREF_P(expr);
					}
				}
			}
	}

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_op_array *new_op_array;
	zval *inc_filename;

	SAVE_OPLINE();
	inc_filename = RT_CONSTANT(opline, opline->op1);
	new_op_array = zend_include_or_eval(inc_filename, opline->extended_value);
	if (UNEXPECTED(EG(exception) != NULL)) {

		if (new_op_array != ZEND_FAKE_OP_ARRAY && new_op_array != NULL) {
			destroy_op_array(new_op_array);
			efree_size(new_op_array, sizeof(zend_op_array));
		}
		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	} else if (new_op_array == ZEND_FAKE_OP_ARRAY) {
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_TRUE(EX_VAR(opline->result.var));
		}
	} else if (EXPECTED(new_op_array != NULL)) {
		zval *return_value = NULL;
		zend_execute_data *call;

		if (RETURN_VALUE_USED(opline)) {
			return_value = EX_VAR(opline->result.var);
		}

		new_op_array->scope = EX(func)->op_array.scope;

		call = zend_vm_stack_push_call_frame(
		    (Z_TYPE_INFO(EX(This)) & ZEND_CALL_HAS_THIS) | ZEND_CALL_NESTED_CODE | ZEND_CALL_HAS_SYMBOL_TABLE,
			(zend_function*)new_op_array, 0,
			Z_PTR(EX(This)));

		if (EX_CALL_INFO() & ZEND_CALL_HAS_SYMBOL_TABLE) {
			call->symbol_table = EX(symbol_table);
		} else {
			call->symbol_table = zend_rebuild_symbol_table();
		}

		call->prev_execute_data = execute_data;
		i_init_code_execute_data(call, new_op_array, return_value);

		if (EXPECTED(zend_execute_ex == execute_ex)) {

			ZEND_VM_ENTER();
		} else {
			ZEND_ADD_CALL_FLAG(call, ZEND_CALL_TOP);
			zend_execute_ex(call);
			zend_vm_stack_free_call_frame(call);
		}

		destroy_op_array(new_op_array);
		efree_size(new_op_array, sizeof(zend_op_array));
		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_rethrow_exception(execute_data);

			UNDEF_RESULT();
			HANDLE_EXCEPTION();
		}
	} else if (RETURN_VALUE_USED(opline)) {
		ZVAL_FALSE(EX_VAR(opline->result.var));
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INCLUDE_OR_EVAL_SPEC_OBSERVER_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_op_array *new_op_array;
	zval *inc_filename;

	SAVE_OPLINE();
	inc_filename = get_zval_ptr(opline->op1_type, opline->op1, BP_VAR_R);
	new_op_array = zend_include_or_eval(inc_filename, opline->extended_value);
	if (UNEXPECTED(EG(exception) != NULL)) {
		FREE_OP(opline->op1_type, opline->op1.var);
		if (new_op_array != ZEND_FAKE_OP_ARRAY && new_op_array != NULL) {
			destroy_op_array(new_op_array);
			efree_size(new_op_array, sizeof(zend_op_array));
		}
		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	} else if (new_op_array == ZEND_FAKE_OP_ARRAY) {
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_TRUE(EX_VAR(opline->result.var));
		}
	} else if (EXPECTED(new_op_array != NULL)) {
		zval *return_value = NULL;
		zend_execute_data *call;

		if (RETURN_VALUE_USED(opline)) {
			return_value = EX_VAR(opline->result.var);
		}

		new_op_array->scope = EX(func)->op_array.scope;

		call = zend_vm_stack_push_call_frame(
		    (Z_TYPE_INFO(EX(This)) & ZEND_CALL_HAS_THIS) | ZEND_CALL_NESTED_CODE | ZEND_CALL_HAS_SYMBOL_TABLE,
			(zend_function*)new_op_array, 0,
			Z_PTR(EX(This)));

		if (EX_CALL_INFO() & ZEND_CALL_HAS_SYMBOL_TABLE) {
			call->symbol_table = EX(symbol_table);
		} else {
			call->symbol_table = zend_rebuild_symbol_table();
		}

		call->prev_execute_data = execute_data;
		i_init_code_execute_data(call, new_op_array, return_value);
		zend_observer_fcall_begin(call);
		if (EXPECTED(zend_execute_ex == execute_ex)) {
			FREE_OP(opline->op1_type, opline->op1.var);
			ZEND_VM_ENTER();
		} else {
			ZEND_ADD_CALL_FLAG(call, ZEND_CALL_TOP);
			zend_execute_ex(call);
			zend_vm_stack_free_call_frame(call);
		}

		destroy_op_array(new_op_array);
		efree_size(new_op_array, sizeof(zend_op_array));
		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_rethrow_exception(execute_data);
			FREE_OP(opline->op1_type, opline->op1.var);
			UNDEF_RESULT();
			HANDLE_EXCEPTION();
		}
	} else if (RETURN_VALUE_USED(opline)) {
		ZVAL_FALSE(EX_VAR(opline->result.var));
	}
	FREE_OP(opline->op1_type, opline->op1.var);
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FE_RESET_R_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array_ptr, *result;

	SAVE_OPLINE();

	array_ptr = RT_CONSTANT(opline, opline->op1);
	if (EXPECTED(Z_TYPE_P(array_ptr) == IS_ARRAY)) {
		result = EX_VAR(opline->result.var);
		ZVAL_COPY_VALUE(result, array_ptr);
		if (IS_CONST != IS_TMP_VAR && Z_OPT_REFCOUNTED_P(result)) {
			Z_ADDREF_P(array_ptr);
		}
		Z_FE_POS_P(result) = 0;

		ZEND_VM_NEXT_OPCODE();
	} else if (IS_CONST != IS_CONST && EXPECTED(Z_TYPE_P(array_ptr) == IS_OBJECT)) {
		zend_object *zobj = Z_OBJ_P(array_ptr);
		if (!zobj->ce->get_iterator) {
			HashTable *properties;

			result = EX_VAR(opline->result.var);
			ZVAL_OBJ(result, zobj);
			if (IS_CONST != IS_TMP_VAR) {
				GC_ADDREF(zobj);
			}
			properties = zobj->properties;
			if (properties) {
				if (UNEXPECTED(GC_REFCOUNT(properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(properties);
					}
					properties = zobj->properties = zend_array_dup(properties);
				}
			} else {
				properties = zobj->handlers->get_properties(zobj);
			}
			Z_FE_ITER_P(EX_VAR(opline->result.var)) = zend_hash_iterator_add(properties, 0);

			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			zend_bool is_empty = zend_fe_reset_iterator(array_ptr, 0 OPLINE_CC EXECUTE_DATA_CC);

			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			} else if (is_empty) {
				ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
			} else {
				ZEND_VM_NEXT_OPCODE();
			}
		}
	} else {
		zend_error(E_WARNING, "foreach() argument must be of type array|object, %s given", zend_zval_type_name(array_ptr));
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		Z_FE_ITER_P(EX_VAR(opline->result.var)) = (uint32_t)-1;

		ZEND_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
	}
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FE_RESET_RW_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array_ptr, *array_ref;

	SAVE_OPLINE();

	if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		array_ref = array_ptr = NULL;
		if (Z_ISREF_P(array_ref)) {
			array_ptr = Z_REFVAL_P(array_ref);
		}
	} else {
		array_ref = array_ptr = RT_CONSTANT(opline, opline->op1);
	}

	if (EXPECTED(Z_TYPE_P(array_ptr) == IS_ARRAY)) {
		if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
			if (array_ptr == array_ref) {
				ZVAL_NEW_REF(array_ref, array_ref);
				array_ptr = Z_REFVAL_P(array_ref);
			}
			Z_ADDREF_P(array_ref);
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), array_ref);
		} else {
			array_ref = EX_VAR(opline->result.var);
			ZVAL_NEW_REF(array_ref, array_ptr);
			array_ptr = Z_REFVAL_P(array_ref);
		}
		if (IS_CONST == IS_CONST) {
			ZVAL_ARR(array_ptr, zend_array_dup(Z_ARRVAL_P(array_ptr)));
		} else {
			SEPARATE_ARRAY(array_ptr);
		}
		Z_FE_ITER_P(EX_VAR(opline->result.var)) = zend_hash_iterator_add(Z_ARRVAL_P(array_ptr), 0);

		if (IS_CONST == IS_VAR) {

		}
		ZEND_VM_NEXT_OPCODE();
	} else if (IS_CONST != IS_CONST && EXPECTED(Z_TYPE_P(array_ptr) == IS_OBJECT)) {
		if (!Z_OBJCE_P(array_ptr)->get_iterator) {
			if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
				if (array_ptr == array_ref) {
					ZVAL_NEW_REF(array_ref, array_ref);
					array_ptr = Z_REFVAL_P(array_ref);
				}
				Z_ADDREF_P(array_ref);
				ZVAL_COPY_VALUE(EX_VAR(opline->result.var), array_ref);
			} else {
				array_ptr = EX_VAR(opline->result.var);
				ZVAL_COPY_VALUE(array_ptr, array_ref);
			}
			if (Z_OBJ_P(array_ptr)->properties
			 && UNEXPECTED(GC_REFCOUNT(Z_OBJ_P(array_ptr)->properties) > 1)) {
				if (EXPECTED(!(GC_FLAGS(Z_OBJ_P(array_ptr)->properties) & IS_ARRAY_IMMUTABLE))) {
					GC_DELREF(Z_OBJ_P(array_ptr)->properties);
				}
				Z_OBJ_P(array_ptr)->properties = zend_array_dup(Z_OBJ_P(array_ptr)->properties);
			}
			Z_FE_ITER_P(EX_VAR(opline->result.var)) = zend_hash_iterator_add(Z_OBJPROP_P(array_ptr), 0);

			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			zend_bool is_empty = zend_fe_reset_iterator(array_ptr, 1 OPLINE_CC EXECUTE_DATA_CC);

			if (IS_CONST == IS_VAR) {

			} else {

			}
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			} else if (is_empty) {
				ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
			} else {
				ZEND_VM_NEXT_OPCODE();
			}
		}
	} else {
		zend_error(E_WARNING, "foreach() argument must be of type array|object, %s given", zend_zval_type_name(array_ptr));
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		Z_FE_ITER_P(EX_VAR(opline->result.var)) = (uint32_t)-1;
		if (IS_CONST == IS_VAR) {

		} else {

		}
		ZEND_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
	}
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMP_SET_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *ref = NULL;
	bool ret;

	SAVE_OPLINE();
	value = RT_CONSTANT(opline, opline->op1);

	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && Z_ISREF_P(value)) {
		if (IS_CONST == IS_VAR) {
			ref = value;
		}
		value = Z_REFVAL_P(value);
	}

	ret = i_zend_is_true(value);

	if (UNEXPECTED(EG(exception))) {

		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}

	if (ret) {
		zval *result = EX_VAR(opline->result.var);

		ZVAL_COPY_VALUE(result, value);
		if (IS_CONST == IS_CONST) {
			if (UNEXPECTED(Z_OPT_REFCOUNTED_P(result))) Z_ADDREF_P(result);
		} else if (IS_CONST == IS_CV) {
			if (Z_OPT_REFCOUNTED_P(result)) Z_ADDREF_P(result);
		} else if (IS_CONST == IS_VAR && ref) {
			zend_reference *r = Z_REF_P(ref);

			if (UNEXPECTED(GC_DELREF(r) == 0)) {
				efree_size(r, sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(result)) {
				Z_ADDREF_P(result);
			}
		}
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_COALESCE_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *ref = NULL;

	SAVE_OPLINE();
	value = RT_CONSTANT(opline, opline->op1);

	if ((IS_CONST & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
		if (IS_CONST & IS_VAR) {
			ref = value;
		}
		value = Z_REFVAL_P(value);
	}

	if (Z_TYPE_P(value) > IS_NULL) {
		zval *result = EX_VAR(opline->result.var);
		ZVAL_COPY_VALUE(result, value);
		if (IS_CONST == IS_CONST) {
			if (UNEXPECTED(Z_OPT_REFCOUNTED_P(result))) Z_ADDREF_P(result);
		} else if (IS_CONST == IS_CV) {
			if (Z_OPT_REFCOUNTED_P(result)) Z_ADDREF_P(result);
		} else if ((IS_CONST & IS_VAR) && ref) {
			zend_reference *r = Z_REF_P(ref);

			if (UNEXPECTED(GC_DELREF(r) == 0)) {
				efree_size(r, sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(result)) {
				Z_ADDREF_P(result);
			}
		}
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMP_NULL_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;

	val = RT_CONSTANT(opline, opline->op1);
	if (IS_CONST != IS_CONST) {
		ZVAL_DEREF(val);
	}

	if (Z_TYPE_INFO_P(val) > IS_NULL) {
		ZEND_VM_NEXT_OPCODE();
	} else {
		zval *result = EX_VAR(opline->result.var);

		if (EXPECTED(opline->extended_value == ZEND_SHORT_CIRCUITING_CHAIN_EXPR)) {
			ZVAL_NULL(result);
			if (UNEXPECTED(Z_TYPE_INFO_P(val) == IS_UNDEF)) {
				SAVE_OPLINE();
				ZVAL_UNDEFINED_OP1();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
		} else if (opline->extended_value == ZEND_SHORT_CIRCUITING_CHAIN_ISSET) {
			ZVAL_FALSE(result);
		} else {
			ZEND_ASSERT(opline->extended_value == ZEND_SHORT_CIRCUITING_CHAIN_EMPTY);
			ZVAL_TRUE(result);
		}

		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_QM_ASSIGN_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *result = EX_VAR(opline->result.var);

	value = RT_CONSTANT(opline, opline->op1);
	if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(value) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(result);
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_CONST == IS_CV) {
		ZVAL_COPY_DEREF(result, value);
	} else if (IS_CONST == IS_VAR) {
		if (UNEXPECTED(Z_ISREF_P(value))) {
			ZVAL_COPY_VALUE(result, Z_REFVAL_P(value));
			if (UNEXPECTED(Z_DELREF_P(value) == 0)) {
				efree_size(Z_REF_P(value), sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(result)) {
				Z_ADDREF_P(result);
			}
		} else {
			ZVAL_COPY_VALUE(result, value);
		}
	} else {
		ZVAL_COPY_VALUE(result, value);
		if (IS_CONST == IS_CONST) {
			if (UNEXPECTED(Z_OPT_REFCOUNTED_P(result))) {
				Z_ADDREF_P(result);
			}
		}
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DECLARE_CLASS_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	do_bind_class(RT_CONSTANT(opline, opline->op1), (opline->op2_type == IS_CONST) ? Z_STR_P(RT_CONSTANT(opline, opline->op2)) : NULL);
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_YIELD_FROM_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);
	zval *val;

	SAVE_OPLINE();
	val = RT_CONSTANT(opline, opline->op1);

	if (UNEXPECTED(generator->flags & ZEND_GENERATOR_FORCED_CLOSE)) {
		zend_throw_error(NULL, "Cannot use \"yield from\" in a force-closed generator");

		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

yield_from_try_again:
	if (Z_TYPE_P(val) == IS_ARRAY) {
		ZVAL_COPY_VALUE(&generator->values, val);
		if (Z_OPT_REFCOUNTED_P(val)) {
			Z_ADDREF_P(val);
		}
		Z_FE_POS(generator->values) = 0;

	} else if (IS_CONST != IS_CONST && Z_TYPE_P(val) == IS_OBJECT && Z_OBJCE_P(val)->get_iterator) {
		zend_class_entry *ce = Z_OBJCE_P(val);
		if (ce == zend_ce_generator) {
			zend_generator *new_gen = (zend_generator *) Z_OBJ_P(val);

			Z_ADDREF_P(val);

			if (UNEXPECTED(new_gen->execute_data == NULL)) {
				zend_throw_error(NULL, "Generator passed to yield from was aborted without proper return and is unable to continue");
				zval_ptr_dtor(val);
				UNDEF_RESULT();
				HANDLE_EXCEPTION();
			} else if (Z_ISUNDEF(new_gen->retval)) {
				if (UNEXPECTED(zend_generator_get_current(new_gen) == generator)) {
					zend_throw_error(NULL, "Impossible to yield from the Generator being currently run");
					zval_ptr_dtor(val);
					UNDEF_RESULT();
					HANDLE_EXCEPTION();
				} else {
					zend_generator_yield_from(generator, new_gen);
				}
			} else {
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), &new_gen->retval);
				}
				ZEND_VM_NEXT_OPCODE();
			}
		} else {
			zend_object_iterator *iter = ce->get_iterator(ce, val, 0);

			if (UNEXPECTED(!iter) || UNEXPECTED(EG(exception))) {
				if (!EG(exception)) {
					zend_throw_error(NULL, "Object of type %s did not create an Iterator", ZSTR_VAL(ce->name));
				}
				UNDEF_RESULT();
				HANDLE_EXCEPTION();
			}

			iter->index = 0;
			if (iter->funcs->rewind) {
				iter->funcs->rewind(iter);
				if (UNEXPECTED(EG(exception) != NULL)) {
					OBJ_RELEASE(&iter->std);
					UNDEF_RESULT();
					HANDLE_EXCEPTION();
				}
			}

			ZVAL_OBJ(&generator->values, &iter->std);
		}
	} else if ((IS_CONST & (IS_VAR|IS_CV)) && Z_TYPE_P(val) == IS_REFERENCE) {
		val = Z_REFVAL_P(val);
		goto yield_from_try_again;
	} else {
		zend_throw_error(NULL, "Can use \"yield from\" only with arrays and Traversables");

		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

	/* This is the default return value
	 * when the expression is a Generator, it will be overwritten in zend_generator_resume() */
	if (RETURN_VALUE_USED(opline)) {
		ZVAL_NULL(EX_VAR(opline->result.var));
	}

	/* This generator has no send target (though the generator we delegate to might have one) */
	generator->send_target = NULL;

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_STRLEN_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	value = RT_CONSTANT(opline, opline->op1);
	if (EXPECTED(Z_TYPE_P(value) == IS_STRING)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_STRLEN_P(value));

		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_bool strict;

		if ((IS_CONST & (IS_VAR|IS_CV)) && Z_TYPE_P(value) == IS_REFERENCE) {
			value = Z_REFVAL_P(value);
			if (EXPECTED(Z_TYPE_P(value) == IS_STRING)) {
				ZVAL_LONG(EX_VAR(opline->result.var), Z_STRLEN_P(value));

				ZEND_VM_NEXT_OPCODE();
			}
		}

		SAVE_OPLINE();
		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(value) == IS_UNDEF)) {
			value = ZVAL_UNDEFINED_OP1();
		}
		strict = EX_USES_STRICT_TYPES();
		do {
			if (EXPECTED(!strict)) {
				zend_string *str;
				zval tmp;

				ZVAL_COPY(&tmp, value);
				if (zend_parse_arg_str_weak(&tmp, &str)) {
					ZVAL_LONG(EX_VAR(opline->result.var), ZSTR_LEN(str));
					zval_ptr_dtor(&tmp);
					break;
				}
				zval_ptr_dtor(&tmp);
			}
			if (!EG(exception)) {
				zend_type_error("strlen(): Argument #1 ($str) must be of type string, %s given", zend_zval_type_name(value));
			}
			ZVAL_UNDEF(EX_VAR(opline->result.var));
		} while (0);
	}

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_TYPE_CHECK_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	int result = 0;

	value = RT_CONSTANT(opline, opline->op1);
	if ((opline->extended_value >> (uint32_t)Z_TYPE_P(value)) & 1) {
type_check_resource:
		if (opline->extended_value != MAY_BE_RESOURCE
		 || EXPECTED(NULL != zend_rsrc_list_get_rsrc_type(Z_RES_P(value)))) {
			result = 1;
		}
	} else if ((IS_CONST & (IS_CV|IS_VAR)) && Z_ISREF_P(value)) {
		value = Z_REFVAL_P(value);
		if ((opline->extended_value >> (uint32_t)Z_TYPE_P(value)) & 1) {
			goto type_check_resource;
		}
	} else if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(value) == IS_UNDEF)) {
		result = ((1 << IS_NULL) & opline->extended_value) != 0;
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		if (UNEXPECTED(EG(exception))) {
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		}
	}
	if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
		SAVE_OPLINE();

		ZEND_VM_SMART_BRANCH(result, 1);
	} else {
		ZEND_VM_SMART_BRANCH(result, 0);
	}
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DEFINED_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_constant *c;

	c = CACHED_PTR(opline->extended_value);
	if (EXPECTED(c != NULL)) {
		if (!IS_SPECIAL_CACHE_VAL(c)) {
defined_true:
			ZEND_VM_SMART_BRANCH_TRUE();
		} else if (EXPECTED(zend_hash_num_elements(EG(zend_constants)) == DECODE_SPECIAL_CACHE_NUM(c))) {
defined_false:
			ZEND_VM_SMART_BRANCH_FALSE();
		}
	}
	if (zend_quick_check_constant(RT_CONSTANT(opline, opline->op1) OPLINE_CC EXECUTE_DATA_CC) != SUCCESS) {
		CACHE_PTR(opline->extended_value, ENCODE_SPECIAL_CACHE_NUM(zend_hash_num_elements(EG(zend_constants))));
		goto defined_false;
	} else {
		goto defined_true;
	}
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_QM_ASSIGN_LONG_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	value = RT_CONSTANT(opline, opline->op1);
	ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(value));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_QM_ASSIGN_DOUBLE_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	value = RT_CONSTANT(opline, opline->op1);
	ZVAL_DOUBLE(EX_VAR(opline->result.var), Z_DVAL_P(value));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_QM_ASSIGN_NOREF_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	value = RT_CONSTANT(opline, opline->op1);
	ZVAL_COPY_VALUE(EX_VAR(opline->result.var), value);
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAL_SIMPLE_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;

	value = RT_CONSTANT(opline, opline->op1);
	arg = ZEND_CALL_VAR(EX(call), opline->result.var);
	ZVAL_COPY_VALUE(arg, value);
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAL_EX_SIMPLE_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;
	uint32_t arg_num = opline->op2.num;

	arg = ZEND_CALL_VAR(EX(call), opline->result.var);
	if (QUICK_ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
		ZEND_VM_TAIL_CALL(zend_cannot_pass_by_ref_helper_SPEC(arg_num, arg ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
	}
	value = RT_CONSTANT(opline, opline->op1);
	ZVAL_COPY_VALUE(arg, value);
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			fast_long_add_function(result, op1, op2);
			ZEND_VM_NEXT_OPCODE();
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto add_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
add_double:
			result = EX_VAR(opline->result.var);
			ZVAL_DOUBLE(result, d1 + d2);
			ZEND_VM_NEXT_OPCODE();
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto add_double;
		}
	}

	ZEND_VM_TAIL_CALL(zend_add_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SUB_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			fast_long_sub_function(result, op1, op2);
			ZEND_VM_NEXT_OPCODE();
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto sub_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
sub_double:
			result = EX_VAR(opline->result.var);
			ZVAL_DOUBLE(result, d1 - d2);
			ZEND_VM_NEXT_OPCODE();
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto sub_double;
		}
	}

	ZEND_VM_TAIL_CALL(zend_sub_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_MUL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			zend_long overflow;

			result = EX_VAR(opline->result.var);
			ZEND_SIGNED_MULTIPLY_LONG(Z_LVAL_P(op1), Z_LVAL_P(op2), Z_LVAL_P(result), Z_DVAL_P(result), overflow);
			Z_TYPE_INFO_P(result) = overflow ? IS_DOUBLE : IS_LONG;
			ZEND_VM_NEXT_OPCODE();
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto mul_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
mul_double:
			result = EX_VAR(opline->result.var);
			ZVAL_DOUBLE(result, d1 * d2);
			ZEND_VM_NEXT_OPCODE();
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto mul_double;
		}
	}

	ZEND_VM_TAIL_CALL(zend_mul_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DIV_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	fast_div_function(EX_VAR(opline->result.var), op1, op2);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_MOD_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			if (UNEXPECTED(Z_LVAL_P(op2) == 0)) {
				ZEND_VM_TAIL_CALL(zend_mod_by_zero_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
			} else if (UNEXPECTED(Z_LVAL_P(op2) == -1)) {
				/* Prevent overflow error/crash if op1==ZEND_LONG_MIN */
				ZVAL_LONG(result, 0);
			} else {
				ZVAL_LONG(result, Z_LVAL_P(op1) % Z_LVAL_P(op2));
			}
			ZEND_VM_NEXT_OPCODE();
		}
	}

	ZEND_VM_TAIL_CALL(zend_mod_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)
			&& EXPECTED((zend_ulong)Z_LVAL_P(op2) < SIZEOF_ZEND_LONG * 8)) {
		/* Perform shift on unsigned numbers to get well-defined wrap behavior. */
		ZVAL_LONG(EX_VAR(opline->result.var),
			(zend_long) ((zend_ulong) Z_LVAL_P(op1) << Z_LVAL_P(op2)));
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_shift_left_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SR_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)
			&& EXPECTED((zend_ulong)Z_LVAL_P(op2) < SIZEOF_ZEND_LONG * 8)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(op1) >> Z_LVAL_P(op2));
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_shift_right_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POW_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	pow_function(EX_VAR(opline->result.var), op1, op2);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_IDENTICAL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_identical_function(op1, op2);


	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_not_identical_function(op1, op2);


	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) == Z_LVAL_P(op2))) {
is_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE();
			} else {
is_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) != Z_LVAL_P(op2))) {
is_not_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE();
			} else {
is_not_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_not_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) < Z_LVAL_P(op2))) {
is_smaller_true:
				ZEND_VM_SMART_BRANCH_TRUE();
			} else {
is_smaller_false:
				ZEND_VM_SMART_BRANCH_FALSE();
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_smaller_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_smaller_double:
			if (d1 < d2) {
				goto is_smaller_true;
			} else {
				goto is_smaller_false;
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_smaller_double;
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_smaller_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) <= Z_LVAL_P(op2))) {
is_smaller_or_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE();
				ZVAL_TRUE(EX_VAR(opline->result.var));
				ZEND_VM_NEXT_OPCODE();
			} else {
is_smaller_or_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE();
				ZVAL_FALSE(EX_VAR(opline->result.var));
				ZEND_VM_NEXT_OPCODE();
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_smaller_or_equal_double:
			if (d1 <= d2) {
				goto is_smaller_or_equal_true;
			} else {
				goto is_smaller_or_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_smaller_or_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SPACESHIP_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	compare_function(EX_VAR(opline->result.var), op1, op2);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BW_OR_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(op1) | Z_LVAL_P(op2));
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_bw_or_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BW_AND_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(op1) & Z_LVAL_P(op2));
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_bw_and_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BW_XOR_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(op1) ^ Z_LVAL_P(op2));
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_bw_xor_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BOOL_XOR_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	boolean_xor_function(EX_VAR(opline->result.var), op1, op2);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_R_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	dim = RT_CONSTANT(opline, opline->op2);
	if (IS_CONST != IS_CONST) {
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_array:
			value = zend_fetch_dimension_address_inner(Z_ARRVAL_P(container), dim, IS_CONST, BP_VAR_R EXECUTE_DATA_CC);
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		} else if (EXPECTED(Z_TYPE_P(container) == IS_REFERENCE)) {
			container = Z_REFVAL_P(container);
			if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				goto fetch_dim_r_array;
			} else {
				goto fetch_dim_r_slow;
			}
		} else {
fetch_dim_r_slow:
			if (IS_CONST == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
		}
	} else {
		zend_fetch_dimension_address_read_R(container, dim, IS_CONST OPLINE_CC EXECUTE_DATA_CC);
	}


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_IS_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	zend_fetch_dimension_address_read_IS(container, RT_CONSTANT(opline, opline->op2), IS_CONST OPLINE_CC EXECUTE_DATA_CC);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
        if ((IS_CONST & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
        }
		ZEND_VM_TAIL_CALL(ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_CONST == IS_UNUSED) {
			ZEND_VM_TAIL_CALL(zend_use_undef_in_read_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_FETCH_DIM_R_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_R_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	offset = RT_CONSTANT(opline, opline->op2);

	if (IS_CONST == IS_CONST ||
	    (IS_CONST != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
	    do {
			if ((IS_CONST & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			zend_wrong_property_read(container, offset);
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if (IS_CONST == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value & ~ZEND_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
		} else {
			if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));

		if (IS_CONST != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_IS_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	offset = RT_CONSTANT(opline, opline->op2);

	if (IS_CONST == IS_CONST ||
	    (IS_CONST != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_CONST & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if (IS_CONST == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if (IS_CONST != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_CONST & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_R_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_LIST_R_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	zend_fetch_dimension_address_LIST_r(container, RT_CONSTANT(opline, opline->op2), IS_CONST OPLINE_CC EXECUTE_DATA_CC);

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_string *op1_str, *op2_str, *str;


	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if ((IS_CONST == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
	    (IS_CONST == IS_CONST || EXPECTED(Z_TYPE_P(op2) == IS_STRING))) {
		zend_string *op1_str = Z_STR_P(op1);
		zend_string *op2_str = Z_STR_P(op2);
		zend_string *str;

		if (IS_CONST != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if (IS_CONST == IS_CONST || IS_CONST == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
		} else if (IS_CONST != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if (IS_CONST == IS_CONST || IS_CONST == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else if (IS_CONST != IS_CONST && IS_CONST != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
		    size_t len = ZSTR_LEN(op1_str);

			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else {
			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	if (IS_CONST == IS_CONST) {
		op1_str = Z_STR_P(op1);
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		op1_str = zend_string_copy(Z_STR_P(op1));
	} else {
		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		op1_str = zval_get_string_func(op1);
	}
	if (IS_CONST == IS_CONST) {
		op2_str = Z_STR_P(op2);
	} else if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
		op2_str = zend_string_copy(Z_STR_P(op2));
	} else {
		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP2();
		}
		op2_str = zval_get_string_func(op2);
	}
	do {
		if (IS_CONST != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(Z_REFCOUNTED_P(op2))) {
						GC_ADDREF(op2_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
				zend_string_release_ex(op1_str, 0);
				break;
			}
		}
		if (IS_CONST != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(Z_REFCOUNTED_P(op1))) {
						GC_ADDREF(op1_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
				zend_string_release_ex(op2_str, 0);
				break;
			}
		}
		str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
		memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
		memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
		ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
		if (IS_CONST != IS_CONST) {
			zend_string_release_ex(op1_str, 0);
		}
		if (IS_CONST != IS_CONST) {
			zend_string_release_ex(op2_str, 0);
		}
	} while (0);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_METHOD_CALL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	zend_function *fbc;
	zend_class_entry *called_scope;
	zend_object *obj;
	zend_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = RT_CONSTANT(opline, opline->op1);

	if (IS_CONST != IS_CONST) {
		function_name = RT_CONSTANT(opline, opline->op2);
	}

	if (IS_CONST != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		do {
			if ((IS_CONST & (IS_VAR|IS_CV)) && Z_ISREF_P(function_name)) {
				function_name = Z_REFVAL_P(function_name);
				if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {

					HANDLE_EXCEPTION();
				}
			}
			zend_throw_error(NULL, "Method name must be a string");


			HANDLE_EXCEPTION();
		} while (0);
	}

	if (IS_CONST == IS_UNUSED) {
		obj = Z_OBJ_P(object);
	} else {
		do {
			if (IS_CONST != IS_CONST && EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
				obj = Z_OBJ_P(object);
			} else {
				if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(object))) {
					zend_reference *ref = Z_REF_P(object);

					object = &ref->val;
					if (EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
						obj = Z_OBJ_P(object);
						if (IS_CONST & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(zend_reference));
							} else {
								Z_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if (IS_CONST != IS_CONST) {

						}
						HANDLE_EXCEPTION();
					}
				}
				if (IS_CONST == IS_CONST) {
					function_name = RT_CONSTANT(opline, opline->op2);
				}
				zend_invalid_method_call(object, function_name);


				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if (IS_CONST == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
	    fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
	    zend_object *orig_obj = obj;

		if (IS_CONST == IS_CONST) {
			function_name = RT_CONSTANT(opline, opline->op2);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, Z_STR_P(function_name), ((IS_CONST == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(obj->ce, Z_STR_P(function_name));
			}

			if ((IS_CONST & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if (IS_CONST == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if ((IS_CONST & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (IS_CONST != IS_CONST) {

	}

	call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_STATIC) != 0)) {
		if ((IS_CONST & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			zend_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (zend_object*)called_scope;
		call_info = ZEND_CALL_NESTED_FUNCTION;
	} else if (IS_CONST & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if (IS_CONST == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS | ZEND_CALL_RELEASE_THIS;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	uint32_t call_info;
	zend_function *fbc;
	zend_execute_data *call;

	SAVE_OPLINE();

	if (IS_CONST == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op1)), Z_STR_P(RT_CONSTANT(opline, opline->op1) + 1), ZEND_FETCH_CLASS_DEFAULT | ZEND_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {

				HANDLE_EXCEPTION();
			}
			if (IS_CONST != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_CONST == IS_UNUSED) {
		ce = zend_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {

			HANDLE_EXCEPTION();
		}
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_CONST == IS_CONST &&
	    IS_CONST == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_CONST != IS_CONST &&
	           IS_CONST == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if (IS_CONST != IS_UNUSED) {
		function_name = RT_CONSTANT(opline, opline->op2);
		if (IS_CONST != IS_CONST) {
			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				do {
					if (IS_CONST & (IS_VAR|IS_CV) && Z_ISREF_P(function_name)) {
						function_name = Z_REFVAL_P(function_name);
						if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					zend_throw_error(NULL, "Method name must be a string");

					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, Z_STR_P(function_name));
		} else {
			fbc = zend_std_get_static_method(ce, Z_STR_P(function_name), ((IS_CONST == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(ce, Z_STR_P(function_name));
			}

			HANDLE_EXCEPTION();
		}
		if (IS_CONST == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE)))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if (IS_CONST != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (Z_TYPE(EX(This)) == IS_OBJECT && Z_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_throw_error(NULL, "Cannot call private %s::__construct()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & ZEND_ACC_STATIC)) {
		if (Z_TYPE(EX(This)) == IS_OBJECT && instanceof_function(Z_OBJCE(EX(This)), ce)) {
			ce = (zend_class_entry*)Z_OBJ(EX(This));
			call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
		} else {
			zend_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is ZEND_FETCH_CLASS */
		if (IS_CONST == IS_UNUSED
		 && ((opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_PARENT ||
		     (opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_SELF)) {
			if (Z_TYPE(EX(This)) == IS_OBJECT) {
				ce = Z_OBJCE(EX(This));
			} else {
				ce = Z_CE(EX(This));
			}
		}
		call_info = ZEND_CALL_NESTED_FUNCTION;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_USER_CALL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_fcall_info_cache fcc;
	char *error = NULL;
	zend_function *func;
	void *object_or_called_scope;
	zend_execute_data *call;
	uint32_t call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_DYNAMIC;

	SAVE_OPLINE();
	function_name = RT_CONSTANT(opline, opline->op2);
	if (zend_is_callable_ex(function_name, NULL, 0, NULL, &fcc, &error)) {
		ZEND_ASSERT(!error);
		func = fcc.function_handler;
		object_or_called_scope = fcc.called_scope;
		if (func->common.fn_flags & ZEND_ACC_CLOSURE) {
			/* Delay closure destruction until its invocation */
			GC_ADDREF(ZEND_CLOSURE_OBJECT(func));
			call_info |= ZEND_CALL_CLOSURE;
			if (func->common.fn_flags & ZEND_ACC_FAKE_CLOSURE) {
				call_info |= ZEND_CALL_FAKE_CLOSURE;
			}
			if (fcc.object) {
				object_or_called_scope = fcc.object;
				call_info |= ZEND_CALL_HAS_THIS;
			}
		} else if (fcc.object) {
			GC_ADDREF(fcc.object); /* For $this pointer */
			object_or_called_scope = fcc.object;
			call_info |= ZEND_CALL_RELEASE_THIS | ZEND_CALL_HAS_THIS;
		}

		if ((IS_CONST & (IS_TMP_VAR|IS_VAR)) && UNEXPECTED(EG(exception))) {
			if (call_info & ZEND_CALL_CLOSURE) {
				zend_object_release(ZEND_CLOSURE_OBJECT(func));
			} else if (call_info & ZEND_CALL_RELEASE_THIS) {
				zend_object_release(fcc.object);
			}
			HANDLE_EXCEPTION();
		}

		if (EXPECTED(func->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&func->op_array))) {
			init_func_run_time_cache(&func->op_array);
		}
	} else {
		zend_type_error("%s(): Argument #1 ($function) must be a valid callback, %s", Z_STRVAL_P(RT_CONSTANT(opline, opline->op1)), error);
		efree(error);

		HANDLE_EXCEPTION();
	}

	call = zend_vm_stack_push_call_frame(call_info,
		func, opline->extended_value, object_or_called_scope);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;

	if (IS_CONST == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
	}

	value = RT_CONSTANT(opline, opline->op1);
	ZVAL_COPY_VALUE(arg, value);
	if (IS_CONST == IS_CONST) {
		if (UNEXPECTED(Z_OPT_REFCOUNTED_P(arg))) {
			Z_ADDREF_P(arg);
		}
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAL_EX_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;
	uint32_t arg_num;

	if (IS_CONST == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(arg_num <= MAX_ARG_FLAG_NUM)) {
		if (QUICK_ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_val_by_ref;
		}
	} else if (ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_val_by_ref:
		ZEND_VM_TAIL_CALL(zend_cannot_pass_by_ref_helper_SPEC(arg_num, arg ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
	}
	value = RT_CONSTANT(opline, opline->op1);
	ZVAL_COPY_VALUE(arg, value);
	if (IS_CONST == IS_CONST) {
		if (UNEXPECTED(Z_OPT_REFCOUNTED_P(arg))) {
			Z_ADDREF_P(arg);
		}
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_CLASS_CONSTANT_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_class_entry *ce, *scope;
	zend_class_constant *c;
	zval *value, *zv;
	USE_OPLINE

	SAVE_OPLINE();

	do {
		if (IS_CONST == IS_CONST) {
			if (EXPECTED(CACHED_PTR(opline->extended_value + sizeof(void*)))) {
				value = CACHED_PTR(opline->extended_value + sizeof(void*));
				break;
			} else if (EXPECTED(CACHED_PTR(opline->extended_value))) {
				ce = CACHED_PTR(opline->extended_value);
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op1)), Z_STR_P(RT_CONSTANT(opline, opline->op1) + 1), ZEND_FETCH_CLASS_DEFAULT | ZEND_FETCH_CLASS_EXCEPTION);
				if (UNEXPECTED(ce == NULL)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));
					HANDLE_EXCEPTION();
				}
			}
		} else {
			if (IS_CONST == IS_UNUSED) {
				ce = zend_fetch_class(NULL, opline->op1.num);
				if (UNEXPECTED(ce == NULL)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));
					HANDLE_EXCEPTION();
				}
			} else {
				ce = Z_CE_P(EX_VAR(opline->op1.var));
			}
			if (EXPECTED(CACHED_PTR(opline->extended_value) == ce)) {
				value = CACHED_PTR(opline->extended_value + sizeof(void*));
				break;
			}
		}

		zv = zend_hash_find_ex(&ce->constants_table, Z_STR_P(RT_CONSTANT(opline, opline->op2)), 1);
		if (EXPECTED(zv != NULL)) {
			c = Z_PTR_P(zv);
			scope = EX(func)->op_array.scope;
			if (!zend_verify_const_access(c, scope)) {
				zend_throw_error(NULL, "Cannot access %s constant %s::%s", zend_visibility_string(Z_ACCESS_FLAGS(c->value)), ZSTR_VAL(ce->name), Z_STRVAL_P(RT_CONSTANT(opline, opline->op2)));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
			value = &c->value;
			if (Z_TYPE_P(value) == IS_CONSTANT_AST) {
				zval_update_constant_ex(value, c->ce);
				if (UNEXPECTED(EG(exception) != NULL)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));
					HANDLE_EXCEPTION();
				}
			}
			CACHE_POLYMORPHIC_PTR(opline->extended_value, ce, value);
		} else {
			zend_throw_error(NULL, "Undefined constant %s::%s",
				ZSTR_VAL(ce->name), Z_STRVAL_P(RT_CONSTANT(opline, opline->op2)));
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		}
	} while (0);

	ZVAL_COPY_OR_DUP(EX_VAR(opline->result.var), value);

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) &&
	    UNEXPECTED(opline->extended_value & ZEND_ARRAY_ELEMENT_REF)) {
		expr_ptr = NULL;
		if (Z_ISREF_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}

	} else {
		expr_ptr = RT_CONSTANT(opline, opline->op1);
		if (IS_CONST == IS_TMP_VAR) {
			/* pass */
		} else if (IS_CONST == IS_CONST) {
			Z_TRY_ADDREF_P(expr_ptr);
		} else if (IS_CONST == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			Z_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_CONST == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(expr_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(expr_ptr);

				expr_ptr = Z_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(expr_ptr)) {
					Z_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_CONST != IS_UNUSED) {
		zval *offset = RT_CONSTANT(opline, opline->op2);
		zend_string *str;
		zend_ulong hval;

add_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if (IS_CONST != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index:
			zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(offset) == IS_REFERENCE)) {
			offset = Z_REFVAL_P(offset);
			goto add_again;
		} else if (Z_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (Z_TYPE_P(offset) == IS_DOUBLE) {
			hval = zend_dval_to_lval(Z_DVAL_P(offset));
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_RESOURCE) {
			zend_use_resource_as_offset(offset);
			hval = Z_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_CONST == IS_CV && Z_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			zend_illegal_offset();
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			zend_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_ARRAY_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_CONST != IS_UNUSED) {
		size = opline->extended_value >> ZEND_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, zend_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & ZEND_ARRAY_NOT_PACKED) {
			zend_hash_real_init_mixed(Z_ARRVAL_P(array));
		}
		ZEND_VM_TAIL_CALL(ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, zend_new_array(0));
		ZEND_VM_NEXT_OPCODE();
	}
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	bool result;
	zend_ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	offset = RT_CONSTANT(opline, opline->op2);

	if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
		HashTable *ht;
		zval *value;
		zend_string *str;

isset_dim_obj_array:
		ht = Z_ARRVAL_P(container);
isset_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if (IS_CONST != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index_prop;
				}
			}
			value = zend_hash_find_ex_ind(ht, str, IS_CONST == IS_CONST);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index_prop:
			value = zend_hash_index_find(ht, hval);
		} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(offset))) {
			offset = Z_REFVAL_P(offset);
			goto isset_again;
		} else {
			value = zend_find_array_dim_slow(ht, offset EXECUTE_DATA_CC);
			if (UNEXPECTED(EG(exception))) {
				result = 0;
				goto isset_dim_obj_exit;
			}
		}

		if (!(opline->extended_value & ZEND_ISEMPTY)) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = value != NULL && Z_TYPE_P(value) > IS_NULL &&
			    (!Z_ISREF_P(value) || Z_TYPE_P(Z_REFVAL_P(value)) != IS_NULL);

			if (IS_CONST & (IS_CONST|IS_CV)) {
				/* avoid exception check */

				ZEND_VM_SMART_BRANCH(result, 0);
			}
		} else {
			result = (value == NULL || !i_zend_is_true(value));
		}
		goto isset_dim_obj_exit;
	} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(container))) {
		container = Z_REFVAL_P(container);
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
			goto isset_dim_obj_array;
		}
	}

	if (IS_CONST == IS_CONST && Z_EXTRA_P(offset) == ZEND_EXTRA_VALUE) {
		offset++;
	}
	if (!(opline->extended_value & ZEND_ISEMPTY)) {
		result = zend_isset_dim_slow(container, offset EXECUTE_DATA_CC);
	} else {
		result = zend_isempty_dim_slow(container, offset EXECUTE_DATA_CC);
	}

isset_dim_obj_exit:


	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	offset = RT_CONSTANT(opline, opline->op2);

	if (IS_CONST == IS_CONST ||
	    (IS_CONST != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		if ((IS_CONST & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
			container = Z_REFVAL_P(container);
			if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & ZEND_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & ZEND_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if (IS_CONST == IS_CONST) {
		name = Z_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & ZEND_ISEMPTY) ^
		Z_OBJ_HT_P(container)->has_property(Z_OBJ_P(container), name, (opline->extended_value & ZEND_ISEMPTY), ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_ISEMPTY) : NULL));

	if (IS_CONST != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

isset_object_finish:


	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ARRAY_KEY_EXISTS_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *key, *subject;
	HashTable *ht;
	zend_bool result;

	SAVE_OPLINE();

	key = RT_CONSTANT(opline, opline->op1);
	subject = RT_CONSTANT(opline, opline->op2);

	if (EXPECTED(Z_TYPE_P(subject) == IS_ARRAY)) {
array_key_exists_array:
		ht = Z_ARRVAL_P(subject);
		result = zend_array_key_exists_fast(ht, key OPLINE_CC EXECUTE_DATA_CC);
	} else {
		if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(subject))) {
			subject = Z_REFVAL_P(subject);
			if (EXPECTED(Z_TYPE_P(subject) == IS_ARRAY)) {
				goto array_key_exists_array;
			}
		}
		zend_array_key_exists_error(subject, key OPLINE_CC EXECUTE_DATA_CC);
		result = 0;
	}


	ZEND_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|UNUSED|CV, ANY) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DECLARE_CLASS_DELAYED_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *lcname, *zv;
	zend_class_entry *ce;

	ce = CACHED_PTR(opline->extended_value);
	if (ce == NULL) {
		lcname = RT_CONSTANT(opline, opline->op1);
		zv = zend_hash_find_ex(EG(class_table), Z_STR_P(lcname + 1), 1);
		if (zv) {
			SAVE_OPLINE();
			ce = Z_CE_P(zv);
			zv = zend_hash_set_bucket_key(EG(class_table), (Bucket*)zv, Z_STR_P(lcname));
			if (UNEXPECTED(!zv)) {
				zend_error_noreturn(E_COMPILE_ERROR, "Cannot declare %s %s, because the name is already in use", zend_get_object_type(ce), ZSTR_VAL(ce->name));
			} else {
				if (zend_do_link_class(ce, Z_STR_P(RT_CONSTANT(opline, opline->op2))) == FAILURE) {
					/* Reload bucket pointer, the hash table may have been reallocated */
					zv = zend_hash_find(EG(class_table), Z_STR_P(lcname));
					zend_hash_set_bucket_key(EG(class_table), (Bucket *) zv, Z_STR_P(lcname + 1));
					HANDLE_EXCEPTION();
				}
			}
		}
		CACHE_PTR(opline->extended_value, ce);
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DECLARE_CONST_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *name;
	zval *val;
	zend_constant c;

	SAVE_OPLINE();
	name  = RT_CONSTANT(opline, opline->op1);
	val   = RT_CONSTANT(opline, opline->op2);

	ZVAL_COPY(&c.value, val);
	if (Z_OPT_CONSTANT(c.value)) {
		if (UNEXPECTED(zval_update_constant_ex(&c.value, EX(func)->op_array.scope) != SUCCESS)) {
			zval_ptr_dtor_nogc(&c.value);


			HANDLE_EXCEPTION();
		}
	}
	/* non persistent, case sensitive */
	ZEND_CONSTANT_SET_FLAGS(&c, CONST_CS, PHP_USER_CONSTANT);
	c.name = zend_string_copy(Z_STR_P(name));

	if (zend_register_constant(&c) == FAILURE) {
	}


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_YIELD_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & ZEND_GENERATOR_FORCED_CLOSE)) {
		ZEND_VM_TAIL_CALL(zend_yield_in_closed_generator_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CONST != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CONST & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = RT_CONSTANT(opline, opline->op1);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
						Z_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = NULL;

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_CONST == IS_VAR) {
						ZEND_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == ZEND_RETURNS_FUNCTION
						 && !Z_ISREF_P(value_ptr)) {
							zend_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (Z_ISREF_P(value_ptr)) {
						Z_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, Z_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = RT_CONSTANT(opline, opline->op1);

			/* Consts, temporary variables and references need copying */
			if (IS_CONST == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
					Z_ADDREF(generator->value);
				}
			} else if (IS_CONST == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if ((IS_CONST & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, Z_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CONST == IS_CV) {
					if (Z_OPT_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {
		zval *key = RT_CONSTANT(opline, opline->op2);
		if ((IS_CONST & (IS_CV|IS_VAR)) && UNEXPECTED(Z_TYPE_P(key)) == IS_REFERENCE) {
			key = Z_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SWITCH_LONG_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op, *jump_zv;
	HashTable *jumptable;

	op = RT_CONSTANT(opline, opline->op1);

	if (Z_TYPE_P(op) != IS_LONG) {
		ZVAL_DEREF(op);
		if (Z_TYPE_P(op) != IS_LONG) {
			/* Wrong type, fall back to ZEND_CASE chain */
			ZEND_VM_NEXT_OPCODE();
		}
	}

	jumptable = Z_ARRVAL_P(RT_CONSTANT(opline, opline->op2));
	jump_zv = zend_hash_index_find(jumptable, Z_LVAL_P(op));
	if (jump_zv != NULL) {
		ZEND_VM_SET_RELATIVE_OPCODE(opline, Z_LVAL_P(jump_zv));
		ZEND_VM_CONTINUE();
	} else {
		/* default */
		ZEND_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
		ZEND_VM_CONTINUE();
	}
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SWITCH_STRING_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op, *jump_zv;
	HashTable *jumptable;

	op = RT_CONSTANT(opline, opline->op1);

	if (Z_TYPE_P(op) != IS_STRING) {
		if (IS_CONST == IS_CONST) {
			/* Wrong type, fall back to ZEND_CASE chain */
			ZEND_VM_NEXT_OPCODE();
		} else {
			ZVAL_DEREF(op);
			if (Z_TYPE_P(op) != IS_STRING) {
				/* Wrong type, fall back to ZEND_CASE chain */
				ZEND_VM_NEXT_OPCODE();
			}
		}
	}

	jumptable = Z_ARRVAL_P(RT_CONSTANT(opline, opline->op2));
	jump_zv = zend_hash_find_ex(jumptable, Z_STR_P(op), IS_CONST == IS_CONST);
	if (jump_zv != NULL) {
		ZEND_VM_SET_RELATIVE_OPCODE(opline, Z_LVAL_P(jump_zv));
		ZEND_VM_CONTINUE();
	} else {
		/* default */
		ZEND_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
		ZEND_VM_CONTINUE();
	}
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_MATCH_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op, *jump_zv;
	HashTable *jumptable;

	op = RT_CONSTANT(opline, opline->op1);
	jumptable = Z_ARRVAL_P(RT_CONSTANT(opline, opline->op2));

match_try_again:
	if (Z_TYPE_P(op) == IS_LONG) {
		jump_zv = zend_hash_index_find(jumptable, Z_LVAL_P(op));
	} else if (Z_TYPE_P(op) == IS_STRING) {
		jump_zv = zend_hash_find_ex(jumptable, Z_STR_P(op), IS_CONST == IS_CONST);
	} else if (Z_TYPE_P(op) == IS_REFERENCE) {
		op = Z_REFVAL_P(op);
		goto match_try_again;
	} else {
		if (UNEXPECTED((IS_CONST & IS_CV) && Z_TYPE_P(op) == IS_UNDEF)) {
			SAVE_OPLINE();
			op = ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
			goto match_try_again;
		}

		goto default_branch;
	}

	if (jump_zv != NULL) {
		ZEND_VM_SET_RELATIVE_OPCODE(opline, Z_LVAL_P(jump_zv));
		ZEND_VM_CONTINUE();
	} else {
default_branch:
		/* default */
		ZEND_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
		ZEND_VM_CONTINUE();
	}
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IN_ARRAY_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;
	HashTable *ht = Z_ARRVAL_P(RT_CONSTANT(opline, opline->op2));
	zval *result;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		result = zend_hash_find_ex(ht, Z_STR_P(op1), IS_CONST == IS_CONST);
	} else if (opline->extended_value) {
		if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
			result = zend_hash_index_find(ht, Z_LVAL_P(op1));
		} else {
			result = NULL;
		}
	} else if (Z_TYPE_P(op1) <= IS_FALSE) {
		result = zend_hash_find_ex(ht, ZSTR_EMPTY_ALLOC(), 1);
	} else {
		zend_string *key;
		zval key_tmp, *val;

		result = NULL;
		ZEND_HASH_FOREACH_STR_KEY_VAL(ht, key, val) {
			ZVAL_STR(&key_tmp, key);
			if (zend_compare(op1, &key_tmp) == 0) {
				result = val;
				break;
			}
		} ZEND_HASH_FOREACH_END();
	}

	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CONST == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			fast_long_add_function(result, op1, op2);
			ZEND_VM_NEXT_OPCODE();
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto add_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
add_double:
			result = EX_VAR(opline->result.var);
			ZVAL_DOUBLE(result, d1 + d2);
			ZEND_VM_NEXT_OPCODE();
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto add_double;
		}
	}

	ZEND_VM_TAIL_CALL(zend_add_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SUB_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CONST == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			fast_long_sub_function(result, op1, op2);
			ZEND_VM_NEXT_OPCODE();
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto sub_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
sub_double:
			result = EX_VAR(opline->result.var);
			ZVAL_DOUBLE(result, d1 - d2);
			ZEND_VM_NEXT_OPCODE();
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto sub_double;
		}
	}

	ZEND_VM_TAIL_CALL(zend_sub_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_MOD_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CONST == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			if (UNEXPECTED(Z_LVAL_P(op2) == 0)) {
				ZEND_VM_TAIL_CALL(zend_mod_by_zero_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
			} else if (UNEXPECTED(Z_LVAL_P(op2) == -1)) {
				/* Prevent overflow error/crash if op1==ZEND_LONG_MIN */
				ZVAL_LONG(result, 0);
			} else {
				ZVAL_LONG(result, Z_LVAL_P(op1) % Z_LVAL_P(op2));
			}
			ZEND_VM_NEXT_OPCODE();
		}
	}

	ZEND_VM_TAIL_CALL(zend_mod_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SL_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CONST == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)
			&& EXPECTED((zend_ulong)Z_LVAL_P(op2) < SIZEOF_ZEND_LONG * 8)) {
		/* Perform shift on unsigned numbers to get well-defined wrap behavior. */
		ZVAL_LONG(EX_VAR(opline->result.var),
			(zend_long) ((zend_ulong) Z_LVAL_P(op1) << Z_LVAL_P(op2)));
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_shift_left_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SR_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CONST == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)
			&& EXPECTED((zend_ulong)Z_LVAL_P(op2) < SIZEOF_ZEND_LONG * 8)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(op1) >> Z_LVAL_P(op2));
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_shift_right_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CONST == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) < Z_LVAL_P(op2))) {
is_smaller_true:
				ZEND_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_smaller_false:
				ZEND_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_smaller_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_smaller_double:
			if (d1 < d2) {
				goto is_smaller_true;
			} else {
				goto is_smaller_false;
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_smaller_double;
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_smaller_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CONST == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) < Z_LVAL_P(op2))) {
is_smaller_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_smaller_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_smaller_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_smaller_double:
			if (d1 < d2) {
				goto is_smaller_true;
			} else {
				goto is_smaller_false;
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_smaller_double;
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_smaller_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CONST == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) < Z_LVAL_P(op2))) {
is_smaller_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_smaller_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_smaller_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_smaller_double:
			if (d1 < d2) {
				goto is_smaller_true;
			} else {
				goto is_smaller_false;
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_smaller_double;
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_smaller_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CONST == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) <= Z_LVAL_P(op2))) {
is_smaller_or_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_NONE();
				ZVAL_TRUE(EX_VAR(opline->result.var));
				ZEND_VM_NEXT_OPCODE();
			} else {
is_smaller_or_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_NONE();
				ZVAL_FALSE(EX_VAR(opline->result.var));
				ZEND_VM_NEXT_OPCODE();
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_smaller_or_equal_double:
			if (d1 <= d2) {
				goto is_smaller_or_equal_true;
			} else {
				goto is_smaller_or_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_smaller_or_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CONST == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) <= Z_LVAL_P(op2))) {
is_smaller_or_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPZ();
				ZVAL_TRUE(EX_VAR(opline->result.var));
				ZEND_VM_NEXT_OPCODE();
			} else {
is_smaller_or_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPZ();
				ZVAL_FALSE(EX_VAR(opline->result.var));
				ZEND_VM_NEXT_OPCODE();
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_smaller_or_equal_double:
			if (d1 <= d2) {
				goto is_smaller_or_equal_true;
			} else {
				goto is_smaller_or_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_smaller_or_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CONST == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) <= Z_LVAL_P(op2))) {
is_smaller_or_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPNZ();
				ZVAL_TRUE(EX_VAR(opline->result.var));
				ZEND_VM_NEXT_OPCODE();
			} else {
is_smaller_or_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPNZ();
				ZVAL_FALSE(EX_VAR(opline->result.var));
				ZEND_VM_NEXT_OPCODE();
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_smaller_or_equal_double:
			if (d1 <= d2) {
				goto is_smaller_or_equal_true;
			} else {
				goto is_smaller_or_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_smaller_or_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SUB_LONG_NO_OVERFLOW_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	ZVAL_LONG(result, Z_LVAL_P(op1) - Z_LVAL_P(op2));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SUB_LONG_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	fast_long_sub_function(result, op1, op2);
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SUB_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	ZVAL_DOUBLE(result, Z_DVAL_P(op1) - Z_DVAL_P(op2));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_LVAL_P(op1) < Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_NONE(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_LVAL_P(op1) < Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPZ(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_LVAL_P(op1) < Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_DVAL_P(op1) < Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_NONE(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_DVAL_P(op1) < Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPZ(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_DVAL_P(op1) < Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_LVAL_P(op1) <= Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_NONE(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_LVAL_P(op1) <= Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPZ(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_LVAL_P(op1) <= Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_DVAL_P(op1) <= Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_NONE(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_DVAL_P(op1) <= Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPZ(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_DVAL_P(op1) <= Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_R_INDEX_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;
	zend_long offset;
	HashTable *ht;

	container = RT_CONSTANT(opline, opline->op1);
	dim = EX_VAR(opline->op2.var);
	if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_index_array:
		if (EXPECTED(Z_TYPE_P(dim) == IS_LONG)) {
			offset = Z_LVAL_P(dim);
		} else {
			offset = zval_get_long(dim);
		}
		ht = Z_ARRVAL_P(container);
		ZEND_HASH_INDEX_FIND(ht, offset, value, fetch_dim_r_index_undef);
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
			SAVE_OPLINE();

			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			ZEND_VM_NEXT_OPCODE();
		}
	} else if (IS_CONST != IS_CONST && EXPECTED(Z_TYPE_P(container) == IS_REFERENCE)) {
		container = Z_REFVAL_P(container);
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
			goto fetch_dim_r_index_array;
		} else {
			goto fetch_dim_r_index_slow;
		}
	} else {
fetch_dim_r_index_slow:
		SAVE_OPLINE();
		if ((IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
			dim++;
		}
		zend_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);

		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

fetch_dim_r_index_undef:
	ZVAL_NULL(EX_VAR(opline->result.var));
	SAVE_OPLINE();
	zend_undefined_offset(offset);

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DIV_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	fast_div_function(EX_VAR(opline->result.var), op1, op2);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POW_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	pow_function(EX_VAR(opline->result.var), op1, op2);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if ((IS_CONST == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
	    ((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(Z_TYPE_P(op2) == IS_STRING))) {
		zend_string *op1_str = Z_STR_P(op1);
		zend_string *op2_str = Z_STR_P(op2);
		zend_string *str;

		if (IS_CONST != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if (IS_CONST == IS_CONST || IS_CONST == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else if (IS_CONST != IS_CONST && IS_CONST != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
		    size_t len = ZSTR_LEN(op1_str);

			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else {
			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		}
		ZEND_VM_NEXT_OPCODE();
	} else {
		SAVE_OPLINE();

		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
			op1 = ZVAL_UNDEFINED_OP1();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
			op2 = ZVAL_UNDEFINED_OP2();
		}
		concat_function(EX_VAR(opline->result.var), op1, op2);

		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SPACESHIP_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	compare_function(EX_VAR(opline->result.var), op1, op2);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_R_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (IS_CONST != IS_CONST) {
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_array:
			value = zend_fetch_dimension_address_inner(Z_ARRVAL_P(container), dim, (IS_TMP_VAR|IS_VAR), BP_VAR_R EXECUTE_DATA_CC);
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		} else if (EXPECTED(Z_TYPE_P(container) == IS_REFERENCE)) {
			container = Z_REFVAL_P(container);
			if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				goto fetch_dim_r_array;
			} else {
				goto fetch_dim_r_slow;
			}
		} else {
fetch_dim_r_slow:
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
		}
	} else {
		zend_fetch_dimension_address_read_R(container, dim, (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_IS_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	zend_fetch_dimension_address_read_IS(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
        if ((IS_CONST & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
        }
		ZEND_VM_TAIL_CALL(ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			ZEND_VM_TAIL_CALL(zend_use_undef_in_read_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_FETCH_DIM_R_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_R_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (IS_CONST == IS_CONST ||
	    (IS_CONST != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
	    do {
			if ((IS_CONST & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			zend_wrong_property_read(container, offset);
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value & ~ZEND_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
		} else {
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_IS_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (IS_CONST == IS_CONST ||
	    (IS_CONST != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_CONST & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_CONST & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_R_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_LIST_R_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	zend_fetch_dimension_address_LIST_r(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_string *op1_str, *op2_str, *str;


	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if ((IS_CONST == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
	    ((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(Z_TYPE_P(op2) == IS_STRING))) {
		zend_string *op1_str = Z_STR_P(op1);
		zend_string *op2_str = Z_STR_P(op2);
		zend_string *str;

		if (IS_CONST != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if (IS_CONST == IS_CONST || IS_CONST == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else if (IS_CONST != IS_CONST && IS_CONST != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
		    size_t len = ZSTR_LEN(op1_str);

			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else {
			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	if (IS_CONST == IS_CONST) {
		op1_str = Z_STR_P(op1);
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		op1_str = zend_string_copy(Z_STR_P(op1));
	} else {
		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		op1_str = zval_get_string_func(op1);
	}
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		op2_str = Z_STR_P(op2);
	} else if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
		op2_str = zend_string_copy(Z_STR_P(op2));
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP2();
		}
		op2_str = zval_get_string_func(op2);
	}
	do {
		if (IS_CONST != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					if (UNEXPECTED(Z_REFCOUNTED_P(op2))) {
						GC_ADDREF(op2_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
				zend_string_release_ex(op1_str, 0);
				break;
			}
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(Z_REFCOUNTED_P(op1))) {
						GC_ADDREF(op1_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
				zend_string_release_ex(op2_str, 0);
				break;
			}
		}
		str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
		memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
		memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
		ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
		if (IS_CONST != IS_CONST) {
			zend_string_release_ex(op1_str, 0);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_string_release_ex(op2_str, 0);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_METHOD_CALL_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	zend_function *fbc;
	zend_class_entry *called_scope;
	zend_object *obj;
	zend_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = RT_CONSTANT(opline, opline->op1);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		do {
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && Z_ISREF_P(function_name)) {
				function_name = Z_REFVAL_P(function_name);
				if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {

					HANDLE_EXCEPTION();
				}
			}
			zend_throw_error(NULL, "Method name must be a string");
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

			HANDLE_EXCEPTION();
		} while (0);
	}

	if (IS_CONST == IS_UNUSED) {
		obj = Z_OBJ_P(object);
	} else {
		do {
			if (IS_CONST != IS_CONST && EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
				obj = Z_OBJ_P(object);
			} else {
				if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(object))) {
					zend_reference *ref = Z_REF_P(object);

					object = &ref->val;
					if (EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
						obj = Z_OBJ_P(object);
						if (IS_CONST & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(zend_reference));
							} else {
								Z_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
							zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
						}
						HANDLE_EXCEPTION();
					}
				}
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				}
				zend_invalid_method_call(object, function_name);
				zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
	    fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
	    zend_object *orig_obj = obj;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, Z_STR_P(function_name), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(obj->ce, Z_STR_P(function_name));
			}
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			if ((IS_CONST & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if ((IS_CONST & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}

	call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_STATIC) != 0)) {
		if ((IS_CONST & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			zend_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (zend_object*)called_scope;
		call_info = ZEND_CALL_NESTED_FUNCTION;
	} else if (IS_CONST & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if (IS_CONST == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS | ZEND_CALL_RELEASE_THIS;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	uint32_t call_info;
	zend_function *fbc;
	zend_execute_data *call;

	SAVE_OPLINE();

	if (IS_CONST == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op1)), Z_STR_P(RT_CONSTANT(opline, opline->op1) + 1), ZEND_FETCH_CLASS_DEFAULT | ZEND_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {
				zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
				HANDLE_EXCEPTION();
			}
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_CONST == IS_UNUSED) {
		ce = zend_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			HANDLE_EXCEPTION();
		}
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_CONST == IS_CONST &&
	    (IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_CONST != IS_CONST &&
	           (IS_TMP_VAR|IS_VAR) == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				do {
					if ((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV) && Z_ISREF_P(function_name)) {
						function_name = Z_REFVAL_P(function_name);
						if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					zend_throw_error(NULL, "Method name must be a string");
					zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, Z_STR_P(function_name));
		} else {
			fbc = zend_std_get_static_method(ce, Z_STR_P(function_name), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(ce, Z_STR_P(function_name));
			}
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			HANDLE_EXCEPTION();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE)))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (Z_TYPE(EX(This)) == IS_OBJECT && Z_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_throw_error(NULL, "Cannot call private %s::__construct()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & ZEND_ACC_STATIC)) {
		if (Z_TYPE(EX(This)) == IS_OBJECT && instanceof_function(Z_OBJCE(EX(This)), ce)) {
			ce = (zend_class_entry*)Z_OBJ(EX(This));
			call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
		} else {
			zend_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is ZEND_FETCH_CLASS */
		if (IS_CONST == IS_UNUSED
		 && ((opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_PARENT ||
		     (opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_SELF)) {
			if (Z_TYPE(EX(This)) == IS_OBJECT) {
				ce = Z_OBJCE(EX(This));
			} else {
				ce = Z_CE(EX(This));
			}
		}
		call_info = ZEND_CALL_NESTED_FUNCTION;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_USER_CALL_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_fcall_info_cache fcc;
	char *error = NULL;
	zend_function *func;
	void *object_or_called_scope;
	zend_execute_data *call;
	uint32_t call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_DYNAMIC;

	SAVE_OPLINE();
	function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (zend_is_callable_ex(function_name, NULL, 0, NULL, &fcc, &error)) {
		ZEND_ASSERT(!error);
		func = fcc.function_handler;
		object_or_called_scope = fcc.called_scope;
		if (func->common.fn_flags & ZEND_ACC_CLOSURE) {
			/* Delay closure destruction until its invocation */
			GC_ADDREF(ZEND_CLOSURE_OBJECT(func));
			call_info |= ZEND_CALL_CLOSURE;
			if (func->common.fn_flags & ZEND_ACC_FAKE_CLOSURE) {
				call_info |= ZEND_CALL_FAKE_CLOSURE;
			}
			if (fcc.object) {
				object_or_called_scope = fcc.object;
				call_info |= ZEND_CALL_HAS_THIS;
			}
		} else if (fcc.object) {
			GC_ADDREF(fcc.object); /* For $this pointer */
			object_or_called_scope = fcc.object;
			call_info |= ZEND_CALL_RELEASE_THIS | ZEND_CALL_HAS_THIS;
		}

		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
		if (((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) && UNEXPECTED(EG(exception))) {
			if (call_info & ZEND_CALL_CLOSURE) {
				zend_object_release(ZEND_CLOSURE_OBJECT(func));
			} else if (call_info & ZEND_CALL_RELEASE_THIS) {
				zend_object_release(fcc.object);
			}
			HANDLE_EXCEPTION();
		}

		if (EXPECTED(func->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&func->op_array))) {
			init_func_run_time_cache(&func->op_array);
		}
	} else {
		zend_type_error("%s(): Argument #1 ($function) must be a valid callback, %s", Z_STRVAL_P(RT_CONSTANT(opline, opline->op1)), error);
		efree(error);
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
		HANDLE_EXCEPTION();
	}

	call = zend_vm_stack_push_call_frame(call_info,
		func, opline->extended_value, object_or_called_scope);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) &&
	    UNEXPECTED(opline->extended_value & ZEND_ARRAY_ELEMENT_REF)) {
		expr_ptr = NULL;
		if (Z_ISREF_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}

	} else {
		expr_ptr = RT_CONSTANT(opline, opline->op1);
		if (IS_CONST == IS_TMP_VAR) {
			/* pass */
		} else if (IS_CONST == IS_CONST) {
			Z_TRY_ADDREF_P(expr_ptr);
		} else if (IS_CONST == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			Z_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_CONST == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(expr_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(expr_ptr);

				expr_ptr = Z_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(expr_ptr)) {
					Z_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval *offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		zend_string *str;
		zend_ulong hval;

add_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index:
			zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(offset) == IS_REFERENCE)) {
			offset = Z_REFVAL_P(offset);
			goto add_again;
		} else if (Z_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (Z_TYPE_P(offset) == IS_DOUBLE) {
			hval = zend_dval_to_lval(Z_DVAL_P(offset));
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_RESOURCE) {
			zend_use_resource_as_offset(offset);
			hval = Z_RES_HANDLE_P(offset);
			goto num_index;
		} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && Z_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			zend_illegal_offset();
			zval_ptr_dtor_nogc(expr_ptr);
		}
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	} else {
		if (!zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			zend_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_ARRAY_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_CONST != IS_UNUSED) {
		size = opline->extended_value >> ZEND_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, zend_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & ZEND_ARRAY_NOT_PACKED) {
			zend_hash_real_init_mixed(Z_ARRVAL_P(array));
		}
		ZEND_VM_TAIL_CALL(ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, zend_new_array(0));
		ZEND_VM_NEXT_OPCODE();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	bool result;
	zend_ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
		HashTable *ht;
		zval *value;
		zend_string *str;

isset_dim_obj_array:
		ht = Z_ARRVAL_P(container);
isset_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index_prop;
				}
			}
			value = zend_hash_find_ex_ind(ht, str, (IS_TMP_VAR|IS_VAR) == IS_CONST);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index_prop:
			value = zend_hash_index_find(ht, hval);
		} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(offset))) {
			offset = Z_REFVAL_P(offset);
			goto isset_again;
		} else {
			value = zend_find_array_dim_slow(ht, offset EXECUTE_DATA_CC);
			if (UNEXPECTED(EG(exception))) {
				result = 0;
				goto isset_dim_obj_exit;
			}
		}

		if (!(opline->extended_value & ZEND_ISEMPTY)) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = value != NULL && Z_TYPE_P(value) > IS_NULL &&
			    (!Z_ISREF_P(value) || Z_TYPE_P(Z_REFVAL_P(value)) != IS_NULL);

			if (IS_CONST & (IS_CONST|IS_CV)) {
				/* avoid exception check */
				zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
				ZEND_VM_SMART_BRANCH(result, 0);
			}
		} else {
			result = (value == NULL || !i_zend_is_true(value));
		}
		goto isset_dim_obj_exit;
	} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(container))) {
		container = Z_REFVAL_P(container);
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
			goto isset_dim_obj_array;
		}
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST && Z_EXTRA_P(offset) == ZEND_EXTRA_VALUE) {
		offset++;
	}
	if (!(opline->extended_value & ZEND_ISEMPTY)) {
		result = zend_isset_dim_slow(container, offset EXECUTE_DATA_CC);
	} else {
		result = zend_isempty_dim_slow(container, offset EXECUTE_DATA_CC);
	}

isset_dim_obj_exit:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (IS_CONST == IS_CONST ||
	    (IS_CONST != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		if ((IS_CONST & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
			container = Z_REFVAL_P(container);
			if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & ZEND_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & ZEND_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = Z_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & ZEND_ISEMPTY) ^
		Z_OBJ_HT_P(container)->has_property(Z_OBJ_P(container), name, (opline->extended_value & ZEND_ISEMPTY), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_ISEMPTY) : NULL));

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

isset_object_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ARRAY_KEY_EXISTS_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *key, *subject;
	HashTable *ht;
	zend_bool result;

	SAVE_OPLINE();

	key = RT_CONSTANT(opline, opline->op1);
	subject = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(subject) == IS_ARRAY)) {
array_key_exists_array:
		ht = Z_ARRVAL_P(subject);
		result = zend_array_key_exists_fast(ht, key OPLINE_CC EXECUTE_DATA_CC);
	} else {
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(subject))) {
			subject = Z_REFVAL_P(subject);
			if (EXPECTED(Z_TYPE_P(subject) == IS_ARRAY)) {
				goto array_key_exists_array;
			}
		}
		zend_array_key_exists_error(subject, key OPLINE_CC EXECUTE_DATA_CC);
		result = 0;
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|UNUSED|CV, ANY) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_YIELD_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & ZEND_GENERATOR_FORCED_CLOSE)) {
		ZEND_VM_TAIL_CALL(zend_yield_in_closed_generator_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CONST != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CONST & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = RT_CONSTANT(opline, opline->op1);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
						Z_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = NULL;

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_CONST == IS_VAR) {
						ZEND_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == ZEND_RETURNS_FUNCTION
						 && !Z_ISREF_P(value_ptr)) {
							zend_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (Z_ISREF_P(value_ptr)) {
						Z_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, Z_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = RT_CONSTANT(opline, opline->op1);

			/* Consts, temporary variables and references need copying */
			if (IS_CONST == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
					Z_ADDREF(generator->value);
				}
			} else if (IS_CONST == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if ((IS_CONST & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, Z_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CONST == IS_CV) {
					if (Z_OPT_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval *key = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if (((IS_TMP_VAR|IS_VAR) & (IS_CV|IS_VAR)) && UNEXPECTED(Z_TYPE_P(key)) == IS_REFERENCE) {
			key = Z_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_CONST_UNUSED(int type ZEND_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE
	zval *varname;
	zval *retval;
	zend_string *name, *tmp_name;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = RT_CONSTANT(opline, opline->op1);

	if (IS_CONST == IS_CONST) {
		name = Z_STR_P(varname);
	} else if (EXPECTED(Z_TYPE_P(varname) == IS_STRING)) {
		name = Z_STR_P(varname);
		tmp_name = NULL;
	} else {
		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(varname) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		name = zval_try_get_tmp_string(varname, &tmp_name);
		if (UNEXPECTED(!name)) {

			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		}
	}

	target_symbol_table = zend_get_target_symbol_table(opline->extended_value EXECUTE_DATA_CC);
	retval = zend_hash_find_ex(target_symbol_table, name, IS_CONST == IS_CONST);
	if (retval == NULL) {
		if (UNEXPECTED(zend_string_equals(name, ZSTR_KNOWN(ZEND_STR_THIS)))) {
fetch_this:
			zend_fetch_this_var(type OPLINE_CC EXECUTE_DATA_CC);
			if (IS_CONST != IS_CONST) {
				zend_tmp_string_release(tmp_name);
			}
			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
		if (type == BP_VAR_W) {
			retval = zend_hash_add_new(target_symbol_table, name, &EG(uninitialized_zval));
		} else if (type == BP_VAR_IS) {
			retval = &EG(uninitialized_zval);
		} else {
			zend_error(E_WARNING, "Undefined variable $%s", ZSTR_VAL(name));
			if (type == BP_VAR_RW) {
				retval = zend_hash_update(target_symbol_table, name, &EG(uninitialized_zval));
			} else {
				retval = &EG(uninitialized_zval);
			}
		}
	/* GLOBAL or $$name variable may be an INDIRECT pointer to CV */
	} else if (Z_TYPE_P(retval) == IS_INDIRECT) {
		retval = Z_INDIRECT_P(retval);
		if (Z_TYPE_P(retval) == IS_UNDEF) {
			if (UNEXPECTED(zend_string_equals(name, ZSTR_KNOWN(ZEND_STR_THIS)))) {
				goto fetch_this;
			}
			if (type == BP_VAR_W) {
				ZVAL_NULL(retval);
			} else if (type == BP_VAR_IS) {
				retval = &EG(uninitialized_zval);
			} else {
				zend_error(E_WARNING, "Undefined variable $%s", ZSTR_VAL(name));
				if (type == BP_VAR_RW) {
					ZVAL_NULL(retval);
				} else {
					retval = &EG(uninitialized_zval);
				}
			}
		}
	}

	if (!(opline->extended_value & ZEND_FETCH_GLOBAL_LOCK)) {

	}

	if (IS_CONST != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

	ZEND_ASSERT(retval != NULL);
	if (type == BP_VAR_R || type == BP_VAR_IS) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
	} else {
		ZVAL_INDIRECT(EX_VAR(opline->result.var), retval);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_R_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_TAIL_CALL(zend_fetch_var_address_helper_SPEC_CONST_UNUSED(BP_VAR_R ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_W_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_TAIL_CALL(zend_fetch_var_address_helper_SPEC_CONST_UNUSED(BP_VAR_W ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_RW_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_TAIL_CALL(zend_fetch_var_address_helper_SPEC_CONST_UNUSED(BP_VAR_RW ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	int fetch_type =
		(UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) ?
			BP_VAR_W : BP_VAR_R;
	ZEND_VM_TAIL_CALL(zend_fetch_var_address_helper_SPEC_CONST_UNUSED(fetch_type ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_UNSET_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_TAIL_CALL(zend_fetch_var_address_helper_SPEC_CONST_UNUSED(BP_VAR_UNSET ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_IS_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_TAIL_CALL(zend_fetch_var_address_helper_SPEC_CONST_UNUSED(BP_VAR_IS ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
        if ((IS_CONST & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
        }
		ZEND_VM_TAIL_CALL(ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_UNUSED == IS_UNUSED) {
			ZEND_VM_TAIL_CALL(zend_use_undef_in_read_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	uint32_t call_info;
	zend_function *fbc;
	zend_execute_data *call;

	SAVE_OPLINE();

	if (IS_CONST == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op1)), Z_STR_P(RT_CONSTANT(opline, opline->op1) + 1), ZEND_FETCH_CLASS_DEFAULT | ZEND_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {

				HANDLE_EXCEPTION();
			}
			if (IS_UNUSED != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_CONST == IS_UNUSED) {
		ce = zend_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {

			HANDLE_EXCEPTION();
		}
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_CONST == IS_CONST &&
	    IS_UNUSED == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_CONST != IS_CONST &&
	           IS_UNUSED == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if (IS_UNUSED != IS_UNUSED) {
		function_name = NULL;
		if (IS_UNUSED != IS_CONST) {
			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				do {
					if (IS_UNUSED & (IS_VAR|IS_CV) && Z_ISREF_P(function_name)) {
						function_name = Z_REFVAL_P(function_name);
						if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if (IS_UNUSED == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					zend_throw_error(NULL, "Method name must be a string");

					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, Z_STR_P(function_name));
		} else {
			fbc = zend_std_get_static_method(ce, Z_STR_P(function_name), ((IS_UNUSED == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(ce, Z_STR_P(function_name));
			}

			HANDLE_EXCEPTION();
		}
		if (IS_UNUSED == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE)))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if (IS_UNUSED != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (Z_TYPE(EX(This)) == IS_OBJECT && Z_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_throw_error(NULL, "Cannot call private %s::__construct()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & ZEND_ACC_STATIC)) {
		if (Z_TYPE(EX(This)) == IS_OBJECT && instanceof_function(Z_OBJCE(EX(This)), ce)) {
			ce = (zend_class_entry*)Z_OBJ(EX(This));
			call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
		} else {
			zend_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is ZEND_FETCH_CLASS */
		if (IS_CONST == IS_UNUSED
		 && ((opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_PARENT ||
		     (opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_SELF)) {
			if (Z_TYPE(EX(This)) == IS_OBJECT) {
				ce = Z_OBJCE(EX(This));
			} else {
				ce = Z_CE(EX(This));
			}
		}
		call_info = ZEND_CALL_NESTED_FUNCTION;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_VERIFY_RETURN_TYPE_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	if (IS_CONST == IS_UNUSED) {
		SAVE_OPLINE();
		zend_verify_missing_return_type(EX(func));
		HANDLE_EXCEPTION();
	} else {
/* prevents "undefined variable opline" errors */
#if 0 || (IS_CONST != IS_UNUSED)
		USE_OPLINE
		zval *retval_ref, *retval_ptr;
		zend_arg_info *ret_info = EX(func)->common.arg_info - 1;
		retval_ref = retval_ptr = RT_CONSTANT(opline, opline->op1);

		if (IS_CONST == IS_CONST) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval_ptr);
			retval_ref = retval_ptr = EX_VAR(opline->result.var);
		} else if (IS_CONST == IS_VAR) {
			if (UNEXPECTED(Z_TYPE_P(retval_ptr) == IS_INDIRECT)) {
				retval_ptr = Z_INDIRECT_P(retval_ptr);
			}
			ZVAL_DEREF(retval_ptr);
		} else if (IS_CONST == IS_CV) {
			ZVAL_DEREF(retval_ptr);
		}

		if (EXPECTED(ZEND_TYPE_CONTAINS_CODE(ret_info->type, Z_TYPE_P(retval_ptr)))) {
			ZEND_VM_NEXT_OPCODE();
		}

		if (IS_CONST == IS_CV && UNEXPECTED(Z_ISUNDEF_P(retval_ptr))) {
			SAVE_OPLINE();
			retval_ref = retval_ptr = ZVAL_UNDEFINED_OP1();
			if (ZEND_TYPE_FULL_MASK(ret_info->type) & MAY_BE_NULL) {
				ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
			}
		}

		zend_reference *ref = NULL;
		void *cache_slot = CACHE_ADDR(opline->op2.num);
		if (UNEXPECTED(retval_ref != retval_ptr)) {
			if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
				ref = Z_REF_P(retval_ref);
			} else {
				/* A cast might happen - unwrap the reference if this is a by-value return */
				if (Z_REFCOUNT_P(retval_ref) == 1) {
					ZVAL_UNREF(retval_ref);
				} else {
					Z_DELREF_P(retval_ref);
					ZVAL_COPY(retval_ref, retval_ptr);
				}
				retval_ptr = retval_ref;
			}
		}

		SAVE_OPLINE();
		if (UNEXPECTED(!zend_check_type_slow(ret_info->type, retval_ptr, ref, cache_slot, NULL, 1, 0))) {
			zend_verify_return_error(EX(func), retval_ptr);
			HANDLE_EXCEPTION();
		}
		ZEND_VM_NEXT_OPCODE();
#endif
	}
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAL_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
	}

	value = RT_CONSTANT(opline, opline->op1);
	ZVAL_COPY_VALUE(arg, value);
	if (IS_CONST == IS_CONST) {
		if (UNEXPECTED(Z_OPT_REFCOUNTED_P(arg))) {
			Z_ADDREF_P(arg);
		}
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAL_EX_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(0)) {
		if (QUICK_ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_val_by_ref;
		}
	} else if (ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_val_by_ref:
		ZEND_VM_TAIL_CALL(zend_cannot_pass_by_ref_helper_SPEC(arg_num, arg ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
	}
	value = RT_CONSTANT(opline, opline->op1);
	ZVAL_COPY_VALUE(arg, value);
	if (IS_CONST == IS_CONST) {
		if (UNEXPECTED(Z_OPT_REFCOUNTED_P(arg))) {
			Z_ADDREF_P(arg);
		}
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAL_EX_SPEC_CONST_UNUSED_QUICK_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(1)) {
		if (QUICK_ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_val_by_ref;
		}
	} else if (ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_val_by_ref:
		ZEND_VM_TAIL_CALL(zend_cannot_pass_by_ref_helper_SPEC(arg_num, arg ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
	}
	value = RT_CONSTANT(opline, opline->op1);
	ZVAL_COPY_VALUE(arg, value);
	if (IS_CONST == IS_CONST) {
		if (UNEXPECTED(Z_OPT_REFCOUNTED_P(arg))) {
			Z_ADDREF_P(arg);
		}
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_NEW_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *result;
	zend_function *constructor;
	zend_class_entry *ce;
	zend_execute_data *call;

	SAVE_OPLINE();
	if (IS_CONST == IS_CONST) {
		ce = CACHED_PTR(opline->op2.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op1)), Z_STR_P(RT_CONSTANT(opline, opline->op1) + 1), ZEND_FETCH_CLASS_DEFAULT | ZEND_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
			CACHE_PTR(opline->op2.num, ce);
		}
	} else if (IS_CONST == IS_UNUSED) {
		ce = zend_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		}
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));
	}

	result = EX_VAR(opline->result.var);
	if (UNEXPECTED(object_init_ex(result, ce) != SUCCESS)) {
		ZVAL_UNDEF(result);
		HANDLE_EXCEPTION();
	}

	constructor = Z_OBJ_HT_P(result)->get_constructor(Z_OBJ_P(result));
	if (constructor == NULL) {
		if (UNEXPECTED(EG(exception))) {
			HANDLE_EXCEPTION();
		}

		/* If there are no arguments, skip over the DO_FCALL opcode. We check if the next
		 * opcode is DO_FCALL in case EXT instructions are used. */
		if (EXPECTED(opline->extended_value == 0 && (opline+1)->opcode == ZEND_DO_FCALL)) {
			ZEND_VM_NEXT_OPCODE_EX(1, 2);
		}

		/* Perform a dummy function call */
		call = zend_vm_stack_push_call_frame(
			ZEND_CALL_FUNCTION, (zend_function *) &zend_pass_function,
			opline->extended_value, NULL);
	} else {
		if (EXPECTED(constructor->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&constructor->op_array))) {
			init_func_run_time_cache(&constructor->op_array);
		}
		/* We are not handling overloaded classes right now */
		call = zend_vm_stack_push_call_frame(
			ZEND_CALL_FUNCTION | ZEND_CALL_RELEASE_THIS | ZEND_CALL_HAS_THIS,
			constructor,
			opline->extended_value,
			Z_OBJ_P(result));
		Z_ADDREF_P(result);
	}

	call->prev_execute_data = EX(call);
	EX(call) = call;
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) &&
	    UNEXPECTED(opline->extended_value & ZEND_ARRAY_ELEMENT_REF)) {
		expr_ptr = NULL;
		if (Z_ISREF_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}

	} else {
		expr_ptr = RT_CONSTANT(opline, opline->op1);
		if (IS_CONST == IS_TMP_VAR) {
			/* pass */
		} else if (IS_CONST == IS_CONST) {
			Z_TRY_ADDREF_P(expr_ptr);
		} else if (IS_CONST == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			Z_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_CONST == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(expr_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(expr_ptr);

				expr_ptr = Z_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(expr_ptr)) {
					Z_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_UNUSED != IS_UNUSED) {
		zval *offset = NULL;
		zend_string *str;
		zend_ulong hval;

add_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if (IS_UNUSED != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index:
			zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_UNUSED & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(offset) == IS_REFERENCE)) {
			offset = Z_REFVAL_P(offset);
			goto add_again;
		} else if (Z_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (Z_TYPE_P(offset) == IS_DOUBLE) {
			hval = zend_dval_to_lval(Z_DVAL_P(offset));
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_RESOURCE) {
			zend_use_resource_as_offset(offset);
			hval = Z_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_UNUSED == IS_CV && Z_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			zend_illegal_offset();
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			zend_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_ARRAY_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_CONST != IS_UNUSED) {
		size = opline->extended_value >> ZEND_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, zend_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & ZEND_ARRAY_NOT_PACKED) {
			zend_hash_real_init_mixed(Z_ARRVAL_P(array));
		}
		ZEND_VM_TAIL_CALL(ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, zend_new_array(0));
		ZEND_VM_NEXT_OPCODE();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_UNSET_VAR_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varname;
	zend_string *name, *tmp_name;
	HashTable *target_symbol_table;

	SAVE_OPLINE();

	varname = RT_CONSTANT(opline, opline->op1);

	if (IS_CONST == IS_CONST) {
		name = Z_STR_P(varname);
	} else if (EXPECTED(Z_TYPE_P(varname) == IS_STRING)) {
		name = Z_STR_P(varname);
		tmp_name = NULL;
	} else {
		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(varname) == IS_UNDEF)) {
			varname = ZVAL_UNDEFINED_OP1();
		}
		name = zval_try_get_tmp_string(varname, &tmp_name);
		if (UNEXPECTED(!name)) {

			HANDLE_EXCEPTION();
		}
	}

	target_symbol_table = zend_get_target_symbol_table(opline->extended_value EXECUTE_DATA_CC);
	zend_hash_del_ind(target_symbol_table, name);

	if (IS_CONST != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	/* Should be bool result? as below got: result = (opline->extended_value & ZEND_ISEMPTY) */
	int result;
	zval *varname;
	zend_string *name, *tmp_name;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = RT_CONSTANT(opline, opline->op1);
	if (IS_CONST == IS_CONST) {
		name = Z_STR_P(varname);
	} else {
		name = zval_get_tmp_string(varname, &tmp_name);
	}

	target_symbol_table = zend_get_target_symbol_table(opline->extended_value EXECUTE_DATA_CC);
	value = zend_hash_find_ex(target_symbol_table, name, IS_CONST == IS_CONST);

	if (IS_CONST != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

	if (!value) {
		result = (opline->extended_value & ZEND_ISEMPTY);
	} else {
		if (Z_TYPE_P(value) == IS_INDIRECT) {
			value = Z_INDIRECT_P(value);
		}
		if (!(opline->extended_value & ZEND_ISEMPTY)) {
			if (Z_ISREF_P(value)) {
				value = Z_REFVAL_P(value);
			}
			result = Z_TYPE_P(value) > IS_NULL;
		} else {
			result = !i_zend_is_true(value);
		}
	}

	ZEND_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_function *func;
	zval *zfunc;
	zval *object;
	zend_class_entry *called_scope;

	func = CACHED_PTR(opline->extended_value);
	if (UNEXPECTED(func == NULL)) {
		zfunc = zend_hash_find_ex(EG(function_table), Z_STR_P(RT_CONSTANT(opline, opline->op1)), 1);
		ZEND_ASSERT(zfunc != NULL);
		func = Z_FUNC_P(zfunc);
		ZEND_ASSERT(func->type == ZEND_USER_FUNCTION);
		CACHE_PTR(opline->extended_value, func);
	}

	if (Z_TYPE(EX(This)) == IS_OBJECT) {
		called_scope = Z_OBJCE(EX(This));
		if (UNEXPECTED((func->common.fn_flags & ZEND_ACC_STATIC) ||
				(EX(func)->common.fn_flags & ZEND_ACC_STATIC))) {
			object = NULL;
		} else {
			object = &EX(This);
		}
	} else {
		called_scope = Z_CE(EX(This));
		object = NULL;
	}
	zend_create_closure(EX_VAR(opline->result.var), func,
		EX(func)->op_array.scope, called_scope, object);

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_YIELD_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & ZEND_GENERATOR_FORCED_CLOSE)) {
		ZEND_VM_TAIL_CALL(zend_yield_in_closed_generator_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CONST != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CONST & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = RT_CONSTANT(opline, opline->op1);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
						Z_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = NULL;

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_CONST == IS_VAR) {
						ZEND_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == ZEND_RETURNS_FUNCTION
						 && !Z_ISREF_P(value_ptr)) {
							zend_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (Z_ISREF_P(value_ptr)) {
						Z_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, Z_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = RT_CONSTANT(opline, opline->op1);

			/* Consts, temporary variables and references need copying */
			if (IS_CONST == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
					Z_ADDREF(generator->value);
				}
			} else if (IS_CONST == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if ((IS_CONST & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, Z_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CONST == IS_CV) {
					if (Z_OPT_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {
		zval *key = NULL;
		if ((IS_UNUSED & (IS_CV|IS_VAR)) && UNEXPECTED(Z_TYPE_P(key)) == IS_REFERENCE) {
			key = Z_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_MATCH_ERROR_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op;

	SAVE_OPLINE();
	op = RT_CONSTANT(opline, opline->op1);
	zend_throw_exception_ex(zend_ce_unhandled_match_error, 0, "Unhandled match value of type %s", zend_zval_type_name(op));
	HANDLE_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_COUNT_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;
	zend_long count;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);

	while (1) {
		if (Z_TYPE_P(op1) == IS_ARRAY) {
			count = zend_array_count(Z_ARRVAL_P(op1));
			break;
		} else if (Z_TYPE_P(op1) == IS_OBJECT) {
			zend_object *zobj = Z_OBJ_P(op1);

			/* first, we check if the handler is defined */
			if (zobj->handlers->count_elements) {
				if (SUCCESS == zobj->handlers->count_elements(zobj, &count)) {
					break;
				}
				if (UNEXPECTED(EG(exception))) {
					count = 0;
					break;
				}
			}

			/* if not and the object implements Countable we call its count() method */
			if (zend_class_implements_interface(zobj->ce, zend_ce_countable)) {
				zval retval;

				zend_call_method_with_0_params(zobj, NULL, NULL, "count", &retval);
				count = zval_get_long(&retval);
				zval_ptr_dtor(&retval);
				break;
			}

			/* If There's no handler and it doesn't implement Countable then emit a TypeError */
		} else if ((IS_CONST & (IS_VAR|IS_CV)) != 0 && Z_TYPE_P(op1) == IS_REFERENCE) {
			op1 = Z_REFVAL_P(op1);
			continue;
		} else if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		count = 0;
		zend_type_error("%s(): Argument #1 ($var) must be of type Countable|array, %s given", opline->extended_value ? "sizeof" : "count", zend_zval_type_name(op1));
		break;
	}

	ZVAL_LONG(EX_VAR(opline->result.var), count);

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_GET_CLASS_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (IS_CONST == IS_UNUSED) {
		if (UNEXPECTED(!EX(func)->common.scope)) {
			SAVE_OPLINE();
			zend_throw_error(NULL, "get_class() without arguments must be called from within a class");
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		} else {
			ZVAL_STR_COPY(EX_VAR(opline->result.var), EX(func)->common.scope->name);
			ZEND_VM_NEXT_OPCODE();
		}
	} else {
		zval *op1;

		SAVE_OPLINE();
		op1 = RT_CONSTANT(opline, opline->op1);
		while (1) {
			if (Z_TYPE_P(op1) == IS_OBJECT) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), Z_OBJCE_P(op1)->name);
			} else if ((IS_CONST & (IS_VAR|IS_CV)) != 0 && Z_TYPE_P(op1) == IS_REFERENCE) {
				op1 = Z_REFVAL_P(op1);
				continue;
			} else {
				if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
					ZVAL_UNDEFINED_OP1();
				}
				zend_type_error("get_class(): Argument #1 ($object) must be of type object, %s given", zend_zval_type_name(op1));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
			}
			break;
		}

		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_GET_TYPE_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;
	zend_string *type;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	type = zend_zval_get_legacy_type(op1);
	if (EXPECTED(type)) {
		ZVAL_INTERNED_STR(EX_VAR(opline->result.var), type);
	} else {
		ZVAL_STRING(EX_VAR(opline->result.var), "unknown type");
	}

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FUNC_GET_ARGS_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_array *ht;
	uint32_t arg_count, result_size, skip;

	arg_count = EX_NUM_ARGS();
	if (IS_CONST == IS_CONST) {
		skip = Z_LVAL_P(RT_CONSTANT(opline, opline->op1));
		if (arg_count < skip) {
			result_size = 0;
		} else {
			result_size = arg_count - skip;
		}
	} else {
		skip = 0;
		result_size = arg_count;
	}

	if (result_size) {
		uint32_t first_extra_arg = EX(func)->op_array.num_args;

		ht = zend_new_array(result_size);
		ZVAL_ARR(EX_VAR(opline->result.var), ht);
		zend_hash_real_init_packed(ht);
		ZEND_HASH_FILL_PACKED(ht) {
			zval *p, *q;
			uint32_t i = skip;
			p = EX_VAR_NUM(i);
			if (arg_count > first_extra_arg) {
				while (i < first_extra_arg) {
					q = p;
					if (EXPECTED(Z_TYPE_INFO_P(q) != IS_UNDEF)) {
						ZVAL_DEREF(q);
						if (Z_OPT_REFCOUNTED_P(q)) {
							Z_ADDREF_P(q);
						}
						ZEND_HASH_FILL_SET(q);
					} else {
						ZEND_HASH_FILL_SET_NULL();
					}
					ZEND_HASH_FILL_NEXT();
					p++;
					i++;
				}
				if (skip < first_extra_arg) {
					skip = 0;
				} else {
					skip -= first_extra_arg;
				}
				p = EX_VAR_NUM(EX(func)->op_array.last_var + EX(func)->op_array.T + skip);
			}
			while (i < arg_count) {
				q = p;
				if (EXPECTED(Z_TYPE_INFO_P(q) != IS_UNDEF)) {
					ZVAL_DEREF(q);
					if (Z_OPT_REFCOUNTED_P(q)) {
						Z_ADDREF_P(q);
					}
					ZEND_HASH_FILL_SET(q);
				} else {
					ZEND_HASH_FILL_SET_NULL();
				}
				ZEND_HASH_FILL_NEXT();
				p++;
				i++;
			}
		} ZEND_HASH_FILL_END();
		ht->nNumOfElements = result_size;
	} else {
		ZVAL_EMPTY_ARRAY(EX_VAR(opline->result.var));
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DIV_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	fast_div_function(EX_VAR(opline->result.var), op1, op2);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POW_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	pow_function(EX_VAR(opline->result.var), op1, op2);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);

	if ((IS_CONST == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
	    (IS_CV == IS_CONST || EXPECTED(Z_TYPE_P(op2) == IS_STRING))) {
		zend_string *op1_str = Z_STR_P(op1);
		zend_string *op2_str = Z_STR_P(op2);
		zend_string *str;

		if (IS_CONST != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
		} else if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if (IS_CONST == IS_CONST || IS_CONST == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else if (IS_CONST != IS_CONST && IS_CONST != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
		    size_t len = ZSTR_LEN(op1_str);

			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else {
			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		}
		ZEND_VM_NEXT_OPCODE();
	} else {
		SAVE_OPLINE();

		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
			op1 = ZVAL_UNDEFINED_OP1();
		}
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
			op2 = ZVAL_UNDEFINED_OP2();
		}
		concat_function(EX_VAR(opline->result.var), op1, op2);


		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SPACESHIP_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	compare_function(EX_VAR(opline->result.var), op1, op2);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_R_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	dim = EX_VAR(opline->op2.var);
	if (IS_CONST != IS_CONST) {
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_array:
			value = zend_fetch_dimension_address_inner(Z_ARRVAL_P(container), dim, IS_CV, BP_VAR_R EXECUTE_DATA_CC);
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		} else if (EXPECTED(Z_TYPE_P(container) == IS_REFERENCE)) {
			container = Z_REFVAL_P(container);
			if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				goto fetch_dim_r_array;
			} else {
				goto fetch_dim_r_slow;
			}
		} else {
fetch_dim_r_slow:
			if (IS_CV == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
		}
	} else {
		zend_fetch_dimension_address_read_R(container, dim, IS_CV OPLINE_CC EXECUTE_DATA_CC);
	}


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_IS_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	zend_fetch_dimension_address_read_IS(container, EX_VAR(opline->op2.var), IS_CV OPLINE_CC EXECUTE_DATA_CC);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
        if ((IS_CONST & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
        }
		ZEND_VM_TAIL_CALL(ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_CV == IS_UNUSED) {
			ZEND_VM_TAIL_CALL(zend_use_undef_in_read_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_FETCH_DIM_R_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_R_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	offset = EX_VAR(opline->op2.var);

	if (IS_CONST == IS_CONST ||
	    (IS_CONST != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
	    do {
			if ((IS_CONST & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			zend_wrong_property_read(container, offset);
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if (IS_CV == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value & ~ZEND_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
		} else {
			if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));

		if (IS_CV != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_IS_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	offset = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	if (IS_CONST == IS_CONST ||
	    (IS_CONST != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_CONST & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if (IS_CV == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if (IS_CV != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_CONST & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_R_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_LIST_R_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	zend_fetch_dimension_address_LIST_r(container, EX_VAR(opline->op2.var), IS_CV OPLINE_CC EXECUTE_DATA_CC);

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_string *op1_str, *op2_str, *str;


	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if ((IS_CONST == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
	    (IS_CV == IS_CONST || EXPECTED(Z_TYPE_P(op2) == IS_STRING))) {
		zend_string *op1_str = Z_STR_P(op1);
		zend_string *op2_str = Z_STR_P(op2);
		zend_string *str;

		if (IS_CONST != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
		} else if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if (IS_CONST == IS_CONST || IS_CONST == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else if (IS_CONST != IS_CONST && IS_CONST != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
		    size_t len = ZSTR_LEN(op1_str);

			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else {
			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	if (IS_CONST == IS_CONST) {
		op1_str = Z_STR_P(op1);
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		op1_str = zend_string_copy(Z_STR_P(op1));
	} else {
		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		op1_str = zval_get_string_func(op1);
	}
	if (IS_CV == IS_CONST) {
		op2_str = Z_STR_P(op2);
	} else if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
		op2_str = zend_string_copy(Z_STR_P(op2));
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP2();
		}
		op2_str = zval_get_string_func(op2);
	}
	do {
		if (IS_CONST != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(Z_REFCOUNTED_P(op2))) {
						GC_ADDREF(op2_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
				zend_string_release_ex(op1_str, 0);
				break;
			}
		}
		if (IS_CV != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(Z_REFCOUNTED_P(op1))) {
						GC_ADDREF(op1_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
				zend_string_release_ex(op2_str, 0);
				break;
			}
		}
		str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
		memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
		memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
		ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
		if (IS_CONST != IS_CONST) {
			zend_string_release_ex(op1_str, 0);
		}
		if (IS_CV != IS_CONST) {
			zend_string_release_ex(op2_str, 0);
		}
	} while (0);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_METHOD_CALL_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	zend_function *fbc;
	zend_class_entry *called_scope;
	zend_object *obj;
	zend_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = RT_CONSTANT(opline, opline->op1);

	if (IS_CV != IS_CONST) {
		function_name = EX_VAR(opline->op2.var);
	}

	if (IS_CV != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		do {
			if ((IS_CV & (IS_VAR|IS_CV)) && Z_ISREF_P(function_name)) {
				function_name = Z_REFVAL_P(function_name);
				if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {

					HANDLE_EXCEPTION();
				}
			}
			zend_throw_error(NULL, "Method name must be a string");


			HANDLE_EXCEPTION();
		} while (0);
	}

	if (IS_CONST == IS_UNUSED) {
		obj = Z_OBJ_P(object);
	} else {
		do {
			if (IS_CONST != IS_CONST && EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
				obj = Z_OBJ_P(object);
			} else {
				if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(object))) {
					zend_reference *ref = Z_REF_P(object);

					object = &ref->val;
					if (EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
						obj = Z_OBJ_P(object);
						if (IS_CONST & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(zend_reference));
							} else {
								Z_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if (IS_CV != IS_CONST) {

						}
						HANDLE_EXCEPTION();
					}
				}
				if (IS_CV == IS_CONST) {
					function_name = EX_VAR(opline->op2.var);
				}
				zend_invalid_method_call(object, function_name);


				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if (IS_CV == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
	    fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
	    zend_object *orig_obj = obj;

		if (IS_CV == IS_CONST) {
			function_name = EX_VAR(opline->op2.var);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, Z_STR_P(function_name), ((IS_CV == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(obj->ce, Z_STR_P(function_name));
			}

			if ((IS_CONST & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if (IS_CV == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if ((IS_CONST & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (IS_CV != IS_CONST) {

	}

	call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_STATIC) != 0)) {
		if ((IS_CONST & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			zend_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (zend_object*)called_scope;
		call_info = ZEND_CALL_NESTED_FUNCTION;
	} else if (IS_CONST & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if (IS_CONST == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS | ZEND_CALL_RELEASE_THIS;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	uint32_t call_info;
	zend_function *fbc;
	zend_execute_data *call;

	SAVE_OPLINE();

	if (IS_CONST == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op1)), Z_STR_P(RT_CONSTANT(opline, opline->op1) + 1), ZEND_FETCH_CLASS_DEFAULT | ZEND_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {

				HANDLE_EXCEPTION();
			}
			if (IS_CV != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_CONST == IS_UNUSED) {
		ce = zend_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {

			HANDLE_EXCEPTION();
		}
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_CONST == IS_CONST &&
	    IS_CV == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_CONST != IS_CONST &&
	           IS_CV == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if (IS_CV != IS_UNUSED) {
		function_name = EX_VAR(opline->op2.var);
		if (IS_CV != IS_CONST) {
			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				do {
					if (IS_CV & (IS_VAR|IS_CV) && Z_ISREF_P(function_name)) {
						function_name = Z_REFVAL_P(function_name);
						if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					zend_throw_error(NULL, "Method name must be a string");

					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, Z_STR_P(function_name));
		} else {
			fbc = zend_std_get_static_method(ce, Z_STR_P(function_name), ((IS_CV == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(ce, Z_STR_P(function_name));
			}

			HANDLE_EXCEPTION();
		}
		if (IS_CV == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE)))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if (IS_CV != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (Z_TYPE(EX(This)) == IS_OBJECT && Z_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_throw_error(NULL, "Cannot call private %s::__construct()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & ZEND_ACC_STATIC)) {
		if (Z_TYPE(EX(This)) == IS_OBJECT && instanceof_function(Z_OBJCE(EX(This)), ce)) {
			ce = (zend_class_entry*)Z_OBJ(EX(This));
			call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
		} else {
			zend_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is ZEND_FETCH_CLASS */
		if (IS_CONST == IS_UNUSED
		 && ((opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_PARENT ||
		     (opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_SELF)) {
			if (Z_TYPE(EX(This)) == IS_OBJECT) {
				ce = Z_OBJCE(EX(This));
			} else {
				ce = Z_CE(EX(This));
			}
		}
		call_info = ZEND_CALL_NESTED_FUNCTION;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_USER_CALL_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_fcall_info_cache fcc;
	char *error = NULL;
	zend_function *func;
	void *object_or_called_scope;
	zend_execute_data *call;
	uint32_t call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_DYNAMIC;

	SAVE_OPLINE();
	function_name = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	if (zend_is_callable_ex(function_name, NULL, 0, NULL, &fcc, &error)) {
		ZEND_ASSERT(!error);
		func = fcc.function_handler;
		object_or_called_scope = fcc.called_scope;
		if (func->common.fn_flags & ZEND_ACC_CLOSURE) {
			/* Delay closure destruction until its invocation */
			GC_ADDREF(ZEND_CLOSURE_OBJECT(func));
			call_info |= ZEND_CALL_CLOSURE;
			if (func->common.fn_flags & ZEND_ACC_FAKE_CLOSURE) {
				call_info |= ZEND_CALL_FAKE_CLOSURE;
			}
			if (fcc.object) {
				object_or_called_scope = fcc.object;
				call_info |= ZEND_CALL_HAS_THIS;
			}
		} else if (fcc.object) {
			GC_ADDREF(fcc.object); /* For $this pointer */
			object_or_called_scope = fcc.object;
			call_info |= ZEND_CALL_RELEASE_THIS | ZEND_CALL_HAS_THIS;
		}

		if ((IS_CV & (IS_TMP_VAR|IS_VAR)) && UNEXPECTED(EG(exception))) {
			if (call_info & ZEND_CALL_CLOSURE) {
				zend_object_release(ZEND_CLOSURE_OBJECT(func));
			} else if (call_info & ZEND_CALL_RELEASE_THIS) {
				zend_object_release(fcc.object);
			}
			HANDLE_EXCEPTION();
		}

		if (EXPECTED(func->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&func->op_array))) {
			init_func_run_time_cache(&func->op_array);
		}
	} else {
		zend_type_error("%s(): Argument #1 ($function) must be a valid callback, %s", Z_STRVAL_P(RT_CONSTANT(opline, opline->op1)), error);
		efree(error);

		HANDLE_EXCEPTION();
	}

	call = zend_vm_stack_push_call_frame(call_info,
		func, opline->extended_value, object_or_called_scope);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) &&
	    UNEXPECTED(opline->extended_value & ZEND_ARRAY_ELEMENT_REF)) {
		expr_ptr = NULL;
		if (Z_ISREF_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}

	} else {
		expr_ptr = RT_CONSTANT(opline, opline->op1);
		if (IS_CONST == IS_TMP_VAR) {
			/* pass */
		} else if (IS_CONST == IS_CONST) {
			Z_TRY_ADDREF_P(expr_ptr);
		} else if (IS_CONST == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			Z_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_CONST == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(expr_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(expr_ptr);

				expr_ptr = Z_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(expr_ptr)) {
					Z_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_CV != IS_UNUSED) {
		zval *offset = EX_VAR(opline->op2.var);
		zend_string *str;
		zend_ulong hval;

add_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if (IS_CV != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index:
			zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(offset) == IS_REFERENCE)) {
			offset = Z_REFVAL_P(offset);
			goto add_again;
		} else if (Z_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (Z_TYPE_P(offset) == IS_DOUBLE) {
			hval = zend_dval_to_lval(Z_DVAL_P(offset));
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_RESOURCE) {
			zend_use_resource_as_offset(offset);
			hval = Z_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_CV == IS_CV && Z_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			zend_illegal_offset();
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			zend_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_ARRAY_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_CONST != IS_UNUSED) {
		size = opline->extended_value >> ZEND_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, zend_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & ZEND_ARRAY_NOT_PACKED) {
			zend_hash_real_init_mixed(Z_ARRVAL_P(array));
		}
		ZEND_VM_TAIL_CALL(ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, zend_new_array(0));
		ZEND_VM_NEXT_OPCODE();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	bool result;
	zend_ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	offset = EX_VAR(opline->op2.var);

	if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
		HashTable *ht;
		zval *value;
		zend_string *str;

isset_dim_obj_array:
		ht = Z_ARRVAL_P(container);
isset_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if (IS_CV != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index_prop;
				}
			}
			value = zend_hash_find_ex_ind(ht, str, IS_CV == IS_CONST);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index_prop:
			value = zend_hash_index_find(ht, hval);
		} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(offset))) {
			offset = Z_REFVAL_P(offset);
			goto isset_again;
		} else {
			value = zend_find_array_dim_slow(ht, offset EXECUTE_DATA_CC);
			if (UNEXPECTED(EG(exception))) {
				result = 0;
				goto isset_dim_obj_exit;
			}
		}

		if (!(opline->extended_value & ZEND_ISEMPTY)) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = value != NULL && Z_TYPE_P(value) > IS_NULL &&
			    (!Z_ISREF_P(value) || Z_TYPE_P(Z_REFVAL_P(value)) != IS_NULL);

			if (IS_CONST & (IS_CONST|IS_CV)) {
				/* avoid exception check */

				ZEND_VM_SMART_BRANCH(result, 0);
			}
		} else {
			result = (value == NULL || !i_zend_is_true(value));
		}
		goto isset_dim_obj_exit;
	} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(container))) {
		container = Z_REFVAL_P(container);
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
			goto isset_dim_obj_array;
		}
	}

	if (IS_CV == IS_CONST && Z_EXTRA_P(offset) == ZEND_EXTRA_VALUE) {
		offset++;
	}
	if (!(opline->extended_value & ZEND_ISEMPTY)) {
		result = zend_isset_dim_slow(container, offset EXECUTE_DATA_CC);
	} else {
		result = zend_isempty_dim_slow(container, offset EXECUTE_DATA_CC);
	}

isset_dim_obj_exit:


	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	offset = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	if (IS_CONST == IS_CONST ||
	    (IS_CONST != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		if ((IS_CONST & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
			container = Z_REFVAL_P(container);
			if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & ZEND_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & ZEND_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if (IS_CV == IS_CONST) {
		name = Z_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & ZEND_ISEMPTY) ^
		Z_OBJ_HT_P(container)->has_property(Z_OBJ_P(container), name, (opline->extended_value & ZEND_ISEMPTY), ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_ISEMPTY) : NULL));

	if (IS_CV != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

isset_object_finish:


	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ARRAY_KEY_EXISTS_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *key, *subject;
	HashTable *ht;
	zend_bool result;

	SAVE_OPLINE();

	key = RT_CONSTANT(opline, opline->op1);
	subject = EX_VAR(opline->op2.var);

	if (EXPECTED(Z_TYPE_P(subject) == IS_ARRAY)) {
array_key_exists_array:
		ht = Z_ARRVAL_P(subject);
		result = zend_array_key_exists_fast(ht, key OPLINE_CC EXECUTE_DATA_CC);
	} else {
		if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(subject))) {
			subject = Z_REFVAL_P(subject);
			if (EXPECTED(Z_TYPE_P(subject) == IS_ARRAY)) {
				goto array_key_exists_array;
			}
		}
		zend_array_key_exists_error(subject, key OPLINE_CC EXECUTE_DATA_CC);
		result = 0;
	}


	ZEND_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|UNUSED|CV, ANY) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_YIELD_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & ZEND_GENERATOR_FORCED_CLOSE)) {
		ZEND_VM_TAIL_CALL(zend_yield_in_closed_generator_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CONST != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CONST & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = RT_CONSTANT(opline, opline->op1);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
						Z_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = NULL;

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_CONST == IS_VAR) {
						ZEND_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == ZEND_RETURNS_FUNCTION
						 && !Z_ISREF_P(value_ptr)) {
							zend_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (Z_ISREF_P(value_ptr)) {
						Z_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, Z_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = RT_CONSTANT(opline, opline->op1);

			/* Consts, temporary variables and references need copying */
			if (IS_CONST == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
					Z_ADDREF(generator->value);
				}
			} else if (IS_CONST == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if ((IS_CONST & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, Z_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CONST == IS_CV) {
					if (Z_OPT_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {
		zval *key = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
		if ((IS_CV & (IS_CV|IS_VAR)) && UNEXPECTED(Z_TYPE_P(key)) == IS_REFERENCE) {
			key = Z_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BW_NOT_SPEC_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;

	op1 = EX_VAR(opline->op1.var);
	if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), ~Z_LVAL_P(op1));
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_bw_not_helper_SPEC(op1 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMP_NULL_SPEC_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;

	val = EX_VAR(opline->op1.var);
	if ((IS_TMP_VAR|IS_VAR|IS_CV) != IS_CONST) {
		ZVAL_DEREF(val);
	}

	if (Z_TYPE_INFO_P(val) > IS_NULL) {
		ZEND_VM_NEXT_OPCODE();
	} else {
		zval *result = EX_VAR(opline->result.var);

		if (EXPECTED(opline->extended_value == ZEND_SHORT_CIRCUITING_CHAIN_EXPR)) {
			ZVAL_NULL(result);
			if (UNEXPECTED(Z_TYPE_INFO_P(val) == IS_UNDEF)) {
				SAVE_OPLINE();
				ZVAL_UNDEFINED_OP1();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
		} else if (opline->extended_value == ZEND_SHORT_CIRCUITING_CHAIN_ISSET) {
			ZVAL_FALSE(result);
		} else {
			ZEND_ASSERT(opline->extended_value == ZEND_SHORT_CIRCUITING_CHAIN_EMPTY);
			ZVAL_TRUE(result);
		}

		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_QM_ASSIGN_LONG_SPEC_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	value = EX_VAR(opline->op1.var);
	ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(value));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_QM_ASSIGN_DOUBLE_SPEC_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	value = EX_VAR(opline->op1.var);
	ZVAL_DOUBLE(EX_VAR(opline->result.var), Z_DVAL_P(value));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_QM_ASSIGN_NOREF_SPEC_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	value = EX_VAR(opline->op1.var);
	ZVAL_COPY_VALUE(EX_VAR(opline->result.var), value);
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			fast_long_add_function(result, op1, op2);
			ZEND_VM_NEXT_OPCODE();
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto add_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
add_double:
			result = EX_VAR(opline->result.var);
			ZVAL_DOUBLE(result, d1 + d2);
			ZEND_VM_NEXT_OPCODE();
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto add_double;
		}
	}

	ZEND_VM_TAIL_CALL(zend_add_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SUB_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			fast_long_sub_function(result, op1, op2);
			ZEND_VM_NEXT_OPCODE();
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto sub_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
sub_double:
			result = EX_VAR(opline->result.var);
			ZVAL_DOUBLE(result, d1 - d2);
			ZEND_VM_NEXT_OPCODE();
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto sub_double;
		}
	}

	ZEND_VM_TAIL_CALL(zend_sub_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_MUL_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			zend_long overflow;

			result = EX_VAR(opline->result.var);
			ZEND_SIGNED_MULTIPLY_LONG(Z_LVAL_P(op1), Z_LVAL_P(op2), Z_LVAL_P(result), Z_DVAL_P(result), overflow);
			Z_TYPE_INFO_P(result) = overflow ? IS_DOUBLE : IS_LONG;
			ZEND_VM_NEXT_OPCODE();
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto mul_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
mul_double:
			result = EX_VAR(opline->result.var);
			ZVAL_DOUBLE(result, d1 * d2);
			ZEND_VM_NEXT_OPCODE();
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto mul_double;
		}
	}

	ZEND_VM_TAIL_CALL(zend_mul_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_MOD_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			if (UNEXPECTED(Z_LVAL_P(op2) == 0)) {
				ZEND_VM_TAIL_CALL(zend_mod_by_zero_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
			} else if (UNEXPECTED(Z_LVAL_P(op2) == -1)) {
				/* Prevent overflow error/crash if op1==ZEND_LONG_MIN */
				ZVAL_LONG(result, 0);
			} else {
				ZVAL_LONG(result, Z_LVAL_P(op1) % Z_LVAL_P(op2));
			}
			ZEND_VM_NEXT_OPCODE();
		}
	}

	ZEND_VM_TAIL_CALL(zend_mod_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SL_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)
			&& EXPECTED((zend_ulong)Z_LVAL_P(op2) < SIZEOF_ZEND_LONG * 8)) {
		/* Perform shift on unsigned numbers to get well-defined wrap behavior. */
		ZVAL_LONG(EX_VAR(opline->result.var),
			(zend_long) ((zend_ulong) Z_LVAL_P(op1) << Z_LVAL_P(op2)));
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_shift_left_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SR_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)
			&& EXPECTED((zend_ulong)Z_LVAL_P(op2) < SIZEOF_ZEND_LONG * 8)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(op1) >> Z_LVAL_P(op2));
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_shift_right_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) < Z_LVAL_P(op2))) {
is_smaller_true:
				ZEND_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_smaller_false:
				ZEND_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_smaller_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_smaller_double:
			if (d1 < d2) {
				goto is_smaller_true;
			} else {
				goto is_smaller_false;
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_smaller_double;
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_smaller_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) < Z_LVAL_P(op2))) {
is_smaller_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_smaller_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_smaller_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_smaller_double:
			if (d1 < d2) {
				goto is_smaller_true;
			} else {
				goto is_smaller_false;
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_smaller_double;
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_smaller_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) < Z_LVAL_P(op2))) {
is_smaller_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_smaller_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_smaller_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_smaller_double:
			if (d1 < d2) {
				goto is_smaller_true;
			} else {
				goto is_smaller_false;
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_smaller_double;
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_smaller_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) <= Z_LVAL_P(op2))) {
is_smaller_or_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_NONE();
				ZVAL_TRUE(EX_VAR(opline->result.var));
				ZEND_VM_NEXT_OPCODE();
			} else {
is_smaller_or_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_NONE();
				ZVAL_FALSE(EX_VAR(opline->result.var));
				ZEND_VM_NEXT_OPCODE();
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_smaller_or_equal_double:
			if (d1 <= d2) {
				goto is_smaller_or_equal_true;
			} else {
				goto is_smaller_or_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_smaller_or_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) <= Z_LVAL_P(op2))) {
is_smaller_or_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPZ();
				ZVAL_TRUE(EX_VAR(opline->result.var));
				ZEND_VM_NEXT_OPCODE();
			} else {
is_smaller_or_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPZ();
				ZVAL_FALSE(EX_VAR(opline->result.var));
				ZEND_VM_NEXT_OPCODE();
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_smaller_or_equal_double:
			if (d1 <= d2) {
				goto is_smaller_or_equal_true;
			} else {
				goto is_smaller_or_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_smaller_or_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) <= Z_LVAL_P(op2))) {
is_smaller_or_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPNZ();
				ZVAL_TRUE(EX_VAR(opline->result.var));
				ZEND_VM_NEXT_OPCODE();
			} else {
is_smaller_or_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPNZ();
				ZVAL_FALSE(EX_VAR(opline->result.var));
				ZEND_VM_NEXT_OPCODE();
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_smaller_or_equal_double:
			if (d1 <= d2) {
				goto is_smaller_or_equal_true;
			} else {
				goto is_smaller_or_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_smaller_or_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BW_OR_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(op1) | Z_LVAL_P(op2));
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_bw_or_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BW_AND_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(op1) & Z_LVAL_P(op2));
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_bw_and_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BW_XOR_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(op1) ^ Z_LVAL_P(op2));
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_bw_xor_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_LIST_R_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	zend_fetch_dimension_address_LIST_r(container, RT_CONSTANT(opline, opline->op2), IS_CONST OPLINE_CC EXECUTE_DATA_CC);

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SWITCH_LONG_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op, *jump_zv;
	HashTable *jumptable;

	op = EX_VAR(opline->op1.var);

	if (Z_TYPE_P(op) != IS_LONG) {
		ZVAL_DEREF(op);
		if (Z_TYPE_P(op) != IS_LONG) {
			/* Wrong type, fall back to ZEND_CASE chain */
			ZEND_VM_NEXT_OPCODE();
		}
	}

	jumptable = Z_ARRVAL_P(RT_CONSTANT(opline, opline->op2));
	jump_zv = zend_hash_index_find(jumptable, Z_LVAL_P(op));
	if (jump_zv != NULL) {
		ZEND_VM_SET_RELATIVE_OPCODE(opline, Z_LVAL_P(jump_zv));
		ZEND_VM_CONTINUE();
	} else {
		/* default */
		ZEND_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
		ZEND_VM_CONTINUE();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SWITCH_STRING_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op, *jump_zv;
	HashTable *jumptable;

	op = EX_VAR(opline->op1.var);

	if (Z_TYPE_P(op) != IS_STRING) {
		if ((IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
			/* Wrong type, fall back to ZEND_CASE chain */
			ZEND_VM_NEXT_OPCODE();
		} else {
			ZVAL_DEREF(op);
			if (Z_TYPE_P(op) != IS_STRING) {
				/* Wrong type, fall back to ZEND_CASE chain */
				ZEND_VM_NEXT_OPCODE();
			}
		}
	}

	jumptable = Z_ARRVAL_P(RT_CONSTANT(opline, opline->op2));
	jump_zv = zend_hash_find_ex(jumptable, Z_STR_P(op), (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST);
	if (jump_zv != NULL) {
		ZEND_VM_SET_RELATIVE_OPCODE(opline, Z_LVAL_P(jump_zv));
		ZEND_VM_CONTINUE();
	} else {
		/* default */
		ZEND_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
		ZEND_VM_CONTINUE();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_MATCH_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op, *jump_zv;
	HashTable *jumptable;

	op = EX_VAR(opline->op1.var);
	jumptable = Z_ARRVAL_P(RT_CONSTANT(opline, opline->op2));

match_try_again:
	if (Z_TYPE_P(op) == IS_LONG) {
		jump_zv = zend_hash_index_find(jumptable, Z_LVAL_P(op));
	} else if (Z_TYPE_P(op) == IS_STRING) {
		jump_zv = zend_hash_find_ex(jumptable, Z_STR_P(op), (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST);
	} else if (Z_TYPE_P(op) == IS_REFERENCE) {
		op = Z_REFVAL_P(op);
		goto match_try_again;
	} else {
		if (UNEXPECTED(((IS_TMP_VAR|IS_VAR|IS_CV) & IS_CV) && Z_TYPE_P(op) == IS_UNDEF)) {
			SAVE_OPLINE();
			op = ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
			goto match_try_again;
		}

		goto default_branch;
	}

	if (jump_zv != NULL) {
		ZEND_VM_SET_RELATIVE_OPCODE(opline, Z_LVAL_P(jump_zv));
		ZEND_VM_CONTINUE();
	} else {
default_branch:
		/* default */
		ZEND_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
		ZEND_VM_CONTINUE();
	}
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	ZVAL_LONG(result, Z_LVAL_P(op1) + Z_LVAL_P(op2));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_LONG_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	fast_long_add_function(result, op1, op2);
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	ZVAL_DOUBLE(result, Z_DVAL_P(op1) + Z_DVAL_P(op2));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	ZVAL_LONG(result, Z_LVAL_P(op1) - Z_LVAL_P(op2));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SUB_LONG_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	fast_long_sub_function(result, op1, op2);
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SUB_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	ZVAL_DOUBLE(result, Z_DVAL_P(op1) - Z_DVAL_P(op2));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	ZVAL_LONG(result, Z_LVAL_P(op1) * Z_LVAL_P(op2));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_MUL_LONG_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	zend_long overflow;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	ZEND_SIGNED_MULTIPLY_LONG(Z_LVAL_P(op1), Z_LVAL_P(op2), Z_LVAL_P(result), Z_DVAL_P(result), overflow);
	Z_TYPE_INFO_P(result) = overflow ? IS_DOUBLE : IS_LONG;
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_MUL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	ZVAL_DOUBLE(result, Z_DVAL_P(op1) * Z_DVAL_P(op2));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_LVAL_P(op1) == Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_NONE(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_LVAL_P(op1) == Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPZ(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_LVAL_P(op1) == Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_DVAL_P(op1) == Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_NONE(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_DVAL_P(op1) == Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPZ(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_DVAL_P(op1) == Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_LVAL_P(op1) != Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_NONE(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_LVAL_P(op1) != Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPZ(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_LVAL_P(op1) != Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_DVAL_P(op1) != Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_NONE(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_DVAL_P(op1) != Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPZ(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_DVAL_P(op1) != Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_LVAL_P(op1) < Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_NONE(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_LVAL_P(op1) < Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPZ(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_LVAL_P(op1) < Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_DVAL_P(op1) < Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_NONE(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_DVAL_P(op1) < Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPZ(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_DVAL_P(op1) < Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_LVAL_P(op1) <= Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_NONE(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_LVAL_P(op1) <= Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPZ(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_LVAL_P(op1) <= Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_DVAL_P(op1) <= Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_NONE(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_DVAL_P(op1) <= Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPZ(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (Z_DVAL_P(op1) <= Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			fast_long_add_function(result, op1, op2);
			ZEND_VM_NEXT_OPCODE();
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto add_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
add_double:
			result = EX_VAR(opline->result.var);
			ZVAL_DOUBLE(result, d1 + d2);
			ZEND_VM_NEXT_OPCODE();
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto add_double;
		}
	}

	ZEND_VM_TAIL_CALL(zend_add_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SUB_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			fast_long_sub_function(result, op1, op2);
			ZEND_VM_NEXT_OPCODE();
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto sub_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
sub_double:
			result = EX_VAR(opline->result.var);
			ZVAL_DOUBLE(result, d1 - d2);
			ZEND_VM_NEXT_OPCODE();
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto sub_double;
		}
	}

	ZEND_VM_TAIL_CALL(zend_sub_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_MUL_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			zend_long overflow;

			result = EX_VAR(opline->result.var);
			ZEND_SIGNED_MULTIPLY_LONG(Z_LVAL_P(op1), Z_LVAL_P(op2), Z_LVAL_P(result), Z_DVAL_P(result), overflow);
			Z_TYPE_INFO_P(result) = overflow ? IS_DOUBLE : IS_LONG;
			ZEND_VM_NEXT_OPCODE();
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto mul_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
mul_double:
			result = EX_VAR(opline->result.var);
			ZVAL_DOUBLE(result, d1 * d2);
			ZEND_VM_NEXT_OPCODE();
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto mul_double;
		}
	}

	ZEND_VM_TAIL_CALL(zend_mul_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_MOD_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			if (UNEXPECTED(Z_LVAL_P(op2) == 0)) {
				ZEND_VM_TAIL_CALL(zend_mod_by_zero_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
			} else if (UNEXPECTED(Z_LVAL_P(op2) == -1)) {
				/* Prevent overflow error/crash if op1==ZEND_LONG_MIN */
				ZVAL_LONG(result, 0);
			} else {
				ZVAL_LONG(result, Z_LVAL_P(op1) % Z_LVAL_P(op2));
			}
			ZEND_VM_NEXT_OPCODE();
		}
	}

	ZEND_VM_TAIL_CALL(zend_mod_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SL_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)
			&& EXPECTED((zend_ulong)Z_LVAL_P(op2) < SIZEOF_ZEND_LONG * 8)) {
		/* Perform shift on unsigned numbers to get well-defined wrap behavior. */
		ZVAL_LONG(EX_VAR(opline->result.var),
			(zend_long) ((zend_ulong) Z_LVAL_P(op1) << Z_LVAL_P(op2)));
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_shift_left_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SR_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)
			&& EXPECTED((zend_ulong)Z_LVAL_P(op2) < SIZEOF_ZEND_LONG * 8)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(op1) >> Z_LVAL_P(op2));
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_shift_right_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) < Z_LVAL_P(op2))) {
is_smaller_true:
				ZEND_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_smaller_false:
				ZEND_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_smaller_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_smaller_double:
			if (d1 < d2) {
				goto is_smaller_true;
			} else {
				goto is_smaller_false;
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_smaller_double;
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_smaller_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) < Z_LVAL_P(op2))) {
is_smaller_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_smaller_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_smaller_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_smaller_double:
			if (d1 < d2) {
				goto is_smaller_true;
			} else {
				goto is_smaller_false;
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_smaller_double;
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_smaller_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) < Z_LVAL_P(op2))) {
is_smaller_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_smaller_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_smaller_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_smaller_double:
			if (d1 < d2) {
				goto is_smaller_true;
			} else {
				goto is_smaller_false;
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_smaller_double;
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_smaller_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) <= Z_LVAL_P(op2))) {
is_smaller_or_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_NONE();
				ZVAL_TRUE(EX_VAR(opline->result.var));
				ZEND_VM_NEXT_OPCODE();
			} else {
is_smaller_or_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_NONE();
				ZVAL_FALSE(EX_VAR(opline->result.var));
				ZEND_VM_NEXT_OPCODE();
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_smaller_or_equal_double:
			if (d1 <= d2) {
				goto is_smaller_or_equal_true;
			} else {
				goto is_smaller_or_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_smaller_or_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) <= Z_LVAL_P(op2))) {
is_smaller_or_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPZ();
				ZVAL_TRUE(EX_VAR(opline->result.var));
				ZEND_VM_NEXT_OPCODE();
			} else {
is_smaller_or_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPZ();
				ZVAL_FALSE(EX_VAR(opline->result.var));
				ZEND_VM_NEXT_OPCODE();
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_smaller_or_equal_double:
			if (d1 <= d2) {
				goto is_smaller_or_equal_true;
			} else {
				goto is_smaller_or_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_smaller_or_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) <= Z_LVAL_P(op2))) {
is_smaller_or_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPNZ();
				ZVAL_TRUE(EX_VAR(opline->result.var));
				ZEND_VM_NEXT_OPCODE();
			} else {
is_smaller_or_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPNZ();
				ZVAL_FALSE(EX_VAR(opline->result.var));
				ZEND_VM_NEXT_OPCODE();
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_smaller_or_equal_double:
			if (d1 <= d2) {
				goto is_smaller_or_equal_true;
			} else {
				goto is_smaller_or_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_smaller_or_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BW_OR_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(op1) | Z_LVAL_P(op2));
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_bw_or_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BW_AND_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(op1) & Z_LVAL_P(op2));
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_bw_and_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BW_XOR_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(op1) ^ Z_LVAL_P(op2));
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_bw_xor_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	ZVAL_LONG(result, Z_LVAL_P(op1) + Z_LVAL_P(op2));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	fast_long_add_function(result, op1, op2);
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	ZVAL_DOUBLE(result, Z_DVAL_P(op1) + Z_DVAL_P(op2));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	ZVAL_LONG(result, Z_LVAL_P(op1) - Z_LVAL_P(op2));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	fast_long_sub_function(result, op1, op2);
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	ZVAL_DOUBLE(result, Z_DVAL_P(op1) - Z_DVAL_P(op2));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	ZVAL_LONG(result, Z_LVAL_P(op1) * Z_LVAL_P(op2));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	zend_long overflow;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	ZEND_SIGNED_MULTIPLY_LONG(Z_LVAL_P(op1), Z_LVAL_P(op2), Z_LVAL_P(result), Z_DVAL_P(result), overflow);
	Z_TYPE_INFO_P(result) = overflow ? IS_DOUBLE : IS_LONG;
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	ZVAL_DOUBLE(result, Z_DVAL_P(op1) * Z_DVAL_P(op2));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_LVAL_P(op1) == Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_NONE(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_LVAL_P(op1) == Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPZ(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_LVAL_P(op1) == Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_DVAL_P(op1) == Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_NONE(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_DVAL_P(op1) == Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPZ(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_DVAL_P(op1) == Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_LVAL_P(op1) != Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_NONE(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_LVAL_P(op1) != Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPZ(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_LVAL_P(op1) != Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_DVAL_P(op1) != Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_NONE(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_DVAL_P(op1) != Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPZ(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_DVAL_P(op1) != Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_LVAL_P(op1) < Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_NONE(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_LVAL_P(op1) < Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPZ(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_LVAL_P(op1) < Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_DVAL_P(op1) < Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_NONE(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_DVAL_P(op1) < Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPZ(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_DVAL_P(op1) < Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_LVAL_P(op1) <= Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_NONE(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_LVAL_P(op1) <= Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPZ(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_LVAL_P(op1) <= Z_LVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_DVAL_P(op1) <= Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_NONE(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_DVAL_P(op1) <= Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPZ(result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (Z_DVAL_P(op1) <= Z_DVAL_P(op2));
	ZEND_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	zend_fetch_dimension_address_LIST_r(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_MATCH_ERROR_SPEC_TMPVARCV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op;

	SAVE_OPLINE();
	op = EX_VAR(opline->op1.var);
	zend_throw_exception_ex(zend_ce_unhandled_match_error, 0, "Unhandled match value of type %s", zend_zval_type_name(op));
	HANDLE_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_LIST_R_SPEC_TMPVARCV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	zend_fetch_dimension_address_LIST_r(container, EX_VAR(opline->op2.var), IS_CV OPLINE_CC EXECUTE_DATA_CC);

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BOOL_NOT_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;

	val = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (Z_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_FALSE(EX_VAR(opline->result.var));
	} else if (EXPECTED(Z_TYPE_INFO_P(val) <= IS_TRUE)) {
		/* The result and op1 can be the same cv zval */
		const uint32_t orig_val_type = Z_TYPE_INFO_P(val);
		ZVAL_TRUE(EX_VAR(opline->result.var));
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(orig_val_type == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	} else {
		SAVE_OPLINE();
		ZVAL_BOOL(EX_VAR(opline->result.var), !i_zend_is_true(val));
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ECHO_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *z;

	SAVE_OPLINE();
	z = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (Z_TYPE_P(z) == IS_STRING) {
		zend_string *str = Z_STR_P(z);

		if (ZSTR_LEN(str) != 0) {
			zend_write(ZSTR_VAL(str), ZSTR_LEN(str));
		}
	} else {
		zend_string *str = zval_get_string_func(z);

		if (ZSTR_LEN(str) != 0) {
			zend_write(ZSTR_VAL(str), ZSTR_LEN(str));
		} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(z) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		zend_string_release_ex(str, 0);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMPZ_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	zend_uchar op1_type;

	val = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (Z_TYPE_INFO_P(val) == IS_TRUE) {
		ZEND_VM_NEXT_OPCODE();
	} else if (EXPECTED(Z_TYPE_INFO_P(val) <= IS_TRUE)) {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	SAVE_OPLINE();
	op1_type = (IS_TMP_VAR|IS_VAR);
	if (i_zend_is_true(val)) {
		opline++;
	} else {
		opline = OP_JMP_ADDR(opline, opline->op2);
	}
	if (op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(val);
	}
	ZEND_VM_JMP(opline);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMPNZ_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	zend_uchar op1_type;

	val = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (Z_TYPE_INFO_P(val) == IS_TRUE) {
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	} else if (EXPECTED(Z_TYPE_INFO_P(val) <= IS_TRUE)) {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	op1_type = (IS_TMP_VAR|IS_VAR);
	if (i_zend_is_true(val)) {
		opline = OP_JMP_ADDR(opline, opline->op2);
	} else {
		opline++;
	}
	if (op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(val);
	}
	ZEND_VM_JMP(opline);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMPZNZ_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	zend_uchar op1_type;

	val = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_INFO_P(val) == IS_TRUE)) {
		ZEND_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
		ZEND_VM_CONTINUE();
	} else if (EXPECTED(Z_TYPE_INFO_P(val) <= IS_TRUE)) {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	SAVE_OPLINE();
	op1_type = (IS_TMP_VAR|IS_VAR);
	if (i_zend_is_true(val)) {
		opline = ZEND_OFFSET_TO_OPLINE(opline, opline->extended_value);
	} else {
		opline = OP_JMP_ADDR(opline, opline->op2);
	}
	if (op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(val);
	}
	ZEND_VM_JMP(opline);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMPZ_EX_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	bool ret;

	val = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (Z_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		ZEND_VM_NEXT_OPCODE();
	} else if (EXPECTED(Z_TYPE_INFO_P(val) <= IS_TRUE)) {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	SAVE_OPLINE();
	ret = i_zend_is_true(val);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	if (ret) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		opline++;
	} else {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		opline = OP_JMP_ADDR(opline, opline->op2);
	}
	ZEND_VM_JMP(opline);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMPNZ_EX_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	bool ret;

	val = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (Z_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	} else if (EXPECTED(Z_TYPE_INFO_P(val) <= IS_TRUE)) {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			ZEND_VM_NEXT_OPCODE();
		}
	}

	SAVE_OPLINE();
	ret = i_zend_is_true(val);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	if (ret) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		opline = OP_JMP_ADDR(opline, opline->op2);
	} else {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		opline++;
	}
	ZEND_VM_JMP(opline);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FREE_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FE_FREE_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *var;
	USE_OPLINE

	var = EX_VAR(opline->op1.var);
	if (Z_TYPE_P(var) != IS_ARRAY) {
		SAVE_OPLINE();
		if (Z_FE_ITER_P(var) != (uint32_t)-1) {
			zend_hash_iterator_del(Z_FE_ITER_P(var));
		}
		zval_ptr_dtor_nogc(var);
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	/* This is freeing an array. Use an inlined version of zval_ptr_dtor_nogc. */
	/* PHP only needs to save the opline and check for an exception if the last reference to the array was garbage collected (destructors of elements in the array could throw an exception) */
	if (Z_REFCOUNTED_P(var) && !Z_DELREF_P(var)) {
		SAVE_OPLINE();
		rc_dtor_func(Z_COUNTED_P(var));
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_THROW_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	do {
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST || UNEXPECTED(Z_TYPE_P(value) != IS_OBJECT)) {
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
				value = Z_REFVAL_P(value);
				if (EXPECTED(Z_TYPE_P(value) == IS_OBJECT)) {
					break;
				}
			}
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(value) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
			zend_throw_error(NULL, "Can only throw objects");
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} while (0);

	zend_exception_save();
	Z_TRY_ADDREF_P(value);
	zend_throw_exception_object(value);
	zend_exception_restore();
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	HANDLE_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BOOL_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;

	val = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (Z_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
	} else if (EXPECTED(Z_TYPE_INFO_P(val) <= IS_TRUE)) {
		/* The result and op1 can be the same cv zval */
		const uint32_t orig_val_type = Z_TYPE_INFO_P(val);
		ZVAL_FALSE(EX_VAR(opline->result.var));
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(orig_val_type == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	} else {
		SAVE_OPLINE();
		ZVAL_BOOL(EX_VAR(opline->result.var), i_zend_is_true(val));
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CLONE_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *obj;
	zend_object *zobj;
	zend_class_entry *ce, *scope;
	zend_function *clone;
	zend_object_clone_obj_t clone_call;

	SAVE_OPLINE();
	obj = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	do {
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST ||
		    ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(Z_TYPE_P(obj) != IS_OBJECT))) {
		    if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && Z_ISREF_P(obj)) {
				obj = Z_REFVAL_P(obj);
				if (EXPECTED(Z_TYPE_P(obj) == IS_OBJECT)) {
					break;
				}
			}
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(obj) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
			zend_throw_error(NULL, "__clone method called on non-object");
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} while (0);

	zobj = Z_OBJ_P(obj);
	ce = zobj->ce;
	clone = ce->clone;
	clone_call = zobj->handlers->clone_obj;
	if (UNEXPECTED(clone_call == NULL)) {
		zend_throw_error(NULL, "Trying to clone an uncloneable object of class %s", ZSTR_VAL(ce->name));
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}

	if (clone && !(clone->common.fn_flags & ZEND_ACC_PUBLIC)) {
		scope = EX(func)->op_array.scope;
		if (clone->common.scope != scope) {
			if (UNEXPECTED(clone->common.fn_flags & ZEND_ACC_PRIVATE)
			 || UNEXPECTED(!zend_check_protected(zend_get_function_root_class(clone), scope))) {
				zend_wrong_clone_call(clone, scope);
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		}
	}

	ZVAL_OBJ(EX_VAR(opline->result.var), clone_call(zobj));

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INCLUDE_OR_EVAL_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_op_array *new_op_array;
	zval *inc_filename;

	SAVE_OPLINE();
	inc_filename = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	new_op_array = zend_include_or_eval(inc_filename, opline->extended_value);
	if (UNEXPECTED(EG(exception) != NULL)) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		if (new_op_array != ZEND_FAKE_OP_ARRAY && new_op_array != NULL) {
			destroy_op_array(new_op_array);
			efree_size(new_op_array, sizeof(zend_op_array));
		}
		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	} else if (new_op_array == ZEND_FAKE_OP_ARRAY) {
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_TRUE(EX_VAR(opline->result.var));
		}
	} else if (EXPECTED(new_op_array != NULL)) {
		zval *return_value = NULL;
		zend_execute_data *call;

		if (RETURN_VALUE_USED(opline)) {
			return_value = EX_VAR(opline->result.var);
		}

		new_op_array->scope = EX(func)->op_array.scope;

		call = zend_vm_stack_push_call_frame(
		    (Z_TYPE_INFO(EX(This)) & ZEND_CALL_HAS_THIS) | ZEND_CALL_NESTED_CODE | ZEND_CALL_HAS_SYMBOL_TABLE,
			(zend_function*)new_op_array, 0,
			Z_PTR(EX(This)));

		if (EX_CALL_INFO() & ZEND_CALL_HAS_SYMBOL_TABLE) {
			call->symbol_table = EX(symbol_table);
		} else {
			call->symbol_table = zend_rebuild_symbol_table();
		}

		call->prev_execute_data = execute_data;
		i_init_code_execute_data(call, new_op_array, return_value);

		if (EXPECTED(zend_execute_ex == execute_ex)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			ZEND_VM_ENTER();
		} else {
			ZEND_ADD_CALL_FLAG(call, ZEND_CALL_TOP);
			zend_execute_ex(call);
			zend_vm_stack_free_call_frame(call);
		}

		destroy_op_array(new_op_array);
		efree_size(new_op_array, sizeof(zend_op_array));
		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_rethrow_exception(execute_data);
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			UNDEF_RESULT();
			HANDLE_EXCEPTION();
		}
	} else if (RETURN_VALUE_USED(opline)) {
		ZVAL_FALSE(EX_VAR(opline->result.var));
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_YIELD_FROM_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);
	zval *val;

	SAVE_OPLINE();
	val = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (UNEXPECTED(generator->flags & ZEND_GENERATOR_FORCED_CLOSE)) {
		zend_throw_error(NULL, "Cannot use \"yield from\" in a force-closed generator");
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

yield_from_try_again:
	if (Z_TYPE_P(val) == IS_ARRAY) {
		ZVAL_COPY_VALUE(&generator->values, val);
		if (Z_OPT_REFCOUNTED_P(val)) {
			Z_ADDREF_P(val);
		}
		Z_FE_POS(generator->values) = 0;
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && Z_TYPE_P(val) == IS_OBJECT && Z_OBJCE_P(val)->get_iterator) {
		zend_class_entry *ce = Z_OBJCE_P(val);
		if (ce == zend_ce_generator) {
			zend_generator *new_gen = (zend_generator *) Z_OBJ_P(val);

			Z_ADDREF_P(val);
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

			if (UNEXPECTED(new_gen->execute_data == NULL)) {
				zend_throw_error(NULL, "Generator passed to yield from was aborted without proper return and is unable to continue");
				zval_ptr_dtor(val);
				UNDEF_RESULT();
				HANDLE_EXCEPTION();
			} else if (Z_ISUNDEF(new_gen->retval)) {
				if (UNEXPECTED(zend_generator_get_current(new_gen) == generator)) {
					zend_throw_error(NULL, "Impossible to yield from the Generator being currently run");
					zval_ptr_dtor(val);
					UNDEF_RESULT();
					HANDLE_EXCEPTION();
				} else {
					zend_generator_yield_from(generator, new_gen);
				}
			} else {
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), &new_gen->retval);
				}
				ZEND_VM_NEXT_OPCODE();
			}
		} else {
			zend_object_iterator *iter = ce->get_iterator(ce, val, 0);
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

			if (UNEXPECTED(!iter) || UNEXPECTED(EG(exception))) {
				if (!EG(exception)) {
					zend_throw_error(NULL, "Object of type %s did not create an Iterator", ZSTR_VAL(ce->name));
				}
				UNDEF_RESULT();
				HANDLE_EXCEPTION();
			}

			iter->index = 0;
			if (iter->funcs->rewind) {
				iter->funcs->rewind(iter);
				if (UNEXPECTED(EG(exception) != NULL)) {
					OBJ_RELEASE(&iter->std);
					UNDEF_RESULT();
					HANDLE_EXCEPTION();
				}
			}

			ZVAL_OBJ(&generator->values, &iter->std);
		}
	} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && Z_TYPE_P(val) == IS_REFERENCE) {
		val = Z_REFVAL_P(val);
		goto yield_from_try_again;
	} else {
		zend_throw_error(NULL, "Can use \"yield from\" only with arrays and Traversables");
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

	/* This is the default return value
	 * when the expression is a Generator, it will be overwritten in zend_generator_resume() */
	if (RETURN_VALUE_USED(opline)) {
		ZVAL_NULL(EX_VAR(opline->result.var));
	}

	/* This generator has no send target (though the generator we delegate to might have one) */
	generator->send_target = NULL;

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_STRLEN_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (EXPECTED(Z_TYPE_P(value) == IS_STRING)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_STRLEN_P(value));
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_bool strict;

		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && Z_TYPE_P(value) == IS_REFERENCE) {
			value = Z_REFVAL_P(value);
			if (EXPECTED(Z_TYPE_P(value) == IS_STRING)) {
				ZVAL_LONG(EX_VAR(opline->result.var), Z_STRLEN_P(value));
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				ZEND_VM_NEXT_OPCODE();
			}
		}

		SAVE_OPLINE();
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(value) == IS_UNDEF)) {
			value = ZVAL_UNDEFINED_OP1();
		}
		strict = EX_USES_STRICT_TYPES();
		do {
			if (EXPECTED(!strict)) {
				zend_string *str;
				zval tmp;

				ZVAL_COPY(&tmp, value);
				if (zend_parse_arg_str_weak(&tmp, &str)) {
					ZVAL_LONG(EX_VAR(opline->result.var), ZSTR_LEN(str));
					zval_ptr_dtor(&tmp);
					break;
				}
				zval_ptr_dtor(&tmp);
			}
			if (!EG(exception)) {
				zend_type_error("strlen(): Argument #1 ($str) must be of type string, %s given", zend_zval_type_name(value));
			}
			ZVAL_UNDEF(EX_VAR(opline->result.var));
		} while (0);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_TYPE_CHECK_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	int result = 0;

	value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if ((opline->extended_value >> (uint32_t)Z_TYPE_P(value)) & 1) {
type_check_resource:
		if (opline->extended_value != MAY_BE_RESOURCE
		 || EXPECTED(NULL != zend_rsrc_list_get_rsrc_type(Z_RES_P(value)))) {
			result = 1;
		}
	} else if (((IS_TMP_VAR|IS_VAR) & (IS_CV|IS_VAR)) && Z_ISREF_P(value)) {
		value = Z_REFVAL_P(value);
		if ((opline->extended_value >> (uint32_t)Z_TYPE_P(value)) & 1) {
			goto type_check_resource;
		}
	} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(value) == IS_UNDEF)) {
		result = ((1 << IS_NULL) & opline->extended_value) != 0;
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		if (UNEXPECTED(EG(exception))) {
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		}
	}
	if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
		SAVE_OPLINE();
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		ZEND_VM_SMART_BRANCH(result, 1);
	} else {
		ZEND_VM_SMART_BRANCH(result, 0);
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_CLASS_NAME_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	uint32_t fetch_type;
	zend_class_entry *called_scope, *scope;
	USE_OPLINE

	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval *op = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		SAVE_OPLINE();
		if (UNEXPECTED(Z_TYPE_P(op) != IS_OBJECT)) {
			ZVAL_DEREF(op);
			if (Z_TYPE_P(op) != IS_OBJECT) {
				zend_type_error("Cannot use \"::class\" on value of type %s", zend_zval_type_name(op));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				HANDLE_EXCEPTION();
			}
		}

		ZVAL_STR_COPY(EX_VAR(opline->result.var), Z_OBJCE_P(op)->name);
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	fetch_type = opline->op1.num;
	scope = EX(func)->op_array.scope;
	if (UNEXPECTED(scope == NULL)) {
		SAVE_OPLINE();
		zend_throw_error(NULL, "Cannot use \"%s\" in the global scope",
			fetch_type == ZEND_FETCH_CLASS_SELF ? "self" :
			fetch_type == ZEND_FETCH_CLASS_PARENT ? "parent" : "static");
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}

	switch (fetch_type) {
		case ZEND_FETCH_CLASS_SELF:
			ZVAL_STR_COPY(EX_VAR(opline->result.var), scope->name);
			break;
		case ZEND_FETCH_CLASS_PARENT:
			if (UNEXPECTED(scope->parent == NULL)) {
				SAVE_OPLINE();
				zend_throw_error(NULL,
					"Cannot use \"parent\" when current class scope has no parent");
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
			ZVAL_STR_COPY(EX_VAR(opline->result.var), scope->parent->name);
			break;
		case ZEND_FETCH_CLASS_STATIC:
			if (Z_TYPE(EX(This)) == IS_OBJECT) {
				called_scope = Z_OBJCE(EX(This));
			} else {
				called_scope = Z_CE(EX(This));
			}
			ZVAL_STR_COPY(EX_VAR(opline->result.var), called_scope->name);
			break;
		EMPTY_SWITCH_DEFAULT_CASE()
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DIV_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	fast_div_function(EX_VAR(opline->result.var), op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POW_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	pow_function(EX_VAR(opline->result.var), op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);

	if (((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
	    (IS_CONST == IS_CONST || EXPECTED(Z_TYPE_P(op2) == IS_STRING))) {
		zend_string *op1_str = Z_STR_P(op1);
		zend_string *op2_str = Z_STR_P(op2);
		zend_string *str;

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if (IS_CONST == IS_CONST || IS_CONST == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
		} else if (IS_CONST != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && (IS_TMP_VAR|IS_VAR) != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
		    size_t len = ZSTR_LEN(op1_str);

			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else {
			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		}
		ZEND_VM_NEXT_OPCODE();
	} else {
		SAVE_OPLINE();

		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
			op1 = ZVAL_UNDEFINED_OP1();
		}
		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
			op2 = ZVAL_UNDEFINED_OP2();
		}
		concat_function(EX_VAR(opline->result.var), op1, op2);
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) == Z_LVAL_P(op2))) {
is_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) == Z_LVAL_P(op2))) {
is_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) == Z_LVAL_P(op2))) {
is_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) != Z_LVAL_P(op2))) {
is_not_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_not_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_not_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) != Z_LVAL_P(op2))) {
is_not_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_not_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_not_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) != Z_LVAL_P(op2))) {
is_not_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_not_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_not_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SPACESHIP_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	compare_function(EX_VAR(opline->result.var), op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BOOL_XOR_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	boolean_xor_function(EX_VAR(opline->result.var), op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_R_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	dim = RT_CONSTANT(opline, opline->op2);
	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_array:
			value = zend_fetch_dimension_address_inner(Z_ARRVAL_P(container), dim, IS_CONST, BP_VAR_R EXECUTE_DATA_CC);
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		} else if (EXPECTED(Z_TYPE_P(container) == IS_REFERENCE)) {
			container = Z_REFVAL_P(container);
			if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				goto fetch_dim_r_array;
			} else {
				goto fetch_dim_r_slow;
			}
		} else {
fetch_dim_r_slow:
			if (IS_CONST == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
		}
	} else {
		zend_fetch_dimension_address_read_R(container, dim, IS_CONST OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_IS_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	zend_fetch_dimension_address_read_IS(container, RT_CONSTANT(opline, opline->op2), IS_CONST OPLINE_CC EXECUTE_DATA_CC);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_R_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = RT_CONSTANT(opline, opline->op2);

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST ||
	    ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
	    do {
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			zend_wrong_property_read(container, offset);
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if (IS_CONST == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value & ~ZEND_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
		} else {
			if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));

		if (IS_CONST != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = RT_CONSTANT(opline, opline->op2);

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST ||
	    ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		do {
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if (IS_CONST == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if (IS_CONST != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_string *op1_str, *op2_str, *str;


	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
	    (IS_CONST == IS_CONST || EXPECTED(Z_TYPE_P(op2) == IS_STRING))) {
		zend_string *op1_str = Z_STR_P(op1);
		zend_string *op2_str = Z_STR_P(op2);
		zend_string *str;

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if (IS_CONST == IS_CONST || IS_CONST == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
		} else if (IS_CONST != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && (IS_TMP_VAR|IS_VAR) != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
		    size_t len = ZSTR_LEN(op1_str);

			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else {
			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		op1_str = Z_STR_P(op1);
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		op1_str = zend_string_copy(Z_STR_P(op1));
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		op1_str = zval_get_string_func(op1);
	}
	if (IS_CONST == IS_CONST) {
		op2_str = Z_STR_P(op2);
	} else if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
		op2_str = zend_string_copy(Z_STR_P(op2));
	} else {
		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP2();
		}
		op2_str = zval_get_string_func(op2);
	}
	do {
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(Z_REFCOUNTED_P(op2))) {
						GC_ADDREF(op2_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
				zend_string_release_ex(op1_str, 0);
				break;
			}
		}
		if (IS_CONST != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					if (UNEXPECTED(Z_REFCOUNTED_P(op1))) {
						GC_ADDREF(op1_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
				zend_string_release_ex(op2_str, 0);
				break;
			}
		}
		str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
		memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
		memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
		ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_string_release_ex(op1_str, 0);
		}
		if (IS_CONST != IS_CONST) {
			zend_string_release_ex(op2_str, 0);
		}
	} while (0);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	zend_function *fbc;
	zend_class_entry *called_scope;
	zend_object *obj;
	zend_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (IS_CONST != IS_CONST) {
		function_name = RT_CONSTANT(opline, opline->op2);
	}

	if (IS_CONST != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		do {
			if ((IS_CONST & (IS_VAR|IS_CV)) && Z_ISREF_P(function_name)) {
				function_name = Z_REFVAL_P(function_name);
				if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {
					zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
					HANDLE_EXCEPTION();
				}
			}
			zend_throw_error(NULL, "Method name must be a string");

			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		} while (0);
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
		obj = Z_OBJ_P(object);
	} else {
		do {
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST && EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
				obj = Z_OBJ_P(object);
			} else {
				if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(object))) {
					zend_reference *ref = Z_REF_P(object);

					object = &ref->val;
					if (EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
						obj = Z_OBJ_P(object);
						if ((IS_TMP_VAR|IS_VAR) & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(zend_reference));
							} else {
								Z_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if (IS_CONST != IS_CONST) {

						}
						HANDLE_EXCEPTION();
					}
				}
				if (IS_CONST == IS_CONST) {
					function_name = RT_CONSTANT(opline, opline->op2);
				}
				zend_invalid_method_call(object, function_name);

				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if (IS_CONST == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
	    fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
	    zend_object *orig_obj = obj;

		if (IS_CONST == IS_CONST) {
			function_name = RT_CONSTANT(opline, opline->op2);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, Z_STR_P(function_name), ((IS_CONST == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(obj->ce, Z_STR_P(function_name));
			}

			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if (IS_CONST == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (IS_CONST != IS_CONST) {

	}

	call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_STATIC) != 0)) {
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			zend_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (zend_object*)called_scope;
		call_info = ZEND_CALL_NESTED_FUNCTION;
	} else if ((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS | ZEND_CALL_RELEASE_THIS;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAL_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;

	if (IS_CONST == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
	}

	value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	ZVAL_COPY_VALUE(arg, value);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		if (UNEXPECTED(Z_OPT_REFCOUNTED_P(arg))) {
			Z_ADDREF_P(arg);
		}
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CASE_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) == Z_LVAL_P(op2))) {
case_true:
				ZEND_VM_SMART_BRANCH_TRUE();
			} else {
case_false:
				ZEND_VM_SMART_BRANCH_FALSE();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto case_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
case_double:
			if (d1 == d2) {
				goto case_true;
			} else {
				goto case_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto case_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));

			if (result) {
				goto case_true;
			} else {
				goto case_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_case_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	bool result;
	zend_ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = RT_CONSTANT(opline, opline->op2);

	if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
		HashTable *ht;
		zval *value;
		zend_string *str;

isset_dim_obj_array:
		ht = Z_ARRVAL_P(container);
isset_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if (IS_CONST != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index_prop;
				}
			}
			value = zend_hash_find_ex_ind(ht, str, IS_CONST == IS_CONST);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index_prop:
			value = zend_hash_index_find(ht, hval);
		} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(offset))) {
			offset = Z_REFVAL_P(offset);
			goto isset_again;
		} else {
			value = zend_find_array_dim_slow(ht, offset EXECUTE_DATA_CC);
			if (UNEXPECTED(EG(exception))) {
				result = 0;
				goto isset_dim_obj_exit;
			}
		}

		if (!(opline->extended_value & ZEND_ISEMPTY)) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = value != NULL && Z_TYPE_P(value) > IS_NULL &&
			    (!Z_ISREF_P(value) || Z_TYPE_P(Z_REFVAL_P(value)) != IS_NULL);

			if ((IS_TMP_VAR|IS_VAR) & (IS_CONST|IS_CV)) {
				/* avoid exception check */

				ZEND_VM_SMART_BRANCH(result, 0);
			}
		} else {
			result = (value == NULL || !i_zend_is_true(value));
		}
		goto isset_dim_obj_exit;
	} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(container))) {
		container = Z_REFVAL_P(container);
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
			goto isset_dim_obj_array;
		}
	}

	if (IS_CONST == IS_CONST && Z_EXTRA_P(offset) == ZEND_EXTRA_VALUE) {
		offset++;
	}
	if (!(opline->extended_value & ZEND_ISEMPTY)) {
		result = zend_isset_dim_slow(container, offset EXECUTE_DATA_CC);
	} else {
		result = zend_isempty_dim_slow(container, offset EXECUTE_DATA_CC);
	}

isset_dim_obj_exit:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = RT_CONSTANT(opline, opline->op2);

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST ||
	    ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
			container = Z_REFVAL_P(container);
			if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & ZEND_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & ZEND_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if (IS_CONST == IS_CONST) {
		name = Z_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & ZEND_ISEMPTY) ^
		Z_OBJ_HT_P(container)->has_property(Z_OBJ_P(container), name, (opline->extended_value & ZEND_ISEMPTY), ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_ISEMPTY) : NULL));

	if (IS_CONST != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

isset_object_finish:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *key, *subject;
	HashTable *ht;
	zend_bool result;

	SAVE_OPLINE();

	key = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	subject = RT_CONSTANT(opline, opline->op2);

	if (EXPECTED(Z_TYPE_P(subject) == IS_ARRAY)) {
array_key_exists_array:
		ht = Z_ARRVAL_P(subject);
		result = zend_array_key_exists_fast(ht, key OPLINE_CC EXECUTE_DATA_CC);
	} else {
		if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(subject))) {
			subject = Z_REFVAL_P(subject);
			if (EXPECTED(Z_TYPE_P(subject) == IS_ARRAY)) {
				goto array_key_exists_array;
			}
		}
		zend_array_key_exists_error(subject, key OPLINE_CC EXECUTE_DATA_CC);
		result = 0;
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|UNUSED|CV, ANY) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INSTANCEOF_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr;
	zend_bool result;

	SAVE_OPLINE();
	expr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

try_instanceof:
	if (Z_TYPE_P(expr) == IS_OBJECT) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			ce = CACHED_PTR(opline->extended_value);
			if (UNEXPECTED(ce == NULL)) {
				ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op2)), Z_STR_P(RT_CONSTANT(opline, opline->op2) + 1), ZEND_FETCH_CLASS_NO_AUTOLOAD);
				if (EXPECTED(ce)) {
					CACHE_PTR(opline->extended_value, ce);
				}
			}
		} else if (IS_CONST == IS_UNUSED) {
			ce = zend_fetch_class(NULL, opline->op2.num);
			if (UNEXPECTED(ce == NULL)) {
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		result = ce && instanceof_function(Z_OBJCE_P(expr), ce);
	} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && Z_TYPE_P(expr) == IS_REFERENCE) {
		expr = Z_REFVAL_P(expr);
		goto try_instanceof;
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(expr) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		result = 0;
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;
	zend_long offset;
	HashTable *ht;

	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	dim = RT_CONSTANT(opline, opline->op2);
	if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_index_array:
		if (EXPECTED(Z_TYPE_P(dim) == IS_LONG)) {
			offset = Z_LVAL_P(dim);
		} else {
			offset = zval_get_long(dim);
		}
		ht = Z_ARRVAL_P(container);
		ZEND_HASH_INDEX_FIND(ht, offset, value, fetch_dim_r_index_undef);
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
			SAVE_OPLINE();
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			ZEND_VM_NEXT_OPCODE();
		}
	} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && EXPECTED(Z_TYPE_P(container) == IS_REFERENCE)) {
		container = Z_REFVAL_P(container);
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
			goto fetch_dim_r_index_array;
		} else {
			goto fetch_dim_r_index_slow;
		}
	} else {
fetch_dim_r_index_slow:
		SAVE_OPLINE();
		if (IS_CONST == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
			dim++;
		}
		zend_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

fetch_dim_r_index_undef:
	ZVAL_NULL(EX_VAR(opline->result.var));
	SAVE_OPLINE();
	zend_undefined_offset(offset);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;
	zend_long offset;
	HashTable *ht;

	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	dim = EX_VAR(opline->op2.var);
	if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_index_array:
		if (EXPECTED(Z_TYPE_P(dim) == IS_LONG)) {
			offset = Z_LVAL_P(dim);
		} else {
			offset = zval_get_long(dim);
		}
		ht = Z_ARRVAL_P(container);
		ZEND_HASH_INDEX_FIND(ht, offset, value, fetch_dim_r_index_undef);
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
			SAVE_OPLINE();
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			ZEND_VM_NEXT_OPCODE();
		}
	} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && EXPECTED(Z_TYPE_P(container) == IS_REFERENCE)) {
		container = Z_REFVAL_P(container);
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
			goto fetch_dim_r_index_array;
		} else {
			goto fetch_dim_r_index_slow;
		}
	} else {
fetch_dim_r_index_slow:
		SAVE_OPLINE();
		if ((IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
			dim++;
		}
		zend_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

fetch_dim_r_index_undef:
	ZVAL_NULL(EX_VAR(opline->result.var));
	SAVE_OPLINE();
	zend_undefined_offset(offset);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DIV_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	fast_div_function(EX_VAR(opline->result.var), op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POW_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	pow_function(EX_VAR(opline->result.var), op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
	    ((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(Z_TYPE_P(op2) == IS_STRING))) {
		zend_string *op1_str = Z_STR_P(op1);
		zend_string *op2_str = Z_STR_P(op2);
		zend_string *str;

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && (IS_TMP_VAR|IS_VAR) != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
		    size_t len = ZSTR_LEN(op1_str);

			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else {
			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		}
		ZEND_VM_NEXT_OPCODE();
	} else {
		SAVE_OPLINE();

		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
			op1 = ZVAL_UNDEFINED_OP1();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
			op2 = ZVAL_UNDEFINED_OP2();
		}
		concat_function(EX_VAR(opline->result.var), op1, op2);
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) == Z_LVAL_P(op2))) {
is_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) == Z_LVAL_P(op2))) {
is_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) == Z_LVAL_P(op2))) {
is_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) != Z_LVAL_P(op2))) {
is_not_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_not_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_not_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) != Z_LVAL_P(op2))) {
is_not_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_not_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_not_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) != Z_LVAL_P(op2))) {
is_not_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_not_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_not_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SPACESHIP_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	compare_function(EX_VAR(opline->result.var), op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BOOL_XOR_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	boolean_xor_function(EX_VAR(opline->result.var), op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_array:
			value = zend_fetch_dimension_address_inner(Z_ARRVAL_P(container), dim, (IS_TMP_VAR|IS_VAR), BP_VAR_R EXECUTE_DATA_CC);
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		} else if (EXPECTED(Z_TYPE_P(container) == IS_REFERENCE)) {
			container = Z_REFVAL_P(container);
			if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				goto fetch_dim_r_array;
			} else {
				goto fetch_dim_r_slow;
			}
		} else {
fetch_dim_r_slow:
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
		}
	} else {
		zend_fetch_dimension_address_read_R(container, dim, (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	zend_fetch_dimension_address_read_IS(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST ||
	    ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
	    do {
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			zend_wrong_property_read(container, offset);
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value & ~ZEND_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
		} else {
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST ||
	    ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		do {
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_string *op1_str, *op2_str, *str;


	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
	    ((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(Z_TYPE_P(op2) == IS_STRING))) {
		zend_string *op1_str = Z_STR_P(op1);
		zend_string *op2_str = Z_STR_P(op2);
		zend_string *str;

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && (IS_TMP_VAR|IS_VAR) != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
		    size_t len = ZSTR_LEN(op1_str);

			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else {
			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		op1_str = Z_STR_P(op1);
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		op1_str = zend_string_copy(Z_STR_P(op1));
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		op1_str = zval_get_string_func(op1);
	}
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		op2_str = Z_STR_P(op2);
	} else if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
		op2_str = zend_string_copy(Z_STR_P(op2));
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP2();
		}
		op2_str = zval_get_string_func(op2);
	}
	do {
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					if (UNEXPECTED(Z_REFCOUNTED_P(op2))) {
						GC_ADDREF(op2_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
				zend_string_release_ex(op1_str, 0);
				break;
			}
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					if (UNEXPECTED(Z_REFCOUNTED_P(op1))) {
						GC_ADDREF(op1_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
				zend_string_release_ex(op2_str, 0);
				break;
			}
		}
		str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
		memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
		memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
		ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_string_release_ex(op1_str, 0);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_string_release_ex(op2_str, 0);
		}
	} while (0);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	zend_function *fbc;
	zend_class_entry *called_scope;
	zend_object *obj;
	zend_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		do {
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && Z_ISREF_P(function_name)) {
				function_name = Z_REFVAL_P(function_name);
				if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {
					zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
					HANDLE_EXCEPTION();
				}
			}
			zend_throw_error(NULL, "Method name must be a string");
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		} while (0);
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
		obj = Z_OBJ_P(object);
	} else {
		do {
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST && EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
				obj = Z_OBJ_P(object);
			} else {
				if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(object))) {
					zend_reference *ref = Z_REF_P(object);

					object = &ref->val;
					if (EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
						obj = Z_OBJ_P(object);
						if ((IS_TMP_VAR|IS_VAR) & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(zend_reference));
							} else {
								Z_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
							zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
						}
						HANDLE_EXCEPTION();
					}
				}
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				}
				zend_invalid_method_call(object, function_name);
				zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
	    fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
	    zend_object *orig_obj = obj;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, Z_STR_P(function_name), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(obj->ce, Z_STR_P(function_name));
			}
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}

	call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_STATIC) != 0)) {
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			zend_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (zend_object*)called_scope;
		call_info = ZEND_CALL_NESTED_FUNCTION;
	} else if ((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS | ZEND_CALL_RELEASE_THIS;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CASE_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) == Z_LVAL_P(op2))) {
case_true:
				ZEND_VM_SMART_BRANCH_TRUE();
			} else {
case_false:
				ZEND_VM_SMART_BRANCH_FALSE();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto case_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
case_double:
			if (d1 == d2) {
				goto case_true;
			} else {
				goto case_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto case_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			if (result) {
				goto case_true;
			} else {
				goto case_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_case_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	bool result;
	zend_ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
		HashTable *ht;
		zval *value;
		zend_string *str;

isset_dim_obj_array:
		ht = Z_ARRVAL_P(container);
isset_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index_prop;
				}
			}
			value = zend_hash_find_ex_ind(ht, str, (IS_TMP_VAR|IS_VAR) == IS_CONST);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index_prop:
			value = zend_hash_index_find(ht, hval);
		} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(offset))) {
			offset = Z_REFVAL_P(offset);
			goto isset_again;
		} else {
			value = zend_find_array_dim_slow(ht, offset EXECUTE_DATA_CC);
			if (UNEXPECTED(EG(exception))) {
				result = 0;
				goto isset_dim_obj_exit;
			}
		}

		if (!(opline->extended_value & ZEND_ISEMPTY)) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = value != NULL && Z_TYPE_P(value) > IS_NULL &&
			    (!Z_ISREF_P(value) || Z_TYPE_P(Z_REFVAL_P(value)) != IS_NULL);

			if ((IS_TMP_VAR|IS_VAR) & (IS_CONST|IS_CV)) {
				/* avoid exception check */
				zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
				ZEND_VM_SMART_BRANCH(result, 0);
			}
		} else {
			result = (value == NULL || !i_zend_is_true(value));
		}
		goto isset_dim_obj_exit;
	} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(container))) {
		container = Z_REFVAL_P(container);
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
			goto isset_dim_obj_array;
		}
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST && Z_EXTRA_P(offset) == ZEND_EXTRA_VALUE) {
		offset++;
	}
	if (!(opline->extended_value & ZEND_ISEMPTY)) {
		result = zend_isset_dim_slow(container, offset EXECUTE_DATA_CC);
	} else {
		result = zend_isempty_dim_slow(container, offset EXECUTE_DATA_CC);
	}

isset_dim_obj_exit:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST ||
	    ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
			container = Z_REFVAL_P(container);
			if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & ZEND_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & ZEND_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = Z_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & ZEND_ISEMPTY) ^
		Z_OBJ_HT_P(container)->has_property(Z_OBJ_P(container), name, (opline->extended_value & ZEND_ISEMPTY), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_ISEMPTY) : NULL));

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

isset_object_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *key, *subject;
	HashTable *ht;
	zend_bool result;

	SAVE_OPLINE();

	key = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	subject = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(subject) == IS_ARRAY)) {
array_key_exists_array:
		ht = Z_ARRVAL_P(subject);
		result = zend_array_key_exists_fast(ht, key OPLINE_CC EXECUTE_DATA_CC);
	} else {
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(subject))) {
			subject = Z_REFVAL_P(subject);
			if (EXPECTED(Z_TYPE_P(subject) == IS_ARRAY)) {
				goto array_key_exists_array;
			}
		}
		zend_array_key_exists_error(subject, key OPLINE_CC EXECUTE_DATA_CC);
		result = 0;
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|UNUSED|CV, ANY) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INSTANCEOF_SPEC_TMPVAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr;
	zend_bool result;

	SAVE_OPLINE();
	expr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

try_instanceof:
	if (Z_TYPE_P(expr) == IS_OBJECT) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			ce = CACHED_PTR(opline->extended_value);
			if (UNEXPECTED(ce == NULL)) {
				ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op2)), Z_STR_P(RT_CONSTANT(opline, opline->op2) + 1), ZEND_FETCH_CLASS_NO_AUTOLOAD);
				if (EXPECTED(ce)) {
					CACHE_PTR(opline->extended_value, ce);
				}
			}
		} else if (IS_VAR == IS_UNUSED) {
			ce = zend_fetch_class(NULL, opline->op2.num);
			if (UNEXPECTED(ce == NULL)) {
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		result = ce && instanceof_function(Z_OBJCE_P(expr), ce);
	} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && Z_TYPE_P(expr) == IS_REFERENCE) {
		expr = Z_REFVAL_P(expr);
		goto try_instanceof;
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(expr) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		result = 0;
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_TMPVAR_UNUSED(int type ZEND_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE
	zval *varname;
	zval *retval;
	zend_string *name, *tmp_name;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = Z_STR_P(varname);
	} else if (EXPECTED(Z_TYPE_P(varname) == IS_STRING)) {
		name = Z_STR_P(varname);
		tmp_name = NULL;
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(varname) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		name = zval_try_get_tmp_string(varname, &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		}
	}

	target_symbol_table = zend_get_target_symbol_table(opline->extended_value EXECUTE_DATA_CC);
	retval = zend_hash_find_ex(target_symbol_table, name, (IS_TMP_VAR|IS_VAR) == IS_CONST);
	if (retval == NULL) {
		if (UNEXPECTED(zend_string_equals(name, ZSTR_KNOWN(ZEND_STR_THIS)))) {
fetch_this:
			zend_fetch_this_var(type OPLINE_CC EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
				zend_tmp_string_release(tmp_name);
			}
			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
		if (type == BP_VAR_W) {
			retval = zend_hash_add_new(target_symbol_table, name, &EG(uninitialized_zval));
		} else if (type == BP_VAR_IS) {
			retval = &EG(uninitialized_zval);
		} else {
			zend_error(E_WARNING, "Undefined variable $%s", ZSTR_VAL(name));
			if (type == BP_VAR_RW) {
				retval = zend_hash_update(target_symbol_table, name, &EG(uninitialized_zval));
			} else {
				retval = &EG(uninitialized_zval);
			}
		}
	/* GLOBAL or $$name variable may be an INDIRECT pointer to CV */
	} else if (Z_TYPE_P(retval) == IS_INDIRECT) {
		retval = Z_INDIRECT_P(retval);
		if (Z_TYPE_P(retval) == IS_UNDEF) {
			if (UNEXPECTED(zend_string_equals(name, ZSTR_KNOWN(ZEND_STR_THIS)))) {
				goto fetch_this;
			}
			if (type == BP_VAR_W) {
				ZVAL_NULL(retval);
			} else if (type == BP_VAR_IS) {
				retval = &EG(uninitialized_zval);
			} else {
				zend_error(E_WARNING, "Undefined variable $%s", ZSTR_VAL(name));
				if (type == BP_VAR_RW) {
					ZVAL_NULL(retval);
				} else {
					retval = &EG(uninitialized_zval);
				}
			}
		}
	}

	if (!(opline->extended_value & ZEND_FETCH_GLOBAL_LOCK)) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

	ZEND_ASSERT(retval != NULL);
	if (type == BP_VAR_R || type == BP_VAR_IS) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
	} else {
		ZVAL_INDIRECT(EX_VAR(opline->result.var), retval);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_R_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_TAIL_CALL(zend_fetch_var_address_helper_SPEC_TMPVAR_UNUSED(BP_VAR_R ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_W_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_TAIL_CALL(zend_fetch_var_address_helper_SPEC_TMPVAR_UNUSED(BP_VAR_W ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_RW_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_TAIL_CALL(zend_fetch_var_address_helper_SPEC_TMPVAR_UNUSED(BP_VAR_RW ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_FUNC_ARG_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	int fetch_type =
		(UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) ?
			BP_VAR_W : BP_VAR_R;
	ZEND_VM_TAIL_CALL(zend_fetch_var_address_helper_SPEC_TMPVAR_UNUSED(fetch_type ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_UNSET_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_TAIL_CALL(zend_fetch_var_address_helper_SPEC_TMPVAR_UNUSED(BP_VAR_UNSET ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_IS_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_TAIL_CALL(zend_fetch_var_address_helper_SPEC_TMPVAR_UNUSED(BP_VAR_IS ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAL_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
	}

	value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	ZVAL_COPY_VALUE(arg, value);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		if (UNEXPECTED(Z_OPT_REFCOUNTED_P(arg))) {
			Z_ADDREF_P(arg);
		}
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_UNSET_VAR_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varname;
	zend_string *name, *tmp_name;
	HashTable *target_symbol_table;

	SAVE_OPLINE();

	varname = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = Z_STR_P(varname);
	} else if (EXPECTED(Z_TYPE_P(varname) == IS_STRING)) {
		name = Z_STR_P(varname);
		tmp_name = NULL;
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(varname) == IS_UNDEF)) {
			varname = ZVAL_UNDEFINED_OP1();
		}
		name = zval_try_get_tmp_string(varname, &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	}

	target_symbol_table = zend_get_target_symbol_table(opline->extended_value EXECUTE_DATA_CC);
	zend_hash_del_ind(target_symbol_table, name);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	/* Should be bool result? as below got: result = (opline->extended_value & ZEND_ISEMPTY) */
	int result;
	zval *varname;
	zend_string *name, *tmp_name;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = Z_STR_P(varname);
	} else {
		name = zval_get_tmp_string(varname, &tmp_name);
	}

	target_symbol_table = zend_get_target_symbol_table(opline->extended_value EXECUTE_DATA_CC);
	value = zend_hash_find_ex(target_symbol_table, name, (IS_TMP_VAR|IS_VAR) == IS_CONST);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	if (!value) {
		result = (opline->extended_value & ZEND_ISEMPTY);
	} else {
		if (Z_TYPE_P(value) == IS_INDIRECT) {
			value = Z_INDIRECT_P(value);
		}
		if (!(opline->extended_value & ZEND_ISEMPTY)) {
			if (Z_ISREF_P(value)) {
				value = Z_REFVAL_P(value);
			}
			result = Z_TYPE_P(value) > IS_NULL;
		} else {
			result = !i_zend_is_true(value);
		}
	}

	ZEND_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INSTANCEOF_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr;
	zend_bool result;

	SAVE_OPLINE();
	expr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

try_instanceof:
	if (Z_TYPE_P(expr) == IS_OBJECT) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			ce = CACHED_PTR(opline->extended_value);
			if (UNEXPECTED(ce == NULL)) {
				ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op2)), Z_STR_P(RT_CONSTANT(opline, opline->op2) + 1), ZEND_FETCH_CLASS_NO_AUTOLOAD);
				if (EXPECTED(ce)) {
					CACHE_PTR(opline->extended_value, ce);
				}
			}
		} else if (IS_UNUSED == IS_UNUSED) {
			ce = zend_fetch_class(NULL, opline->op2.num);
			if (UNEXPECTED(ce == NULL)) {
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		result = ce && instanceof_function(Z_OBJCE_P(expr), ce);
	} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && Z_TYPE_P(expr) == IS_REFERENCE) {
		expr = Z_REFVAL_P(expr);
		goto try_instanceof;
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(expr) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		result = 0;
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_COUNT_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;
	zend_long count;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	while (1) {
		if (Z_TYPE_P(op1) == IS_ARRAY) {
			count = zend_array_count(Z_ARRVAL_P(op1));
			break;
		} else if (Z_TYPE_P(op1) == IS_OBJECT) {
			zend_object *zobj = Z_OBJ_P(op1);

			/* first, we check if the handler is defined */
			if (zobj->handlers->count_elements) {
				if (SUCCESS == zobj->handlers->count_elements(zobj, &count)) {
					break;
				}
				if (UNEXPECTED(EG(exception))) {
					count = 0;
					break;
				}
			}

			/* if not and the object implements Countable we call its count() method */
			if (zend_class_implements_interface(zobj->ce, zend_ce_countable)) {
				zval retval;

				zend_call_method_with_0_params(zobj, NULL, NULL, "count", &retval);
				count = zval_get_long(&retval);
				zval_ptr_dtor(&retval);
				break;
			}

			/* If There's no handler and it doesn't implement Countable then emit a TypeError */
		} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) != 0 && Z_TYPE_P(op1) == IS_REFERENCE) {
			op1 = Z_REFVAL_P(op1);
			continue;
		} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		count = 0;
		zend_type_error("%s(): Argument #1 ($var) must be of type Countable|array, %s given", opline->extended_value ? "sizeof" : "count", zend_zval_type_name(op1));
		break;
	}

	ZVAL_LONG(EX_VAR(opline->result.var), count);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_GET_CLASS_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
		if (UNEXPECTED(!EX(func)->common.scope)) {
			SAVE_OPLINE();
			zend_throw_error(NULL, "get_class() without arguments must be called from within a class");
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		} else {
			ZVAL_STR_COPY(EX_VAR(opline->result.var), EX(func)->common.scope->name);
			ZEND_VM_NEXT_OPCODE();
		}
	} else {
		zval *op1;

		SAVE_OPLINE();
		op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		while (1) {
			if (Z_TYPE_P(op1) == IS_OBJECT) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), Z_OBJCE_P(op1)->name);
			} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) != 0 && Z_TYPE_P(op1) == IS_REFERENCE) {
				op1 = Z_REFVAL_P(op1);
				continue;
			} else {
				if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
					ZVAL_UNDEFINED_OP1();
				}
				zend_type_error("get_class(): Argument #1 ($object) must be of type object, %s given", zend_zval_type_name(op1));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
			}
			break;
		}
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_COPY_TMP_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	zval *result = EX_VAR(opline->result.var);
	ZVAL_COPY(result, value);
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DIV_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	fast_div_function(EX_VAR(opline->result.var), op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POW_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	pow_function(EX_VAR(opline->result.var), op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = EX_VAR(opline->op2.var);

	if (((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
	    (IS_CV == IS_CONST || EXPECTED(Z_TYPE_P(op2) == IS_STRING))) {
		zend_string *op1_str = Z_STR_P(op1);
		zend_string *op2_str = Z_STR_P(op2);
		zend_string *str;

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
		} else if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && (IS_TMP_VAR|IS_VAR) != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
		    size_t len = ZSTR_LEN(op1_str);

			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else {
			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		}
		ZEND_VM_NEXT_OPCODE();
	} else {
		SAVE_OPLINE();

		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
			op1 = ZVAL_UNDEFINED_OP1();
		}
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
			op2 = ZVAL_UNDEFINED_OP2();
		}
		concat_function(EX_VAR(opline->result.var), op1, op2);
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SPACESHIP_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	compare_function(EX_VAR(opline->result.var), op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_R_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	dim = EX_VAR(opline->op2.var);
	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_array:
			value = zend_fetch_dimension_address_inner(Z_ARRVAL_P(container), dim, IS_CV, BP_VAR_R EXECUTE_DATA_CC);
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		} else if (EXPECTED(Z_TYPE_P(container) == IS_REFERENCE)) {
			container = Z_REFVAL_P(container);
			if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				goto fetch_dim_r_array;
			} else {
				goto fetch_dim_r_slow;
			}
		} else {
fetch_dim_r_slow:
			if (IS_CV == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
		}
	} else {
		zend_fetch_dimension_address_read_R(container, dim, IS_CV OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_IS_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	zend_fetch_dimension_address_read_IS(container, EX_VAR(opline->op2.var), IS_CV OPLINE_CC EXECUTE_DATA_CC);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_R_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = EX_VAR(opline->op2.var);

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST ||
	    ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
	    do {
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			zend_wrong_property_read(container, offset);
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if (IS_CV == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value & ~ZEND_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
		} else {
			if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));

		if (IS_CV != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST ||
	    ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		do {
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if (IS_CV == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if (IS_CV != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_string *op1_str, *op2_str, *str;


	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = EX_VAR(opline->op2.var);
	if (((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
	    (IS_CV == IS_CONST || EXPECTED(Z_TYPE_P(op2) == IS_STRING))) {
		zend_string *op1_str = Z_STR_P(op1);
		zend_string *op2_str = Z_STR_P(op2);
		zend_string *str;

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
		} else if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && (IS_TMP_VAR|IS_VAR) != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
		    size_t len = ZSTR_LEN(op1_str);

			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else {
			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		op1_str = Z_STR_P(op1);
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		op1_str = zend_string_copy(Z_STR_P(op1));
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		op1_str = zval_get_string_func(op1);
	}
	if (IS_CV == IS_CONST) {
		op2_str = Z_STR_P(op2);
	} else if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
		op2_str = zend_string_copy(Z_STR_P(op2));
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP2();
		}
		op2_str = zval_get_string_func(op2);
	}
	do {
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(Z_REFCOUNTED_P(op2))) {
						GC_ADDREF(op2_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
				zend_string_release_ex(op1_str, 0);
				break;
			}
		}
		if (IS_CV != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					if (UNEXPECTED(Z_REFCOUNTED_P(op1))) {
						GC_ADDREF(op1_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
				zend_string_release_ex(op2_str, 0);
				break;
			}
		}
		str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
		memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
		memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
		ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_string_release_ex(op1_str, 0);
		}
		if (IS_CV != IS_CONST) {
			zend_string_release_ex(op2_str, 0);
		}
	} while (0);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	zend_function *fbc;
	zend_class_entry *called_scope;
	zend_object *obj;
	zend_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (IS_CV != IS_CONST) {
		function_name = EX_VAR(opline->op2.var);
	}

	if (IS_CV != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		do {
			if ((IS_CV & (IS_VAR|IS_CV)) && Z_ISREF_P(function_name)) {
				function_name = Z_REFVAL_P(function_name);
				if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {
					zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
					HANDLE_EXCEPTION();
				}
			}
			zend_throw_error(NULL, "Method name must be a string");

			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		} while (0);
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
		obj = Z_OBJ_P(object);
	} else {
		do {
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST && EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
				obj = Z_OBJ_P(object);
			} else {
				if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(object))) {
					zend_reference *ref = Z_REF_P(object);

					object = &ref->val;
					if (EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
						obj = Z_OBJ_P(object);
						if ((IS_TMP_VAR|IS_VAR) & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(zend_reference));
							} else {
								Z_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if (IS_CV != IS_CONST) {

						}
						HANDLE_EXCEPTION();
					}
				}
				if (IS_CV == IS_CONST) {
					function_name = EX_VAR(opline->op2.var);
				}
				zend_invalid_method_call(object, function_name);

				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if (IS_CV == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
	    fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
	    zend_object *orig_obj = obj;

		if (IS_CV == IS_CONST) {
			function_name = EX_VAR(opline->op2.var);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, Z_STR_P(function_name), ((IS_CV == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(obj->ce, Z_STR_P(function_name));
			}

			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if (IS_CV == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (IS_CV != IS_CONST) {

	}

	call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_STATIC) != 0)) {
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			zend_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (zend_object*)called_scope;
		call_info = ZEND_CALL_NESTED_FUNCTION;
	} else if ((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS | ZEND_CALL_RELEASE_THIS;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CASE_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = EX_VAR(opline->op2.var);
	if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) == Z_LVAL_P(op2))) {
case_true:
				ZEND_VM_SMART_BRANCH_TRUE();
			} else {
case_false:
				ZEND_VM_SMART_BRANCH_FALSE();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto case_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
case_double:
			if (d1 == d2) {
				goto case_true;
			} else {
				goto case_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto case_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));

			if (result) {
				goto case_true;
			} else {
				goto case_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_case_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	bool result;
	zend_ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = EX_VAR(opline->op2.var);

	if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
		HashTable *ht;
		zval *value;
		zend_string *str;

isset_dim_obj_array:
		ht = Z_ARRVAL_P(container);
isset_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if (IS_CV != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index_prop;
				}
			}
			value = zend_hash_find_ex_ind(ht, str, IS_CV == IS_CONST);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index_prop:
			value = zend_hash_index_find(ht, hval);
		} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(offset))) {
			offset = Z_REFVAL_P(offset);
			goto isset_again;
		} else {
			value = zend_find_array_dim_slow(ht, offset EXECUTE_DATA_CC);
			if (UNEXPECTED(EG(exception))) {
				result = 0;
				goto isset_dim_obj_exit;
			}
		}

		if (!(opline->extended_value & ZEND_ISEMPTY)) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = value != NULL && Z_TYPE_P(value) > IS_NULL &&
			    (!Z_ISREF_P(value) || Z_TYPE_P(Z_REFVAL_P(value)) != IS_NULL);

			if ((IS_TMP_VAR|IS_VAR) & (IS_CONST|IS_CV)) {
				/* avoid exception check */

				ZEND_VM_SMART_BRANCH(result, 0);
			}
		} else {
			result = (value == NULL || !i_zend_is_true(value));
		}
		goto isset_dim_obj_exit;
	} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(container))) {
		container = Z_REFVAL_P(container);
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
			goto isset_dim_obj_array;
		}
	}

	if (IS_CV == IS_CONST && Z_EXTRA_P(offset) == ZEND_EXTRA_VALUE) {
		offset++;
	}
	if (!(opline->extended_value & ZEND_ISEMPTY)) {
		result = zend_isset_dim_slow(container, offset EXECUTE_DATA_CC);
	} else {
		result = zend_isempty_dim_slow(container, offset EXECUTE_DATA_CC);
	}

isset_dim_obj_exit:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST ||
	    ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
			container = Z_REFVAL_P(container);
			if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & ZEND_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & ZEND_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if (IS_CV == IS_CONST) {
		name = Z_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & ZEND_ISEMPTY) ^
		Z_OBJ_HT_P(container)->has_property(Z_OBJ_P(container), name, (opline->extended_value & ZEND_ISEMPTY), ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_ISEMPTY) : NULL));

	if (IS_CV != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

isset_object_finish:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *key, *subject;
	HashTable *ht;
	zend_bool result;

	SAVE_OPLINE();

	key = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	subject = EX_VAR(opline->op2.var);

	if (EXPECTED(Z_TYPE_P(subject) == IS_ARRAY)) {
array_key_exists_array:
		ht = Z_ARRVAL_P(subject);
		result = zend_array_key_exists_fast(ht, key OPLINE_CC EXECUTE_DATA_CC);
	} else {
		if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(subject))) {
			subject = Z_REFVAL_P(subject);
			if (EXPECTED(Z_TYPE_P(subject) == IS_ARRAY)) {
				goto array_key_exists_array;
			}
		}
		zend_array_key_exists_error(subject, key OPLINE_CC EXECUTE_DATA_CC);
		result = 0;
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|UNUSED|CV, ANY) */
static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_RETURN_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;

	retval_ptr = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	return_value = EX(return_value);
	if (IS_TMP_VAR == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(retval_ptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		retval_ptr = ZVAL_UNDEFINED_OP1();
		if (return_value) {
			ZVAL_NULL(return_value);
		}
	} else if (!return_value) {
		if (IS_TMP_VAR & (IS_VAR|IS_TMP_VAR)) {
			if (Z_REFCOUNTED_P(retval_ptr) && !Z_DELREF_P(retval_ptr)) {
				SAVE_OPLINE();
				rc_dtor_func(Z_COUNTED_P(retval_ptr));
			}
		}
	} else {
		if ((IS_TMP_VAR & (IS_CONST|IS_TMP_VAR))) {
			ZVAL_COPY_VALUE(return_value, retval_ptr);
			if (IS_TMP_VAR == IS_CONST) {
				if (UNEXPECTED(Z_OPT_REFCOUNTED_P(return_value))) {
					Z_ADDREF_P(return_value);
				}
			}
		} else if (IS_TMP_VAR == IS_CV) {
			do {
				if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
					if (EXPECTED(!Z_OPT_ISREF_P(retval_ptr))) {
						if (EXPECTED(!(EX_CALL_INFO() & ZEND_CALL_CODE))) {
							zend_refcounted *ref = Z_COUNTED_P(retval_ptr);
							ZVAL_COPY_VALUE(return_value, retval_ptr);
							if (GC_MAY_LEAK(ref)) {
								gc_possible_root(ref);
							}
							ZVAL_NULL(retval_ptr);
							break;
						} else {
							Z_ADDREF_P(retval_ptr);
						}
					} else {
						retval_ptr = Z_REFVAL_P(retval_ptr);
						if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
							Z_ADDREF_P(retval_ptr);
						}
					}
				}
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			} while (0);
		} else /* if (IS_TMP_VAR == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(retval_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(retval_ptr);

				retval_ptr = Z_REFVAL_P(retval_ptr);
				ZVAL_COPY_VALUE(return_value, retval_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
					Z_ADDREF_P(retval_ptr);
				}
			} else {
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			}
		}
	}

	ZEND_VM_TAIL_CALL(zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;

	SAVE_OPLINE();

	do {
		if ((IS_TMP_VAR & (IS_CONST|IS_TMP_VAR)) ||
		    (IS_TMP_VAR == IS_VAR && opline->extended_value == ZEND_RETURNS_VALUE)) {
			/* Not supposed to happen, but we'll allow it */
			zend_error(E_NOTICE, "Only variable references should be returned by reference");

			retval_ptr = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
			if (!EX(return_value)) {
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			} else {
				if (IS_TMP_VAR == IS_VAR && UNEXPECTED(Z_ISREF_P(retval_ptr))) {
					ZVAL_COPY_VALUE(EX(return_value), retval_ptr);
					break;
				}

				ZVAL_NEW_REF(EX(return_value), retval_ptr);
				if (IS_TMP_VAR == IS_CONST) {
					Z_TRY_ADDREF_P(retval_ptr);
				}
			}
			break;
		}

		retval_ptr = NULL;

		if (IS_TMP_VAR == IS_VAR) {
			ZEND_ASSERT(retval_ptr != &EG(uninitialized_zval));
			if (opline->extended_value == ZEND_RETURNS_FUNCTION && !Z_ISREF_P(retval_ptr)) {
				zend_error(E_NOTICE, "Only variable references should be returned by reference");
				if (EX(return_value)) {
					ZVAL_NEW_REF(EX(return_value), retval_ptr);
				} else {

				}
				break;
			}
		}

		if (EX(return_value)) {
			if (Z_ISREF_P(retval_ptr)) {
				Z_ADDREF_P(retval_ptr);
			} else {
				ZVAL_MAKE_REF_EX(retval_ptr, 2);
			}
			ZVAL_REF(EX(return_value), Z_REF_P(retval_ptr));
		}

	} while (0);

	ZEND_VM_TAIL_CALL(zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_GENERATOR_RETURN_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval;

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	retval = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);

	/* Copy return value into generator->retval */
	if ((IS_TMP_VAR & (IS_CONST|IS_TMP_VAR))) {
		ZVAL_COPY_VALUE(&generator->retval, retval);
		if (IS_TMP_VAR == IS_CONST) {
			if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->retval))) {
				Z_ADDREF(generator->retval);
			}
		}
	} else if (IS_TMP_VAR == IS_CV) {
		ZVAL_COPY_DEREF(&generator->retval, retval);
	} else /* if (IS_TMP_VAR == IS_VAR) */ {
		if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_refcounted *ref = Z_COUNTED_P(retval);

			retval = Z_REFVAL_P(retval);
			ZVAL_COPY_VALUE(&generator->retval, retval);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(retval)) {
				Z_ADDREF_P(retval);
			}
		} else {
			ZVAL_COPY_VALUE(&generator->retval, retval);
		}
	}

	/* Close the generator to free up resources */
	zend_generator_close(generator, 1);

	/* Pass execution back to handling code */
	ZEND_VM_RETURN();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_USER_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *arg, *param;

	SAVE_OPLINE();

	if (UNEXPECTED(ARG_MUST_BE_SENT_BY_REF(EX(call)->func, opline->op2.num))) {
		zend_param_must_be_ref(EX(call)->func, opline->op2.num);
	}

	arg = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	param = ZEND_CALL_VAR(EX(call), opline->result.var);
	ZVAL_COPY(param, arg);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CAST_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr;
	zval *result = EX_VAR(opline->result.var);
	HashTable *ht;

	SAVE_OPLINE();
	expr = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);

	switch (opline->extended_value) {
		case IS_LONG:
			ZVAL_LONG(result, zval_get_long(expr));
			break;
		case IS_DOUBLE:
			ZVAL_DOUBLE(result, zval_get_double(expr));
			break;
		case IS_STRING:
			ZVAL_STR(result, zval_get_string(expr));
			break;
		default:
			ZEND_ASSERT(opline->extended_value != _IS_BOOL && "Must use ZEND_BOOL instead");
			if (IS_TMP_VAR & (IS_VAR|IS_CV)) {
				ZVAL_DEREF(expr);
			}
			/* If value is already of correct type, return it directly */
			if (Z_TYPE_P(expr) == opline->extended_value) {
				ZVAL_COPY_VALUE(result, expr);
				if (IS_TMP_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(result))) Z_ADDREF_P(result);
				} else if (IS_TMP_VAR != IS_TMP_VAR) {
					if (Z_OPT_REFCOUNTED_P(result)) Z_ADDREF_P(result);
				}

				ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
			}

			if (opline->extended_value == IS_ARRAY) {
				if (IS_TMP_VAR == IS_CONST || Z_TYPE_P(expr) != IS_OBJECT || Z_OBJCE_P(expr) == zend_ce_closure) {
					if (Z_TYPE_P(expr) != IS_NULL) {
						ZVAL_ARR(result, zend_new_array(1));
						expr = zend_hash_index_add_new(Z_ARRVAL_P(result), 0, expr);
						if (IS_TMP_VAR == IS_CONST) {
							if (UNEXPECTED(Z_OPT_REFCOUNTED_P(expr))) Z_ADDREF_P(expr);
						} else {
							if (Z_OPT_REFCOUNTED_P(expr)) Z_ADDREF_P(expr);
						}
					} else {
						ZVAL_EMPTY_ARRAY(result);
					}
				} else {
					HashTable *obj_ht = zend_get_properties_for(expr, ZEND_PROP_PURPOSE_ARRAY_CAST);
					if (obj_ht) {
						/* fast copy */
						ZVAL_ARR(result, zend_proptable_to_symtable(obj_ht,
							(Z_OBJCE_P(expr)->default_properties_count ||
							 Z_OBJ_P(expr)->handlers != &std_object_handlers ||
							 GC_IS_RECURSIVE(obj_ht))));
						zend_release_properties(obj_ht);
					} else {
						ZVAL_EMPTY_ARRAY(result);
					}
				}
			} else {
				ZEND_ASSERT(opline->extended_value == IS_OBJECT);
				ZVAL_OBJ(result, zend_objects_new(zend_standard_class_def));
				if (Z_TYPE_P(expr) == IS_ARRAY) {
					ht = zend_symtable_to_proptable(Z_ARR_P(expr));
					if (GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) {
						/* TODO: try not to duplicate immutable arrays as well ??? */
						ht = zend_array_dup(ht);
					}
					Z_OBJ_P(result)->properties = ht;
				} else if (Z_TYPE_P(expr) != IS_NULL) {
					Z_OBJ_P(result)->properties = ht = zend_new_array(1);
					expr = zend_hash_add_new(ht, ZSTR_KNOWN(ZEND_STR_SCALAR), expr);
					if (IS_TMP_VAR == IS_CONST) {
						if (UNEXPECTED(Z_OPT_REFCOUNTED_P(expr))) Z_ADDREF_P(expr);
					} else {
						if (Z_OPT_REFCOUNTED_P(expr)) Z_ADDREF_P(expr);
					}
				}
			}
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FE_RESET_R_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array_ptr, *result;

	SAVE_OPLINE();

	array_ptr = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	if (EXPECTED(Z_TYPE_P(array_ptr) == IS_ARRAY)) {
		result = EX_VAR(opline->result.var);
		ZVAL_COPY_VALUE(result, array_ptr);
		if (IS_TMP_VAR != IS_TMP_VAR && Z_OPT_REFCOUNTED_P(result)) {
			Z_ADDREF_P(array_ptr);
		}
		Z_FE_POS_P(result) = 0;

		ZEND_VM_NEXT_OPCODE();
	} else if (IS_TMP_VAR != IS_CONST && EXPECTED(Z_TYPE_P(array_ptr) == IS_OBJECT)) {
		zend_object *zobj = Z_OBJ_P(array_ptr);
		if (!zobj->ce->get_iterator) {
			HashTable *properties;

			result = EX_VAR(opline->result.var);
			ZVAL_OBJ(result, zobj);
			if (IS_TMP_VAR != IS_TMP_VAR) {
				GC_ADDREF(zobj);
			}
			properties = zobj->properties;
			if (properties) {
				if (UNEXPECTED(GC_REFCOUNT(properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(properties);
					}
					properties = zobj->properties = zend_array_dup(properties);
				}
			} else {
				properties = zobj->handlers->get_properties(zobj);
			}
			Z_FE_ITER_P(EX_VAR(opline->result.var)) = zend_hash_iterator_add(properties, 0);

			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			zend_bool is_empty = zend_fe_reset_iterator(array_ptr, 0 OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			} else if (is_empty) {
				ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
			} else {
				ZEND_VM_NEXT_OPCODE();
			}
		}
	} else {
		zend_error(E_WARNING, "foreach() argument must be of type array|object, %s given", zend_zval_type_name(array_ptr));
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		Z_FE_ITER_P(EX_VAR(opline->result.var)) = (uint32_t)-1;
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		ZEND_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FE_RESET_RW_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array_ptr, *array_ref;

	SAVE_OPLINE();

	if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		array_ref = array_ptr = NULL;
		if (Z_ISREF_P(array_ref)) {
			array_ptr = Z_REFVAL_P(array_ref);
		}
	} else {
		array_ref = array_ptr = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	}

	if (EXPECTED(Z_TYPE_P(array_ptr) == IS_ARRAY)) {
		if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
			if (array_ptr == array_ref) {
				ZVAL_NEW_REF(array_ref, array_ref);
				array_ptr = Z_REFVAL_P(array_ref);
			}
			Z_ADDREF_P(array_ref);
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), array_ref);
		} else {
			array_ref = EX_VAR(opline->result.var);
			ZVAL_NEW_REF(array_ref, array_ptr);
			array_ptr = Z_REFVAL_P(array_ref);
		}
		if (IS_TMP_VAR == IS_CONST) {
			ZVAL_ARR(array_ptr, zend_array_dup(Z_ARRVAL_P(array_ptr)));
		} else {
			SEPARATE_ARRAY(array_ptr);
		}
		Z_FE_ITER_P(EX_VAR(opline->result.var)) = zend_hash_iterator_add(Z_ARRVAL_P(array_ptr), 0);

		if (IS_TMP_VAR == IS_VAR) {

		}
		ZEND_VM_NEXT_OPCODE();
	} else if (IS_TMP_VAR != IS_CONST && EXPECTED(Z_TYPE_P(array_ptr) == IS_OBJECT)) {
		if (!Z_OBJCE_P(array_ptr)->get_iterator) {
			if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
				if (array_ptr == array_ref) {
					ZVAL_NEW_REF(array_ref, array_ref);
					array_ptr = Z_REFVAL_P(array_ref);
				}
				Z_ADDREF_P(array_ref);
				ZVAL_COPY_VALUE(EX_VAR(opline->result.var), array_ref);
			} else {
				array_ptr = EX_VAR(opline->result.var);
				ZVAL_COPY_VALUE(array_ptr, array_ref);
			}
			if (Z_OBJ_P(array_ptr)->properties
			 && UNEXPECTED(GC_REFCOUNT(Z_OBJ_P(array_ptr)->properties) > 1)) {
				if (EXPECTED(!(GC_FLAGS(Z_OBJ_P(array_ptr)->properties) & IS_ARRAY_IMMUTABLE))) {
					GC_DELREF(Z_OBJ_P(array_ptr)->properties);
				}
				Z_OBJ_P(array_ptr)->properties = zend_array_dup(Z_OBJ_P(array_ptr)->properties);
			}
			Z_FE_ITER_P(EX_VAR(opline->result.var)) = zend_hash_iterator_add(Z_OBJPROP_P(array_ptr), 0);

			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			zend_bool is_empty = zend_fe_reset_iterator(array_ptr, 1 OPLINE_CC EXECUTE_DATA_CC);

			if (IS_TMP_VAR == IS_VAR) {

			} else {
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			}
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			} else if (is_empty) {
				ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
			} else {
				ZEND_VM_NEXT_OPCODE();
			}
		}
	} else {
		zend_error(E_WARNING, "foreach() argument must be of type array|object, %s given", zend_zval_type_name(array_ptr));
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		Z_FE_ITER_P(EX_VAR(opline->result.var)) = (uint32_t)-1;
		if (IS_TMP_VAR == IS_VAR) {

		} else {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		}
		ZEND_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_END_SILENCE_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (E_HAS_ONLY_FATAL_ERRORS(EG(error_reporting))
			&& !E_HAS_ONLY_FATAL_ERRORS(Z_LVAL_P(EX_VAR(opline->op1.var)))) {
		EG(error_reporting) = Z_LVAL_P(EX_VAR(opline->op1.var));
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMP_SET_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *ref = NULL;
	bool ret;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && Z_ISREF_P(value)) {
		if (IS_TMP_VAR == IS_VAR) {
			ref = value;
		}
		value = Z_REFVAL_P(value);
	}

	ret = i_zend_is_true(value);

	if (UNEXPECTED(EG(exception))) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}

	if (ret) {
		zval *result = EX_VAR(opline->result.var);

		ZVAL_COPY_VALUE(result, value);
		if (IS_TMP_VAR == IS_CONST) {
			if (UNEXPECTED(Z_OPT_REFCOUNTED_P(result))) Z_ADDREF_P(result);
		} else if (IS_TMP_VAR == IS_CV) {
			if (Z_OPT_REFCOUNTED_P(result)) Z_ADDREF_P(result);
		} else if (IS_TMP_VAR == IS_VAR && ref) {
			zend_reference *r = Z_REF_P(ref);

			if (UNEXPECTED(GC_DELREF(r) == 0)) {
				efree_size(r, sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(result)) {
				Z_ADDREF_P(result);
			}
		}
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_COALESCE_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *ref = NULL;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_TMP_VAR & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
		if (IS_TMP_VAR & IS_VAR) {
			ref = value;
		}
		value = Z_REFVAL_P(value);
	}

	if (Z_TYPE_P(value) > IS_NULL) {
		zval *result = EX_VAR(opline->result.var);
		ZVAL_COPY_VALUE(result, value);
		if (IS_TMP_VAR == IS_CONST) {
			if (UNEXPECTED(Z_OPT_REFCOUNTED_P(result))) Z_ADDREF_P(result);
		} else if (IS_TMP_VAR == IS_CV) {
			if (Z_OPT_REFCOUNTED_P(result)) Z_ADDREF_P(result);
		} else if ((IS_TMP_VAR & IS_VAR) && ref) {
			zend_reference *r = Z_REF_P(ref);

			if (UNEXPECTED(GC_DELREF(r) == 0)) {
				efree_size(r, sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(result)) {
				Z_ADDREF_P(result);
			}
		}
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_QM_ASSIGN_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *result = EX_VAR(opline->result.var);

	value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	if (IS_TMP_VAR == IS_CV && UNEXPECTED(Z_TYPE_P(value) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(result);
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_TMP_VAR == IS_CV) {
		ZVAL_COPY_DEREF(result, value);
	} else if (IS_TMP_VAR == IS_VAR) {
		if (UNEXPECTED(Z_ISREF_P(value))) {
			ZVAL_COPY_VALUE(result, Z_REFVAL_P(value));
			if (UNEXPECTED(Z_DELREF_P(value) == 0)) {
				efree_size(Z_REF_P(value), sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(result)) {
				Z_ADDREF_P(result);
			}
		} else {
			ZVAL_COPY_VALUE(result, value);
		}
	} else {
		ZVAL_COPY_VALUE(result, value);
		if (IS_TMP_VAR == IS_CONST) {
			if (UNEXPECTED(Z_OPT_REFCOUNTED_P(result))) {
				Z_ADDREF_P(result);
			}
		}
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_IDENTICAL_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CASE_STRICT_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_identical_function(op1, op2);

	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_not_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
        if ((IS_TMP_VAR & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
        }
		ZEND_VM_TAIL_CALL(ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_CONST == IS_UNUSED) {
			ZEND_VM_TAIL_CALL(zend_use_undef_in_read_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_FETCH_DIM_R_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_TMP_VAR & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_R_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_ADD_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_string **rope;
	zval *var;

	/* op1 and result are the same */
	rope = (zend_string**)EX_VAR(opline->op1.var);
	if (IS_CONST == IS_CONST) {
		var = RT_CONSTANT(opline, opline->op2);
		rope[opline->extended_value] = Z_STR_P(var);
		if (UNEXPECTED(Z_REFCOUNTED_P(var))) {
			Z_ADDREF_P(var);
		}
	} else {
		var = RT_CONSTANT(opline, opline->op2);
		if (EXPECTED(Z_TYPE_P(var) == IS_STRING)) {
			if (IS_CONST == IS_CV) {
				rope[opline->extended_value] = zend_string_copy(Z_STR_P(var));
			} else {
				rope[opline->extended_value] = Z_STR_P(var);
			}
		} else {
			SAVE_OPLINE();
			if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(var) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			rope[opline->extended_value] = zval_get_string_func(var);

			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_END_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_string **rope;
	zval *var, *ret;
	uint32_t i;
	size_t len = 0;
	char *target;

	rope = (zend_string**)EX_VAR(opline->op1.var);
	if (IS_CONST == IS_CONST) {
		var = RT_CONSTANT(opline, opline->op2);
		rope[opline->extended_value] = Z_STR_P(var);
		if (UNEXPECTED(Z_REFCOUNTED_P(var))) {
			Z_ADDREF_P(var);
		}
	} else {
		var = RT_CONSTANT(opline, opline->op2);
		if (EXPECTED(Z_TYPE_P(var) == IS_STRING)) {
			if (IS_CONST == IS_CV) {
				rope[opline->extended_value] = zend_string_copy(Z_STR_P(var));
			} else {
				rope[opline->extended_value] = Z_STR_P(var);
			}
		} else {
			SAVE_OPLINE();
			if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(var) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			rope[opline->extended_value] = zval_get_string_func(var);

			if (UNEXPECTED(EG(exception))) {
				for (i = 0; i <= opline->extended_value; i++) {
					zend_string_release_ex(rope[i], 0);
				}
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		}
	}
	for (i = 0; i <= opline->extended_value; i++) {
		len += ZSTR_LEN(rope[i]);
	}
	ret = EX_VAR(opline->result.var);
	ZVAL_STR(ret, zend_string_alloc(len, 0));
	target = Z_STRVAL_P(ret);
	for (i = 0; i <= opline->extended_value; i++) {
		memcpy(target, ZSTR_VAL(rope[i]), ZSTR_LEN(rope[i]));
		target += ZSTR_LEN(rope[i]);
		zend_string_release_ex(rope[i], 0);
	}
	*target = '\0';

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAL_EX_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;
	uint32_t arg_num;

	if (IS_CONST == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(arg_num <= MAX_ARG_FLAG_NUM)) {
		if (QUICK_ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_val_by_ref;
		}
	} else if (ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_val_by_ref:
		ZEND_VM_TAIL_CALL(zend_cannot_pass_by_ref_helper_SPEC(arg_num, arg ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
	}
	value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	ZVAL_COPY_VALUE(arg, value);
	if (IS_TMP_VAR == IS_CONST) {
		if (UNEXPECTED(Z_OPT_REFCOUNTED_P(arg))) {
			Z_ADDREF_P(arg);
		}
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) &&
	    UNEXPECTED(opline->extended_value & ZEND_ARRAY_ELEMENT_REF)) {
		expr_ptr = NULL;
		if (Z_ISREF_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}

	} else {
		expr_ptr = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
		if (IS_TMP_VAR == IS_TMP_VAR) {
			/* pass */
		} else if (IS_TMP_VAR == IS_CONST) {
			Z_TRY_ADDREF_P(expr_ptr);
		} else if (IS_TMP_VAR == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			Z_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_TMP_VAR == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(expr_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(expr_ptr);

				expr_ptr = Z_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(expr_ptr)) {
					Z_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_CONST != IS_UNUSED) {
		zval *offset = RT_CONSTANT(opline, opline->op2);
		zend_string *str;
		zend_ulong hval;

add_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if (IS_CONST != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index:
			zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(offset) == IS_REFERENCE)) {
			offset = Z_REFVAL_P(offset);
			goto add_again;
		} else if (Z_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (Z_TYPE_P(offset) == IS_DOUBLE) {
			hval = zend_dval_to_lval(Z_DVAL_P(offset));
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_RESOURCE) {
			zend_use_resource_as_offset(offset);
			hval = Z_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_CONST == IS_CV && Z_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			zend_illegal_offset();
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			zend_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_ARRAY_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_TMP_VAR != IS_UNUSED) {
		size = opline->extended_value >> ZEND_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, zend_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & ZEND_ARRAY_NOT_PACKED) {
			zend_hash_real_init_mixed(Z_ARRVAL_P(array));
		}
		ZEND_VM_TAIL_CALL(ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, zend_new_array(0));
		ZEND_VM_NEXT_OPCODE();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_YIELD_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & ZEND_GENERATOR_FORCED_CLOSE)) {
		ZEND_VM_TAIL_CALL(zend_yield_in_closed_generator_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_TMP_VAR != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_TMP_VAR & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_TMP_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
						Z_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = NULL;

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_TMP_VAR == IS_VAR) {
						ZEND_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == ZEND_RETURNS_FUNCTION
						 && !Z_ISREF_P(value_ptr)) {
							zend_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (Z_ISREF_P(value_ptr)) {
						Z_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, Z_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_TMP_VAR == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
					Z_ADDREF(generator->value);
				}
			} else if (IS_TMP_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if ((IS_TMP_VAR & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, Z_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_TMP_VAR == IS_CV) {
					if (Z_OPT_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {
		zval *key = RT_CONSTANT(opline, opline->op2);
		if ((IS_CONST & (IS_CV|IS_VAR)) && UNEXPECTED(Z_TYPE_P(key)) == IS_REFERENCE) {
			key = Z_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IN_ARRAY_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;
	HashTable *ht = Z_ARRVAL_P(RT_CONSTANT(opline, opline->op2));
	zval *result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		result = zend_hash_find_ex(ht, Z_STR_P(op1), IS_TMP_VAR == IS_CONST);
	} else if (opline->extended_value) {
		if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
			result = zend_hash_index_find(ht, Z_LVAL_P(op1));
		} else {
			result = NULL;
		}
	} else if (Z_TYPE_P(op1) <= IS_FALSE) {
		result = zend_hash_find_ex(ht, ZSTR_EMPTY_ALLOC(), 1);
	} else {
		zend_string *key;
		zval key_tmp, *val;

		result = NULL;
		ZEND_HASH_FOREACH_STR_KEY_VAL(ht, key, val) {
			ZVAL_STR(&key_tmp, key);
			if (zend_compare(op1, &key_tmp) == 0) {
				result = val;
				break;
			}
		} ZEND_HASH_FOREACH_END();
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
        if ((IS_TMP_VAR & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
        }
		ZEND_VM_TAIL_CALL(ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			ZEND_VM_TAIL_CALL(zend_use_undef_in_read_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_TMP_VAR & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_ADD_SPEC_TMP_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_string **rope;
	zval *var;

	/* op1 and result are the same */
	rope = (zend_string**)EX_VAR(opline->op1.var);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		var = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		rope[opline->extended_value] = Z_STR_P(var);
		if (UNEXPECTED(Z_REFCOUNTED_P(var))) {
			Z_ADDREF_P(var);
		}
	} else {
		var = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if (EXPECTED(Z_TYPE_P(var) == IS_STRING)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CV) {
				rope[opline->extended_value] = zend_string_copy(Z_STR_P(var));
			} else {
				rope[opline->extended_value] = Z_STR_P(var);
			}
		} else {
			SAVE_OPLINE();
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(var) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			rope[opline->extended_value] = zval_get_string_func(var);
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_END_SPEC_TMP_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_string **rope;
	zval *var, *ret;
	uint32_t i;
	size_t len = 0;
	char *target;

	rope = (zend_string**)EX_VAR(opline->op1.var);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		var = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		rope[opline->extended_value] = Z_STR_P(var);
		if (UNEXPECTED(Z_REFCOUNTED_P(var))) {
			Z_ADDREF_P(var);
		}
	} else {
		var = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if (EXPECTED(Z_TYPE_P(var) == IS_STRING)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CV) {
				rope[opline->extended_value] = zend_string_copy(Z_STR_P(var));
			} else {
				rope[opline->extended_value] = Z_STR_P(var);
			}
		} else {
			SAVE_OPLINE();
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(var) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			rope[opline->extended_value] = zval_get_string_func(var);
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			if (UNEXPECTED(EG(exception))) {
				for (i = 0; i <= opline->extended_value; i++) {
					zend_string_release_ex(rope[i], 0);
				}
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		}
	}
	for (i = 0; i <= opline->extended_value; i++) {
		len += ZSTR_LEN(rope[i]);
	}
	ret = EX_VAR(opline->result.var);
	ZVAL_STR(ret, zend_string_alloc(len, 0));
	target = Z_STRVAL_P(ret);
	for (i = 0; i <= opline->extended_value; i++) {
		memcpy(target, ZSTR_VAL(rope[i]), ZSTR_LEN(rope[i]));
		target += ZSTR_LEN(rope[i]);
		zend_string_release_ex(rope[i], 0);
	}
	*target = '\0';

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) &&
	    UNEXPECTED(opline->extended_value & ZEND_ARRAY_ELEMENT_REF)) {
		expr_ptr = NULL;
		if (Z_ISREF_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}

	} else {
		expr_ptr = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
		if (IS_TMP_VAR == IS_TMP_VAR) {
			/* pass */
		} else if (IS_TMP_VAR == IS_CONST) {
			Z_TRY_ADDREF_P(expr_ptr);
		} else if (IS_TMP_VAR == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			Z_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_TMP_VAR == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(expr_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(expr_ptr);

				expr_ptr = Z_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(expr_ptr)) {
					Z_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval *offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		zend_string *str;
		zend_ulong hval;

add_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index:
			zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(offset) == IS_REFERENCE)) {
			offset = Z_REFVAL_P(offset);
			goto add_again;
		} else if (Z_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (Z_TYPE_P(offset) == IS_DOUBLE) {
			hval = zend_dval_to_lval(Z_DVAL_P(offset));
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_RESOURCE) {
			zend_use_resource_as_offset(offset);
			hval = Z_RES_HANDLE_P(offset);
			goto num_index;
		} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && Z_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			zend_illegal_offset();
			zval_ptr_dtor_nogc(expr_ptr);
		}
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	} else {
		if (!zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			zend_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_ARRAY_SPEC_TMP_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_TMP_VAR != IS_UNUSED) {
		size = opline->extended_value >> ZEND_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, zend_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & ZEND_ARRAY_NOT_PACKED) {
			zend_hash_real_init_mixed(Z_ARRVAL_P(array));
		}
		ZEND_VM_TAIL_CALL(ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, zend_new_array(0));
		ZEND_VM_NEXT_OPCODE();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_YIELD_SPEC_TMP_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & ZEND_GENERATOR_FORCED_CLOSE)) {
		ZEND_VM_TAIL_CALL(zend_yield_in_closed_generator_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_TMP_VAR != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_TMP_VAR & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_TMP_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
						Z_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = NULL;

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_TMP_VAR == IS_VAR) {
						ZEND_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == ZEND_RETURNS_FUNCTION
						 && !Z_ISREF_P(value_ptr)) {
							zend_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (Z_ISREF_P(value_ptr)) {
						Z_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, Z_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_TMP_VAR == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
					Z_ADDREF(generator->value);
				}
			} else if (IS_TMP_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if ((IS_TMP_VAR & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, Z_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_TMP_VAR == IS_CV) {
					if (Z_OPT_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval *key = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if (((IS_TMP_VAR|IS_VAR) & (IS_CV|IS_VAR)) && UNEXPECTED(Z_TYPE_P(key)) == IS_REFERENCE) {
			key = Z_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_IDENTICAL_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CASE_STRICT_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_IDENTICAL_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_not_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CASE_STRICT_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var_deref(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
        if ((IS_TMP_VAR & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
        }
		ZEND_VM_TAIL_CALL(ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_UNUSED == IS_UNUSED) {
			ZEND_VM_TAIL_CALL(zend_use_undef_in_read_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_VERIFY_RETURN_TYPE_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	if (IS_TMP_VAR == IS_UNUSED) {
		SAVE_OPLINE();
		zend_verify_missing_return_type(EX(func));
		HANDLE_EXCEPTION();
	} else {
/* prevents "undefined variable opline" errors */
#if 0 || (IS_TMP_VAR != IS_UNUSED)
		USE_OPLINE
		zval *retval_ref, *retval_ptr;
		zend_arg_info *ret_info = EX(func)->common.arg_info - 1;
		retval_ref = retval_ptr = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);

		if (IS_TMP_VAR == IS_CONST) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval_ptr);
			retval_ref = retval_ptr = EX_VAR(opline->result.var);
		} else if (IS_TMP_VAR == IS_VAR) {
			if (UNEXPECTED(Z_TYPE_P(retval_ptr) == IS_INDIRECT)) {
				retval_ptr = Z_INDIRECT_P(retval_ptr);
			}
			ZVAL_DEREF(retval_ptr);
		} else if (IS_TMP_VAR == IS_CV) {
			ZVAL_DEREF(retval_ptr);
		}

		if (EXPECTED(ZEND_TYPE_CONTAINS_CODE(ret_info->type, Z_TYPE_P(retval_ptr)))) {
			ZEND_VM_NEXT_OPCODE();
		}

		if (IS_TMP_VAR == IS_CV && UNEXPECTED(Z_ISUNDEF_P(retval_ptr))) {
			SAVE_OPLINE();
			retval_ref = retval_ptr = ZVAL_UNDEFINED_OP1();
			if (ZEND_TYPE_FULL_MASK(ret_info->type) & MAY_BE_NULL) {
				ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
			}
		}

		zend_reference *ref = NULL;
		void *cache_slot = CACHE_ADDR(opline->op2.num);
		if (UNEXPECTED(retval_ref != retval_ptr)) {
			if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
				ref = Z_REF_P(retval_ref);
			} else {
				/* A cast might happen - unwrap the reference if this is a by-value return */
				if (Z_REFCOUNT_P(retval_ref) == 1) {
					ZVAL_UNREF(retval_ref);
				} else {
					Z_DELREF_P(retval_ref);
					ZVAL_COPY(retval_ref, retval_ptr);
				}
				retval_ptr = retval_ref;
			}
		}

		SAVE_OPLINE();
		if (UNEXPECTED(!zend_check_type_slow(ret_info->type, retval_ptr, ref, cache_slot, NULL, 1, 0))) {
			zend_verify_return_error(EX(func), retval_ptr);
			HANDLE_EXCEPTION();
		}
		ZEND_VM_NEXT_OPCODE();
#endif
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAL_EX_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(0)) {
		if (QUICK_ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_val_by_ref;
		}
	} else if (ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_val_by_ref:
		ZEND_VM_TAIL_CALL(zend_cannot_pass_by_ref_helper_SPEC(arg_num, arg ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
	}
	value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	ZVAL_COPY_VALUE(arg, value);
	if (IS_TMP_VAR == IS_CONST) {
		if (UNEXPECTED(Z_OPT_REFCOUNTED_P(arg))) {
			Z_ADDREF_P(arg);
		}
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAL_EX_SPEC_TMP_UNUSED_QUICK_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(1)) {
		if (QUICK_ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_val_by_ref;
		}
	} else if (ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_val_by_ref:
		ZEND_VM_TAIL_CALL(zend_cannot_pass_by_ref_helper_SPEC(arg_num, arg ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
	}
	value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	ZVAL_COPY_VALUE(arg, value);
	if (IS_TMP_VAR == IS_CONST) {
		if (UNEXPECTED(Z_OPT_REFCOUNTED_P(arg))) {
			Z_ADDREF_P(arg);
		}
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) &&
	    UNEXPECTED(opline->extended_value & ZEND_ARRAY_ELEMENT_REF)) {
		expr_ptr = NULL;
		if (Z_ISREF_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}

	} else {
		expr_ptr = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
		if (IS_TMP_VAR == IS_TMP_VAR) {
			/* pass */
		} else if (IS_TMP_VAR == IS_CONST) {
			Z_TRY_ADDREF_P(expr_ptr);
		} else if (IS_TMP_VAR == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			Z_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_TMP_VAR == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(expr_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(expr_ptr);

				expr_ptr = Z_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(expr_ptr)) {
					Z_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_UNUSED != IS_UNUSED) {
		zval *offset = NULL;
		zend_string *str;
		zend_ulong hval;

add_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if (IS_UNUSED != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index:
			zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_UNUSED & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(offset) == IS_REFERENCE)) {
			offset = Z_REFVAL_P(offset);
			goto add_again;
		} else if (Z_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (Z_TYPE_P(offset) == IS_DOUBLE) {
			hval = zend_dval_to_lval(Z_DVAL_P(offset));
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_RESOURCE) {
			zend_use_resource_as_offset(offset);
			hval = Z_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_UNUSED == IS_CV && Z_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			zend_illegal_offset();
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			zend_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_ARRAY_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_TMP_VAR != IS_UNUSED) {
		size = opline->extended_value >> ZEND_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, zend_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & ZEND_ARRAY_NOT_PACKED) {
			zend_hash_real_init_mixed(Z_ARRVAL_P(array));
		}
		ZEND_VM_TAIL_CALL(ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, zend_new_array(0));
		ZEND_VM_NEXT_OPCODE();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_YIELD_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & ZEND_GENERATOR_FORCED_CLOSE)) {
		ZEND_VM_TAIL_CALL(zend_yield_in_closed_generator_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_TMP_VAR != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_TMP_VAR & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_TMP_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
						Z_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = NULL;

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_TMP_VAR == IS_VAR) {
						ZEND_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == ZEND_RETURNS_FUNCTION
						 && !Z_ISREF_P(value_ptr)) {
							zend_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (Z_ISREF_P(value_ptr)) {
						Z_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, Z_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_TMP_VAR == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
					Z_ADDREF(generator->value);
				}
			} else if (IS_TMP_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if ((IS_TMP_VAR & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, Z_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_TMP_VAR == IS_CV) {
					if (Z_OPT_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {
		zval *key = NULL;
		if ((IS_UNUSED & (IS_CV|IS_VAR)) && UNEXPECTED(Z_TYPE_P(key)) == IS_REFERENCE) {
			key = Z_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_GET_TYPE_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;
	zend_string *type;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	type = zend_zval_get_legacy_type(op1);
	if (EXPECTED(type)) {
		ZVAL_INTERNED_STR(EX_VAR(opline->result.var), type);
	} else {
		ZVAL_STRING(EX_VAR(opline->result.var), "unknown type");
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CASE_STRICT_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);

	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
        if ((IS_TMP_VAR & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
        }
		ZEND_VM_TAIL_CALL(ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_CV == IS_UNUSED) {
			ZEND_VM_TAIL_CALL(zend_use_undef_in_read_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_FETCH_DIM_R_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_TMP_VAR & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_R_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_ADD_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_string **rope;
	zval *var;

	/* op1 and result are the same */
	rope = (zend_string**)EX_VAR(opline->op1.var);
	if (IS_CV == IS_CONST) {
		var = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
		rope[opline->extended_value] = Z_STR_P(var);
		if (UNEXPECTED(Z_REFCOUNTED_P(var))) {
			Z_ADDREF_P(var);
		}
	} else {
		var = EX_VAR(opline->op2.var);
		if (EXPECTED(Z_TYPE_P(var) == IS_STRING)) {
			if (IS_CV == IS_CV) {
				rope[opline->extended_value] = zend_string_copy(Z_STR_P(var));
			} else {
				rope[opline->extended_value] = Z_STR_P(var);
			}
		} else {
			SAVE_OPLINE();
			if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(var) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			rope[opline->extended_value] = zval_get_string_func(var);

			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_END_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_string **rope;
	zval *var, *ret;
	uint32_t i;
	size_t len = 0;
	char *target;

	rope = (zend_string**)EX_VAR(opline->op1.var);
	if (IS_CV == IS_CONST) {
		var = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
		rope[opline->extended_value] = Z_STR_P(var);
		if (UNEXPECTED(Z_REFCOUNTED_P(var))) {
			Z_ADDREF_P(var);
		}
	} else {
		var = EX_VAR(opline->op2.var);
		if (EXPECTED(Z_TYPE_P(var) == IS_STRING)) {
			if (IS_CV == IS_CV) {
				rope[opline->extended_value] = zend_string_copy(Z_STR_P(var));
			} else {
				rope[opline->extended_value] = Z_STR_P(var);
			}
		} else {
			SAVE_OPLINE();
			if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(var) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			rope[opline->extended_value] = zval_get_string_func(var);

			if (UNEXPECTED(EG(exception))) {
				for (i = 0; i <= opline->extended_value; i++) {
					zend_string_release_ex(rope[i], 0);
				}
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		}
	}
	for (i = 0; i <= opline->extended_value; i++) {
		len += ZSTR_LEN(rope[i]);
	}
	ret = EX_VAR(opline->result.var);
	ZVAL_STR(ret, zend_string_alloc(len, 0));
	target = Z_STRVAL_P(ret);
	for (i = 0; i <= opline->extended_value; i++) {
		memcpy(target, ZSTR_VAL(rope[i]), ZSTR_LEN(rope[i]));
		target += ZSTR_LEN(rope[i]);
		zend_string_release_ex(rope[i], 0);
	}
	*target = '\0';

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) &&
	    UNEXPECTED(opline->extended_value & ZEND_ARRAY_ELEMENT_REF)) {
		expr_ptr = NULL;
		if (Z_ISREF_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}

	} else {
		expr_ptr = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
		if (IS_TMP_VAR == IS_TMP_VAR) {
			/* pass */
		} else if (IS_TMP_VAR == IS_CONST) {
			Z_TRY_ADDREF_P(expr_ptr);
		} else if (IS_TMP_VAR == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			Z_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_TMP_VAR == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(expr_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(expr_ptr);

				expr_ptr = Z_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(expr_ptr)) {
					Z_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_CV != IS_UNUSED) {
		zval *offset = EX_VAR(opline->op2.var);
		zend_string *str;
		zend_ulong hval;

add_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if (IS_CV != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index:
			zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(offset) == IS_REFERENCE)) {
			offset = Z_REFVAL_P(offset);
			goto add_again;
		} else if (Z_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (Z_TYPE_P(offset) == IS_DOUBLE) {
			hval = zend_dval_to_lval(Z_DVAL_P(offset));
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_RESOURCE) {
			zend_use_resource_as_offset(offset);
			hval = Z_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_CV == IS_CV && Z_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			zend_illegal_offset();
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			zend_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_ARRAY_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_TMP_VAR != IS_UNUSED) {
		size = opline->extended_value >> ZEND_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, zend_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & ZEND_ARRAY_NOT_PACKED) {
			zend_hash_real_init_mixed(Z_ARRVAL_P(array));
		}
		ZEND_VM_TAIL_CALL(ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, zend_new_array(0));
		ZEND_VM_NEXT_OPCODE();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_YIELD_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & ZEND_GENERATOR_FORCED_CLOSE)) {
		ZEND_VM_TAIL_CALL(zend_yield_in_closed_generator_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_TMP_VAR != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_TMP_VAR & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_TMP_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
						Z_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = NULL;

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_TMP_VAR == IS_VAR) {
						ZEND_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == ZEND_RETURNS_FUNCTION
						 && !Z_ISREF_P(value_ptr)) {
							zend_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (Z_ISREF_P(value_ptr)) {
						Z_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, Z_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_TMP_VAR == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
					Z_ADDREF(generator->value);
				}
			} else if (IS_TMP_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if ((IS_TMP_VAR & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, Z_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_TMP_VAR == IS_CV) {
					if (Z_OPT_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {
		zval *key = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
		if ((IS_CV & (IS_CV|IS_VAR)) && UNEXPECTED(Z_TYPE_P(key)) == IS_REFERENCE) {
			key = Z_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BIND_LEXICAL_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *closure, *var;

	closure = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	if (opline->extended_value & ZEND_BIND_REF) {
		/* By-ref binding */
		var = _get_zval_ptr_cv_BP_VAR_W(opline->op2.var EXECUTE_DATA_CC);
		if (Z_ISREF_P(var)) {
			Z_ADDREF_P(var);
		} else {
			ZVAL_MAKE_REF_EX(var, 2);
		}
	} else {
		var = EX_VAR(opline->op2.var);
		if (UNEXPECTED(Z_ISUNDEF_P(var)) && !(opline->extended_value & ZEND_BIND_IMPLICIT)) {
			SAVE_OPLINE();
			var = ZVAL_UNDEFINED_OP2();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		ZVAL_DEREF(var);
		Z_TRY_ADDREF_P(var);
	}

	zend_closure_bind_var_ex(closure,
		(opline->extended_value & ~(ZEND_BIND_REF|ZEND_BIND_IMPLICIT)), var);
	ZEND_VM_NEXT_OPCODE();
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_pre_inc_helper_SPEC_VAR(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	SAVE_OPLINE();
	if (IS_VAR == IS_CV && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_UNDEF)) {
		ZVAL_NULL(var_ptr);
		ZVAL_UNDEFINED_OP1();
	}

	do {
		if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_REFERENCE)) {
			zend_reference *ref = Z_REF_P(var_ptr);
			var_ptr = Z_REFVAL_P(var_ptr);
			if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
				zend_incdec_typed_ref(ref, NULL OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		increment_function(var_ptr);
	} while (0);

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_INC_SPEC_VAR_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(var_ptr) == IS_LONG)) {
		fast_long_increment_function(var_ptr);
		if (UNEXPECTED(0)) {
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
		}
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_pre_inc_helper_SPEC_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_INC_SPEC_VAR_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(var_ptr) == IS_LONG)) {
		fast_long_increment_function(var_ptr);
		if (UNEXPECTED(1)) {
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
		}
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_pre_inc_helper_SPEC_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_pre_dec_helper_SPEC_VAR(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	SAVE_OPLINE();
	if (IS_VAR == IS_CV && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_UNDEF)) {
		ZVAL_NULL(var_ptr);
		ZVAL_UNDEFINED_OP1();
	}

	do {
		if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_REFERENCE)) {
			zend_reference *ref = Z_REF_P(var_ptr);
			var_ptr = Z_REFVAL_P(var_ptr);

			if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
				zend_incdec_typed_ref(ref, NULL OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		decrement_function(var_ptr);
	} while (0);

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_DEC_SPEC_VAR_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(var_ptr) == IS_LONG)) {
		fast_long_decrement_function(var_ptr);
		if (UNEXPECTED(0)) {
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
		}
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_pre_dec_helper_SPEC_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_DEC_SPEC_VAR_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(var_ptr) == IS_LONG)) {
		fast_long_decrement_function(var_ptr);
		if (UNEXPECTED(1)) {
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
		}
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_pre_dec_helper_SPEC_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_post_inc_helper_SPEC_VAR(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	SAVE_OPLINE();
	if (IS_VAR == IS_CV && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_UNDEF)) {
		ZVAL_NULL(var_ptr);
		ZVAL_UNDEFINED_OP1();
	}

	do {
		if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_REFERENCE)) {
			zend_reference *ref = Z_REF_P(var_ptr);
			var_ptr = Z_REFVAL_P(var_ptr);

			if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
				zend_incdec_typed_ref(ref, EX_VAR(opline->result.var) OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);

		increment_function(var_ptr);
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POST_INC_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(var_ptr) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(var_ptr));
		fast_long_increment_function(var_ptr);
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_post_inc_helper_SPEC_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_post_dec_helper_SPEC_VAR(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	SAVE_OPLINE();
	if (IS_VAR == IS_CV && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_UNDEF)) {
		ZVAL_NULL(var_ptr);
		ZVAL_UNDEFINED_OP1();
	}

	do {
		if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_REFERENCE)) {
			zend_reference *ref = Z_REF_P(var_ptr);
			var_ptr = Z_REFVAL_P(var_ptr);

			if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
				zend_incdec_typed_ref(ref, EX_VAR(opline->result.var) OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);

		decrement_function(var_ptr);
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POST_DEC_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(var_ptr) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(var_ptr));
		fast_long_decrement_function(var_ptr);
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_post_dec_helper_SPEC_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_RETURN_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;

	retval_ptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	return_value = EX(return_value);
	if (IS_VAR == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(retval_ptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		retval_ptr = ZVAL_UNDEFINED_OP1();
		if (return_value) {
			ZVAL_NULL(return_value);
		}
	} else if (!return_value) {
		if (IS_VAR & (IS_VAR|IS_TMP_VAR)) {
			if (Z_REFCOUNTED_P(retval_ptr) && !Z_DELREF_P(retval_ptr)) {
				SAVE_OPLINE();
				rc_dtor_func(Z_COUNTED_P(retval_ptr));
			}
		}
	} else {
		if ((IS_VAR & (IS_CONST|IS_TMP_VAR))) {
			ZVAL_COPY_VALUE(return_value, retval_ptr);
			if (IS_VAR == IS_CONST) {
				if (UNEXPECTED(Z_OPT_REFCOUNTED_P(return_value))) {
					Z_ADDREF_P(return_value);
				}
			}
		} else if (IS_VAR == IS_CV) {
			do {
				if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
					if (EXPECTED(!Z_OPT_ISREF_P(retval_ptr))) {
						if (EXPECTED(!(EX_CALL_INFO() & ZEND_CALL_CODE))) {
							zend_refcounted *ref = Z_COUNTED_P(retval_ptr);
							ZVAL_COPY_VALUE(return_value, retval_ptr);
							if (GC_MAY_LEAK(ref)) {
								gc_possible_root(ref);
							}
							ZVAL_NULL(retval_ptr);
							break;
						} else {
							Z_ADDREF_P(retval_ptr);
						}
					} else {
						retval_ptr = Z_REFVAL_P(retval_ptr);
						if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
							Z_ADDREF_P(retval_ptr);
						}
					}
				}
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			} while (0);
		} else /* if (IS_VAR == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(retval_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(retval_ptr);

				retval_ptr = Z_REFVAL_P(retval_ptr);
				ZVAL_COPY_VALUE(return_value, retval_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
					Z_ADDREF_P(retval_ptr);
				}
			} else {
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			}
		}
	}

	ZEND_VM_TAIL_CALL(zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;

	SAVE_OPLINE();

	do {
		if ((IS_VAR & (IS_CONST|IS_TMP_VAR)) ||
		    (IS_VAR == IS_VAR && opline->extended_value == ZEND_RETURNS_VALUE)) {
			/* Not supposed to happen, but we'll allow it */
			zend_error(E_NOTICE, "Only variable references should be returned by reference");

			retval_ptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
			if (!EX(return_value)) {
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			} else {
				if (IS_VAR == IS_VAR && UNEXPECTED(Z_ISREF_P(retval_ptr))) {
					ZVAL_COPY_VALUE(EX(return_value), retval_ptr);
					break;
				}

				ZVAL_NEW_REF(EX(return_value), retval_ptr);
				if (IS_VAR == IS_CONST) {
					Z_TRY_ADDREF_P(retval_ptr);
				}
			}
			break;
		}

		retval_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

		if (IS_VAR == IS_VAR) {
			ZEND_ASSERT(retval_ptr != &EG(uninitialized_zval));
			if (opline->extended_value == ZEND_RETURNS_FUNCTION && !Z_ISREF_P(retval_ptr)) {
				zend_error(E_NOTICE, "Only variable references should be returned by reference");
				if (EX(return_value)) {
					ZVAL_NEW_REF(EX(return_value), retval_ptr);
				} else {
					zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				}
				break;
			}
		}

		if (EX(return_value)) {
			if (Z_ISREF_P(retval_ptr)) {
				Z_ADDREF_P(retval_ptr);
			} else {
				ZVAL_MAKE_REF_EX(retval_ptr, 2);
			}
			ZVAL_REF(EX(return_value), Z_REF_P(retval_ptr));
		}

		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	} while (0);

	ZEND_VM_TAIL_CALL(zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_GENERATOR_RETURN_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval;

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	retval = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	/* Copy return value into generator->retval */
	if ((IS_VAR & (IS_CONST|IS_TMP_VAR))) {
		ZVAL_COPY_VALUE(&generator->retval, retval);
		if (IS_VAR == IS_CONST) {
			if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->retval))) {
				Z_ADDREF(generator->retval);
			}
		}
	} else if (IS_VAR == IS_CV) {
		ZVAL_COPY_DEREF(&generator->retval, retval);
	} else /* if (IS_VAR == IS_VAR) */ {
		if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_refcounted *ref = Z_COUNTED_P(retval);

			retval = Z_REFVAL_P(retval);
			ZVAL_COPY_VALUE(&generator->retval, retval);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(retval)) {
				Z_ADDREF_P(retval);
			}
		} else {
			ZVAL_COPY_VALUE(&generator->retval, retval);
		}
	}

	/* Close the generator to free up resources */
	zend_generator_close(generator, 1);

	/* Pass execution back to handling code */
	ZEND_VM_RETURN();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_USER_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *arg, *param;

	SAVE_OPLINE();

	if (UNEXPECTED(ARG_MUST_BE_SENT_BY_REF(EX(call)->func, opline->op2.num))) {
		zend_param_must_be_ref(EX(call)->func, opline->op2.num);
	}

	arg = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	param = ZEND_CALL_VAR(EX(call), opline->result.var);
	ZVAL_COPY(param, arg);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CAST_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr;
	zval *result = EX_VAR(opline->result.var);
	HashTable *ht;

	SAVE_OPLINE();
	expr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	switch (opline->extended_value) {
		case IS_LONG:
			ZVAL_LONG(result, zval_get_long(expr));
			break;
		case IS_DOUBLE:
			ZVAL_DOUBLE(result, zval_get_double(expr));
			break;
		case IS_STRING:
			ZVAL_STR(result, zval_get_string(expr));
			break;
		default:
			ZEND_ASSERT(opline->extended_value != _IS_BOOL && "Must use ZEND_BOOL instead");
			if (IS_VAR & (IS_VAR|IS_CV)) {
				ZVAL_DEREF(expr);
			}
			/* If value is already of correct type, return it directly */
			if (Z_TYPE_P(expr) == opline->extended_value) {
				ZVAL_COPY_VALUE(result, expr);
				if (IS_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(result))) Z_ADDREF_P(result);
				} else if (IS_VAR != IS_TMP_VAR) {
					if (Z_OPT_REFCOUNTED_P(result)) Z_ADDREF_P(result);
				}

				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
			}

			if (opline->extended_value == IS_ARRAY) {
				if (IS_VAR == IS_CONST || Z_TYPE_P(expr) != IS_OBJECT || Z_OBJCE_P(expr) == zend_ce_closure) {
					if (Z_TYPE_P(expr) != IS_NULL) {
						ZVAL_ARR(result, zend_new_array(1));
						expr = zend_hash_index_add_new(Z_ARRVAL_P(result), 0, expr);
						if (IS_VAR == IS_CONST) {
							if (UNEXPECTED(Z_OPT_REFCOUNTED_P(expr))) Z_ADDREF_P(expr);
						} else {
							if (Z_OPT_REFCOUNTED_P(expr)) Z_ADDREF_P(expr);
						}
					} else {
						ZVAL_EMPTY_ARRAY(result);
					}
				} else {
					HashTable *obj_ht = zend_get_properties_for(expr, ZEND_PROP_PURPOSE_ARRAY_CAST);
					if (obj_ht) {
						/* fast copy */
						ZVAL_ARR(result, zend_proptable_to_symtable(obj_ht,
							(Z_OBJCE_P(expr)->default_properties_count ||
							 Z_OBJ_P(expr)->handlers != &std_object_handlers ||
							 GC_IS_RECURSIVE(obj_ht))));
						zend_release_properties(obj_ht);
					} else {
						ZVAL_EMPTY_ARRAY(result);
					}
				}
			} else {
				ZEND_ASSERT(opline->extended_value == IS_OBJECT);
				ZVAL_OBJ(result, zend_objects_new(zend_standard_class_def));
				if (Z_TYPE_P(expr) == IS_ARRAY) {
					ht = zend_symtable_to_proptable(Z_ARR_P(expr));
					if (GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) {
						/* TODO: try not to duplicate immutable arrays as well ??? */
						ht = zend_array_dup(ht);
					}
					Z_OBJ_P(result)->properties = ht;
				} else if (Z_TYPE_P(expr) != IS_NULL) {
					Z_OBJ_P(result)->properties = ht = zend_new_array(1);
					expr = zend_hash_add_new(ht, ZSTR_KNOWN(ZEND_STR_SCALAR), expr);
					if (IS_VAR == IS_CONST) {
						if (UNEXPECTED(Z_OPT_REFCOUNTED_P(expr))) Z_ADDREF_P(expr);
					} else {
						if (Z_OPT_REFCOUNTED_P(expr)) Z_ADDREF_P(expr);
					}
				}
			}
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FE_RESET_R_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array_ptr, *result;

	SAVE_OPLINE();

	array_ptr = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	if (EXPECTED(Z_TYPE_P(array_ptr) == IS_ARRAY)) {
		result = EX_VAR(opline->result.var);
		ZVAL_COPY_VALUE(result, array_ptr);
		if (IS_VAR != IS_TMP_VAR && Z_OPT_REFCOUNTED_P(result)) {
			Z_ADDREF_P(array_ptr);
		}
		Z_FE_POS_P(result) = 0;

		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		ZEND_VM_NEXT_OPCODE();
	} else if (IS_VAR != IS_CONST && EXPECTED(Z_TYPE_P(array_ptr) == IS_OBJECT)) {
		zend_object *zobj = Z_OBJ_P(array_ptr);
		if (!zobj->ce->get_iterator) {
			HashTable *properties;

			result = EX_VAR(opline->result.var);
			ZVAL_OBJ(result, zobj);
			if (IS_VAR != IS_TMP_VAR) {
				GC_ADDREF(zobj);
			}
			properties = zobj->properties;
			if (properties) {
				if (UNEXPECTED(GC_REFCOUNT(properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(properties);
					}
					properties = zobj->properties = zend_array_dup(properties);
				}
			} else {
				properties = zobj->handlers->get_properties(zobj);
			}
			Z_FE_ITER_P(EX_VAR(opline->result.var)) = zend_hash_iterator_add(properties, 0);

			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			zend_bool is_empty = zend_fe_reset_iterator(array_ptr, 0 OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			} else if (is_empty) {
				ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
			} else {
				ZEND_VM_NEXT_OPCODE();
			}
		}
	} else {
		zend_error(E_WARNING, "foreach() argument must be of type array|object, %s given", zend_zval_type_name(array_ptr));
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		Z_FE_ITER_P(EX_VAR(opline->result.var)) = (uint32_t)-1;
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		ZEND_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FE_RESET_RW_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array_ptr, *array_ref;

	SAVE_OPLINE();

	if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		array_ref = array_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (Z_ISREF_P(array_ref)) {
			array_ptr = Z_REFVAL_P(array_ref);
		}
	} else {
		array_ref = array_ptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	}

	if (EXPECTED(Z_TYPE_P(array_ptr) == IS_ARRAY)) {
		if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
			if (array_ptr == array_ref) {
				ZVAL_NEW_REF(array_ref, array_ref);
				array_ptr = Z_REFVAL_P(array_ref);
			}
			Z_ADDREF_P(array_ref);
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), array_ref);
		} else {
			array_ref = EX_VAR(opline->result.var);
			ZVAL_NEW_REF(array_ref, array_ptr);
			array_ptr = Z_REFVAL_P(array_ref);
		}
		if (IS_VAR == IS_CONST) {
			ZVAL_ARR(array_ptr, zend_array_dup(Z_ARRVAL_P(array_ptr)));
		} else {
			SEPARATE_ARRAY(array_ptr);
		}
		Z_FE_ITER_P(EX_VAR(opline->result.var)) = zend_hash_iterator_add(Z_ARRVAL_P(array_ptr), 0);

		if (IS_VAR == IS_VAR) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		}
		ZEND_VM_NEXT_OPCODE();
	} else if (IS_VAR != IS_CONST && EXPECTED(Z_TYPE_P(array_ptr) == IS_OBJECT)) {
		if (!Z_OBJCE_P(array_ptr)->get_iterator) {
			if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
				if (array_ptr == array_ref) {
					ZVAL_NEW_REF(array_ref, array_ref);
					array_ptr = Z_REFVAL_P(array_ref);
				}
				Z_ADDREF_P(array_ref);
				ZVAL_COPY_VALUE(EX_VAR(opline->result.var), array_ref);
			} else {
				array_ptr = EX_VAR(opline->result.var);
				ZVAL_COPY_VALUE(array_ptr, array_ref);
			}
			if (Z_OBJ_P(array_ptr)->properties
			 && UNEXPECTED(GC_REFCOUNT(Z_OBJ_P(array_ptr)->properties) > 1)) {
				if (EXPECTED(!(GC_FLAGS(Z_OBJ_P(array_ptr)->properties) & IS_ARRAY_IMMUTABLE))) {
					GC_DELREF(Z_OBJ_P(array_ptr)->properties);
				}
				Z_OBJ_P(array_ptr)->properties = zend_array_dup(Z_OBJ_P(array_ptr)->properties);
			}
			Z_FE_ITER_P(EX_VAR(opline->result.var)) = zend_hash_iterator_add(Z_OBJPROP_P(array_ptr), 0);

			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			zend_bool is_empty = zend_fe_reset_iterator(array_ptr, 1 OPLINE_CC EXECUTE_DATA_CC);

			if (IS_VAR == IS_VAR) {
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			} else {
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			}
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			} else if (is_empty) {
				ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
			} else {
				ZEND_VM_NEXT_OPCODE();
			}
		}
	} else {
		zend_error(E_WARNING, "foreach() argument must be of type array|object, %s given", zend_zval_type_name(array_ptr));
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		Z_FE_ITER_P(EX_VAR(opline->result.var)) = (uint32_t)-1;
		if (IS_VAR == IS_VAR) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		} else {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		}
		ZEND_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FE_FETCH_R_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array;
	zval *value;
	uint32_t value_type;
	HashTable *fe_ht;
	HashPosition pos;
	Bucket *p;

	array = EX_VAR(opline->op1.var);
	SAVE_OPLINE();
	if (EXPECTED(Z_TYPE_P(array) == IS_ARRAY)) {
		fe_ht = Z_ARRVAL_P(array);
		pos = Z_FE_POS_P(array);
		p = fe_ht->arData + pos;
		while (1) {
			if (UNEXPECTED(pos >= fe_ht->nNumUsed)) {
				/* reached end of iteration */
fe_fetch_r_exit:
				ZEND_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
				ZEND_VM_CONTINUE();
			}
			pos++;
			value = &p->val;
			value_type = Z_TYPE_INFO_P(value);
			if (EXPECTED(value_type != IS_UNDEF)) {
				if (UNEXPECTED(value_type == IS_INDIRECT)) {
					value = Z_INDIRECT_P(value);
					value_type = Z_TYPE_INFO_P(value);
					if (EXPECTED(value_type != IS_UNDEF)) {
						break;
					}
				} else {
					break;
				}
			}
			p++;
		}
		Z_FE_POS_P(array) = pos;
		if (RETURN_VALUE_USED(opline)) {
			if (!p->key) {
				ZVAL_LONG(EX_VAR(opline->result.var), p->h);
			} else {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), p->key);
			}
		}
	} else {
		zend_object_iterator *iter;

		ZEND_ASSERT(Z_TYPE_P(array) == IS_OBJECT);
		if ((iter = zend_iterator_unwrap(array)) == NULL) {
			/* plain object */

			fe_ht = Z_OBJPROP_P(array);
			pos = zend_hash_iterator_pos(Z_FE_ITER_P(array), fe_ht);
			p = fe_ht->arData + pos;
			while (1) {
				if (UNEXPECTED(pos >= fe_ht->nNumUsed)) {
					/* reached end of iteration */
					goto fe_fetch_r_exit;
				}
				pos++;
				value = &p->val;
				value_type = Z_TYPE_INFO_P(value);
				if (EXPECTED(value_type != IS_UNDEF)) {
					if (UNEXPECTED(value_type == IS_INDIRECT)) {
						value = Z_INDIRECT_P(value);
						value_type = Z_TYPE_INFO_P(value);
						if (EXPECTED(value_type != IS_UNDEF)
						 && EXPECTED(zend_check_property_access(Z_OBJ_P(array), p->key, 0) == SUCCESS)) {
							break;
						}
					} else if (EXPECTED(Z_OBJCE_P(array)->default_properties_count == 0)
							|| !p->key
							|| zend_check_property_access(Z_OBJ_P(array), p->key, 1) == SUCCESS) {
						break;
					}
				}
				p++;
			}
			EG(ht_iterators)[Z_FE_ITER_P(array)].pos = pos;
			if (RETURN_VALUE_USED(opline)) {
				if (UNEXPECTED(!p->key)) {
					ZVAL_LONG(EX_VAR(opline->result.var), p->h);
				} else if (ZSTR_VAL(p->key)[0]) {
					ZVAL_STR_COPY(EX_VAR(opline->result.var), p->key);
				} else {
					const char *class_name, *prop_name;
					size_t prop_name_len;
					zend_unmangle_property_name_ex(
						p->key, &class_name, &prop_name, &prop_name_len);
					ZVAL_STRINGL(EX_VAR(opline->result.var), prop_name, prop_name_len);
				}
			}
		} else {
			if (EXPECTED(++iter->index > 0)) {
				/* This could cause an endless loop if index becomes zero again.
				 * In case that ever happens we need an additional flag. */
				iter->funcs->move_forward(iter);
				if (UNEXPECTED(EG(exception) != NULL)) {
					UNDEF_RESULT();
					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(iter->funcs->valid(iter) == FAILURE)) {
					/* reached end of iteration */
					if (UNEXPECTED(EG(exception) != NULL)) {
						UNDEF_RESULT();
						HANDLE_EXCEPTION();
					}
					goto fe_fetch_r_exit;
				}
			}
			value = iter->funcs->get_current_data(iter);
			if (UNEXPECTED(EG(exception) != NULL)) {
				UNDEF_RESULT();
				HANDLE_EXCEPTION();
			}
			if (!value) {
				/* failure in get_current_data */
				goto fe_fetch_r_exit;
			}
			if (RETURN_VALUE_USED(opline)) {
				if (iter->funcs->get_current_key) {
					iter->funcs->get_current_key(iter, EX_VAR(opline->result.var));
					if (UNEXPECTED(EG(exception) != NULL)) {
						UNDEF_RESULT();
						HANDLE_EXCEPTION();
					}
				} else {
					ZVAL_LONG(EX_VAR(opline->result.var), iter->index);
				}
			}
			value_type = Z_TYPE_INFO_P(value);
		}
	}

	if (EXPECTED(opline->op2_type == IS_CV)) {
		zval *variable_ptr = EX_VAR(opline->op2.var);
		zend_assign_to_variable(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES());
	} else {
		zval *res = EX_VAR(opline->op2.var);
		zend_refcounted *gc = Z_COUNTED_P(value);

		ZVAL_COPY_VALUE_EX(res, value, gc, value_type);
		if (Z_TYPE_INFO_REFCOUNTED(value_type)) {
			GC_ADDREF(gc);
		}
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FE_FETCH_RW_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array;
	zval *value;
	uint32_t value_type;
	HashTable *fe_ht;
	HashPosition pos;
	Bucket *p;

	array = EX_VAR(opline->op1.var);
	SAVE_OPLINE();

	ZVAL_DEREF(array);
	if (EXPECTED(Z_TYPE_P(array) == IS_ARRAY)) {
		pos = zend_hash_iterator_pos_ex(Z_FE_ITER_P(EX_VAR(opline->op1.var)), array);
		fe_ht = Z_ARRVAL_P(array);
		p = fe_ht->arData + pos;
		while (1) {
			if (UNEXPECTED(pos >= fe_ht->nNumUsed)) {
				/* reached end of iteration */
				goto fe_fetch_w_exit;
			}
			pos++;
			value = &p->val;
			value_type = Z_TYPE_INFO_P(value);
			if (EXPECTED(value_type != IS_UNDEF)) {
				if (UNEXPECTED(value_type == IS_INDIRECT)) {
					value = Z_INDIRECT_P(value);
					value_type = Z_TYPE_INFO_P(value);
					if (EXPECTED(value_type != IS_UNDEF)) {
						break;
					}
				} else {
					break;
				}
			}
			p++;
		}
		EG(ht_iterators)[Z_FE_ITER_P(EX_VAR(opline->op1.var))].pos = pos;
		if (RETURN_VALUE_USED(opline)) {
			if (!p->key) {
				ZVAL_LONG(EX_VAR(opline->result.var), p->h);
			} else {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), p->key);
			}
		}
	} else if (EXPECTED(Z_TYPE_P(array) == IS_OBJECT)) {
		zend_object_iterator *iter;

		if ((iter = zend_iterator_unwrap(array)) == NULL) {
			/* plain object */

			fe_ht = Z_OBJPROP_P(array);
			pos = zend_hash_iterator_pos(Z_FE_ITER_P(EX_VAR(opline->op1.var)), fe_ht);
			p = fe_ht->arData + pos;
			while (1) {
				if (UNEXPECTED(pos >= fe_ht->nNumUsed)) {
					/* reached end of iteration */
					goto fe_fetch_w_exit;
				}
				pos++;
				value = &p->val;
				value_type = Z_TYPE_INFO_P(value);
				if (EXPECTED(value_type != IS_UNDEF)) {
					if (UNEXPECTED(value_type == IS_INDIRECT)) {
						value = Z_INDIRECT_P(value);
						value_type = Z_TYPE_INFO_P(value);
						if (EXPECTED(value_type != IS_UNDEF)
						 && EXPECTED(zend_check_property_access(Z_OBJ_P(array), p->key, 0) == SUCCESS)) {
							if ((value_type & Z_TYPE_MASK) != IS_REFERENCE) {
								zend_property_info *prop_info =
									zend_get_typed_property_info_for_slot(Z_OBJ_P(array), value);
								if (UNEXPECTED(prop_info)) {
									ZVAL_NEW_REF(value, value);
									ZEND_REF_ADD_TYPE_SOURCE(Z_REF_P(value), prop_info);
									value_type = IS_REFERENCE_EX;
								}
							}
							break;
						}
					} else if (EXPECTED(Z_OBJCE_P(array)->default_properties_count == 0)
							|| !p->key
							|| zend_check_property_access(Z_OBJ_P(array), p->key, 1) == SUCCESS) {
						break;
					}
				}
				p++;
			}
			EG(ht_iterators)[Z_FE_ITER_P(EX_VAR(opline->op1.var))].pos = pos;
			if (RETURN_VALUE_USED(opline)) {
				if (UNEXPECTED(!p->key)) {
					ZVAL_LONG(EX_VAR(opline->result.var), p->h);
				} else if (ZSTR_VAL(p->key)[0]) {
					ZVAL_STR_COPY(EX_VAR(opline->result.var), p->key);
				} else {
					const char *class_name, *prop_name;
					size_t prop_name_len;
					zend_unmangle_property_name_ex(
						p->key, &class_name, &prop_name, &prop_name_len);
					ZVAL_STRINGL(EX_VAR(opline->result.var), prop_name, prop_name_len);
				}
			}
		} else {
			if (++iter->index > 0) {
				/* This could cause an endless loop if index becomes zero again.
				 * In case that ever happens we need an additional flag. */
				iter->funcs->move_forward(iter);
				if (UNEXPECTED(EG(exception) != NULL)) {
					UNDEF_RESULT();
					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(iter->funcs->valid(iter) == FAILURE)) {
					/* reached end of iteration */
					if (UNEXPECTED(EG(exception) != NULL)) {
						UNDEF_RESULT();
						HANDLE_EXCEPTION();
					}
					goto fe_fetch_w_exit;
				}
			}
			value = iter->funcs->get_current_data(iter);
			if (UNEXPECTED(EG(exception) != NULL)) {
				UNDEF_RESULT();
				HANDLE_EXCEPTION();
			}
			if (!value) {
				/* failure in get_current_data */
				goto fe_fetch_w_exit;
			}
			if (RETURN_VALUE_USED(opline)) {
				if (iter->funcs->get_current_key) {
					iter->funcs->get_current_key(iter, EX_VAR(opline->result.var));
					if (UNEXPECTED(EG(exception) != NULL)) {
						UNDEF_RESULT();
						HANDLE_EXCEPTION();
					}
				} else {
					ZVAL_LONG(EX_VAR(opline->result.var), iter->index);
				}
			}
			value_type = Z_TYPE_INFO_P(value);
		}
	} else {
		zend_error(E_WARNING, "foreach() argument must be of type array|object, %s given", zend_zval_type_name(array));
		if (UNEXPECTED(EG(exception))) {
			UNDEF_RESULT();
			HANDLE_EXCEPTION();
		}
fe_fetch_w_exit:
		ZEND_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
		ZEND_VM_CONTINUE();
	}

	if (EXPECTED((value_type & Z_TYPE_MASK) != IS_REFERENCE)) {
		zend_refcounted *gc = Z_COUNTED_P(value);
		zval *ref;
		ZVAL_NEW_EMPTY_REF(value);
		ref = Z_REFVAL_P(value);
		ZVAL_COPY_VALUE_EX(ref, value, gc, value_type);
	}
	if (EXPECTED(opline->op2_type == IS_CV)) {
		zval *variable_ptr = EX_VAR(opline->op2.var);
		if (EXPECTED(variable_ptr != value)) {
			zend_reference *ref;

			ref = Z_REF_P(value);
			GC_ADDREF(ref);
			i_zval_ptr_dtor(variable_ptr);
			ZVAL_REF(variable_ptr, ref);
		}
	} else {
		Z_ADDREF_P(value);
		ZVAL_REF(EX_VAR(opline->op2.var), Z_REF_P(value));
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMP_SET_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *ref = NULL;
	bool ret;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && Z_ISREF_P(value)) {
		if (IS_VAR == IS_VAR) {
			ref = value;
		}
		value = Z_REFVAL_P(value);
	}

	ret = i_zend_is_true(value);

	if (UNEXPECTED(EG(exception))) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}

	if (ret) {
		zval *result = EX_VAR(opline->result.var);

		ZVAL_COPY_VALUE(result, value);
		if (IS_VAR == IS_CONST) {
			if (UNEXPECTED(Z_OPT_REFCOUNTED_P(result))) Z_ADDREF_P(result);
		} else if (IS_VAR == IS_CV) {
			if (Z_OPT_REFCOUNTED_P(result)) Z_ADDREF_P(result);
		} else if (IS_VAR == IS_VAR && ref) {
			zend_reference *r = Z_REF_P(ref);

			if (UNEXPECTED(GC_DELREF(r) == 0)) {
				efree_size(r, sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(result)) {
				Z_ADDREF_P(result);
			}
		}
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_COALESCE_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *ref = NULL;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_VAR & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
		if (IS_VAR & IS_VAR) {
			ref = value;
		}
		value = Z_REFVAL_P(value);
	}

	if (Z_TYPE_P(value) > IS_NULL) {
		zval *result = EX_VAR(opline->result.var);
		ZVAL_COPY_VALUE(result, value);
		if (IS_VAR == IS_CONST) {
			if (UNEXPECTED(Z_OPT_REFCOUNTED_P(result))) Z_ADDREF_P(result);
		} else if (IS_VAR == IS_CV) {
			if (Z_OPT_REFCOUNTED_P(result)) Z_ADDREF_P(result);
		} else if ((IS_VAR & IS_VAR) && ref) {
			zend_reference *r = Z_REF_P(ref);

			if (UNEXPECTED(GC_DELREF(r) == 0)) {
				efree_size(r, sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(result)) {
				Z_ADDREF_P(result);
			}
		}
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_QM_ASSIGN_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *result = EX_VAR(opline->result.var);

	value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (IS_VAR == IS_CV && UNEXPECTED(Z_TYPE_P(value) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(result);
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_VAR == IS_CV) {
		ZVAL_COPY_DEREF(result, value);
	} else if (IS_VAR == IS_VAR) {
		if (UNEXPECTED(Z_ISREF_P(value))) {
			ZVAL_COPY_VALUE(result, Z_REFVAL_P(value));
			if (UNEXPECTED(Z_DELREF_P(value) == 0)) {
				efree_size(Z_REF_P(value), sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(result)) {
				Z_ADDREF_P(result);
			}
		} else {
			ZVAL_COPY_VALUE(result, value);
		}
	} else {
		ZVAL_COPY_VALUE(result, value);
		if (IS_VAR == IS_CONST) {
			if (UNEXPECTED(Z_OPT_REFCOUNTED_P(result))) {
				Z_ADDREF_P(result);
			}
		}
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAR_SIMPLE_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	arg = ZEND_CALL_VAR(EX(call), opline->result.var);

	if (IS_VAR == IS_CV) {
		ZVAL_COPY(arg, varptr);
	} else /* if (IS_VAR == IS_VAR) */ {
		ZVAL_COPY_VALUE(arg, varptr);
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_IDENTICAL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CASE_STRICT_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_identical_function(op1, op2);

	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_not_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_OP_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *value;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = RT_CONSTANT(opline, opline->op2);

	do {
		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto assign_op_object;
			}
			if (IS_VAR == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

assign_op_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if (IS_CONST == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CONST == IS_CONST) ? CACHE_ADDR((opline+1)->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				zval *orig_zptr = zptr;
				zend_reference *ref;

				do {
					if (UNEXPECTED(Z_ISREF_P(zptr))) {
						ref = Z_REF_P(zptr);
						zptr = Z_REFVAL_P(zptr);
						if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
							zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
							break;
						}
					}

					if (IS_CONST == IS_CONST) {
						prop_info = (zend_property_info*)CACHED_PTR_EX(cache_slot + 2);
					} else {
						prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), orig_zptr);
					}
					if (UNEXPECTED(prop_info)) {
						/* special case for typed properties */
						zend_binary_assign_op_typed_prop(prop_info, zptr, value OPLINE_CC EXECUTE_DATA_CC);
					} else {
						zend_binary_op(zptr, zptr, value OPLINE_CC);
					}
				} while (0);

				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		} else {
			zend_assign_op_overloaded_property(zobj, name, cache_slot, value OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CONST != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMP|VAR|CV, UNUSED|CONST|TMPVAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_OP_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value, *container, *dim;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
assign_dim_op_array:
		SEPARATE_ARRAY(container);
assign_dim_op_new_array:
		dim = RT_CONSTANT(opline, opline->op2);
		if (IS_CONST == IS_UNUSED) {
			var_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(container), &EG(uninitialized_zval));
			if (UNEXPECTED(!var_ptr)) {
				zend_cannot_add_element();
				goto assign_dim_op_ret_null;
			}
		} else {
			if (IS_CONST == IS_CONST) {
				var_ptr = zend_fetch_dimension_address_inner_RW_CONST(Z_ARRVAL_P(container), dim EXECUTE_DATA_CC);
			} else {
				var_ptr = zend_fetch_dimension_address_inner_RW(Z_ARRVAL_P(container), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(!var_ptr)) {
				goto assign_dim_op_ret_null;
			}
		}

		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		do {
			if (IS_CONST != IS_UNUSED && UNEXPECTED(Z_ISREF_P(var_ptr))) {
				zend_reference *ref = Z_REF_P(var_ptr);
				var_ptr = Z_REFVAL_P(var_ptr);
				if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
					zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
					break;
				}
			}
			zend_binary_op(var_ptr, var_ptr, value OPLINE_CC);
		} while (0);

		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
		}
		FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	} else {
		if (EXPECTED(Z_ISREF_P(container))) {
			container = Z_REFVAL_P(container);
			if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				goto assign_dim_op_array;
			}
		}

		dim = RT_CONSTANT(opline, opline->op2);

		if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
			if (IS_CONST == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_binary_assign_op_obj_dim(container, dim OPLINE_CC EXECUTE_DATA_CC);
		} else if (EXPECTED(Z_TYPE_P(container) <= IS_FALSE)) {
			if (IS_VAR == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			ZVAL_ARR(container, zend_new_array(8));
			goto assign_dim_op_new_array;
		} else {
			zend_binary_assign_op_dim_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
assign_dim_op_ret_null:
			FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OP_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = RT_CONSTANT(opline, opline->op2);
	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	do {
		if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_REFERENCE)) {
			zend_reference *ref = Z_REF_P(var_ptr);
			var_ptr = Z_REFVAL_P(var_ptr);
			if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
				zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		zend_binary_op(var_ptr, var_ptr, value OPLINE_CC);
	} while (0);

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_INC_OBJ_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = RT_CONSTANT(opline, opline->op2);

	do {
		if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto pre_incdec_object;
			}
			if (IS_VAR == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

pre_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if (IS_CONST == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				if (IS_CONST == IS_CONST) {
					prop_info = (zend_property_info *) CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), zptr);
				}
				zend_pre_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			zend_pre_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CONST != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POST_INC_OBJ_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = RT_CONSTANT(opline, opline->op2);

	do {
		if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto post_incdec_object;
			}
			if (IS_VAR == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

post_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if (IS_CONST == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}
		cache_slot = (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			} else {
				if (IS_CONST == IS_CONST) {
					prop_info = (zend_property_info*)CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), zptr);
				}

				zend_post_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			zend_post_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CONST != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_W_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	zend_fetch_dimension_address_W(container, RT_CONSTANT(opline, opline->op2), IS_CONST OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_RW_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	zend_fetch_dimension_address_RW(container, RT_CONSTANT(opline, opline->op2), IS_CONST OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
        if ((IS_VAR & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
        }
		ZEND_VM_TAIL_CALL(ZEND_FETCH_DIM_W_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_CONST == IS_UNUSED) {
			ZEND_VM_TAIL_CALL(zend_use_undef_in_read_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_FETCH_DIM_R_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_UNSET_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	zend_fetch_dimension_address_UNSET(container, RT_CONSTANT(opline, opline->op2), IS_CONST OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_W_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();

	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(
		result, container, IS_VAR, property, IS_CONST,
		((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_FETCH_OBJ_FLAGS) : NULL),
		BP_VAR_W, opline->extended_value & ZEND_FETCH_OBJ_FLAGS, 1 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_RW_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(result, container, IS_VAR, property, IS_CONST, ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_RW, 0, 1 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_VAR & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_W_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_R_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *property, *result;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(result, container, IS_VAR, property, IS_CONST, ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_UNSET, 0, 1 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_LIST_W_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	dim = RT_CONSTANT(opline, opline->op2);

	if (IS_VAR == IS_VAR
		&& Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT
		&& UNEXPECTED(!Z_ISREF_P(container))
	) {
		zend_error(E_NOTICE, "Attempting to set reference to non referenceable value");
		zend_fetch_dimension_address_LIST_r(container, dim, IS_CONST OPLINE_CC EXECUTE_DATA_CC);
	} else {
		zend_fetch_dimension_address_W(container, dim, IS_CONST OPLINE_CC EXECUTE_DATA_CC);
	}

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = RT_CONSTANT(opline, opline->op2);
	value = RT_CONSTANT((opline+1), (opline+1)->op1);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CONST == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_CONST == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_CONST == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_CONST, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_CONST != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_CONST == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_CONST == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CONST == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = RT_CONSTANT(opline, opline->op2);
	value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CONST == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_TMP_VAR == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_TMP_VAR == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_TMP_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_TMP_VAR != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_TMP_VAR == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_TMP_VAR == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CONST == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = RT_CONSTANT(opline, opline->op2);
	value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CONST == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_VAR == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_VAR == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_VAR, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_VAR != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_VAR == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_VAR == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CONST == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = RT_CONSTANT(opline, opline->op2);
	value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CONST == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_CV == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_CV == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_CV, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_CV != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_CV == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_CV == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_CV == IS_CV || IS_CV == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CONST == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CONST == IS_UNUSED) {
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CONST == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_CONST == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CONST == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			value = zend_assign_to_variable(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = RT_CONSTANT(opline, opline->op2);
			value = RT_CONSTANT((opline+1), (opline+1)->op1);

			if (IS_CONST == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CONST == IS_UNUSED) {
				zend_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = RT_CONSTANT(opline, opline->op2);
				value = RT_CONSTANT((opline+1), (opline+1)->op1);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = RT_CONSTANT(opline, opline->op2);

				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = RT_CONSTANT(opline, opline->op2);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CONST != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CONST == IS_UNUSED) {
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_TMP_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_TMP_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_TMP_VAR == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = RT_CONSTANT(opline, opline->op2);
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

			if (IS_CONST == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CONST == IS_UNUSED) {
				zend_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = RT_CONSTANT(opline, opline->op2);
				value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = RT_CONSTANT(opline, opline->op2);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = RT_CONSTANT(opline, opline->op2);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CONST != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CONST == IS_UNUSED) {
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_VAR == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = RT_CONSTANT(opline, opline->op2);
			value = _get_zval_ptr_var_deref((opline+1)->op1.var EXECUTE_DATA_CC);

			if (IS_CONST == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CONST == IS_UNUSED) {
				zend_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = RT_CONSTANT(opline, opline->op2);
				value = _get_zval_ptr_var_deref((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = RT_CONSTANT(opline, opline->op2);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = RT_CONSTANT(opline, opline->op2);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CONST != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CONST == IS_UNUSED) {
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_CV == IS_CV || IS_CV == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CV == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_CV == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CV == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = RT_CONSTANT(opline, opline->op2);
			value = _get_zval_ptr_cv_deref_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

			if (IS_CONST == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CONST == IS_UNUSED) {
				zend_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = RT_CONSTANT(opline, opline->op2);
				value = _get_zval_ptr_cv_deref_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = RT_CONSTANT(opline, opline->op2);

				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = RT_CONSTANT(opline, opline->op2);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CONST != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_SPEC_VAR_CONST_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = RT_CONSTANT(opline, opline->op2);
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	value = zend_assign_to_variable(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES());
	if (UNEXPECTED(0)) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* zend_assign_to_variable() always takes care of op2, never free it! */

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_SPEC_VAR_CONST_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = RT_CONSTANT(opline, opline->op2);
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	value = zend_assign_to_variable(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES());
	if (UNEXPECTED(1)) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* zend_assign_to_variable() always takes care of op2, never free it! */

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = RT_CONSTANT(opline, opline->op2);

	value_ptr = _get_zval_ptr_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_VAR == IS_UNUSED) {
			if (IS_CONST == IS_CONST) {
				zend_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CONST == IS_CONST) {
				zend_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		zend_assign_to_property_reference(container, IS_VAR, property, IS_CONST, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));;
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = RT_CONSTANT(opline, opline->op2);

	value_ptr = _get_zval_ptr_cv_BP_VAR_W((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_VAR == IS_UNUSED) {
			if (IS_CONST == IS_CONST) {
				zend_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CONST == IS_CONST) {
				zend_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		zend_assign_to_property_reference(container, IS_VAR, property, IS_CONST, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));


	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	uint32_t call_info;
	zend_function *fbc;
	zend_execute_data *call;

	SAVE_OPLINE();

	if (IS_VAR == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op1)), Z_STR_P(RT_CONSTANT(opline, opline->op1) + 1), ZEND_FETCH_CLASS_DEFAULT | ZEND_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {

				HANDLE_EXCEPTION();
			}
			if (IS_CONST != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_VAR == IS_UNUSED) {
		ce = zend_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {

			HANDLE_EXCEPTION();
		}
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_VAR == IS_CONST &&
	    IS_CONST == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_VAR != IS_CONST &&
	           IS_CONST == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if (IS_CONST != IS_UNUSED) {
		function_name = RT_CONSTANT(opline, opline->op2);
		if (IS_CONST != IS_CONST) {
			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				do {
					if (IS_CONST & (IS_VAR|IS_CV) && Z_ISREF_P(function_name)) {
						function_name = Z_REFVAL_P(function_name);
						if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					zend_throw_error(NULL, "Method name must be a string");

					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, Z_STR_P(function_name));
		} else {
			fbc = zend_std_get_static_method(ce, Z_STR_P(function_name), ((IS_CONST == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(ce, Z_STR_P(function_name));
			}

			HANDLE_EXCEPTION();
		}
		if (IS_CONST == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE)))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if (IS_CONST != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (Z_TYPE(EX(This)) == IS_OBJECT && Z_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_throw_error(NULL, "Cannot call private %s::__construct()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & ZEND_ACC_STATIC)) {
		if (Z_TYPE(EX(This)) == IS_OBJECT && instanceof_function(Z_OBJCE(EX(This)), ce)) {
			ce = (zend_class_entry*)Z_OBJ(EX(This));
			call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
		} else {
			zend_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is ZEND_FETCH_CLASS */
		if (IS_VAR == IS_UNUSED
		 && ((opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_PARENT ||
		     (opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_SELF)) {
			if (Z_TYPE(EX(This)) == IS_OBJECT) {
				ce = Z_OBJCE(EX(This));
			} else {
				ce = Z_CE(EX(This));
			}
		}
		call_info = ZEND_CALL_NESTED_FUNCTION;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAR_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	if (IS_CONST == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
	}

	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (IS_VAR == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(varptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(arg);
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_VAR == IS_CV) {
		ZVAL_COPY_DEREF(arg, varptr);
	} else /* if (IS_VAR == IS_VAR) */ {
		if (UNEXPECTED(Z_ISREF_P(varptr))) {
			zend_refcounted *ref = Z_COUNTED_P(varptr);

			varptr = Z_REFVAL_P(varptr);
			ZVAL_COPY_VALUE(arg, varptr);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(arg)) {
				Z_ADDREF_P(arg);
			}
		} else {
			ZVAL_COPY_VALUE(arg, varptr);
		}
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAR_NO_REF_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	if (IS_CONST == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
	}

	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	ZVAL_COPY_VALUE(arg, varptr);

	if (EXPECTED(Z_ISREF_P(varptr))) {
		ZEND_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	ZVAL_NEW_REF(arg, arg);
	zend_error(E_NOTICE, "Only variables should be passed by reference");
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAR_NO_REF_EX_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;
	uint32_t arg_num;

	if (IS_CONST == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(arg_num <= MAX_ARG_FLAG_NUM)) {
		if (!QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var;
		}

		varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		ZVAL_COPY_VALUE(arg, varptr);

		if (EXPECTED(Z_ISREF_P(varptr) ||
		    QUICK_ARG_MAY_BE_SENT_BY_REF(EX(call)->func, arg_num))) {
			ZEND_VM_NEXT_OPCODE();
		}
	} else {
		if (!ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var;
		}

		varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		ZVAL_COPY_VALUE(arg, varptr);

		if (EXPECTED(Z_ISREF_P(varptr) ||
		    ARG_MAY_BE_SENT_BY_REF(EX(call)->func, arg_num))) {
			ZEND_VM_NEXT_OPCODE();
		}
	}

	SAVE_OPLINE();
	ZVAL_NEW_REF(arg, arg);
	zend_error(E_NOTICE, "Only variables should be passed by reference");
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();

send_var:
	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (UNEXPECTED(Z_ISREF_P(varptr))) {
		zend_refcounted *ref = Z_COUNTED_P(varptr);

		varptr = Z_REFVAL_P(varptr);
		ZVAL_COPY_VALUE(arg, varptr);
		if (UNEXPECTED(GC_DELREF(ref) == 0)) {
			efree_size(ref, sizeof(zend_reference));
		} else if (Z_OPT_REFCOUNTED_P(arg)) {
			Z_ADDREF_P(arg);
		}
	} else {
		ZVAL_COPY_VALUE(arg, varptr);
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_REF_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	SAVE_OPLINE();
	if (IS_CONST == IS_CONST) {
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
	}

	varptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (Z_ISREF_P(varptr)) {
		Z_ADDREF_P(varptr);
	} else {
		ZVAL_MAKE_REF_EX(varptr, 2);
	}
	ZVAL_REF(arg, Z_REF_P(varptr));

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAR_EX_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;
	uint32_t arg_num;

	if (IS_CONST == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(arg_num <= MAX_ARG_FLAG_NUM)) {
		if (QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var_by_ref;
		}
	} else if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_var_by_ref:
		varptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (Z_ISREF_P(varptr)) {
			Z_ADDREF_P(varptr);
		} else {
			ZVAL_MAKE_REF_EX(varptr, 2);
		}
		ZVAL_REF(arg, Z_REF_P(varptr));

		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		ZEND_VM_NEXT_OPCODE();
	}

	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (IS_VAR == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(varptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(arg);
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_VAR == IS_CV) {
		ZVAL_COPY_DEREF(arg, varptr);
	} else /* if (IS_VAR == IS_VAR) */ {
		if (UNEXPECTED(Z_ISREF_P(varptr))) {
			zend_refcounted *ref = Z_COUNTED_P(varptr);

			varptr = Z_REFVAL_P(varptr);
			ZVAL_COPY_VALUE(arg, varptr);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(arg)) {
				Z_ADDREF_P(arg);
			}
		} else {
			ZVAL_COPY_VALUE(arg, varptr);
		}
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_FUNC_ARG_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	if (IS_CONST == IS_CONST) {
		// TODO: Would it make sense to share the cache slot with CHECK_FUNC_ARG?
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
	}

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
		varptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (Z_ISREF_P(varptr)) {
			Z_ADDREF_P(varptr);
		} else {
			ZVAL_MAKE_REF_EX(varptr, 2);
		}
		ZVAL_REF(arg, Z_REF_P(varptr));

		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		ZEND_VM_NEXT_OPCODE();
	}

	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (UNEXPECTED(Z_ISREF_P(varptr))) {
		zend_refcounted *ref = Z_COUNTED_P(varptr);

		varptr = Z_REFVAL_P(varptr);
		ZVAL_COPY_VALUE(arg, varptr);
		if (UNEXPECTED(GC_DELREF(ref) == 0)) {
			efree_size(ref, sizeof(zend_reference));
		} else if (Z_OPT_REFCOUNTED_P(arg)) {
			Z_ADDREF_P(arg);
		}
	} else {
		ZVAL_COPY_VALUE(arg, varptr);
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_CLASS_CONSTANT_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_class_entry *ce, *scope;
	zend_class_constant *c;
	zval *value, *zv;
	USE_OPLINE

	SAVE_OPLINE();

	do {
		if (IS_VAR == IS_CONST) {
			if (EXPECTED(CACHED_PTR(opline->extended_value + sizeof(void*)))) {
				value = CACHED_PTR(opline->extended_value + sizeof(void*));
				break;
			} else if (EXPECTED(CACHED_PTR(opline->extended_value))) {
				ce = CACHED_PTR(opline->extended_value);
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op1)), Z_STR_P(RT_CONSTANT(opline, opline->op1) + 1), ZEND_FETCH_CLASS_DEFAULT | ZEND_FETCH_CLASS_EXCEPTION);
				if (UNEXPECTED(ce == NULL)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));
					HANDLE_EXCEPTION();
				}
			}
		} else {
			if (IS_VAR == IS_UNUSED) {
				ce = zend_fetch_class(NULL, opline->op1.num);
				if (UNEXPECTED(ce == NULL)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));
					HANDLE_EXCEPTION();
				}
			} else {
				ce = Z_CE_P(EX_VAR(opline->op1.var));
			}
			if (EXPECTED(CACHED_PTR(opline->extended_value) == ce)) {
				value = CACHED_PTR(opline->extended_value + sizeof(void*));
				break;
			}
		}

		zv = zend_hash_find_ex(&ce->constants_table, Z_STR_P(RT_CONSTANT(opline, opline->op2)), 1);
		if (EXPECTED(zv != NULL)) {
			c = Z_PTR_P(zv);
			scope = EX(func)->op_array.scope;
			if (!zend_verify_const_access(c, scope)) {
				zend_throw_error(NULL, "Cannot access %s constant %s::%s", zend_visibility_string(Z_ACCESS_FLAGS(c->value)), ZSTR_VAL(ce->name), Z_STRVAL_P(RT_CONSTANT(opline, opline->op2)));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
			value = &c->value;
			if (Z_TYPE_P(value) == IS_CONSTANT_AST) {
				zval_update_constant_ex(value, c->ce);
				if (UNEXPECTED(EG(exception) != NULL)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));
					HANDLE_EXCEPTION();
				}
			}
			CACHE_POLYMORPHIC_PTR(opline->extended_value, ce, value);
		} else {
			zend_throw_error(NULL, "Undefined constant %s::%s",
				ZSTR_VAL(ce->name), Z_STRVAL_P(RT_CONSTANT(opline, opline->op2)));
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		}
	} while (0);

	ZVAL_COPY_OR_DUP(EX_VAR(opline->result.var), value);

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) &&
	    UNEXPECTED(opline->extended_value & ZEND_ARRAY_ELEMENT_REF)) {
		expr_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (Z_ISREF_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	} else {
		expr_ptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (IS_VAR == IS_TMP_VAR) {
			/* pass */
		} else if (IS_VAR == IS_CONST) {
			Z_TRY_ADDREF_P(expr_ptr);
		} else if (IS_VAR == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			Z_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_VAR == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(expr_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(expr_ptr);

				expr_ptr = Z_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(expr_ptr)) {
					Z_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_CONST != IS_UNUSED) {
		zval *offset = RT_CONSTANT(opline, opline->op2);
		zend_string *str;
		zend_ulong hval;

add_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if (IS_CONST != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index:
			zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(offset) == IS_REFERENCE)) {
			offset = Z_REFVAL_P(offset);
			goto add_again;
		} else if (Z_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (Z_TYPE_P(offset) == IS_DOUBLE) {
			hval = zend_dval_to_lval(Z_DVAL_P(offset));
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_RESOURCE) {
			zend_use_resource_as_offset(offset);
			hval = Z_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_CONST == IS_CV && Z_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			zend_illegal_offset();
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			zend_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_ARRAY_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_VAR != IS_UNUSED) {
		size = opline->extended_value >> ZEND_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, zend_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & ZEND_ARRAY_NOT_PACKED) {
			zend_hash_real_init_mixed(Z_ARRVAL_P(array));
		}
		ZEND_VM_TAIL_CALL(ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, zend_new_array(0));
		ZEND_VM_NEXT_OPCODE();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_UNSET_DIM_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	zend_ulong hval;
	zend_string *key;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = RT_CONSTANT(opline, opline->op2);

	do {
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
			HashTable *ht;

unset_dim_array:
			SEPARATE_ARRAY(container);
			ht = Z_ARRVAL_P(container);
offset_again:
			if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
				key = Z_STR_P(offset);
				if (IS_CONST != IS_CONST) {
					if (ZEND_HANDLE_NUMERIC(key, hval)) {
						goto num_index_dim;
					}
				}
str_index_dim:
				if (ht == &EG(symbol_table)) {
					zend_delete_global_variable(key);
				} else {
					zend_hash_del(ht, key);
				}
			} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
				hval = Z_LVAL_P(offset);
num_index_dim:
				zend_hash_index_del(ht, hval);
			} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(offset) == IS_REFERENCE)) {
				offset = Z_REFVAL_P(offset);
				goto offset_again;
			} else if (Z_TYPE_P(offset) == IS_DOUBLE) {
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_dim;
			} else if (Z_TYPE_P(offset) == IS_NULL) {
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else if (Z_TYPE_P(offset) == IS_FALSE) {
				hval = 0;
				goto num_index_dim;
			} else if (Z_TYPE_P(offset) == IS_TRUE) {
				hval = 1;
				goto num_index_dim;
			} else if (Z_TYPE_P(offset) == IS_RESOURCE) {
				hval = Z_RES_HANDLE_P(offset);
				goto num_index_dim;
			} else if (IS_CONST == IS_CV && Z_TYPE_P(offset) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else {
				zend_type_error("Illegal offset type in unset");
			}
			break;
		} else if (Z_ISREF_P(container)) {
			container = Z_REFVAL_P(container);
			if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				goto unset_dim_array;
			}
		}
		if (IS_VAR == IS_CV && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
			container = ZVAL_UNDEFINED_OP1();
		}
		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(offset) == IS_UNDEF)) {
			offset = ZVAL_UNDEFINED_OP2();
		}
		if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
			if (IS_CONST == IS_CONST && Z_EXTRA_P(offset) == ZEND_EXTRA_VALUE) {
				offset++;
			}
			Z_OBJ_HT_P(container)->unset_dimension(Z_OBJ_P(container), offset);
		} else if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) == IS_STRING)) {
			zend_throw_error(NULL, "Cannot unset string offsets");
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_UNSET_OBJ_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = RT_CONSTANT(opline, opline->op2);

	do {
		if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT)) {
			if (Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (Z_TYPE_P(container) != IS_OBJECT) {
					if (IS_VAR == IS_CV
					 && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP1();
					}
					break;
				}
			} else {
				break;
			}
		}
		if (IS_CONST == IS_CONST) {
			name = Z_STR_P(offset);
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				break;
			}
		}
		Z_OBJ_HT_P(container)->unset_property(Z_OBJ_P(container), name, ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL));
		if (IS_CONST != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_YIELD_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & ZEND_GENERATOR_FORCED_CLOSE)) {
		ZEND_VM_TAIL_CALL(zend_yield_in_closed_generator_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_VAR != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_VAR & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
						Z_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_VAR == IS_VAR) {
						ZEND_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == ZEND_RETURNS_FUNCTION
						 && !Z_ISREF_P(value_ptr)) {
							zend_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (Z_ISREF_P(value_ptr)) {
						Z_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, Z_REF_P(value_ptr));
				} while (0);

				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			}
		} else {
			zval *value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_VAR == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
					Z_ADDREF(generator->value);
				}
			} else if (IS_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if ((IS_VAR & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, Z_REFVAL_P(value));
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_VAR == IS_CV) {
					if (Z_OPT_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {
		zval *key = RT_CONSTANT(opline, opline->op2);
		if ((IS_CONST & (IS_CV|IS_VAR)) && UNEXPECTED(Z_TYPE_P(key)) == IS_REFERENCE) {
			key = Z_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IN_ARRAY_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;
	HashTable *ht = Z_ARRVAL_P(RT_CONSTANT(opline, opline->op2));
	zval *result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		result = zend_hash_find_ex(ht, Z_STR_P(op1), IS_VAR == IS_CONST);
	} else if (opline->extended_value) {
		if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
			result = zend_hash_index_find(ht, Z_LVAL_P(op1));
		} else {
			result = NULL;
		}
	} else if (Z_TYPE_P(op1) <= IS_FALSE) {
		result = zend_hash_find_ex(ht, ZSTR_EMPTY_ALLOC(), 1);
	} else {
		zend_string *key;
		zval key_tmp, *val;

		result = NULL;
		ZEND_HASH_FOREACH_STR_KEY_VAL(ht, key, val) {
			ZVAL_STR(&key_tmp, key);
			if (zend_compare(op1, &key_tmp) == 0) {
				result = val;
				break;
			}
		} ZEND_HASH_FOREACH_END();
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_OP_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *value;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto assign_op_object;
			}
			if (IS_VAR == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

assign_op_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR((opline+1)->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				zval *orig_zptr = zptr;
				zend_reference *ref;

				do {
					if (UNEXPECTED(Z_ISREF_P(zptr))) {
						ref = Z_REF_P(zptr);
						zptr = Z_REFVAL_P(zptr);
						if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
							zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
							break;
						}
					}

					if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
						prop_info = (zend_property_info*)CACHED_PTR_EX(cache_slot + 2);
					} else {
						prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), orig_zptr);
					}
					if (UNEXPECTED(prop_info)) {
						/* special case for typed properties */
						zend_binary_assign_op_typed_prop(prop_info, zptr, value OPLINE_CC EXECUTE_DATA_CC);
					} else {
						zend_binary_op(zptr, zptr, value OPLINE_CC);
					}
				} while (0);

				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		} else {
			zend_assign_op_overloaded_property(zobj, name, cache_slot, value OPLINE_CC EXECUTE_DATA_CC);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMP|VAR|CV, UNUSED|CONST|TMPVAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_OP_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value, *container, *dim;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
assign_dim_op_array:
		SEPARATE_ARRAY(container);
assign_dim_op_new_array:
		dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			var_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(container), &EG(uninitialized_zval));
			if (UNEXPECTED(!var_ptr)) {
				zend_cannot_add_element();
				goto assign_dim_op_ret_null;
			}
		} else {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				var_ptr = zend_fetch_dimension_address_inner_RW_CONST(Z_ARRVAL_P(container), dim EXECUTE_DATA_CC);
			} else {
				var_ptr = zend_fetch_dimension_address_inner_RW(Z_ARRVAL_P(container), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(!var_ptr)) {
				goto assign_dim_op_ret_null;
			}
		}

		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		do {
			if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(Z_ISREF_P(var_ptr))) {
				zend_reference *ref = Z_REF_P(var_ptr);
				var_ptr = Z_REFVAL_P(var_ptr);
				if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
					zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
					break;
				}
			}
			zend_binary_op(var_ptr, var_ptr, value OPLINE_CC);
		} while (0);

		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
		}
		FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	} else {
		if (EXPECTED(Z_ISREF_P(container))) {
			container = Z_REFVAL_P(container);
			if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				goto assign_dim_op_array;
			}
		}

		dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

		if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_binary_assign_op_obj_dim(container, dim OPLINE_CC EXECUTE_DATA_CC);
		} else if (EXPECTED(Z_TYPE_P(container) <= IS_FALSE)) {
			if (IS_VAR == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			ZVAL_ARR(container, zend_new_array(8));
			goto assign_dim_op_new_array;
		} else {
			zend_binary_assign_op_dim_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
assign_dim_op_ret_null:
			FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OP_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	do {
		if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_REFERENCE)) {
			zend_reference *ref = Z_REF_P(var_ptr);
			var_ptr = Z_REFVAL_P(var_ptr);
			if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
				zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		zend_binary_op(var_ptr, var_ptr, value OPLINE_CC);
	} while (0);

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_INC_OBJ_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto pre_incdec_object;
			}
			if (IS_VAR == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

pre_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					prop_info = (zend_property_info *) CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), zptr);
				}
				zend_pre_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			zend_pre_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POST_INC_OBJ_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto post_incdec_object;
			}
			if (IS_VAR == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

post_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}
		cache_slot = ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			} else {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					prop_info = (zend_property_info*)CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), zptr);
				}

				zend_post_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			zend_post_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_W_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	zend_fetch_dimension_address_W(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_RW_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	zend_fetch_dimension_address_RW(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
        if ((IS_VAR & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
        }
		ZEND_VM_TAIL_CALL(ZEND_FETCH_DIM_W_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			ZEND_VM_TAIL_CALL(zend_use_undef_in_read_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_UNSET_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	zend_fetch_dimension_address_UNSET(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_W_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();

	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(
		result, container, IS_VAR, property, (IS_TMP_VAR|IS_VAR),
		(((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_FETCH_OBJ_FLAGS) : NULL),
		BP_VAR_W, opline->extended_value & ZEND_FETCH_OBJ_FLAGS, 1 OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_RW_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(result, container, IS_VAR, property, (IS_TMP_VAR|IS_VAR), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_RW, 0, 1 OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_VAR & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_W_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_UNSET_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *property, *result;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(result, container, IS_VAR, property, (IS_TMP_VAR|IS_VAR), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_UNSET, 0, 1 OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_LIST_W_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR
		&& Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT
		&& UNEXPECTED(!Z_ISREF_P(container))
	) {
		zend_error(E_NOTICE, "Attempting to set reference to non referenceable value");
		zend_fetch_dimension_address_LIST_r(container, dim, (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	} else {
		zend_fetch_dimension_address_W(container, dim, (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	value = RT_CONSTANT((opline+1), (opline+1)->op1);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_CONST == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_CONST == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_CONST, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_CONST != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_CONST == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_CONST == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_TMP_VAR == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_TMP_VAR == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_TMP_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_TMP_VAR != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_TMP_VAR == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_TMP_VAR == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_VAR == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_VAR == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_VAR, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_VAR != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_VAR == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_VAR == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_CV == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_CV == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_CV, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_CV != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_CV == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_CV == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_CV == IS_CV || IS_CV == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CONST == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_CONST == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CONST == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			value = zend_assign_to_variable(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			value = RT_CONSTANT((opline+1), (opline+1)->op1);

			if ((IS_TMP_VAR|IS_VAR) == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
				zend_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				value = RT_CONSTANT((opline+1), (opline+1)->op1);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_TMP_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_TMP_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_TMP_VAR == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

			if ((IS_TMP_VAR|IS_VAR) == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
				zend_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_VAR == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			value = _get_zval_ptr_var_deref((opline+1)->op1.var EXECUTE_DATA_CC);

			if ((IS_TMP_VAR|IS_VAR) == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
				zend_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				value = _get_zval_ptr_var_deref((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_CV == IS_CV || IS_CV == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CV == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_CV == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CV == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			value = _get_zval_ptr_cv_deref_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

			if ((IS_TMP_VAR|IS_VAR) == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
				zend_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				value = _get_zval_ptr_cv_deref_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_VAR == IS_UNUSED) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				zend_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				zend_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		zend_assign_to_property_reference(container, IS_VAR, property, (IS_TMP_VAR|IS_VAR), value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));;
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_cv_BP_VAR_W((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_VAR == IS_UNUSED) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				zend_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				zend_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		zend_assign_to_property_reference(container, IS_VAR, property, (IS_TMP_VAR|IS_VAR), value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	uint32_t call_info;
	zend_function *fbc;
	zend_execute_data *call;

	SAVE_OPLINE();

	if (IS_VAR == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op1)), Z_STR_P(RT_CONSTANT(opline, opline->op1) + 1), ZEND_FETCH_CLASS_DEFAULT | ZEND_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {
				zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
				HANDLE_EXCEPTION();
			}
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_VAR == IS_UNUSED) {
		ce = zend_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			HANDLE_EXCEPTION();
		}
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_VAR == IS_CONST &&
	    (IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_VAR != IS_CONST &&
	           (IS_TMP_VAR|IS_VAR) == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				do {
					if ((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV) && Z_ISREF_P(function_name)) {
						function_name = Z_REFVAL_P(function_name);
						if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					zend_throw_error(NULL, "Method name must be a string");
					zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, Z_STR_P(function_name));
		} else {
			fbc = zend_std_get_static_method(ce, Z_STR_P(function_name), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(ce, Z_STR_P(function_name));
			}
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			HANDLE_EXCEPTION();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE)))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (Z_TYPE(EX(This)) == IS_OBJECT && Z_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_throw_error(NULL, "Cannot call private %s::__construct()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & ZEND_ACC_STATIC)) {
		if (Z_TYPE(EX(This)) == IS_OBJECT && instanceof_function(Z_OBJCE(EX(This)), ce)) {
			ce = (zend_class_entry*)Z_OBJ(EX(This));
			call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
		} else {
			zend_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is ZEND_FETCH_CLASS */
		if (IS_VAR == IS_UNUSED
		 && ((opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_PARENT ||
		     (opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_SELF)) {
			if (Z_TYPE(EX(This)) == IS_OBJECT) {
				ce = Z_OBJCE(EX(This));
			} else {
				ce = Z_CE(EX(This));
			}
		}
		call_info = ZEND_CALL_NESTED_FUNCTION;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) &&
	    UNEXPECTED(opline->extended_value & ZEND_ARRAY_ELEMENT_REF)) {
		expr_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (Z_ISREF_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	} else {
		expr_ptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (IS_VAR == IS_TMP_VAR) {
			/* pass */
		} else if (IS_VAR == IS_CONST) {
			Z_TRY_ADDREF_P(expr_ptr);
		} else if (IS_VAR == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			Z_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_VAR == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(expr_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(expr_ptr);

				expr_ptr = Z_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(expr_ptr)) {
					Z_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval *offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		zend_string *str;
		zend_ulong hval;

add_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index:
			zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(offset) == IS_REFERENCE)) {
			offset = Z_REFVAL_P(offset);
			goto add_again;
		} else if (Z_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (Z_TYPE_P(offset) == IS_DOUBLE) {
			hval = zend_dval_to_lval(Z_DVAL_P(offset));
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_RESOURCE) {
			zend_use_resource_as_offset(offset);
			hval = Z_RES_HANDLE_P(offset);
			goto num_index;
		} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && Z_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			zend_illegal_offset();
			zval_ptr_dtor_nogc(expr_ptr);
		}
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	} else {
		if (!zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			zend_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_ARRAY_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_VAR != IS_UNUSED) {
		size = opline->extended_value >> ZEND_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, zend_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & ZEND_ARRAY_NOT_PACKED) {
			zend_hash_real_init_mixed(Z_ARRVAL_P(array));
		}
		ZEND_VM_TAIL_CALL(ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, zend_new_array(0));
		ZEND_VM_NEXT_OPCODE();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_UNSET_DIM_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	zend_ulong hval;
	zend_string *key;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
			HashTable *ht;

unset_dim_array:
			SEPARATE_ARRAY(container);
			ht = Z_ARRVAL_P(container);
offset_again:
			if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
				key = Z_STR_P(offset);
				if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
					if (ZEND_HANDLE_NUMERIC(key, hval)) {
						goto num_index_dim;
					}
				}
str_index_dim:
				if (ht == &EG(symbol_table)) {
					zend_delete_global_variable(key);
				} else {
					zend_hash_del(ht, key);
				}
			} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
				hval = Z_LVAL_P(offset);
num_index_dim:
				zend_hash_index_del(ht, hval);
			} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(offset) == IS_REFERENCE)) {
				offset = Z_REFVAL_P(offset);
				goto offset_again;
			} else if (Z_TYPE_P(offset) == IS_DOUBLE) {
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_dim;
			} else if (Z_TYPE_P(offset) == IS_NULL) {
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else if (Z_TYPE_P(offset) == IS_FALSE) {
				hval = 0;
				goto num_index_dim;
			} else if (Z_TYPE_P(offset) == IS_TRUE) {
				hval = 1;
				goto num_index_dim;
			} else if (Z_TYPE_P(offset) == IS_RESOURCE) {
				hval = Z_RES_HANDLE_P(offset);
				goto num_index_dim;
			} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && Z_TYPE_P(offset) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else {
				zend_type_error("Illegal offset type in unset");
			}
			break;
		} else if (Z_ISREF_P(container)) {
			container = Z_REFVAL_P(container);
			if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				goto unset_dim_array;
			}
		}
		if (IS_VAR == IS_CV && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
			container = ZVAL_UNDEFINED_OP1();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(offset) == IS_UNDEF)) {
			offset = ZVAL_UNDEFINED_OP2();
		}
		if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST && Z_EXTRA_P(offset) == ZEND_EXTRA_VALUE) {
				offset++;
			}
			Z_OBJ_HT_P(container)->unset_dimension(Z_OBJ_P(container), offset);
		} else if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) == IS_STRING)) {
			zend_throw_error(NULL, "Cannot unset string offsets");
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_UNSET_OBJ_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT)) {
			if (Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (Z_TYPE_P(container) != IS_OBJECT) {
					if (IS_VAR == IS_CV
					 && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP1();
					}
					break;
				}
			} else {
				break;
			}
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = Z_STR_P(offset);
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				break;
			}
		}
		Z_OBJ_HT_P(container)->unset_property(Z_OBJ_P(container), name, (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL));
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_YIELD_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & ZEND_GENERATOR_FORCED_CLOSE)) {
		ZEND_VM_TAIL_CALL(zend_yield_in_closed_generator_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_VAR != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_VAR & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
						Z_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_VAR == IS_VAR) {
						ZEND_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == ZEND_RETURNS_FUNCTION
						 && !Z_ISREF_P(value_ptr)) {
							zend_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (Z_ISREF_P(value_ptr)) {
						Z_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, Z_REF_P(value_ptr));
				} while (0);

				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			}
		} else {
			zval *value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_VAR == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
					Z_ADDREF(generator->value);
				}
			} else if (IS_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if ((IS_VAR & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, Z_REFVAL_P(value));
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_VAR == IS_CV) {
					if (Z_OPT_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval *key = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if (((IS_TMP_VAR|IS_VAR) & (IS_CV|IS_VAR)) && UNEXPECTED(Z_TYPE_P(key)) == IS_REFERENCE) {
			key = Z_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_IDENTICAL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CASE_STRICT_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_IDENTICAL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_not_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_SPEC_VAR_TMP_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	value = zend_assign_to_variable(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
	if (UNEXPECTED(0)) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* zend_assign_to_variable() always takes care of op2, never free it! */

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_SPEC_VAR_TMP_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	value = zend_assign_to_variable(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
	if (UNEXPECTED(1)) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* zend_assign_to_variable() always takes care of op2, never free it! */

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_IDENTICAL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var_deref(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CASE_STRICT_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var_deref(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_IDENTICAL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var_deref(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_not_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_SPEC_VAR_VAR_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	value = zend_assign_to_variable(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES());
	if (UNEXPECTED(0)) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* zend_assign_to_variable() always takes care of op2, never free it! */

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_SPEC_VAR_VAR_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	value = zend_assign_to_variable(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES());
	if (UNEXPECTED(1)) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* zend_assign_to_variable() always takes care of op2, never free it! */

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_REF_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *variable_ptr;
	zval *value_ptr;

	SAVE_OPLINE();
	value_ptr = _get_zval_ptr_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR &&
	           UNEXPECTED(Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT)) {

		zend_throw_error(NULL, "Cannot assign by reference to an array dimension of an object");
		variable_ptr = &EG(uninitialized_zval);
	} else if (IS_VAR == IS_VAR &&
	           opline->extended_value == ZEND_RETURNS_FUNCTION &&
			   UNEXPECTED(!Z_ISREF_P(value_ptr))) {

		if (UNEXPECTED(!zend_wrong_assign_to_variable_reference(variable_ptr, value_ptr OPLINE_CC EXECUTE_DATA_CC))) {
			variable_ptr = &EG(uninitialized_zval);
		}
	} else {
		zend_assign_to_variable_reference(variable_ptr, value_ptr);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_OP_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value, *container, *dim;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
assign_dim_op_array:
		SEPARATE_ARRAY(container);
assign_dim_op_new_array:
		dim = NULL;
		if (IS_UNUSED == IS_UNUSED) {
			var_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(container), &EG(uninitialized_zval));
			if (UNEXPECTED(!var_ptr)) {
				zend_cannot_add_element();
				goto assign_dim_op_ret_null;
			}
		} else {
			if (IS_UNUSED == IS_CONST) {
				var_ptr = zend_fetch_dimension_address_inner_RW_CONST(Z_ARRVAL_P(container), dim EXECUTE_DATA_CC);
			} else {
				var_ptr = zend_fetch_dimension_address_inner_RW(Z_ARRVAL_P(container), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(!var_ptr)) {
				goto assign_dim_op_ret_null;
			}
		}

		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		do {
			if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_ISREF_P(var_ptr))) {
				zend_reference *ref = Z_REF_P(var_ptr);
				var_ptr = Z_REFVAL_P(var_ptr);
				if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
					zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
					break;
				}
			}
			zend_binary_op(var_ptr, var_ptr, value OPLINE_CC);
		} while (0);

		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
		}
		FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	} else {
		if (EXPECTED(Z_ISREF_P(container))) {
			container = Z_REFVAL_P(container);
			if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				goto assign_dim_op_array;
			}
		}

		dim = NULL;

		if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
			if (IS_UNUSED == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_binary_assign_op_obj_dim(container, dim OPLINE_CC EXECUTE_DATA_CC);
		} else if (EXPECTED(Z_TYPE_P(container) <= IS_FALSE)) {
			if (IS_VAR == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			ZVAL_ARR(container, zend_new_array(8));
			goto assign_dim_op_new_array;
		} else {
			zend_binary_assign_op_dim_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
assign_dim_op_ret_null:
			FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_W_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	zend_fetch_dimension_address_W(container, NULL, IS_UNUSED OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_RW_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	zend_fetch_dimension_address_RW(container, NULL, IS_UNUSED OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
        if ((IS_VAR & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
        }
		ZEND_VM_TAIL_CALL(ZEND_FETCH_DIM_W_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_UNUSED == IS_UNUSED) {
			ZEND_VM_TAIL_CALL(zend_use_undef_in_read_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_UNUSED == IS_UNUSED) {
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CONST == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_CONST == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CONST == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = NULL;
			if (IS_UNUSED == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			value = zend_assign_to_variable(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = NULL;
			value = RT_CONSTANT((opline+1), (opline+1)->op1);

			if (IS_UNUSED == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_UNUSED == IS_UNUSED) {
				zend_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = NULL;
				value = RT_CONSTANT((opline+1), (opline+1)->op1);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = NULL;

				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = NULL;
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_UNUSED != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_UNUSED == IS_UNUSED) {
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_TMP_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_TMP_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_TMP_VAR == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = NULL;
			if (IS_UNUSED == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = NULL;
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

			if (IS_UNUSED == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_UNUSED == IS_UNUSED) {
				zend_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = NULL;
				value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = NULL;
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = NULL;
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_UNUSED != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_UNUSED == IS_UNUSED) {
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_VAR == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = NULL;
			if (IS_UNUSED == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = NULL;
			value = _get_zval_ptr_var_deref((opline+1)->op1.var EXECUTE_DATA_CC);

			if (IS_UNUSED == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_UNUSED == IS_UNUSED) {
				zend_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = NULL;
				value = _get_zval_ptr_var_deref((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = NULL;
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = NULL;
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_UNUSED != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_UNUSED == IS_UNUSED) {
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_CV == IS_CV || IS_CV == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CV == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_CV == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CV == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = NULL;
			if (IS_UNUSED == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = NULL;
			value = _get_zval_ptr_cv_deref_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

			if (IS_UNUSED == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_UNUSED == IS_UNUSED) {
				zend_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = NULL;
				value = _get_zval_ptr_cv_deref_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = NULL;

				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = NULL;
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_UNUSED != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	uint32_t call_info;
	zend_function *fbc;
	zend_execute_data *call;

	SAVE_OPLINE();

	if (IS_VAR == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op1)), Z_STR_P(RT_CONSTANT(opline, opline->op1) + 1), ZEND_FETCH_CLASS_DEFAULT | ZEND_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {

				HANDLE_EXCEPTION();
			}
			if (IS_UNUSED != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_VAR == IS_UNUSED) {
		ce = zend_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {

			HANDLE_EXCEPTION();
		}
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_VAR == IS_CONST &&
	    IS_UNUSED == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_VAR != IS_CONST &&
	           IS_UNUSED == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if (IS_UNUSED != IS_UNUSED) {
		function_name = NULL;
		if (IS_UNUSED != IS_CONST) {
			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				do {
					if (IS_UNUSED & (IS_VAR|IS_CV) && Z_ISREF_P(function_name)) {
						function_name = Z_REFVAL_P(function_name);
						if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if (IS_UNUSED == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					zend_throw_error(NULL, "Method name must be a string");

					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, Z_STR_P(function_name));
		} else {
			fbc = zend_std_get_static_method(ce, Z_STR_P(function_name), ((IS_UNUSED == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(ce, Z_STR_P(function_name));
			}

			HANDLE_EXCEPTION();
		}
		if (IS_UNUSED == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE)))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if (IS_UNUSED != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (Z_TYPE(EX(This)) == IS_OBJECT && Z_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_throw_error(NULL, "Cannot call private %s::__construct()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & ZEND_ACC_STATIC)) {
		if (Z_TYPE(EX(This)) == IS_OBJECT && instanceof_function(Z_OBJCE(EX(This)), ce)) {
			ce = (zend_class_entry*)Z_OBJ(EX(This));
			call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
		} else {
			zend_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is ZEND_FETCH_CLASS */
		if (IS_VAR == IS_UNUSED
		 && ((opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_PARENT ||
		     (opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_SELF)) {
			if (Z_TYPE(EX(This)) == IS_OBJECT) {
				ce = Z_OBJCE(EX(This));
			} else {
				ce = Z_CE(EX(This));
			}
		}
		call_info = ZEND_CALL_NESTED_FUNCTION;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_VERIFY_RETURN_TYPE_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	if (IS_VAR == IS_UNUSED) {
		SAVE_OPLINE();
		zend_verify_missing_return_type(EX(func));
		HANDLE_EXCEPTION();
	} else {
/* prevents "undefined variable opline" errors */
#if 0 || (IS_VAR != IS_UNUSED)
		USE_OPLINE
		zval *retval_ref, *retval_ptr;
		zend_arg_info *ret_info = EX(func)->common.arg_info - 1;
		retval_ref = retval_ptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

		if (IS_VAR == IS_CONST) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval_ptr);
			retval_ref = retval_ptr = EX_VAR(opline->result.var);
		} else if (IS_VAR == IS_VAR) {
			if (UNEXPECTED(Z_TYPE_P(retval_ptr) == IS_INDIRECT)) {
				retval_ptr = Z_INDIRECT_P(retval_ptr);
			}
			ZVAL_DEREF(retval_ptr);
		} else if (IS_VAR == IS_CV) {
			ZVAL_DEREF(retval_ptr);
		}

		if (EXPECTED(ZEND_TYPE_CONTAINS_CODE(ret_info->type, Z_TYPE_P(retval_ptr)))) {
			ZEND_VM_NEXT_OPCODE();
		}

		if (IS_VAR == IS_CV && UNEXPECTED(Z_ISUNDEF_P(retval_ptr))) {
			SAVE_OPLINE();
			retval_ref = retval_ptr = ZVAL_UNDEFINED_OP1();
			if (ZEND_TYPE_FULL_MASK(ret_info->type) & MAY_BE_NULL) {
				ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
			}
		}

		zend_reference *ref = NULL;
		void *cache_slot = CACHE_ADDR(opline->op2.num);
		if (UNEXPECTED(retval_ref != retval_ptr)) {
			if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
				ref = Z_REF_P(retval_ref);
			} else {
				/* A cast might happen - unwrap the reference if this is a by-value return */
				if (Z_REFCOUNT_P(retval_ref) == 1) {
					ZVAL_UNREF(retval_ref);
				} else {
					Z_DELREF_P(retval_ref);
					ZVAL_COPY(retval_ref, retval_ptr);
				}
				retval_ptr = retval_ref;
			}
		}

		SAVE_OPLINE();
		if (UNEXPECTED(!zend_check_type_slow(ret_info->type, retval_ptr, ref, cache_slot, NULL, 1, 0))) {
			zend_verify_return_error(EX(func), retval_ptr);
			HANDLE_EXCEPTION();
		}
		ZEND_VM_NEXT_OPCODE();
#endif
	}
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAR_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
	}

	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (IS_VAR == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(varptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(arg);
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_VAR == IS_CV) {
		ZVAL_COPY_DEREF(arg, varptr);
	} else /* if (IS_VAR == IS_VAR) */ {
		if (UNEXPECTED(Z_ISREF_P(varptr))) {
			zend_refcounted *ref = Z_COUNTED_P(varptr);

			varptr = Z_REFVAL_P(varptr);
			ZVAL_COPY_VALUE(arg, varptr);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(arg)) {
				Z_ADDREF_P(arg);
			}
		} else {
			ZVAL_COPY_VALUE(arg, varptr);
		}
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAR_NO_REF_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
	}

	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	ZVAL_COPY_VALUE(arg, varptr);

	if (EXPECTED(Z_ISREF_P(varptr))) {
		ZEND_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	ZVAL_NEW_REF(arg, arg);
	zend_error(E_NOTICE, "Only variables should be passed by reference");
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(0)) {
		if (!QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var;
		}

		varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		ZVAL_COPY_VALUE(arg, varptr);

		if (EXPECTED(Z_ISREF_P(varptr) ||
		    QUICK_ARG_MAY_BE_SENT_BY_REF(EX(call)->func, arg_num))) {
			ZEND_VM_NEXT_OPCODE();
		}
	} else {
		if (!ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var;
		}

		varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		ZVAL_COPY_VALUE(arg, varptr);

		if (EXPECTED(Z_ISREF_P(varptr) ||
		    ARG_MAY_BE_SENT_BY_REF(EX(call)->func, arg_num))) {
			ZEND_VM_NEXT_OPCODE();
		}
	}

	SAVE_OPLINE();
	ZVAL_NEW_REF(arg, arg);
	zend_error(E_NOTICE, "Only variables should be passed by reference");
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();

send_var:
	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (UNEXPECTED(Z_ISREF_P(varptr))) {
		zend_refcounted *ref = Z_COUNTED_P(varptr);

		varptr = Z_REFVAL_P(varptr);
		ZVAL_COPY_VALUE(arg, varptr);
		if (UNEXPECTED(GC_DELREF(ref) == 0)) {
			efree_size(ref, sizeof(zend_reference));
		} else if (Z_OPT_REFCOUNTED_P(arg)) {
			Z_ADDREF_P(arg);
		}
	} else {
		ZVAL_COPY_VALUE(arg, varptr);
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED_QUICK_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(1)) {
		if (!QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var;
		}

		varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		ZVAL_COPY_VALUE(arg, varptr);

		if (EXPECTED(Z_ISREF_P(varptr) ||
		    QUICK_ARG_MAY_BE_SENT_BY_REF(EX(call)->func, arg_num))) {
			ZEND_VM_NEXT_OPCODE();
		}
	} else {
		if (!ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var;
		}

		varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		ZVAL_COPY_VALUE(arg, varptr);

		if (EXPECTED(Z_ISREF_P(varptr) ||
		    ARG_MAY_BE_SENT_BY_REF(EX(call)->func, arg_num))) {
			ZEND_VM_NEXT_OPCODE();
		}
	}

	SAVE_OPLINE();
	ZVAL_NEW_REF(arg, arg);
	zend_error(E_NOTICE, "Only variables should be passed by reference");
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();

send_var:
	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (UNEXPECTED(Z_ISREF_P(varptr))) {
		zend_refcounted *ref = Z_COUNTED_P(varptr);

		varptr = Z_REFVAL_P(varptr);
		ZVAL_COPY_VALUE(arg, varptr);
		if (UNEXPECTED(GC_DELREF(ref) == 0)) {
			efree_size(ref, sizeof(zend_reference));
		} else if (Z_OPT_REFCOUNTED_P(arg)) {
			Z_ADDREF_P(arg);
		}
	} else {
		ZVAL_COPY_VALUE(arg, varptr);
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_REF_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	SAVE_OPLINE();
	if (IS_UNUSED == IS_CONST) {
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
	}

	varptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (Z_ISREF_P(varptr)) {
		Z_ADDREF_P(varptr);
	} else {
		ZVAL_MAKE_REF_EX(varptr, 2);
	}
	ZVAL_REF(arg, Z_REF_P(varptr));

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAR_EX_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(0)) {
		if (QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var_by_ref;
		}
	} else if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_var_by_ref:
		varptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (Z_ISREF_P(varptr)) {
			Z_ADDREF_P(varptr);
		} else {
			ZVAL_MAKE_REF_EX(varptr, 2);
		}
		ZVAL_REF(arg, Z_REF_P(varptr));

		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		ZEND_VM_NEXT_OPCODE();
	}

	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (IS_VAR == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(varptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(arg);
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_VAR == IS_CV) {
		ZVAL_COPY_DEREF(arg, varptr);
	} else /* if (IS_VAR == IS_VAR) */ {
		if (UNEXPECTED(Z_ISREF_P(varptr))) {
			zend_refcounted *ref = Z_COUNTED_P(varptr);

			varptr = Z_REFVAL_P(varptr);
			ZVAL_COPY_VALUE(arg, varptr);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(arg)) {
				Z_ADDREF_P(arg);
			}
		} else {
			ZVAL_COPY_VALUE(arg, varptr);
		}
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAR_EX_SPEC_VAR_UNUSED_QUICK_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(1)) {
		if (QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var_by_ref;
		}
	} else if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_var_by_ref:
		varptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (Z_ISREF_P(varptr)) {
			Z_ADDREF_P(varptr);
		} else {
			ZVAL_MAKE_REF_EX(varptr, 2);
		}
		ZVAL_REF(arg, Z_REF_P(varptr));

		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		ZEND_VM_NEXT_OPCODE();
	}

	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (IS_VAR == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(varptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(arg);
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_VAR == IS_CV) {
		ZVAL_COPY_DEREF(arg, varptr);
	} else /* if (IS_VAR == IS_VAR) */ {
		if (UNEXPECTED(Z_ISREF_P(varptr))) {
			zend_refcounted *ref = Z_COUNTED_P(varptr);

			varptr = Z_REFVAL_P(varptr);
			ZVAL_COPY_VALUE(arg, varptr);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(arg)) {
				Z_ADDREF_P(arg);
			}
		} else {
			ZVAL_COPY_VALUE(arg, varptr);
		}
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	if (IS_UNUSED == IS_CONST) {
		// TODO: Would it make sense to share the cache slot with CHECK_FUNC_ARG?
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
	}

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
		varptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (Z_ISREF_P(varptr)) {
			Z_ADDREF_P(varptr);
		} else {
			ZVAL_MAKE_REF_EX(varptr, 2);
		}
		ZVAL_REF(arg, Z_REF_P(varptr));

		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		ZEND_VM_NEXT_OPCODE();
	}

	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (UNEXPECTED(Z_ISREF_P(varptr))) {
		zend_refcounted *ref = Z_COUNTED_P(varptr);

		varptr = Z_REFVAL_P(varptr);
		ZVAL_COPY_VALUE(arg, varptr);
		if (UNEXPECTED(GC_DELREF(ref) == 0)) {
			efree_size(ref, sizeof(zend_reference));
		} else if (Z_OPT_REFCOUNTED_P(arg)) {
			Z_ADDREF_P(arg);
		}
	} else {
		ZVAL_COPY_VALUE(arg, varptr);
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_NEW_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *result;
	zend_function *constructor;
	zend_class_entry *ce;
	zend_execute_data *call;

	SAVE_OPLINE();
	if (IS_VAR == IS_CONST) {
		ce = CACHED_PTR(opline->op2.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op1)), Z_STR_P(RT_CONSTANT(opline, opline->op1) + 1), ZEND_FETCH_CLASS_DEFAULT | ZEND_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
			CACHE_PTR(opline->op2.num, ce);
		}
	} else if (IS_VAR == IS_UNUSED) {
		ce = zend_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		}
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));
	}

	result = EX_VAR(opline->result.var);
	if (UNEXPECTED(object_init_ex(result, ce) != SUCCESS)) {
		ZVAL_UNDEF(result);
		HANDLE_EXCEPTION();
	}

	constructor = Z_OBJ_HT_P(result)->get_constructor(Z_OBJ_P(result));
	if (constructor == NULL) {
		if (UNEXPECTED(EG(exception))) {
			HANDLE_EXCEPTION();
		}

		/* If there are no arguments, skip over the DO_FCALL opcode. We check if the next
		 * opcode is DO_FCALL in case EXT instructions are used. */
		if (EXPECTED(opline->extended_value == 0 && (opline+1)->opcode == ZEND_DO_FCALL)) {
			ZEND_VM_NEXT_OPCODE_EX(1, 2);
		}

		/* Perform a dummy function call */
		call = zend_vm_stack_push_call_frame(
			ZEND_CALL_FUNCTION, (zend_function *) &zend_pass_function,
			opline->extended_value, NULL);
	} else {
		if (EXPECTED(constructor->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&constructor->op_array))) {
			init_func_run_time_cache(&constructor->op_array);
		}
		/* We are not handling overloaded classes right now */
		call = zend_vm_stack_push_call_frame(
			ZEND_CALL_FUNCTION | ZEND_CALL_RELEASE_THIS | ZEND_CALL_HAS_THIS,
			constructor,
			opline->extended_value,
			Z_OBJ_P(result));
		Z_ADDREF_P(result);
	}

	call->prev_execute_data = EX(call);
	EX(call) = call;
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) &&
	    UNEXPECTED(opline->extended_value & ZEND_ARRAY_ELEMENT_REF)) {
		expr_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (Z_ISREF_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	} else {
		expr_ptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (IS_VAR == IS_TMP_VAR) {
			/* pass */
		} else if (IS_VAR == IS_CONST) {
			Z_TRY_ADDREF_P(expr_ptr);
		} else if (IS_VAR == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			Z_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_VAR == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(expr_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(expr_ptr);

				expr_ptr = Z_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(expr_ptr)) {
					Z_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_UNUSED != IS_UNUSED) {
		zval *offset = NULL;
		zend_string *str;
		zend_ulong hval;

add_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if (IS_UNUSED != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index:
			zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_UNUSED & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(offset) == IS_REFERENCE)) {
			offset = Z_REFVAL_P(offset);
			goto add_again;
		} else if (Z_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (Z_TYPE_P(offset) == IS_DOUBLE) {
			hval = zend_dval_to_lval(Z_DVAL_P(offset));
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_RESOURCE) {
			zend_use_resource_as_offset(offset);
			hval = Z_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_UNUSED == IS_CV && Z_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			zend_illegal_offset();
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			zend_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_ARRAY_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_VAR != IS_UNUSED) {
		size = opline->extended_value >> ZEND_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, zend_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & ZEND_ARRAY_NOT_PACKED) {
			zend_hash_real_init_mixed(Z_ARRVAL_P(array));
		}
		ZEND_VM_TAIL_CALL(ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, zend_new_array(0));
		ZEND_VM_NEXT_OPCODE();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEPARATE_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	if (UNEXPECTED(Z_ISREF_P(var_ptr))) {
		if (UNEXPECTED(Z_REFCOUNT_P(var_ptr) == 1)) {
			ZVAL_UNREF(var_ptr);
		}
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_YIELD_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & ZEND_GENERATOR_FORCED_CLOSE)) {
		ZEND_VM_TAIL_CALL(zend_yield_in_closed_generator_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_VAR != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_VAR & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
						Z_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_VAR == IS_VAR) {
						ZEND_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == ZEND_RETURNS_FUNCTION
						 && !Z_ISREF_P(value_ptr)) {
							zend_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (Z_ISREF_P(value_ptr)) {
						Z_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, Z_REF_P(value_ptr));
				} while (0);

				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			}
		} else {
			zval *value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_VAR == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
					Z_ADDREF(generator->value);
				}
			} else if (IS_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if ((IS_VAR & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, Z_REFVAL_P(value));
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_VAR == IS_CV) {
					if (Z_OPT_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {
		zval *key = NULL;
		if ((IS_UNUSED & (IS_CV|IS_VAR)) && UNEXPECTED(Z_TYPE_P(key)) == IS_REFERENCE) {
			key = Z_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_MAKE_REF_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1 = EX_VAR(opline->op1.var);

	if (IS_VAR == IS_CV) {
		if (UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_NEW_EMPTY_REF(op1);
			Z_SET_REFCOUNT_P(op1, 2);
			ZVAL_NULL(Z_REFVAL_P(op1));
			ZVAL_REF(EX_VAR(opline->result.var), Z_REF_P(op1));
		} else {
			if (Z_ISREF_P(op1)) {
				Z_ADDREF_P(op1);
			} else {
				ZVAL_MAKE_REF_EX(op1, 2);
			}
			ZVAL_REF(EX_VAR(opline->result.var), Z_REF_P(op1));
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_INDIRECT)) {
		op1 = Z_INDIRECT_P(op1);
		if (EXPECTED(!Z_ISREF_P(op1))) {
			ZVAL_MAKE_REF_EX(op1, 2);
		} else {
			GC_ADDREF(Z_REF_P(op1));
		}
		ZVAL_REF(EX_VAR(opline->result.var), Z_REF_P(op1));
	} else {
		ZVAL_COPY_VALUE(EX_VAR(opline->result.var), op1);
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_GET_TYPE_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;
	zend_string *type;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	type = zend_zval_get_legacy_type(op1);
	if (EXPECTED(type)) {
		ZVAL_INTERNED_STR(EX_VAR(opline->result.var), type);
	} else {
		ZVAL_STRING(EX_VAR(opline->result.var), "unknown type");
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAR_EX_SIMPLE_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;
	uint32_t arg_num = opline->op2.num;

	if (QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
		ZEND_VM_TAIL_CALL(ZEND_SEND_REF_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	arg = ZEND_CALL_VAR(EX(call), opline->result.var);

	if (IS_VAR == IS_CV) {
		ZVAL_COPY(arg, varptr);
	} else /* if (IS_VAR == IS_VAR) */ {
		ZVAL_COPY_VALUE(arg, varptr);
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CASE_STRICT_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);

	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_OP_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *value;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto assign_op_object;
			}
			if (IS_VAR == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

assign_op_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if (IS_CV == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CV == IS_CONST) ? CACHE_ADDR((opline+1)->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				zval *orig_zptr = zptr;
				zend_reference *ref;

				do {
					if (UNEXPECTED(Z_ISREF_P(zptr))) {
						ref = Z_REF_P(zptr);
						zptr = Z_REFVAL_P(zptr);
						if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
							zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
							break;
						}
					}

					if (IS_CV == IS_CONST) {
						prop_info = (zend_property_info*)CACHED_PTR_EX(cache_slot + 2);
					} else {
						prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), orig_zptr);
					}
					if (UNEXPECTED(prop_info)) {
						/* special case for typed properties */
						zend_binary_assign_op_typed_prop(prop_info, zptr, value OPLINE_CC EXECUTE_DATA_CC);
					} else {
						zend_binary_op(zptr, zptr, value OPLINE_CC);
					}
				} while (0);

				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		} else {
			zend_assign_op_overloaded_property(zobj, name, cache_slot, value OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CV != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMP|VAR|CV, UNUSED|CONST|TMPVAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_OP_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value, *container, *dim;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
assign_dim_op_array:
		SEPARATE_ARRAY(container);
assign_dim_op_new_array:
		dim = EX_VAR(opline->op2.var);
		if (IS_CV == IS_UNUSED) {
			var_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(container), &EG(uninitialized_zval));
			if (UNEXPECTED(!var_ptr)) {
				zend_cannot_add_element();
				goto assign_dim_op_ret_null;
			}
		} else {
			if (IS_CV == IS_CONST) {
				var_ptr = zend_fetch_dimension_address_inner_RW_CONST(Z_ARRVAL_P(container), dim EXECUTE_DATA_CC);
			} else {
				var_ptr = zend_fetch_dimension_address_inner_RW(Z_ARRVAL_P(container), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(!var_ptr)) {
				goto assign_dim_op_ret_null;
			}
		}

		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		do {
			if (IS_CV != IS_UNUSED && UNEXPECTED(Z_ISREF_P(var_ptr))) {
				zend_reference *ref = Z_REF_P(var_ptr);
				var_ptr = Z_REFVAL_P(var_ptr);
				if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
					zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
					break;
				}
			}
			zend_binary_op(var_ptr, var_ptr, value OPLINE_CC);
		} while (0);

		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
		}
		FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	} else {
		if (EXPECTED(Z_ISREF_P(container))) {
			container = Z_REFVAL_P(container);
			if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				goto assign_dim_op_array;
			}
		}

		dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

		if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
			if (IS_CV == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_binary_assign_op_obj_dim(container, dim OPLINE_CC EXECUTE_DATA_CC);
		} else if (EXPECTED(Z_TYPE_P(container) <= IS_FALSE)) {
			if (IS_VAR == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			ZVAL_ARR(container, zend_new_array(8));
			goto assign_dim_op_new_array;
		} else {
			zend_binary_assign_op_dim_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
assign_dim_op_ret_null:
			FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OP_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	do {
		if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_REFERENCE)) {
			zend_reference *ref = Z_REF_P(var_ptr);
			var_ptr = Z_REFVAL_P(var_ptr);
			if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
				zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		zend_binary_op(var_ptr, var_ptr, value OPLINE_CC);
	} while (0);

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_INC_OBJ_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto pre_incdec_object;
			}
			if (IS_VAR == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

pre_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if (IS_CV == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				if (IS_CV == IS_CONST) {
					prop_info = (zend_property_info *) CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), zptr);
				}
				zend_pre_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			zend_pre_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CV != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POST_INC_OBJ_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto post_incdec_object;
			}
			if (IS_VAR == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

post_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if (IS_CV == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}
		cache_slot = (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			} else {
				if (IS_CV == IS_CONST) {
					prop_info = (zend_property_info*)CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), zptr);
				}

				zend_post_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			zend_post_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CV != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_W_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	zend_fetch_dimension_address_W(container, EX_VAR(opline->op2.var), IS_CV OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_RW_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	zend_fetch_dimension_address_RW(container, EX_VAR(opline->op2.var), IS_CV OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
        if ((IS_VAR & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
        }
		ZEND_VM_TAIL_CALL(ZEND_FETCH_DIM_W_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_CV == IS_UNUSED) {
			ZEND_VM_TAIL_CALL(zend_use_undef_in_read_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_FETCH_DIM_R_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_UNSET_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	zend_fetch_dimension_address_UNSET(container, EX_VAR(opline->op2.var), IS_CV OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_W_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();

	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(
		result, container, IS_VAR, property, IS_CV,
		((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_FETCH_OBJ_FLAGS) : NULL),
		BP_VAR_W, opline->extended_value & ZEND_FETCH_OBJ_FLAGS, 1 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_RW_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(result, container, IS_VAR, property, IS_CV, ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_RW, 0, 1 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_VAR & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_W_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_R_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *property, *result;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(result, container, IS_VAR, property, IS_CV, ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_UNSET, 0, 1 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_LIST_W_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	dim = EX_VAR(opline->op2.var);

	if (IS_VAR == IS_VAR
		&& Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT
		&& UNEXPECTED(!Z_ISREF_P(container))
	) {
		zend_error(E_NOTICE, "Attempting to set reference to non referenceable value");
		zend_fetch_dimension_address_LIST_r(container, dim, IS_CV OPLINE_CC EXECUTE_DATA_CC);
	} else {
		zend_fetch_dimension_address_W(container, dim, IS_CV OPLINE_CC EXECUTE_DATA_CC);
	}

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	value = RT_CONSTANT((opline+1), (opline+1)->op1);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CV == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_CONST == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_CONST == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_CONST, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_CONST != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_CONST == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_CONST == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CV == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CV == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_TMP_VAR == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_TMP_VAR == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_TMP_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_TMP_VAR != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_TMP_VAR == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_TMP_VAR == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CV == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CV == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_VAR == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_VAR == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_VAR, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_VAR != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_VAR == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_VAR == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CV == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CV == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_CV == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_CV == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_CV, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_CV != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_CV == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_CV == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_CV == IS_CV || IS_CV == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CV == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CV == IS_UNUSED) {
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CONST == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_CONST == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CONST == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			value = zend_assign_to_variable(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
			value = RT_CONSTANT((opline+1), (opline+1)->op1);

			if (IS_CV == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CV == IS_UNUSED) {
				zend_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
				value = RT_CONSTANT((opline+1), (opline+1)->op1);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CV != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CV == IS_UNUSED) {
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_TMP_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_TMP_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_TMP_VAR == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

			if (IS_CV == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CV == IS_UNUSED) {
				zend_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
				value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CV != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CV == IS_UNUSED) {
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_VAR == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
			value = _get_zval_ptr_var_deref((opline+1)->op1.var EXECUTE_DATA_CC);

			if (IS_CV == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CV == IS_UNUSED) {
				zend_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
				value = _get_zval_ptr_var_deref((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CV != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CV == IS_UNUSED) {
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_CV == IS_CV || IS_CV == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CV == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_CV == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CV == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
			value = _get_zval_ptr_cv_deref_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

			if (IS_CV == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CV == IS_UNUSED) {
				zend_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
				value = _get_zval_ptr_cv_deref_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CV != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_SPEC_VAR_CV_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	value = zend_assign_to_variable(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES());
	if (UNEXPECTED(0)) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* zend_assign_to_variable() always takes care of op2, never free it! */

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_SPEC_VAR_CV_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	value = zend_assign_to_variable(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES());
	if (UNEXPECTED(1)) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* zend_assign_to_variable() always takes care of op2, never free it! */

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_REF_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *variable_ptr;
	zval *value_ptr;

	SAVE_OPLINE();
	value_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR &&
	           UNEXPECTED(Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT)) {

		zend_throw_error(NULL, "Cannot assign by reference to an array dimension of an object");
		variable_ptr = &EG(uninitialized_zval);
	} else if (IS_CV == IS_VAR &&
	           opline->extended_value == ZEND_RETURNS_FUNCTION &&
			   UNEXPECTED(!Z_ISREF_P(value_ptr))) {

		if (UNEXPECTED(!zend_wrong_assign_to_variable_reference(variable_ptr, value_ptr OPLINE_CC EXECUTE_DATA_CC))) {
			variable_ptr = &EG(uninitialized_zval);
		}
	} else {
		zend_assign_to_variable_reference(variable_ptr, value_ptr);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_VAR == IS_UNUSED) {
			if (IS_CV == IS_CONST) {
				zend_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CV == IS_CONST) {
				zend_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		zend_assign_to_property_reference(container, IS_VAR, property, IS_CV, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));;
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_cv_BP_VAR_W((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_VAR == IS_UNUSED) {
			if (IS_CV == IS_CONST) {
				zend_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CV == IS_CONST) {
				zend_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		zend_assign_to_property_reference(container, IS_VAR, property, IS_CV, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));


	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	uint32_t call_info;
	zend_function *fbc;
	zend_execute_data *call;

	SAVE_OPLINE();

	if (IS_VAR == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op1)), Z_STR_P(RT_CONSTANT(opline, opline->op1) + 1), ZEND_FETCH_CLASS_DEFAULT | ZEND_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {

				HANDLE_EXCEPTION();
			}
			if (IS_CV != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_VAR == IS_UNUSED) {
		ce = zend_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {

			HANDLE_EXCEPTION();
		}
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_VAR == IS_CONST &&
	    IS_CV == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_VAR != IS_CONST &&
	           IS_CV == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if (IS_CV != IS_UNUSED) {
		function_name = EX_VAR(opline->op2.var);
		if (IS_CV != IS_CONST) {
			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				do {
					if (IS_CV & (IS_VAR|IS_CV) && Z_ISREF_P(function_name)) {
						function_name = Z_REFVAL_P(function_name);
						if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					zend_throw_error(NULL, "Method name must be a string");

					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, Z_STR_P(function_name));
		} else {
			fbc = zend_std_get_static_method(ce, Z_STR_P(function_name), ((IS_CV == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(ce, Z_STR_P(function_name));
			}

			HANDLE_EXCEPTION();
		}
		if (IS_CV == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE)))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if (IS_CV != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (Z_TYPE(EX(This)) == IS_OBJECT && Z_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_throw_error(NULL, "Cannot call private %s::__construct()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & ZEND_ACC_STATIC)) {
		if (Z_TYPE(EX(This)) == IS_OBJECT && instanceof_function(Z_OBJCE(EX(This)), ce)) {
			ce = (zend_class_entry*)Z_OBJ(EX(This));
			call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
		} else {
			zend_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is ZEND_FETCH_CLASS */
		if (IS_VAR == IS_UNUSED
		 && ((opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_PARENT ||
		     (opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_SELF)) {
			if (Z_TYPE(EX(This)) == IS_OBJECT) {
				ce = Z_OBJCE(EX(This));
			} else {
				ce = Z_CE(EX(This));
			}
		}
		call_info = ZEND_CALL_NESTED_FUNCTION;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) &&
	    UNEXPECTED(opline->extended_value & ZEND_ARRAY_ELEMENT_REF)) {
		expr_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (Z_ISREF_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	} else {
		expr_ptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (IS_VAR == IS_TMP_VAR) {
			/* pass */
		} else if (IS_VAR == IS_CONST) {
			Z_TRY_ADDREF_P(expr_ptr);
		} else if (IS_VAR == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			Z_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_VAR == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(expr_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(expr_ptr);

				expr_ptr = Z_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(expr_ptr)) {
					Z_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_CV != IS_UNUSED) {
		zval *offset = EX_VAR(opline->op2.var);
		zend_string *str;
		zend_ulong hval;

add_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if (IS_CV != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index:
			zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(offset) == IS_REFERENCE)) {
			offset = Z_REFVAL_P(offset);
			goto add_again;
		} else if (Z_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (Z_TYPE_P(offset) == IS_DOUBLE) {
			hval = zend_dval_to_lval(Z_DVAL_P(offset));
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_RESOURCE) {
			zend_use_resource_as_offset(offset);
			hval = Z_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_CV == IS_CV && Z_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			zend_illegal_offset();
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			zend_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_ARRAY_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_VAR != IS_UNUSED) {
		size = opline->extended_value >> ZEND_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, zend_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & ZEND_ARRAY_NOT_PACKED) {
			zend_hash_real_init_mixed(Z_ARRVAL_P(array));
		}
		ZEND_VM_TAIL_CALL(ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, zend_new_array(0));
		ZEND_VM_NEXT_OPCODE();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_UNSET_DIM_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	zend_ulong hval;
	zend_string *key;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = EX_VAR(opline->op2.var);

	do {
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
			HashTable *ht;

unset_dim_array:
			SEPARATE_ARRAY(container);
			ht = Z_ARRVAL_P(container);
offset_again:
			if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
				key = Z_STR_P(offset);
				if (IS_CV != IS_CONST) {
					if (ZEND_HANDLE_NUMERIC(key, hval)) {
						goto num_index_dim;
					}
				}
str_index_dim:
				if (ht == &EG(symbol_table)) {
					zend_delete_global_variable(key);
				} else {
					zend_hash_del(ht, key);
				}
			} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
				hval = Z_LVAL_P(offset);
num_index_dim:
				zend_hash_index_del(ht, hval);
			} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(offset) == IS_REFERENCE)) {
				offset = Z_REFVAL_P(offset);
				goto offset_again;
			} else if (Z_TYPE_P(offset) == IS_DOUBLE) {
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_dim;
			} else if (Z_TYPE_P(offset) == IS_NULL) {
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else if (Z_TYPE_P(offset) == IS_FALSE) {
				hval = 0;
				goto num_index_dim;
			} else if (Z_TYPE_P(offset) == IS_TRUE) {
				hval = 1;
				goto num_index_dim;
			} else if (Z_TYPE_P(offset) == IS_RESOURCE) {
				hval = Z_RES_HANDLE_P(offset);
				goto num_index_dim;
			} else if (IS_CV == IS_CV && Z_TYPE_P(offset) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else {
				zend_type_error("Illegal offset type in unset");
			}
			break;
		} else if (Z_ISREF_P(container)) {
			container = Z_REFVAL_P(container);
			if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				goto unset_dim_array;
			}
		}
		if (IS_VAR == IS_CV && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
			container = ZVAL_UNDEFINED_OP1();
		}
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(offset) == IS_UNDEF)) {
			offset = ZVAL_UNDEFINED_OP2();
		}
		if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
			if (IS_CV == IS_CONST && Z_EXTRA_P(offset) == ZEND_EXTRA_VALUE) {
				offset++;
			}
			Z_OBJ_HT_P(container)->unset_dimension(Z_OBJ_P(container), offset);
		} else if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) == IS_STRING)) {
			zend_throw_error(NULL, "Cannot unset string offsets");
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_UNSET_OBJ_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_VAR != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT)) {
			if (Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (Z_TYPE_P(container) != IS_OBJECT) {
					if (IS_VAR == IS_CV
					 && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP1();
					}
					break;
				}
			} else {
				break;
			}
		}
		if (IS_CV == IS_CONST) {
			name = Z_STR_P(offset);
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				break;
			}
		}
		Z_OBJ_HT_P(container)->unset_property(Z_OBJ_P(container), name, ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL));
		if (IS_CV != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_YIELD_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & ZEND_GENERATOR_FORCED_CLOSE)) {
		ZEND_VM_TAIL_CALL(zend_yield_in_closed_generator_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_VAR != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_VAR & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
						Z_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_VAR == IS_VAR) {
						ZEND_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == ZEND_RETURNS_FUNCTION
						 && !Z_ISREF_P(value_ptr)) {
							zend_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (Z_ISREF_P(value_ptr)) {
						Z_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, Z_REF_P(value_ptr));
				} while (0);

				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			}
		} else {
			zval *value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_VAR == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
					Z_ADDREF(generator->value);
				}
			} else if (IS_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if ((IS_VAR & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, Z_REFVAL_P(value));
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_VAR == IS_CV) {
					if (Z_OPT_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {
		zval *key = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
		if ((IS_CV & (IS_CV|IS_VAR)) && UNEXPECTED(Z_TYPE_P(key)) == IS_REFERENCE) {
			key = Z_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array;
	zval *value, *variable_ptr;
	uint32_t value_type;
	HashTable *fe_ht;
	HashPosition pos;
	Bucket *p;

	array = EX_VAR(opline->op1.var);
	SAVE_OPLINE();
	fe_ht = Z_ARRVAL_P(array);
	pos = Z_FE_POS_P(array);
	p = fe_ht->arData + pos;
	while (1) {
		if (UNEXPECTED(pos >= fe_ht->nNumUsed)) {
			/* reached end of iteration */
			ZEND_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
			ZEND_VM_CONTINUE();
		}
		pos++;
		value = &p->val;
		value_type = Z_TYPE_INFO_P(value);
		if (EXPECTED(value_type != IS_UNDEF)) {
			if (UNEXPECTED(value_type == IS_INDIRECT)) {
				value = Z_INDIRECT_P(value);
				value_type = Z_TYPE_INFO_P(value);
				if (EXPECTED(value_type != IS_UNDEF)) {
					break;
				}
			} else {
				break;
			}
		}
		p++;
	}
	Z_FE_POS_P(array) = pos;
	if (0) {
		if (!p->key) {
			ZVAL_LONG(EX_VAR(opline->result.var), p->h);
		} else {
			ZVAL_STR_COPY(EX_VAR(opline->result.var), p->key);
		}
	}

	variable_ptr = EX_VAR(opline->op2.var);
	zend_assign_to_variable(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES());
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}


static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array;
	zval *value, *variable_ptr;
	uint32_t value_type;
	HashTable *fe_ht;
	HashPosition pos;
	Bucket *p;

	array = EX_VAR(opline->op1.var);
	SAVE_OPLINE();
	fe_ht = Z_ARRVAL_P(array);
	pos = Z_FE_POS_P(array);
	p = fe_ht->arData + pos;
	while (1) {
		if (UNEXPECTED(pos >= fe_ht->nNumUsed)) {
			/* reached end of iteration */
			ZEND_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
			ZEND_VM_CONTINUE();
		}
		pos++;
		value = &p->val;
		value_type = Z_TYPE_INFO_P(value);
		if (EXPECTED(value_type != IS_UNDEF)) {
			if (UNEXPECTED(value_type == IS_INDIRECT)) {
				value = Z_INDIRECT_P(value);
				value_type = Z_TYPE_INFO_P(value);
				if (EXPECTED(value_type != IS_UNDEF)) {
					break;
				}
			} else {
				break;
			}
		}
		p++;
	}
	Z_FE_POS_P(array) = pos;
	if (1) {
		if (!p->key) {
			ZVAL_LONG(EX_VAR(opline->result.var), p->h);
		} else {
			ZVAL_STR_COPY(EX_VAR(opline->result.var), p->key);
		}
	}

	variable_ptr = EX_VAR(opline->op2.var);
	zend_assign_to_variable(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES());
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}


static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CLONE_SPEC_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *obj;
	zend_object *zobj;
	zend_class_entry *ce, *scope;
	zend_function *clone;
	zend_object_clone_obj_t clone_call;

	SAVE_OPLINE();
	obj = &EX(This);

	do {
		if (IS_UNUSED == IS_CONST ||
		    (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(obj) != IS_OBJECT))) {
		    if ((IS_UNUSED & (IS_VAR|IS_CV)) && Z_ISREF_P(obj)) {
				obj = Z_REFVAL_P(obj);
				if (EXPECTED(Z_TYPE_P(obj) == IS_OBJECT)) {
					break;
				}
			}
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			if (IS_UNUSED == IS_CV && UNEXPECTED(Z_TYPE_P(obj) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
			zend_throw_error(NULL, "__clone method called on non-object");

			HANDLE_EXCEPTION();
		}
	} while (0);

	zobj = Z_OBJ_P(obj);
	ce = zobj->ce;
	clone = ce->clone;
	clone_call = zobj->handlers->clone_obj;
	if (UNEXPECTED(clone_call == NULL)) {
		zend_throw_error(NULL, "Trying to clone an uncloneable object of class %s", ZSTR_VAL(ce->name));

		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}

	if (clone && !(clone->common.fn_flags & ZEND_ACC_PUBLIC)) {
		scope = EX(func)->op_array.scope;
		if (clone->common.scope != scope) {
			if (UNEXPECTED(clone->common.fn_flags & ZEND_ACC_PRIVATE)
			 || UNEXPECTED(!zend_check_protected(zend_get_function_root_class(clone), scope))) {
				zend_wrong_clone_call(clone, scope);

				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		}
	}

	ZVAL_OBJ(EX_VAR(opline->result.var), clone_call(zobj));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_CLASS_NAME_SPEC_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	uint32_t fetch_type;
	zend_class_entry *called_scope, *scope;
	USE_OPLINE

	if (IS_UNUSED != IS_UNUSED) {
		zval *op = NULL;
		SAVE_OPLINE();
		if (UNEXPECTED(Z_TYPE_P(op) != IS_OBJECT)) {
			ZVAL_DEREF(op);
			if (Z_TYPE_P(op) != IS_OBJECT) {
				zend_type_error("Cannot use \"::class\" on value of type %s", zend_zval_type_name(op));
				ZVAL_UNDEF(EX_VAR(opline->result.var));

				HANDLE_EXCEPTION();
			}
		}

		ZVAL_STR_COPY(EX_VAR(opline->result.var), Z_OBJCE_P(op)->name);

		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	fetch_type = opline->op1.num;
	scope = EX(func)->op_array.scope;
	if (UNEXPECTED(scope == NULL)) {
		SAVE_OPLINE();
		zend_throw_error(NULL, "Cannot use \"%s\" in the global scope",
			fetch_type == ZEND_FETCH_CLASS_SELF ? "self" :
			fetch_type == ZEND_FETCH_CLASS_PARENT ? "parent" : "static");
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}

	switch (fetch_type) {
		case ZEND_FETCH_CLASS_SELF:
			ZVAL_STR_COPY(EX_VAR(opline->result.var), scope->name);
			break;
		case ZEND_FETCH_CLASS_PARENT:
			if (UNEXPECTED(scope->parent == NULL)) {
				SAVE_OPLINE();
				zend_throw_error(NULL,
					"Cannot use \"parent\" when current class scope has no parent");
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
			ZVAL_STR_COPY(EX_VAR(opline->result.var), scope->parent->name);
			break;
		case ZEND_FETCH_CLASS_STATIC:
			if (Z_TYPE(EX(This)) == IS_OBJECT) {
				called_scope = Z_OBJCE(EX(This));
			} else {
				called_scope = Z_CE(EX(This));
			}
			ZVAL_STR_COPY(EX_VAR(opline->result.var), called_scope->name);
			break;
		EMPTY_SWITCH_DEFAULT_CASE()
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_OP_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *value;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = RT_CONSTANT(opline, opline->op2);

	do {
		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto assign_op_object;
			}
			if (IS_UNUSED == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

assign_op_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if (IS_CONST == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CONST == IS_CONST) ? CACHE_ADDR((opline+1)->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				zval *orig_zptr = zptr;
				zend_reference *ref;

				do {
					if (UNEXPECTED(Z_ISREF_P(zptr))) {
						ref = Z_REF_P(zptr);
						zptr = Z_REFVAL_P(zptr);
						if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
							zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
							break;
						}
					}

					if (IS_CONST == IS_CONST) {
						prop_info = (zend_property_info*)CACHED_PTR_EX(cache_slot + 2);
					} else {
						prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), orig_zptr);
					}
					if (UNEXPECTED(prop_info)) {
						/* special case for typed properties */
						zend_binary_assign_op_typed_prop(prop_info, zptr, value OPLINE_CC EXECUTE_DATA_CC);
					} else {
						zend_binary_op(zptr, zptr, value OPLINE_CC);
					}
				} while (0);

				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		} else {
			zend_assign_op_overloaded_property(zobj, name, cache_slot, value OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CONST != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);


	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMP|VAR|CV, UNUSED|CONST|TMPVAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_INC_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = RT_CONSTANT(opline, opline->op2);

	do {
		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto pre_incdec_object;
			}
			if (IS_UNUSED == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

pre_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if (IS_CONST == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				if (IS_CONST == IS_CONST) {
					prop_info = (zend_property_info *) CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), zptr);
				}
				zend_pre_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			zend_pre_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CONST != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POST_INC_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = RT_CONSTANT(opline, opline->op2);

	do {
		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto post_incdec_object;
			}
			if (IS_UNUSED == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

post_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if (IS_CONST == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}
		cache_slot = (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			} else {
				if (IS_CONST == IS_CONST) {
					prop_info = (zend_property_info*)CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), zptr);
				}

				zend_post_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			zend_post_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CONST != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static zend_always_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_R_SPEC_UNUSED_CONST_INLINE_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = &EX(This);
	offset = RT_CONSTANT(opline, opline->op2);

	if (IS_UNUSED == IS_CONST ||
	    (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
	    do {
			if ((IS_UNUSED & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_UNUSED == IS_CV && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			zend_wrong_property_read(container, offset);
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if (IS_CONST == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value & ~ZEND_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
		} else {
			if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));

		if (IS_CONST != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_R_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_R_SPEC_UNUSED_CONST_INLINE_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_W_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();

	container = &EX(This);
	property = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(
		result, container, IS_UNUSED, property, IS_CONST,
		((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_FETCH_OBJ_FLAGS) : NULL),
		BP_VAR_W, opline->extended_value & ZEND_FETCH_OBJ_FLAGS, 1 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_UNUSED == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();
	container = &EX(This);
	property = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(result, container, IS_UNUSED, property, IS_CONST, ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_RW, 0, 1 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_UNUSED == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = &EX(This);
	offset = RT_CONSTANT(opline, opline->op2);

	if (IS_UNUSED == IS_CONST ||
	    (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_UNUSED & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if (IS_CONST == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if (IS_CONST != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_UNUSED & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_W_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_R_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *property, *result;

	SAVE_OPLINE();
	container = &EX(This);
	property = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(result, container, IS_UNUSED, property, IS_CONST, ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_UNSET, 0, 1 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_UNUSED == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = RT_CONSTANT(opline, opline->op2);
	value = RT_CONSTANT((opline+1), (opline+1)->op1);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CONST == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_CONST == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_CONST == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_CONST, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_CONST != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_CONST == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_CONST == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CONST == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:


	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = RT_CONSTANT(opline, opline->op2);
	value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CONST == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_TMP_VAR == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_TMP_VAR == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_TMP_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_TMP_VAR != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_TMP_VAR == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_TMP_VAR == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CONST == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:


	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = RT_CONSTANT(opline, opline->op2);
	value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CONST == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_VAR == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_VAR == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_VAR, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_VAR != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_VAR == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_VAR == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CONST == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:


	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = RT_CONSTANT(opline, opline->op2);
	value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CONST == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_CV == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_CV == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_CV, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_CV != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_CV == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_CV == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_CV == IS_CV || IS_CV == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CONST == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:


	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = &EX(This);
	property = RT_CONSTANT(opline, opline->op2);

	value_ptr = _get_zval_ptr_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_UNUSED == IS_UNUSED) {
			if (IS_CONST == IS_CONST) {
				zend_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CONST == IS_CONST) {
				zend_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		zend_assign_to_property_reference(container, IS_UNUSED, property, IS_CONST, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}


	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));;
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = &EX(This);
	property = RT_CONSTANT(opline, opline->op2);

	value_ptr = _get_zval_ptr_cv_BP_VAR_W((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_UNUSED == IS_UNUSED) {
			if (IS_CONST == IS_CONST) {
				zend_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CONST == IS_CONST) {
				zend_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		zend_assign_to_property_reference(container, IS_UNUSED, property, IS_CONST, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}



	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_INIT_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_string **rope;
	zval *var;

	/* Compiler allocates the necessary number of zval slots to keep the rope */
	rope = (zend_string**)EX_VAR(opline->result.var);
	if (IS_CONST == IS_CONST) {
		var = RT_CONSTANT(opline, opline->op2);
		rope[0] = Z_STR_P(var);
		if (UNEXPECTED(Z_REFCOUNTED_P(var))) {
			Z_ADDREF_P(var);
		}
	} else {
		var = RT_CONSTANT(opline, opline->op2);
		if (EXPECTED(Z_TYPE_P(var) == IS_STRING)) {
			if (IS_CONST == IS_CV) {
				rope[0] = zend_string_copy(Z_STR_P(var));
			} else {
				rope[0] = Z_STR_P(var);
			}
		} else {
			SAVE_OPLINE();
			if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(var) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			rope[0] = zval_get_string_func(var);

			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_CLASS_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *class_name;
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_CONST == IS_UNUSED) {
		Z_CE_P(EX_VAR(opline->result.var)) = zend_fetch_class(NULL, opline->op1.num);
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	} else if (IS_CONST == IS_CONST) {
		zend_class_entry *ce = CACHED_PTR(opline->extended_value);

		if (UNEXPECTED(ce == NULL)) {
			class_name = RT_CONSTANT(opline, opline->op2);
			ce = zend_fetch_class_by_name(Z_STR_P(class_name), Z_STR_P(class_name + 1), opline->op1.num);
			CACHE_PTR(opline->extended_value, ce);
		}
		Z_CE_P(EX_VAR(opline->result.var)) = ce;
	} else {
		class_name = RT_CONSTANT(opline, opline->op2);
try_class_name:
		if (Z_TYPE_P(class_name) == IS_OBJECT) {
			Z_CE_P(EX_VAR(opline->result.var)) = Z_OBJCE_P(class_name);
		} else if (Z_TYPE_P(class_name) == IS_STRING) {
			Z_CE_P(EX_VAR(opline->result.var)) = zend_fetch_class(Z_STR_P(class_name), opline->op1.num);
		} else if ((IS_CONST & (IS_VAR|IS_CV)) && Z_TYPE_P(class_name) == IS_REFERENCE) {
			class_name = Z_REFVAL_P(class_name);
			goto try_class_name;
		} else {
			if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(class_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
			zend_throw_error(NULL, "Class name must be a valid object or a string");
		}
	}

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	zend_function *fbc;
	zend_class_entry *called_scope;
	zend_object *obj;
	zend_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = &EX(This);

	if (IS_CONST != IS_CONST) {
		function_name = RT_CONSTANT(opline, opline->op2);
	}

	if (IS_CONST != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		do {
			if ((IS_CONST & (IS_VAR|IS_CV)) && Z_ISREF_P(function_name)) {
				function_name = Z_REFVAL_P(function_name);
				if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {

					HANDLE_EXCEPTION();
				}
			}
			zend_throw_error(NULL, "Method name must be a string");


			HANDLE_EXCEPTION();
		} while (0);
	}

	if (IS_UNUSED == IS_UNUSED) {
		obj = Z_OBJ_P(object);
	} else {
		do {
			if (IS_UNUSED != IS_CONST && EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
				obj = Z_OBJ_P(object);
			} else {
				if ((IS_UNUSED & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(object))) {
					zend_reference *ref = Z_REF_P(object);

					object = &ref->val;
					if (EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
						obj = Z_OBJ_P(object);
						if (IS_UNUSED & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(zend_reference));
							} else {
								Z_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if (IS_UNUSED == IS_CV && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if (IS_CONST != IS_CONST) {

						}
						HANDLE_EXCEPTION();
					}
				}
				if (IS_CONST == IS_CONST) {
					function_name = RT_CONSTANT(opline, opline->op2);
				}
				zend_invalid_method_call(object, function_name);


				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if (IS_CONST == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
	    fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
	    zend_object *orig_obj = obj;

		if (IS_CONST == IS_CONST) {
			function_name = RT_CONSTANT(opline, opline->op2);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, Z_STR_P(function_name), ((IS_CONST == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(obj->ce, Z_STR_P(function_name));
			}

			if ((IS_UNUSED & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if (IS_CONST == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if ((IS_UNUSED & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (IS_CONST != IS_CONST) {

	}

	call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_STATIC) != 0)) {
		if ((IS_UNUSED & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			zend_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (zend_object*)called_scope;
		call_info = ZEND_CALL_NESTED_FUNCTION;
	} else if (IS_UNUSED & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if (IS_UNUSED == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS | ZEND_CALL_RELEASE_THIS;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	uint32_t call_info;
	zend_function *fbc;
	zend_execute_data *call;

	SAVE_OPLINE();

	if (IS_UNUSED == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op1)), Z_STR_P(RT_CONSTANT(opline, opline->op1) + 1), ZEND_FETCH_CLASS_DEFAULT | ZEND_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {

				HANDLE_EXCEPTION();
			}
			if (IS_CONST != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_UNUSED == IS_UNUSED) {
		ce = zend_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {

			HANDLE_EXCEPTION();
		}
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_UNUSED == IS_CONST &&
	    IS_CONST == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_UNUSED != IS_CONST &&
	           IS_CONST == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if (IS_CONST != IS_UNUSED) {
		function_name = RT_CONSTANT(opline, opline->op2);
		if (IS_CONST != IS_CONST) {
			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				do {
					if (IS_CONST & (IS_VAR|IS_CV) && Z_ISREF_P(function_name)) {
						function_name = Z_REFVAL_P(function_name);
						if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					zend_throw_error(NULL, "Method name must be a string");

					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, Z_STR_P(function_name));
		} else {
			fbc = zend_std_get_static_method(ce, Z_STR_P(function_name), ((IS_CONST == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(ce, Z_STR_P(function_name));
			}

			HANDLE_EXCEPTION();
		}
		if (IS_CONST == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE)))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if (IS_CONST != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (Z_TYPE(EX(This)) == IS_OBJECT && Z_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_throw_error(NULL, "Cannot call private %s::__construct()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & ZEND_ACC_STATIC)) {
		if (Z_TYPE(EX(This)) == IS_OBJECT && instanceof_function(Z_OBJCE(EX(This)), ce)) {
			ce = (zend_class_entry*)Z_OBJ(EX(This));
			call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
		} else {
			zend_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is ZEND_FETCH_CLASS */
		if (IS_UNUSED == IS_UNUSED
		 && ((opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_PARENT ||
		     (opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_SELF)) {
			if (Z_TYPE(EX(This)) == IS_OBJECT) {
				ce = Z_OBJCE(EX(This));
			} else {
				ce = Z_CE(EX(This));
			}
		}
		call_info = ZEND_CALL_NESTED_FUNCTION;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CHECK_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	uint32_t arg_num;

	if (IS_CONST == IS_CONST) {
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		arg_num = zend_get_arg_offset_by_name(
			EX(call)->func, arg_name, CACHE_ADDR(opline->result.num)) + 1;
		if (UNEXPECTED(arg_num == 0)) {
			/* Treat this as a by-value argument, and throw an error during SEND. */
			ZEND_DEL_CALL_FLAG(EX(call), ZEND_CALL_SEND_ARG_BY_REF);
			ZEND_VM_NEXT_OPCODE();
		}
	} else {
		arg_num = opline->op2.num;
	}

	if (EXPECTED(arg_num <= MAX_ARG_FLAG_NUM)) {
		if (QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			ZEND_ADD_CALL_FLAG(EX(call), ZEND_CALL_SEND_ARG_BY_REF);
		} else {
			ZEND_DEL_CALL_FLAG(EX(call), ZEND_CALL_SEND_ARG_BY_REF);
		}
	} else if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
		ZEND_ADD_CALL_FLAG(EX(call), ZEND_CALL_SEND_ARG_BY_REF);
	} else {
		ZEND_DEL_CALL_FLAG(EX(call), ZEND_CALL_SEND_ARG_BY_REF);
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_CONSTANT_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_constant *c;

	c = CACHED_PTR(opline->extended_value);
	if (EXPECTED(c != NULL) && EXPECTED(!IS_SPECIAL_CACHE_VAL(c))) {
		ZVAL_COPY_OR_DUP(EX_VAR(opline->result.var), &c->value);
		ZEND_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	zend_quick_get_constant(RT_CONSTANT(opline, opline->op2) + 1, opline->op1.num OPLINE_CC EXECUTE_DATA_CC);
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_CLASS_CONSTANT_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_class_entry *ce, *scope;
	zend_class_constant *c;
	zval *value, *zv;
	USE_OPLINE

	SAVE_OPLINE();

	do {
		if (IS_UNUSED == IS_CONST) {
			if (EXPECTED(CACHED_PTR(opline->extended_value + sizeof(void*)))) {
				value = CACHED_PTR(opline->extended_value + sizeof(void*));
				break;
			} else if (EXPECTED(CACHED_PTR(opline->extended_value))) {
				ce = CACHED_PTR(opline->extended_value);
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op1)), Z_STR_P(RT_CONSTANT(opline, opline->op1) + 1), ZEND_FETCH_CLASS_DEFAULT | ZEND_FETCH_CLASS_EXCEPTION);
				if (UNEXPECTED(ce == NULL)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));
					HANDLE_EXCEPTION();
				}
			}
		} else {
			if (IS_UNUSED == IS_UNUSED) {
				ce = zend_fetch_class(NULL, opline->op1.num);
				if (UNEXPECTED(ce == NULL)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));
					HANDLE_EXCEPTION();
				}
			} else {
				ce = Z_CE_P(EX_VAR(opline->op1.var));
			}
			if (EXPECTED(CACHED_PTR(opline->extended_value) == ce)) {
				value = CACHED_PTR(opline->extended_value + sizeof(void*));
				break;
			}
		}

		zv = zend_hash_find_ex(&ce->constants_table, Z_STR_P(RT_CONSTANT(opline, opline->op2)), 1);
		if (EXPECTED(zv != NULL)) {
			c = Z_PTR_P(zv);
			scope = EX(func)->op_array.scope;
			if (!zend_verify_const_access(c, scope)) {
				zend_throw_error(NULL, "Cannot access %s constant %s::%s", zend_visibility_string(Z_ACCESS_FLAGS(c->value)), ZSTR_VAL(ce->name), Z_STRVAL_P(RT_CONSTANT(opline, opline->op2)));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
			value = &c->value;
			if (Z_TYPE_P(value) == IS_CONSTANT_AST) {
				zval_update_constant_ex(value, c->ce);
				if (UNEXPECTED(EG(exception) != NULL)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));
					HANDLE_EXCEPTION();
				}
			}
			CACHE_POLYMORPHIC_PTR(opline->extended_value, ce, value);
		} else {
			zend_throw_error(NULL, "Undefined constant %s::%s",
				ZSTR_VAL(ce->name), Z_STRVAL_P(RT_CONSTANT(opline, opline->op2)));
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		}
	} while (0);

	ZVAL_COPY_OR_DUP(EX_VAR(opline->result.var), value);

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_ARRAY_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_UNUSED != IS_UNUSED) {
		size = opline->extended_value >> ZEND_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, zend_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & ZEND_ARRAY_NOT_PACKED) {
			zend_hash_real_init_mixed(Z_ARRVAL_P(array));
		}
		ZEND_VM_TAIL_CALL(ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, zend_new_array(0));
		ZEND_VM_NEXT_OPCODE();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_UNSET_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	container = &EX(This);
	offset = RT_CONSTANT(opline, opline->op2);

	do {
		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT)) {
			if (Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (Z_TYPE_P(container) != IS_OBJECT) {
					if (IS_UNUSED == IS_CV
					 && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP1();
					}
					break;
				}
			} else {
				break;
			}
		}
		if (IS_CONST == IS_CONST) {
			name = Z_STR_P(offset);
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				break;
			}
		}
		Z_OBJ_HT_P(container)->unset_property(Z_OBJ_P(container), name, ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL));
		if (IS_CONST != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	container = &EX(This);
	offset = RT_CONSTANT(opline, opline->op2);

	if (IS_UNUSED == IS_CONST ||
	    (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		if ((IS_UNUSED & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
			container = Z_REFVAL_P(container);
			if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & ZEND_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & ZEND_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if (IS_CONST == IS_CONST) {
		name = Z_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & ZEND_ISEMPTY) ^
		Z_OBJ_HT_P(container)->has_property(Z_OBJ_P(container), name, (opline->extended_value & ZEND_ISEMPTY), ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_ISEMPTY) : NULL));

	if (IS_CONST != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

isset_object_finish:


	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_YIELD_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & ZEND_GENERATOR_FORCED_CLOSE)) {
		ZEND_VM_TAIL_CALL(zend_yield_in_closed_generator_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_UNUSED != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_UNUSED & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = NULL;
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_UNUSED == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
						Z_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = NULL;

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_UNUSED == IS_VAR) {
						ZEND_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == ZEND_RETURNS_FUNCTION
						 && !Z_ISREF_P(value_ptr)) {
							zend_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (Z_ISREF_P(value_ptr)) {
						Z_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, Z_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = NULL;

			/* Consts, temporary variables and references need copying */
			if (IS_UNUSED == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
					Z_ADDREF(generator->value);
				}
			} else if (IS_UNUSED == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if ((IS_UNUSED & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, Z_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_UNUSED == IS_CV) {
					if (Z_OPT_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {
		zval *key = RT_CONSTANT(opline, opline->op2);
		if ((IS_CONST & (IS_CV|IS_VAR)) && UNEXPECTED(Z_TYPE_P(key)) == IS_REFERENCE) {
			key = Z_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_OP_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *value;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto assign_op_object;
			}
			if (IS_UNUSED == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

assign_op_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR((opline+1)->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				zval *orig_zptr = zptr;
				zend_reference *ref;

				do {
					if (UNEXPECTED(Z_ISREF_P(zptr))) {
						ref = Z_REF_P(zptr);
						zptr = Z_REFVAL_P(zptr);
						if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
							zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
							break;
						}
					}

					if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
						prop_info = (zend_property_info*)CACHED_PTR_EX(cache_slot + 2);
					} else {
						prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), orig_zptr);
					}
					if (UNEXPECTED(prop_info)) {
						/* special case for typed properties */
						zend_binary_assign_op_typed_prop(prop_info, zptr, value OPLINE_CC EXECUTE_DATA_CC);
					} else {
						zend_binary_op(zptr, zptr, value OPLINE_CC);
					}
				} while (0);

				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		} else {
			zend_assign_op_overloaded_property(zobj, name, cache_slot, value OPLINE_CC EXECUTE_DATA_CC);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMP|VAR|CV, UNUSED|CONST|TMPVAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_INC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto pre_incdec_object;
			}
			if (IS_UNUSED == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

pre_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					prop_info = (zend_property_info *) CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), zptr);
				}
				zend_pre_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			zend_pre_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POST_INC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto post_incdec_object;
			}
			if (IS_UNUSED == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

post_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}
		cache_slot = ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			} else {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					prop_info = (zend_property_info*)CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), zptr);
				}

				zend_post_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			zend_post_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_R_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = &EX(This);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (IS_UNUSED == IS_CONST ||
	    (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
	    do {
			if ((IS_UNUSED & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_UNUSED == IS_CV && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			zend_wrong_property_read(container, offset);
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value & ~ZEND_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
		} else {
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_W_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();

	container = &EX(This);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(
		result, container, IS_UNUSED, property, (IS_TMP_VAR|IS_VAR),
		(((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_FETCH_OBJ_FLAGS) : NULL),
		BP_VAR_W, opline->extended_value & ZEND_FETCH_OBJ_FLAGS, 1 OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_UNUSED == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_RW_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();
	container = &EX(This);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(result, container, IS_UNUSED, property, (IS_TMP_VAR|IS_VAR), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_RW, 0, 1 OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_UNUSED == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_IS_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = &EX(This);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (IS_UNUSED == IS_CONST ||
	    (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_UNUSED & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_UNUSED & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_W_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_R_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *property, *result;

	SAVE_OPLINE();
	container = &EX(This);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(result, container, IS_UNUSED, property, (IS_TMP_VAR|IS_VAR), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_UNSET, 0, 1 OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_UNUSED == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	value = RT_CONSTANT((opline+1), (opline+1)->op1);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_CONST == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_CONST == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_CONST, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_CONST != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_CONST == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_CONST == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_TMP_VAR == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_TMP_VAR == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_TMP_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_TMP_VAR != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_TMP_VAR == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_TMP_VAR == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_VAR == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_VAR == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_VAR, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_VAR != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_VAR == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_VAR == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_CV == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_CV == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_CV, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_CV != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_CV == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_CV == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_CV == IS_CV || IS_CV == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = &EX(This);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_UNUSED == IS_UNUSED) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				zend_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				zend_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		zend_assign_to_property_reference(container, IS_UNUSED, property, (IS_TMP_VAR|IS_VAR), value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));;
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = &EX(This);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_cv_BP_VAR_W((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_UNUSED == IS_UNUSED) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				zend_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				zend_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		zend_assign_to_property_reference(container, IS_UNUSED, property, (IS_TMP_VAR|IS_VAR), value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_INIT_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_string **rope;
	zval *var;

	/* Compiler allocates the necessary number of zval slots to keep the rope */
	rope = (zend_string**)EX_VAR(opline->result.var);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		var = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		rope[0] = Z_STR_P(var);
		if (UNEXPECTED(Z_REFCOUNTED_P(var))) {
			Z_ADDREF_P(var);
		}
	} else {
		var = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if (EXPECTED(Z_TYPE_P(var) == IS_STRING)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CV) {
				rope[0] = zend_string_copy(Z_STR_P(var));
			} else {
				rope[0] = Z_STR_P(var);
			}
		} else {
			SAVE_OPLINE();
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(var) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			rope[0] = zval_get_string_func(var);
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_CLASS_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *class_name;
	USE_OPLINE

	SAVE_OPLINE();
	if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
		Z_CE_P(EX_VAR(opline->result.var)) = zend_fetch_class(NULL, opline->op1.num);
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	} else if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		zend_class_entry *ce = CACHED_PTR(opline->extended_value);

		if (UNEXPECTED(ce == NULL)) {
			class_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			ce = zend_fetch_class_by_name(Z_STR_P(class_name), Z_STR_P(class_name + 1), opline->op1.num);
			CACHE_PTR(opline->extended_value, ce);
		}
		Z_CE_P(EX_VAR(opline->result.var)) = ce;
	} else {
		class_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
try_class_name:
		if (Z_TYPE_P(class_name) == IS_OBJECT) {
			Z_CE_P(EX_VAR(opline->result.var)) = Z_OBJCE_P(class_name);
		} else if (Z_TYPE_P(class_name) == IS_STRING) {
			Z_CE_P(EX_VAR(opline->result.var)) = zend_fetch_class(Z_STR_P(class_name), opline->op1.num);
		} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && Z_TYPE_P(class_name) == IS_REFERENCE) {
			class_name = Z_REFVAL_P(class_name);
			goto try_class_name;
		} else {
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(class_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
			zend_throw_error(NULL, "Class name must be a valid object or a string");
		}
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_METHOD_CALL_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	zend_function *fbc;
	zend_class_entry *called_scope;
	zend_object *obj;
	zend_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = &EX(This);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		do {
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && Z_ISREF_P(function_name)) {
				function_name = Z_REFVAL_P(function_name);
				if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {

					HANDLE_EXCEPTION();
				}
			}
			zend_throw_error(NULL, "Method name must be a string");
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

			HANDLE_EXCEPTION();
		} while (0);
	}

	if (IS_UNUSED == IS_UNUSED) {
		obj = Z_OBJ_P(object);
	} else {
		do {
			if (IS_UNUSED != IS_CONST && EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
				obj = Z_OBJ_P(object);
			} else {
				if ((IS_UNUSED & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(object))) {
					zend_reference *ref = Z_REF_P(object);

					object = &ref->val;
					if (EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
						obj = Z_OBJ_P(object);
						if (IS_UNUSED & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(zend_reference));
							} else {
								Z_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if (IS_UNUSED == IS_CV && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
							zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
						}
						HANDLE_EXCEPTION();
					}
				}
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				}
				zend_invalid_method_call(object, function_name);
				zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
	    fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
	    zend_object *orig_obj = obj;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, Z_STR_P(function_name), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(obj->ce, Z_STR_P(function_name));
			}
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			if ((IS_UNUSED & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if ((IS_UNUSED & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}

	call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_STATIC) != 0)) {
		if ((IS_UNUSED & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			zend_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (zend_object*)called_scope;
		call_info = ZEND_CALL_NESTED_FUNCTION;
	} else if (IS_UNUSED & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if (IS_UNUSED == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS | ZEND_CALL_RELEASE_THIS;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	uint32_t call_info;
	zend_function *fbc;
	zend_execute_data *call;

	SAVE_OPLINE();

	if (IS_UNUSED == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op1)), Z_STR_P(RT_CONSTANT(opline, opline->op1) + 1), ZEND_FETCH_CLASS_DEFAULT | ZEND_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {
				zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
				HANDLE_EXCEPTION();
			}
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_UNUSED == IS_UNUSED) {
		ce = zend_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			HANDLE_EXCEPTION();
		}
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_UNUSED == IS_CONST &&
	    (IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_UNUSED != IS_CONST &&
	           (IS_TMP_VAR|IS_VAR) == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				do {
					if ((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV) && Z_ISREF_P(function_name)) {
						function_name = Z_REFVAL_P(function_name);
						if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					zend_throw_error(NULL, "Method name must be a string");
					zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, Z_STR_P(function_name));
		} else {
			fbc = zend_std_get_static_method(ce, Z_STR_P(function_name), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(ce, Z_STR_P(function_name));
			}
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			HANDLE_EXCEPTION();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE)))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (Z_TYPE(EX(This)) == IS_OBJECT && Z_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_throw_error(NULL, "Cannot call private %s::__construct()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & ZEND_ACC_STATIC)) {
		if (Z_TYPE(EX(This)) == IS_OBJECT && instanceof_function(Z_OBJCE(EX(This)), ce)) {
			ce = (zend_class_entry*)Z_OBJ(EX(This));
			call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
		} else {
			zend_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is ZEND_FETCH_CLASS */
		if (IS_UNUSED == IS_UNUSED
		 && ((opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_PARENT ||
		     (opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_SELF)) {
			if (Z_TYPE(EX(This)) == IS_OBJECT) {
				ce = Z_OBJCE(EX(This));
			} else {
				ce = Z_CE(EX(This));
			}
		}
		call_info = ZEND_CALL_NESTED_FUNCTION;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_ARRAY_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_UNUSED != IS_UNUSED) {
		size = opline->extended_value >> ZEND_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, zend_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & ZEND_ARRAY_NOT_PACKED) {
			zend_hash_real_init_mixed(Z_ARRVAL_P(array));
		}
		ZEND_VM_TAIL_CALL(ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, zend_new_array(0));
		ZEND_VM_NEXT_OPCODE();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_UNSET_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	container = &EX(This);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT)) {
			if (Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (Z_TYPE_P(container) != IS_OBJECT) {
					if (IS_UNUSED == IS_CV
					 && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP1();
					}
					break;
				}
			} else {
				break;
			}
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = Z_STR_P(offset);
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				break;
			}
		}
		Z_OBJ_HT_P(container)->unset_property(Z_OBJ_P(container), name, (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL));
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	container = &EX(This);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (IS_UNUSED == IS_CONST ||
	    (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		if ((IS_UNUSED & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
			container = Z_REFVAL_P(container);
			if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & ZEND_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & ZEND_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = Z_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & ZEND_ISEMPTY) ^
		Z_OBJ_HT_P(container)->has_property(Z_OBJ_P(container), name, (opline->extended_value & ZEND_ISEMPTY), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_ISEMPTY) : NULL));

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

isset_object_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_YIELD_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & ZEND_GENERATOR_FORCED_CLOSE)) {
		ZEND_VM_TAIL_CALL(zend_yield_in_closed_generator_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_UNUSED != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_UNUSED & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = NULL;
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_UNUSED == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
						Z_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = NULL;

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_UNUSED == IS_VAR) {
						ZEND_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == ZEND_RETURNS_FUNCTION
						 && !Z_ISREF_P(value_ptr)) {
							zend_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (Z_ISREF_P(value_ptr)) {
						Z_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, Z_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = NULL;

			/* Consts, temporary variables and references need copying */
			if (IS_UNUSED == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
					Z_ADDREF(generator->value);
				}
			} else if (IS_UNUSED == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if ((IS_UNUSED & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, Z_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_UNUSED == IS_CV) {
					if (Z_OPT_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval *key = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if (((IS_TMP_VAR|IS_VAR) & (IS_CV|IS_VAR)) && UNEXPECTED(Z_TYPE_P(key)) == IS_REFERENCE) {
			key = Z_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_CLASS_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *class_name;
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_UNUSED == IS_UNUSED) {
		Z_CE_P(EX_VAR(opline->result.var)) = zend_fetch_class(NULL, opline->op1.num);
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	} else if (IS_UNUSED == IS_CONST) {
		zend_class_entry *ce = CACHED_PTR(opline->extended_value);

		if (UNEXPECTED(ce == NULL)) {
			class_name = NULL;
			ce = zend_fetch_class_by_name(Z_STR_P(class_name), Z_STR_P(class_name + 1), opline->op1.num);
			CACHE_PTR(opline->extended_value, ce);
		}
		Z_CE_P(EX_VAR(opline->result.var)) = ce;
	} else {
		class_name = NULL;
try_class_name:
		if (Z_TYPE_P(class_name) == IS_OBJECT) {
			Z_CE_P(EX_VAR(opline->result.var)) = Z_OBJCE_P(class_name);
		} else if (Z_TYPE_P(class_name) == IS_STRING) {
			Z_CE_P(EX_VAR(opline->result.var)) = zend_fetch_class(Z_STR_P(class_name), opline->op1.num);
		} else if ((IS_UNUSED & (IS_VAR|IS_CV)) && Z_TYPE_P(class_name) == IS_REFERENCE) {
			class_name = Z_REFVAL_P(class_name);
			goto try_class_name;
		} else {
			if (IS_UNUSED == IS_CV && UNEXPECTED(Z_TYPE_P(class_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
			zend_throw_error(NULL, "Class name must be a valid object or a string");
		}
	}

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	uint32_t call_info;
	zend_function *fbc;
	zend_execute_data *call;

	SAVE_OPLINE();

	if (IS_UNUSED == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op1)), Z_STR_P(RT_CONSTANT(opline, opline->op1) + 1), ZEND_FETCH_CLASS_DEFAULT | ZEND_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {

				HANDLE_EXCEPTION();
			}
			if (IS_UNUSED != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_UNUSED == IS_UNUSED) {
		ce = zend_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {

			HANDLE_EXCEPTION();
		}
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_UNUSED == IS_CONST &&
	    IS_UNUSED == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_UNUSED != IS_CONST &&
	           IS_UNUSED == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if (IS_UNUSED != IS_UNUSED) {
		function_name = NULL;
		if (IS_UNUSED != IS_CONST) {
			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				do {
					if (IS_UNUSED & (IS_VAR|IS_CV) && Z_ISREF_P(function_name)) {
						function_name = Z_REFVAL_P(function_name);
						if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if (IS_UNUSED == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					zend_throw_error(NULL, "Method name must be a string");

					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, Z_STR_P(function_name));
		} else {
			fbc = zend_std_get_static_method(ce, Z_STR_P(function_name), ((IS_UNUSED == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(ce, Z_STR_P(function_name));
			}

			HANDLE_EXCEPTION();
		}
		if (IS_UNUSED == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE)))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if (IS_UNUSED != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (Z_TYPE(EX(This)) == IS_OBJECT && Z_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_throw_error(NULL, "Cannot call private %s::__construct()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & ZEND_ACC_STATIC)) {
		if (Z_TYPE(EX(This)) == IS_OBJECT && instanceof_function(Z_OBJCE(EX(This)), ce)) {
			ce = (zend_class_entry*)Z_OBJ(EX(This));
			call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
		} else {
			zend_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is ZEND_FETCH_CLASS */
		if (IS_UNUSED == IS_UNUSED
		 && ((opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_PARENT ||
		     (opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_SELF)) {
			if (Z_TYPE(EX(This)) == IS_OBJECT) {
				ce = Z_OBJCE(EX(This));
			} else {
				ce = Z_CE(EX(This));
			}
		}
		call_info = ZEND_CALL_NESTED_FUNCTION;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_VERIFY_RETURN_TYPE_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	if (IS_UNUSED == IS_UNUSED) {
		SAVE_OPLINE();
		zend_verify_missing_return_type(EX(func));
		HANDLE_EXCEPTION();
	} else {
/* prevents "undefined variable opline" errors */
#if 0 || (IS_UNUSED != IS_UNUSED)
		USE_OPLINE
		zval *retval_ref, *retval_ptr;
		zend_arg_info *ret_info = EX(func)->common.arg_info - 1;
		retval_ref = retval_ptr = NULL;

		if (IS_UNUSED == IS_CONST) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval_ptr);
			retval_ref = retval_ptr = EX_VAR(opline->result.var);
		} else if (IS_UNUSED == IS_VAR) {
			if (UNEXPECTED(Z_TYPE_P(retval_ptr) == IS_INDIRECT)) {
				retval_ptr = Z_INDIRECT_P(retval_ptr);
			}
			ZVAL_DEREF(retval_ptr);
		} else if (IS_UNUSED == IS_CV) {
			ZVAL_DEREF(retval_ptr);
		}

		if (EXPECTED(ZEND_TYPE_CONTAINS_CODE(ret_info->type, Z_TYPE_P(retval_ptr)))) {
			ZEND_VM_NEXT_OPCODE();
		}

		if (IS_UNUSED == IS_CV && UNEXPECTED(Z_ISUNDEF_P(retval_ptr))) {
			SAVE_OPLINE();
			retval_ref = retval_ptr = ZVAL_UNDEFINED_OP1();
			if (ZEND_TYPE_FULL_MASK(ret_info->type) & MAY_BE_NULL) {
				ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
			}
		}

		zend_reference *ref = NULL;
		void *cache_slot = CACHE_ADDR(opline->op2.num);
		if (UNEXPECTED(retval_ref != retval_ptr)) {
			if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
				ref = Z_REF_P(retval_ref);
			} else {
				/* A cast might happen - unwrap the reference if this is a by-value return */
				if (Z_REFCOUNT_P(retval_ref) == 1) {
					ZVAL_UNREF(retval_ref);
				} else {
					Z_DELREF_P(retval_ref);
					ZVAL_COPY(retval_ref, retval_ptr);
				}
				retval_ptr = retval_ref;
			}
		}

		SAVE_OPLINE();
		if (UNEXPECTED(!zend_check_type_slow(ret_info->type, retval_ptr, ref, cache_slot, NULL, 1, 0))) {
			zend_verify_return_error(EX(func), retval_ptr);
			HANDLE_EXCEPTION();
		}
		ZEND_VM_NEXT_OPCODE();
#endif
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		arg_num = zend_get_arg_offset_by_name(
			EX(call)->func, arg_name, CACHE_ADDR(opline->result.num)) + 1;
		if (UNEXPECTED(arg_num == 0)) {
			/* Treat this as a by-value argument, and throw an error during SEND. */
			ZEND_DEL_CALL_FLAG(EX(call), ZEND_CALL_SEND_ARG_BY_REF);
			ZEND_VM_NEXT_OPCODE();
		}
	} else {
		arg_num = opline->op2.num;
	}

	if (EXPECTED(0)) {
		if (QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			ZEND_ADD_CALL_FLAG(EX(call), ZEND_CALL_SEND_ARG_BY_REF);
		} else {
			ZEND_DEL_CALL_FLAG(EX(call), ZEND_CALL_SEND_ARG_BY_REF);
		}
	} else if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
		ZEND_ADD_CALL_FLAG(EX(call), ZEND_CALL_SEND_ARG_BY_REF);
	} else {
		ZEND_DEL_CALL_FLAG(EX(call), ZEND_CALL_SEND_ARG_BY_REF);
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED_QUICK_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		arg_num = zend_get_arg_offset_by_name(
			EX(call)->func, arg_name, CACHE_ADDR(opline->result.num)) + 1;
		if (UNEXPECTED(arg_num == 0)) {
			/* Treat this as a by-value argument, and throw an error during SEND. */
			ZEND_DEL_CALL_FLAG(EX(call), ZEND_CALL_SEND_ARG_BY_REF);
			ZEND_VM_NEXT_OPCODE();
		}
	} else {
		arg_num = opline->op2.num;
	}

	if (EXPECTED(1)) {
		if (QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			ZEND_ADD_CALL_FLAG(EX(call), ZEND_CALL_SEND_ARG_BY_REF);
		} else {
			ZEND_DEL_CALL_FLAG(EX(call), ZEND_CALL_SEND_ARG_BY_REF);
		}
	} else if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
		ZEND_ADD_CALL_FLAG(EX(call), ZEND_CALL_SEND_ARG_BY_REF);
	} else {
		ZEND_DEL_CALL_FLAG(EX(call), ZEND_CALL_SEND_ARG_BY_REF);
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CHECK_UNDEF_ARGS_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zend_execute_data *call = execute_data->call;
	if (EXPECTED(!(ZEND_CALL_INFO(call) & ZEND_CALL_MAY_HAVE_UNDEF))) {
		ZEND_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	zend_handle_undef_args(call);
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_NEW_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *result;
	zend_function *constructor;
	zend_class_entry *ce;
	zend_execute_data *call;

	SAVE_OPLINE();
	if (IS_UNUSED == IS_CONST) {
		ce = CACHED_PTR(opline->op2.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op1)), Z_STR_P(RT_CONSTANT(opline, opline->op1) + 1), ZEND_FETCH_CLASS_DEFAULT | ZEND_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
			CACHE_PTR(opline->op2.num, ce);
		}
	} else if (IS_UNUSED == IS_UNUSED) {
		ce = zend_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		}
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));
	}

	result = EX_VAR(opline->result.var);
	if (UNEXPECTED(object_init_ex(result, ce) != SUCCESS)) {
		ZVAL_UNDEF(result);
		HANDLE_EXCEPTION();
	}

	constructor = Z_OBJ_HT_P(result)->get_constructor(Z_OBJ_P(result));
	if (constructor == NULL) {
		if (UNEXPECTED(EG(exception))) {
			HANDLE_EXCEPTION();
		}

		/* If there are no arguments, skip over the DO_FCALL opcode. We check if the next
		 * opcode is DO_FCALL in case EXT instructions are used. */
		if (EXPECTED(opline->extended_value == 0 && (opline+1)->opcode == ZEND_DO_FCALL)) {
			ZEND_VM_NEXT_OPCODE_EX(1, 2);
		}

		/* Perform a dummy function call */
		call = zend_vm_stack_push_call_frame(
			ZEND_CALL_FUNCTION, (zend_function *) &zend_pass_function,
			opline->extended_value, NULL);
	} else {
		if (EXPECTED(constructor->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&constructor->op_array))) {
			init_func_run_time_cache(&constructor->op_array);
		}
		/* We are not handling overloaded classes right now */
		call = zend_vm_stack_push_call_frame(
			ZEND_CALL_FUNCTION | ZEND_CALL_RELEASE_THIS | ZEND_CALL_HAS_THIS,
			constructor,
			opline->extended_value,
			Z_OBJ_P(result));
		Z_ADDREF_P(result);
	}

	call->prev_execute_data = EX(call);
	EX(call) = call;
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_ARRAY_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_UNUSED != IS_UNUSED) {
		size = opline->extended_value >> ZEND_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, zend_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & ZEND_ARRAY_NOT_PACKED) {
			zend_hash_real_init_mixed(Z_ARRVAL_P(array));
		}
		ZEND_VM_TAIL_CALL(ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, zend_new_array(0));
		ZEND_VM_NEXT_OPCODE();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_YIELD_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & ZEND_GENERATOR_FORCED_CLOSE)) {
		ZEND_VM_TAIL_CALL(zend_yield_in_closed_generator_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_UNUSED != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_UNUSED & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = NULL;
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_UNUSED == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
						Z_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = NULL;

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_UNUSED == IS_VAR) {
						ZEND_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == ZEND_RETURNS_FUNCTION
						 && !Z_ISREF_P(value_ptr)) {
							zend_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (Z_ISREF_P(value_ptr)) {
						Z_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, Z_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = NULL;

			/* Consts, temporary variables and references need copying */
			if (IS_UNUSED == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
					Z_ADDREF(generator->value);
				}
			} else if (IS_UNUSED == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if ((IS_UNUSED & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, Z_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_UNUSED == IS_CV) {
					if (Z_OPT_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {
		zval *key = NULL;
		if ((IS_UNUSED & (IS_CV|IS_VAR)) && UNEXPECTED(Z_TYPE_P(key)) == IS_REFERENCE) {
			key = Z_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_THIS_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(Z_TYPE(EX(This)) == IS_OBJECT)) {
		zval *result = EX_VAR(opline->result.var);

		ZVAL_OBJ(result, Z_OBJ(EX(This)));
		Z_ADDREF_P(result);
		ZEND_VM_NEXT_OPCODE();
	} else {
		ZEND_VM_TAIL_CALL(zend_this_not_in_object_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_THIS_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	ZVAL_BOOL(EX_VAR(opline->result.var),
		(opline->extended_value & ZEND_ISEMPTY) ^
		 (Z_TYPE(EX(This)) == IS_OBJECT));
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_GET_CLASS_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (IS_UNUSED == IS_UNUSED) {
		if (UNEXPECTED(!EX(func)->common.scope)) {
			SAVE_OPLINE();
			zend_throw_error(NULL, "get_class() without arguments must be called from within a class");
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		} else {
			ZVAL_STR_COPY(EX_VAR(opline->result.var), EX(func)->common.scope->name);
			ZEND_VM_NEXT_OPCODE();
		}
	} else {
		zval *op1;

		SAVE_OPLINE();
		op1 = NULL;
		while (1) {
			if (Z_TYPE_P(op1) == IS_OBJECT) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), Z_OBJCE_P(op1)->name);
			} else if ((IS_UNUSED & (IS_VAR|IS_CV)) != 0 && Z_TYPE_P(op1) == IS_REFERENCE) {
				op1 = Z_REFVAL_P(op1);
				continue;
			} else {
				if (IS_UNUSED == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
					ZVAL_UNDEFINED_OP1();
				}
				zend_type_error("get_class(): Argument #1 ($object) must be of type object, %s given", zend_zval_type_name(op1));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
			}
			break;
		}

		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_GET_CALLED_CLASS_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (Z_TYPE(EX(This)) == IS_OBJECT) {
		ZVAL_STR_COPY(EX_VAR(opline->result.var), Z_OBJCE(EX(This))->name);
	} else if (Z_CE(EX(This))) {
		ZVAL_STR_COPY(EX_VAR(opline->result.var), Z_CE(EX(This))->name);
	} else {
		ZEND_ASSERT(!EX(func)->common.scope);
		SAVE_OPLINE();
		zend_throw_error(NULL, "get_called_class() must be called from within a class");
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FUNC_NUM_ARGS_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	ZVAL_LONG(EX_VAR(opline->result.var), EX_NUM_ARGS());
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FUNC_GET_ARGS_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_array *ht;
	uint32_t arg_count, result_size, skip;

	arg_count = EX_NUM_ARGS();
	if (IS_UNUSED == IS_CONST) {
		skip = Z_LVAL_P(RT_CONSTANT(opline, opline->op1));
		if (arg_count < skip) {
			result_size = 0;
		} else {
			result_size = arg_count - skip;
		}
	} else {
		skip = 0;
		result_size = arg_count;
	}

	if (result_size) {
		uint32_t first_extra_arg = EX(func)->op_array.num_args;

		ht = zend_new_array(result_size);
		ZVAL_ARR(EX_VAR(opline->result.var), ht);
		zend_hash_real_init_packed(ht);
		ZEND_HASH_FILL_PACKED(ht) {
			zval *p, *q;
			uint32_t i = skip;
			p = EX_VAR_NUM(i);
			if (arg_count > first_extra_arg) {
				while (i < first_extra_arg) {
					q = p;
					if (EXPECTED(Z_TYPE_INFO_P(q) != IS_UNDEF)) {
						ZVAL_DEREF(q);
						if (Z_OPT_REFCOUNTED_P(q)) {
							Z_ADDREF_P(q);
						}
						ZEND_HASH_FILL_SET(q);
					} else {
						ZEND_HASH_FILL_SET_NULL();
					}
					ZEND_HASH_FILL_NEXT();
					p++;
					i++;
				}
				if (skip < first_extra_arg) {
					skip = 0;
				} else {
					skip -= first_extra_arg;
				}
				p = EX_VAR_NUM(EX(func)->op_array.last_var + EX(func)->op_array.T + skip);
			}
			while (i < arg_count) {
				q = p;
				if (EXPECTED(Z_TYPE_INFO_P(q) != IS_UNDEF)) {
					ZVAL_DEREF(q);
					if (Z_OPT_REFCOUNTED_P(q)) {
						Z_ADDREF_P(q);
					}
					ZEND_HASH_FILL_SET(q);
				} else {
					ZEND_HASH_FILL_SET_NULL();
				}
				ZEND_HASH_FILL_NEXT();
				p++;
				i++;
			}
		} ZEND_HASH_FILL_END();
		ht->nNumOfElements = result_size;
	} else {
		ZVAL_EMPTY_ARRAY(EX_VAR(opline->result.var));
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_OP_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *value;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto assign_op_object;
			}
			if (IS_UNUSED == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

assign_op_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if (IS_CV == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CV == IS_CONST) ? CACHE_ADDR((opline+1)->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				zval *orig_zptr = zptr;
				zend_reference *ref;

				do {
					if (UNEXPECTED(Z_ISREF_P(zptr))) {
						ref = Z_REF_P(zptr);
						zptr = Z_REFVAL_P(zptr);
						if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
							zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
							break;
						}
					}

					if (IS_CV == IS_CONST) {
						prop_info = (zend_property_info*)CACHED_PTR_EX(cache_slot + 2);
					} else {
						prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), orig_zptr);
					}
					if (UNEXPECTED(prop_info)) {
						/* special case for typed properties */
						zend_binary_assign_op_typed_prop(prop_info, zptr, value OPLINE_CC EXECUTE_DATA_CC);
					} else {
						zend_binary_op(zptr, zptr, value OPLINE_CC);
					}
				} while (0);

				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		} else {
			zend_assign_op_overloaded_property(zobj, name, cache_slot, value OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CV != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);


	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMP|VAR|CV, UNUSED|CONST|TMPVAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_INC_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto pre_incdec_object;
			}
			if (IS_UNUSED == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

pre_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if (IS_CV == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				if (IS_CV == IS_CONST) {
					prop_info = (zend_property_info *) CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), zptr);
				}
				zend_pre_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			zend_pre_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CV != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POST_INC_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto post_incdec_object;
			}
			if (IS_UNUSED == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

post_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if (IS_CV == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}
		cache_slot = (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			} else {
				if (IS_CV == IS_CONST) {
					prop_info = (zend_property_info*)CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), zptr);
				}

				zend_post_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			zend_post_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CV != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_R_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = &EX(This);
	offset = EX_VAR(opline->op2.var);

	if (IS_UNUSED == IS_CONST ||
	    (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
	    do {
			if ((IS_UNUSED & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_UNUSED == IS_CV && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			zend_wrong_property_read(container, offset);
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if (IS_CV == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value & ~ZEND_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
		} else {
			if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));

		if (IS_CV != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_W_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();

	container = &EX(This);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(
		result, container, IS_UNUSED, property, IS_CV,
		((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_FETCH_OBJ_FLAGS) : NULL),
		BP_VAR_W, opline->extended_value & ZEND_FETCH_OBJ_FLAGS, 1 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_UNUSED == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();
	container = &EX(This);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(result, container, IS_UNUSED, property, IS_CV, ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_RW, 0, 1 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_UNUSED == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = &EX(This);
	offset = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	if (IS_UNUSED == IS_CONST ||
	    (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_UNUSED & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if (IS_CV == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if (IS_CV != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_UNUSED & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_W_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_R_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *property, *result;

	SAVE_OPLINE();
	container = &EX(This);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(result, container, IS_UNUSED, property, IS_CV, ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_UNSET, 0, 1 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_UNUSED == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	value = RT_CONSTANT((opline+1), (opline+1)->op1);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CV == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_CONST == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_CONST == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_CONST, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_CONST != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_CONST == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_CONST == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CV == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:


	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CV == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_TMP_VAR == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_TMP_VAR == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_TMP_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_TMP_VAR != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_TMP_VAR == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_TMP_VAR == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CV == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:


	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CV == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_VAR == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_VAR == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_VAR, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_VAR != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_VAR == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_VAR == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CV == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:


	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CV == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_CV == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_CV == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_CV, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_CV != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_CV == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_CV == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_CV == IS_CV || IS_CV == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CV == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:


	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = &EX(This);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_UNUSED == IS_UNUSED) {
			if (IS_CV == IS_CONST) {
				zend_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CV == IS_CONST) {
				zend_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		zend_assign_to_property_reference(container, IS_UNUSED, property, IS_CV, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}


	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));;
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = &EX(This);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_cv_BP_VAR_W((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_UNUSED == IS_UNUSED) {
			if (IS_CV == IS_CONST) {
				zend_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CV == IS_CONST) {
				zend_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		zend_assign_to_property_reference(container, IS_UNUSED, property, IS_CV, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}



	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_INIT_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_string **rope;
	zval *var;

	/* Compiler allocates the necessary number of zval slots to keep the rope */
	rope = (zend_string**)EX_VAR(opline->result.var);
	if (IS_CV == IS_CONST) {
		var = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
		rope[0] = Z_STR_P(var);
		if (UNEXPECTED(Z_REFCOUNTED_P(var))) {
			Z_ADDREF_P(var);
		}
	} else {
		var = EX_VAR(opline->op2.var);
		if (EXPECTED(Z_TYPE_P(var) == IS_STRING)) {
			if (IS_CV == IS_CV) {
				rope[0] = zend_string_copy(Z_STR_P(var));
			} else {
				rope[0] = Z_STR_P(var);
			}
		} else {
			SAVE_OPLINE();
			if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(var) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			rope[0] = zval_get_string_func(var);

			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_CLASS_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *class_name;
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_CV == IS_UNUSED) {
		Z_CE_P(EX_VAR(opline->result.var)) = zend_fetch_class(NULL, opline->op1.num);
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	} else if (IS_CV == IS_CONST) {
		zend_class_entry *ce = CACHED_PTR(opline->extended_value);

		if (UNEXPECTED(ce == NULL)) {
			class_name = EX_VAR(opline->op2.var);
			ce = zend_fetch_class_by_name(Z_STR_P(class_name), Z_STR_P(class_name + 1), opline->op1.num);
			CACHE_PTR(opline->extended_value, ce);
		}
		Z_CE_P(EX_VAR(opline->result.var)) = ce;
	} else {
		class_name = EX_VAR(opline->op2.var);
try_class_name:
		if (Z_TYPE_P(class_name) == IS_OBJECT) {
			Z_CE_P(EX_VAR(opline->result.var)) = Z_OBJCE_P(class_name);
		} else if (Z_TYPE_P(class_name) == IS_STRING) {
			Z_CE_P(EX_VAR(opline->result.var)) = zend_fetch_class(Z_STR_P(class_name), opline->op1.num);
		} else if ((IS_CV & (IS_VAR|IS_CV)) && Z_TYPE_P(class_name) == IS_REFERENCE) {
			class_name = Z_REFVAL_P(class_name);
			goto try_class_name;
		} else {
			if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(class_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
			zend_throw_error(NULL, "Class name must be a valid object or a string");
		}
	}

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	zend_function *fbc;
	zend_class_entry *called_scope;
	zend_object *obj;
	zend_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = &EX(This);

	if (IS_CV != IS_CONST) {
		function_name = EX_VAR(opline->op2.var);
	}

	if (IS_CV != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		do {
			if ((IS_CV & (IS_VAR|IS_CV)) && Z_ISREF_P(function_name)) {
				function_name = Z_REFVAL_P(function_name);
				if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {

					HANDLE_EXCEPTION();
				}
			}
			zend_throw_error(NULL, "Method name must be a string");


			HANDLE_EXCEPTION();
		} while (0);
	}

	if (IS_UNUSED == IS_UNUSED) {
		obj = Z_OBJ_P(object);
	} else {
		do {
			if (IS_UNUSED != IS_CONST && EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
				obj = Z_OBJ_P(object);
			} else {
				if ((IS_UNUSED & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(object))) {
					zend_reference *ref = Z_REF_P(object);

					object = &ref->val;
					if (EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
						obj = Z_OBJ_P(object);
						if (IS_UNUSED & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(zend_reference));
							} else {
								Z_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if (IS_UNUSED == IS_CV && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if (IS_CV != IS_CONST) {

						}
						HANDLE_EXCEPTION();
					}
				}
				if (IS_CV == IS_CONST) {
					function_name = EX_VAR(opline->op2.var);
				}
				zend_invalid_method_call(object, function_name);


				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if (IS_CV == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
	    fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
	    zend_object *orig_obj = obj;

		if (IS_CV == IS_CONST) {
			function_name = EX_VAR(opline->op2.var);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, Z_STR_P(function_name), ((IS_CV == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(obj->ce, Z_STR_P(function_name));
			}

			if ((IS_UNUSED & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if (IS_CV == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if ((IS_UNUSED & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (IS_CV != IS_CONST) {

	}

	call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_STATIC) != 0)) {
		if ((IS_UNUSED & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			zend_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (zend_object*)called_scope;
		call_info = ZEND_CALL_NESTED_FUNCTION;
	} else if (IS_UNUSED & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if (IS_UNUSED == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS | ZEND_CALL_RELEASE_THIS;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	uint32_t call_info;
	zend_function *fbc;
	zend_execute_data *call;

	SAVE_OPLINE();

	if (IS_UNUSED == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op1)), Z_STR_P(RT_CONSTANT(opline, opline->op1) + 1), ZEND_FETCH_CLASS_DEFAULT | ZEND_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {

				HANDLE_EXCEPTION();
			}
			if (IS_CV != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_UNUSED == IS_UNUSED) {
		ce = zend_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {

			HANDLE_EXCEPTION();
		}
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_UNUSED == IS_CONST &&
	    IS_CV == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_UNUSED != IS_CONST &&
	           IS_CV == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if (IS_CV != IS_UNUSED) {
		function_name = EX_VAR(opline->op2.var);
		if (IS_CV != IS_CONST) {
			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				do {
					if (IS_CV & (IS_VAR|IS_CV) && Z_ISREF_P(function_name)) {
						function_name = Z_REFVAL_P(function_name);
						if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					zend_throw_error(NULL, "Method name must be a string");

					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, Z_STR_P(function_name));
		} else {
			fbc = zend_std_get_static_method(ce, Z_STR_P(function_name), ((IS_CV == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(ce, Z_STR_P(function_name));
			}

			HANDLE_EXCEPTION();
		}
		if (IS_CV == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE)))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if (IS_CV != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (Z_TYPE(EX(This)) == IS_OBJECT && Z_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_throw_error(NULL, "Cannot call private %s::__construct()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & ZEND_ACC_STATIC)) {
		if (Z_TYPE(EX(This)) == IS_OBJECT && instanceof_function(Z_OBJCE(EX(This)), ce)) {
			ce = (zend_class_entry*)Z_OBJ(EX(This));
			call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
		} else {
			zend_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is ZEND_FETCH_CLASS */
		if (IS_UNUSED == IS_UNUSED
		 && ((opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_PARENT ||
		     (opline->op1.num & ZEND_FETCH_CLASS_MASK) == ZEND_FETCH_CLASS_SELF)) {
			if (Z_TYPE(EX(This)) == IS_OBJECT) {
				ce = Z_OBJCE(EX(This));
			} else {
				ce = Z_CE(EX(This));
			}
		}
		call_info = ZEND_CALL_NESTED_FUNCTION;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_ARRAY_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_UNUSED != IS_UNUSED) {
		size = opline->extended_value >> ZEND_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, zend_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & ZEND_ARRAY_NOT_PACKED) {
			zend_hash_real_init_mixed(Z_ARRVAL_P(array));
		}
		ZEND_VM_TAIL_CALL(ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, zend_new_array(0));
		ZEND_VM_NEXT_OPCODE();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_UNSET_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	container = &EX(This);
	offset = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT)) {
			if (Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (Z_TYPE_P(container) != IS_OBJECT) {
					if (IS_UNUSED == IS_CV
					 && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP1();
					}
					break;
				}
			} else {
				break;
			}
		}
		if (IS_CV == IS_CONST) {
			name = Z_STR_P(offset);
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				break;
			}
		}
		Z_OBJ_HT_P(container)->unset_property(Z_OBJ_P(container), name, ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL));
		if (IS_CV != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	container = &EX(This);
	offset = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	if (IS_UNUSED == IS_CONST ||
	    (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		if ((IS_UNUSED & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
			container = Z_REFVAL_P(container);
			if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & ZEND_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & ZEND_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if (IS_CV == IS_CONST) {
		name = Z_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & ZEND_ISEMPTY) ^
		Z_OBJ_HT_P(container)->has_property(Z_OBJ_P(container), name, (opline->extended_value & ZEND_ISEMPTY), ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_ISEMPTY) : NULL));

	if (IS_CV != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

isset_object_finish:


	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_YIELD_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & ZEND_GENERATOR_FORCED_CLOSE)) {
		ZEND_VM_TAIL_CALL(zend_yield_in_closed_generator_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_UNUSED != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_UNUSED & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = NULL;
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_UNUSED == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
						Z_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = NULL;

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_UNUSED == IS_VAR) {
						ZEND_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == ZEND_RETURNS_FUNCTION
						 && !Z_ISREF_P(value_ptr)) {
							zend_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (Z_ISREF_P(value_ptr)) {
						Z_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, Z_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = NULL;

			/* Consts, temporary variables and references need copying */
			if (IS_UNUSED == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
					Z_ADDREF(generator->value);
				}
			} else if (IS_UNUSED == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if ((IS_UNUSED & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, Z_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_UNUSED == IS_CV) {
					if (Z_OPT_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {
		zval *key = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
		if ((IS_CV & (IS_CV|IS_VAR)) && UNEXPECTED(Z_TYPE_P(key)) == IS_REFERENCE) {
			key = Z_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BOOL_NOT_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;

	val = EX_VAR(opline->op1.var);
	if (Z_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_FALSE(EX_VAR(opline->result.var));
	} else if (EXPECTED(Z_TYPE_INFO_P(val) <= IS_TRUE)) {
		/* The result and op1 can be the same cv zval */
		const uint32_t orig_val_type = Z_TYPE_INFO_P(val);
		ZVAL_TRUE(EX_VAR(opline->result.var));
		if (IS_CV == IS_CV && UNEXPECTED(orig_val_type == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	} else {
		SAVE_OPLINE();
		ZVAL_BOOL(EX_VAR(opline->result.var), !i_zend_is_true(val));

		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_pre_inc_helper_SPEC_CV(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);

	SAVE_OPLINE();
	if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_UNDEF)) {
		ZVAL_NULL(var_ptr);
		ZVAL_UNDEFINED_OP1();
	}

	do {
		if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_REFERENCE)) {
			zend_reference *ref = Z_REF_P(var_ptr);
			var_ptr = Z_REFVAL_P(var_ptr);
			if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
				zend_incdec_typed_ref(ref, NULL OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		increment_function(var_ptr);
	} while (0);

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_INC_SPEC_CV_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(var_ptr) == IS_LONG)) {
		fast_long_increment_function(var_ptr);
		if (UNEXPECTED(0)) {
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
		}
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_pre_inc_helper_SPEC_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_INC_SPEC_CV_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(var_ptr) == IS_LONG)) {
		fast_long_increment_function(var_ptr);
		if (UNEXPECTED(1)) {
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
		}
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_pre_inc_helper_SPEC_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_pre_dec_helper_SPEC_CV(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);

	SAVE_OPLINE();
	if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_UNDEF)) {
		ZVAL_NULL(var_ptr);
		ZVAL_UNDEFINED_OP1();
	}

	do {
		if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_REFERENCE)) {
			zend_reference *ref = Z_REF_P(var_ptr);
			var_ptr = Z_REFVAL_P(var_ptr);

			if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
				zend_incdec_typed_ref(ref, NULL OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		decrement_function(var_ptr);
	} while (0);

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_DEC_SPEC_CV_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(var_ptr) == IS_LONG)) {
		fast_long_decrement_function(var_ptr);
		if (UNEXPECTED(0)) {
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
		}
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_pre_dec_helper_SPEC_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_DEC_SPEC_CV_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(var_ptr) == IS_LONG)) {
		fast_long_decrement_function(var_ptr);
		if (UNEXPECTED(1)) {
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
		}
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_pre_dec_helper_SPEC_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_post_inc_helper_SPEC_CV(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);

	SAVE_OPLINE();
	if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_UNDEF)) {
		ZVAL_NULL(var_ptr);
		ZVAL_UNDEFINED_OP1();
	}

	do {
		if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_REFERENCE)) {
			zend_reference *ref = Z_REF_P(var_ptr);
			var_ptr = Z_REFVAL_P(var_ptr);

			if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
				zend_incdec_typed_ref(ref, EX_VAR(opline->result.var) OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);

		increment_function(var_ptr);
	} while (0);

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POST_INC_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(var_ptr) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(var_ptr));
		fast_long_increment_function(var_ptr);
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_post_inc_helper_SPEC_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_post_dec_helper_SPEC_CV(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);

	SAVE_OPLINE();
	if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_UNDEF)) {
		ZVAL_NULL(var_ptr);
		ZVAL_UNDEFINED_OP1();
	}

	do {
		if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_REFERENCE)) {
			zend_reference *ref = Z_REF_P(var_ptr);
			var_ptr = Z_REFVAL_P(var_ptr);

			if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
				zend_incdec_typed_ref(ref, EX_VAR(opline->result.var) OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);

		decrement_function(var_ptr);
	} while (0);

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POST_DEC_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(var_ptr) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(var_ptr));
		fast_long_decrement_function(var_ptr);
		ZEND_VM_NEXT_OPCODE();
	}

	ZEND_VM_TAIL_CALL(zend_post_dec_helper_SPEC_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ECHO_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *z;

	SAVE_OPLINE();
	z = EX_VAR(opline->op1.var);

	if (Z_TYPE_P(z) == IS_STRING) {
		zend_string *str = Z_STR_P(z);

		if (ZSTR_LEN(str) != 0) {
			zend_write(ZSTR_VAL(str), ZSTR_LEN(str));
		}
	} else {
		zend_string *str = zval_get_string_func(z);

		if (ZSTR_LEN(str) != 0) {
			zend_write(ZSTR_VAL(str), ZSTR_LEN(str));
		} else if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(z) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		zend_string_release_ex(str, 0);
	}

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMPZ_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	zend_uchar op1_type;

	val = EX_VAR(opline->op1.var);

	if (Z_TYPE_INFO_P(val) == IS_TRUE) {
		ZEND_VM_NEXT_OPCODE();
	} else if (EXPECTED(Z_TYPE_INFO_P(val) <= IS_TRUE)) {
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	SAVE_OPLINE();
	op1_type = IS_CV;
	if (i_zend_is_true(val)) {
		opline++;
	} else {
		opline = OP_JMP_ADDR(opline, opline->op2);
	}
	if (op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(val);
	}
	ZEND_VM_JMP(opline);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMPNZ_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	zend_uchar op1_type;

	val = EX_VAR(opline->op1.var);

	if (Z_TYPE_INFO_P(val) == IS_TRUE) {
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	} else if (EXPECTED(Z_TYPE_INFO_P(val) <= IS_TRUE)) {
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	op1_type = IS_CV;
	if (i_zend_is_true(val)) {
		opline = OP_JMP_ADDR(opline, opline->op2);
	} else {
		opline++;
	}
	if (op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(val);
	}
	ZEND_VM_JMP(opline);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMPZNZ_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	zend_uchar op1_type;

	val = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_INFO_P(val) == IS_TRUE)) {
		ZEND_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
		ZEND_VM_CONTINUE();
	} else if (EXPECTED(Z_TYPE_INFO_P(val) <= IS_TRUE)) {
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	SAVE_OPLINE();
	op1_type = IS_CV;
	if (i_zend_is_true(val)) {
		opline = ZEND_OFFSET_TO_OPLINE(opline, opline->extended_value);
	} else {
		opline = OP_JMP_ADDR(opline, opline->op2);
	}
	if (op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(val);
	}
	ZEND_VM_JMP(opline);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMPZ_EX_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	bool ret;

	val = EX_VAR(opline->op1.var);

	if (Z_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		ZEND_VM_NEXT_OPCODE();
	} else if (EXPECTED(Z_TYPE_INFO_P(val) <= IS_TRUE)) {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	SAVE_OPLINE();
	ret = i_zend_is_true(val);

	if (ret) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		opline++;
	} else {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		opline = OP_JMP_ADDR(opline, opline->op2);
	}
	ZEND_VM_JMP(opline);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMPNZ_EX_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	bool ret;

	val = EX_VAR(opline->op1.var);

	if (Z_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	} else if (EXPECTED(Z_TYPE_INFO_P(val) <= IS_TRUE)) {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			ZEND_VM_NEXT_OPCODE();
		}
	}

	SAVE_OPLINE();
	ret = i_zend_is_true(val);

	if (ret) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		opline = OP_JMP_ADDR(opline, opline->op2);
	} else {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		opline++;
	}
	ZEND_VM_JMP(opline);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_RETURN_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;

	retval_ptr = EX_VAR(opline->op1.var);
	return_value = EX(return_value);
	if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(retval_ptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		retval_ptr = ZVAL_UNDEFINED_OP1();
		if (return_value) {
			ZVAL_NULL(return_value);
		}
	} else if (!return_value) {
		if (IS_CV & (IS_VAR|IS_TMP_VAR)) {
			if (Z_REFCOUNTED_P(retval_ptr) && !Z_DELREF_P(retval_ptr)) {
				SAVE_OPLINE();
				rc_dtor_func(Z_COUNTED_P(retval_ptr));
			}
		}
	} else {
		if ((IS_CV & (IS_CONST|IS_TMP_VAR))) {
			ZVAL_COPY_VALUE(return_value, retval_ptr);
			if (IS_CV == IS_CONST) {
				if (UNEXPECTED(Z_OPT_REFCOUNTED_P(return_value))) {
					Z_ADDREF_P(return_value);
				}
			}
		} else if (IS_CV == IS_CV) {
			do {
				if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
					if (EXPECTED(!Z_OPT_ISREF_P(retval_ptr))) {
						if (EXPECTED(!(EX_CALL_INFO() & ZEND_CALL_CODE))) {
							zend_refcounted *ref = Z_COUNTED_P(retval_ptr);
							ZVAL_COPY_VALUE(return_value, retval_ptr);
							if (GC_MAY_LEAK(ref)) {
								gc_possible_root(ref);
							}
							ZVAL_NULL(retval_ptr);
							break;
						} else {
							Z_ADDREF_P(retval_ptr);
						}
					} else {
						retval_ptr = Z_REFVAL_P(retval_ptr);
						if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
							Z_ADDREF_P(retval_ptr);
						}
					}
				}
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			} while (0);
		} else /* if (IS_CV == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(retval_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(retval_ptr);

				retval_ptr = Z_REFVAL_P(retval_ptr);
				ZVAL_COPY_VALUE(return_value, retval_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
					Z_ADDREF_P(retval_ptr);
				}
			} else {
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			}
		}
	}

	ZEND_VM_TAIL_CALL(zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_RETURN_BY_REF_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;

	SAVE_OPLINE();

	do {
		if ((IS_CV & (IS_CONST|IS_TMP_VAR)) ||
		    (IS_CV == IS_VAR && opline->extended_value == ZEND_RETURNS_VALUE)) {
			/* Not supposed to happen, but we'll allow it */
			zend_error(E_NOTICE, "Only variable references should be returned by reference");

			retval_ptr = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
			if (!EX(return_value)) {

			} else {
				if (IS_CV == IS_VAR && UNEXPECTED(Z_ISREF_P(retval_ptr))) {
					ZVAL_COPY_VALUE(EX(return_value), retval_ptr);
					break;
				}

				ZVAL_NEW_REF(EX(return_value), retval_ptr);
				if (IS_CV == IS_CONST) {
					Z_TRY_ADDREF_P(retval_ptr);
				}
			}
			break;
		}

		retval_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);

		if (IS_CV == IS_VAR) {
			ZEND_ASSERT(retval_ptr != &EG(uninitialized_zval));
			if (opline->extended_value == ZEND_RETURNS_FUNCTION && !Z_ISREF_P(retval_ptr)) {
				zend_error(E_NOTICE, "Only variable references should be returned by reference");
				if (EX(return_value)) {
					ZVAL_NEW_REF(EX(return_value), retval_ptr);
				} else {

				}
				break;
			}
		}

		if (EX(return_value)) {
			if (Z_ISREF_P(retval_ptr)) {
				Z_ADDREF_P(retval_ptr);
			} else {
				ZVAL_MAKE_REF_EX(retval_ptr, 2);
			}
			ZVAL_REF(EX(return_value), Z_REF_P(retval_ptr));
		}

	} while (0);

	ZEND_VM_TAIL_CALL(zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_GENERATOR_RETURN_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval;

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	retval = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);

	/* Copy return value into generator->retval */
	if ((IS_CV & (IS_CONST|IS_TMP_VAR))) {
		ZVAL_COPY_VALUE(&generator->retval, retval);
		if (IS_CV == IS_CONST) {
			if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->retval))) {
				Z_ADDREF(generator->retval);
			}
		}
	} else if (IS_CV == IS_CV) {
		ZVAL_COPY_DEREF(&generator->retval, retval);
	} else /* if (IS_CV == IS_VAR) */ {
		if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_refcounted *ref = Z_COUNTED_P(retval);

			retval = Z_REFVAL_P(retval);
			ZVAL_COPY_VALUE(&generator->retval, retval);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(retval)) {
				Z_ADDREF_P(retval);
			}
		} else {
			ZVAL_COPY_VALUE(&generator->retval, retval);
		}
	}

	/* Close the generator to free up resources */
	zend_generator_close(generator, 1);

	/* Pass execution back to handling code */
	ZEND_VM_RETURN();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_THROW_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	SAVE_OPLINE();
	value = EX_VAR(opline->op1.var);

	do {
		if (IS_CV == IS_CONST || UNEXPECTED(Z_TYPE_P(value) != IS_OBJECT)) {
			if ((IS_CV & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
				value = Z_REFVAL_P(value);
				if (EXPECTED(Z_TYPE_P(value) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(value) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
			zend_throw_error(NULL, "Can only throw objects");

			HANDLE_EXCEPTION();
		}
	} while (0);

	zend_exception_save();
	Z_TRY_ADDREF_P(value);
	zend_throw_exception_object(value);
	zend_exception_restore();

	HANDLE_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_USER_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *arg, *param;

	SAVE_OPLINE();

	if (UNEXPECTED(ARG_MUST_BE_SENT_BY_REF(EX(call)->func, opline->op2.num))) {
		zend_param_must_be_ref(EX(call)->func, opline->op2.num);
	}

	arg = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	param = ZEND_CALL_VAR(EX(call), opline->result.var);
	ZVAL_COPY(param, arg);

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BOOL_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;

	val = EX_VAR(opline->op1.var);
	if (Z_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
	} else if (EXPECTED(Z_TYPE_INFO_P(val) <= IS_TRUE)) {
		/* The result and op1 can be the same cv zval */
		const uint32_t orig_val_type = Z_TYPE_INFO_P(val);
		ZVAL_FALSE(EX_VAR(opline->result.var));
		if (IS_CV == IS_CV && UNEXPECTED(orig_val_type == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	} else {
		SAVE_OPLINE();
		ZVAL_BOOL(EX_VAR(opline->result.var), i_zend_is_true(val));

		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CLONE_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *obj;
	zend_object *zobj;
	zend_class_entry *ce, *scope;
	zend_function *clone;
	zend_object_clone_obj_t clone_call;

	SAVE_OPLINE();
	obj = EX_VAR(opline->op1.var);

	do {
		if (IS_CV == IS_CONST ||
		    (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(obj) != IS_OBJECT))) {
		    if ((IS_CV & (IS_VAR|IS_CV)) && Z_ISREF_P(obj)) {
				obj = Z_REFVAL_P(obj);
				if (EXPECTED(Z_TYPE_P(obj) == IS_OBJECT)) {
					break;
				}
			}
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(obj) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
			zend_throw_error(NULL, "__clone method called on non-object");

			HANDLE_EXCEPTION();
		}
	} while (0);

	zobj = Z_OBJ_P(obj);
	ce = zobj->ce;
	clone = ce->clone;
	clone_call = zobj->handlers->clone_obj;
	if (UNEXPECTED(clone_call == NULL)) {
		zend_throw_error(NULL, "Trying to clone an uncloneable object of class %s", ZSTR_VAL(ce->name));

		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}

	if (clone && !(clone->common.fn_flags & ZEND_ACC_PUBLIC)) {
		scope = EX(func)->op_array.scope;
		if (clone->common.scope != scope) {
			if (UNEXPECTED(clone->common.fn_flags & ZEND_ACC_PRIVATE)
			 || UNEXPECTED(!zend_check_protected(zend_get_function_root_class(clone), scope))) {
				zend_wrong_clone_call(clone, scope);

				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		}
	}

	ZVAL_OBJ(EX_VAR(opline->result.var), clone_call(zobj));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CAST_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr;
	zval *result = EX_VAR(opline->result.var);
	HashTable *ht;

	SAVE_OPLINE();
	expr = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);

	switch (opline->extended_value) {
		case IS_LONG:
			ZVAL_LONG(result, zval_get_long(expr));
			break;
		case IS_DOUBLE:
			ZVAL_DOUBLE(result, zval_get_double(expr));
			break;
		case IS_STRING:
			ZVAL_STR(result, zval_get_string(expr));
			break;
		default:
			ZEND_ASSERT(opline->extended_value != _IS_BOOL && "Must use ZEND_BOOL instead");
			if (IS_CV & (IS_VAR|IS_CV)) {
				ZVAL_DEREF(expr);
			}
			/* If value is already of correct type, return it directly */
			if (Z_TYPE_P(expr) == opline->extended_value) {
				ZVAL_COPY_VALUE(result, expr);
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(result))) Z_ADDREF_P(result);
				} else if (IS_CV != IS_TMP_VAR) {
					if (Z_OPT_REFCOUNTED_P(result)) Z_ADDREF_P(result);
				}

				ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
			}

			if (opline->extended_value == IS_ARRAY) {
				if (IS_CV == IS_CONST || Z_TYPE_P(expr) != IS_OBJECT || Z_OBJCE_P(expr) == zend_ce_closure) {
					if (Z_TYPE_P(expr) != IS_NULL) {
						ZVAL_ARR(result, zend_new_array(1));
						expr = zend_hash_index_add_new(Z_ARRVAL_P(result), 0, expr);
						if (IS_CV == IS_CONST) {
							if (UNEXPECTED(Z_OPT_REFCOUNTED_P(expr))) Z_ADDREF_P(expr);
						} else {
							if (Z_OPT_REFCOUNTED_P(expr)) Z_ADDREF_P(expr);
						}
					} else {
						ZVAL_EMPTY_ARRAY(result);
					}
				} else {
					HashTable *obj_ht = zend_get_properties_for(expr, ZEND_PROP_PURPOSE_ARRAY_CAST);
					if (obj_ht) {
						/* fast copy */
						ZVAL_ARR(result, zend_proptable_to_symtable(obj_ht,
							(Z_OBJCE_P(expr)->default_properties_count ||
							 Z_OBJ_P(expr)->handlers != &std_object_handlers ||
							 GC_IS_RECURSIVE(obj_ht))));
						zend_release_properties(obj_ht);
					} else {
						ZVAL_EMPTY_ARRAY(result);
					}
				}
			} else {
				ZEND_ASSERT(opline->extended_value == IS_OBJECT);
				ZVAL_OBJ(result, zend_objects_new(zend_standard_class_def));
				if (Z_TYPE_P(expr) == IS_ARRAY) {
					ht = zend_symtable_to_proptable(Z_ARR_P(expr));
					if (GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) {
						/* TODO: try not to duplicate immutable arrays as well ??? */
						ht = zend_array_dup(ht);
					}
					Z_OBJ_P(result)->properties = ht;
				} else if (Z_TYPE_P(expr) != IS_NULL) {
					Z_OBJ_P(result)->properties = ht = zend_new_array(1);
					expr = zend_hash_add_new(ht, ZSTR_KNOWN(ZEND_STR_SCALAR), expr);
					if (IS_CV == IS_CONST) {
						if (UNEXPECTED(Z_OPT_REFCOUNTED_P(expr))) Z_ADDREF_P(expr);
					} else {
						if (Z_OPT_REFCOUNTED_P(expr)) Z_ADDREF_P(expr);
					}
				}
			}
	}

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_op_array *new_op_array;
	zval *inc_filename;

	SAVE_OPLINE();
	inc_filename = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	new_op_array = zend_include_or_eval(inc_filename, opline->extended_value);
	if (UNEXPECTED(EG(exception) != NULL)) {

		if (new_op_array != ZEND_FAKE_OP_ARRAY && new_op_array != NULL) {
			destroy_op_array(new_op_array);
			efree_size(new_op_array, sizeof(zend_op_array));
		}
		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	} else if (new_op_array == ZEND_FAKE_OP_ARRAY) {
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_TRUE(EX_VAR(opline->result.var));
		}
	} else if (EXPECTED(new_op_array != NULL)) {
		zval *return_value = NULL;
		zend_execute_data *call;

		if (RETURN_VALUE_USED(opline)) {
			return_value = EX_VAR(opline->result.var);
		}

		new_op_array->scope = EX(func)->op_array.scope;

		call = zend_vm_stack_push_call_frame(
		    (Z_TYPE_INFO(EX(This)) & ZEND_CALL_HAS_THIS) | ZEND_CALL_NESTED_CODE | ZEND_CALL_HAS_SYMBOL_TABLE,
			(zend_function*)new_op_array, 0,
			Z_PTR(EX(This)));

		if (EX_CALL_INFO() & ZEND_CALL_HAS_SYMBOL_TABLE) {
			call->symbol_table = EX(symbol_table);
		} else {
			call->symbol_table = zend_rebuild_symbol_table();
		}

		call->prev_execute_data = execute_data;
		i_init_code_execute_data(call, new_op_array, return_value);

		if (EXPECTED(zend_execute_ex == execute_ex)) {

			ZEND_VM_ENTER();
		} else {
			ZEND_ADD_CALL_FLAG(call, ZEND_CALL_TOP);
			zend_execute_ex(call);
			zend_vm_stack_free_call_frame(call);
		}

		destroy_op_array(new_op_array);
		efree_size(new_op_array, sizeof(zend_op_array));
		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_rethrow_exception(execute_data);

			UNDEF_RESULT();
			HANDLE_EXCEPTION();
		}
	} else if (RETURN_VALUE_USED(opline)) {
		ZVAL_FALSE(EX_VAR(opline->result.var));
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FE_RESET_R_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array_ptr, *result;

	SAVE_OPLINE();

	array_ptr = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	if (EXPECTED(Z_TYPE_P(array_ptr) == IS_ARRAY)) {
		result = EX_VAR(opline->result.var);
		ZVAL_COPY_VALUE(result, array_ptr);
		if (IS_CV != IS_TMP_VAR && Z_OPT_REFCOUNTED_P(result)) {
			Z_ADDREF_P(array_ptr);
		}
		Z_FE_POS_P(result) = 0;

		ZEND_VM_NEXT_OPCODE();
	} else if (IS_CV != IS_CONST && EXPECTED(Z_TYPE_P(array_ptr) == IS_OBJECT)) {
		zend_object *zobj = Z_OBJ_P(array_ptr);
		if (!zobj->ce->get_iterator) {
			HashTable *properties;

			result = EX_VAR(opline->result.var);
			ZVAL_OBJ(result, zobj);
			if (IS_CV != IS_TMP_VAR) {
				GC_ADDREF(zobj);
			}
			properties = zobj->properties;
			if (properties) {
				if (UNEXPECTED(GC_REFCOUNT(properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(properties);
					}
					properties = zobj->properties = zend_array_dup(properties);
				}
			} else {
				properties = zobj->handlers->get_properties(zobj);
			}
			Z_FE_ITER_P(EX_VAR(opline->result.var)) = zend_hash_iterator_add(properties, 0);

			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			zend_bool is_empty = zend_fe_reset_iterator(array_ptr, 0 OPLINE_CC EXECUTE_DATA_CC);

			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			} else if (is_empty) {
				ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
			} else {
				ZEND_VM_NEXT_OPCODE();
			}
		}
	} else {
		zend_error(E_WARNING, "foreach() argument must be of type array|object, %s given", zend_zval_type_name(array_ptr));
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		Z_FE_ITER_P(EX_VAR(opline->result.var)) = (uint32_t)-1;

		ZEND_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FE_RESET_RW_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array_ptr, *array_ref;

	SAVE_OPLINE();

	if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		array_ref = array_ptr = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
		if (Z_ISREF_P(array_ref)) {
			array_ptr = Z_REFVAL_P(array_ref);
		}
	} else {
		array_ref = array_ptr = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	}

	if (EXPECTED(Z_TYPE_P(array_ptr) == IS_ARRAY)) {
		if (IS_CV == IS_VAR || IS_CV == IS_CV) {
			if (array_ptr == array_ref) {
				ZVAL_NEW_REF(array_ref, array_ref);
				array_ptr = Z_REFVAL_P(array_ref);
			}
			Z_ADDREF_P(array_ref);
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), array_ref);
		} else {
			array_ref = EX_VAR(opline->result.var);
			ZVAL_NEW_REF(array_ref, array_ptr);
			array_ptr = Z_REFVAL_P(array_ref);
		}
		if (IS_CV == IS_CONST) {
			ZVAL_ARR(array_ptr, zend_array_dup(Z_ARRVAL_P(array_ptr)));
		} else {
			SEPARATE_ARRAY(array_ptr);
		}
		Z_FE_ITER_P(EX_VAR(opline->result.var)) = zend_hash_iterator_add(Z_ARRVAL_P(array_ptr), 0);

		if (IS_CV == IS_VAR) {

		}
		ZEND_VM_NEXT_OPCODE();
	} else if (IS_CV != IS_CONST && EXPECTED(Z_TYPE_P(array_ptr) == IS_OBJECT)) {
		if (!Z_OBJCE_P(array_ptr)->get_iterator) {
			if (IS_CV == IS_VAR || IS_CV == IS_CV) {
				if (array_ptr == array_ref) {
					ZVAL_NEW_REF(array_ref, array_ref);
					array_ptr = Z_REFVAL_P(array_ref);
				}
				Z_ADDREF_P(array_ref);
				ZVAL_COPY_VALUE(EX_VAR(opline->result.var), array_ref);
			} else {
				array_ptr = EX_VAR(opline->result.var);
				ZVAL_COPY_VALUE(array_ptr, array_ref);
			}
			if (Z_OBJ_P(array_ptr)->properties
			 && UNEXPECTED(GC_REFCOUNT(Z_OBJ_P(array_ptr)->properties) > 1)) {
				if (EXPECTED(!(GC_FLAGS(Z_OBJ_P(array_ptr)->properties) & IS_ARRAY_IMMUTABLE))) {
					GC_DELREF(Z_OBJ_P(array_ptr)->properties);
				}
				Z_OBJ_P(array_ptr)->properties = zend_array_dup(Z_OBJ_P(array_ptr)->properties);
			}
			Z_FE_ITER_P(EX_VAR(opline->result.var)) = zend_hash_iterator_add(Z_OBJPROP_P(array_ptr), 0);

			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			zend_bool is_empty = zend_fe_reset_iterator(array_ptr, 1 OPLINE_CC EXECUTE_DATA_CC);

			if (IS_CV == IS_VAR) {

			} else {

			}
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			} else if (is_empty) {
				ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
			} else {
				ZEND_VM_NEXT_OPCODE();
			}
		}
	} else {
		zend_error(E_WARNING, "foreach() argument must be of type array|object, %s given", zend_zval_type_name(array_ptr));
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		Z_FE_ITER_P(EX_VAR(opline->result.var)) = (uint32_t)-1;
		if (IS_CV == IS_VAR) {

		} else {

		}
		ZEND_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_JMP_SET_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *ref = NULL;
	bool ret;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && Z_ISREF_P(value)) {
		if (IS_CV == IS_VAR) {
			ref = value;
		}
		value = Z_REFVAL_P(value);
	}

	ret = i_zend_is_true(value);

	if (UNEXPECTED(EG(exception))) {

		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}

	if (ret) {
		zval *result = EX_VAR(opline->result.var);

		ZVAL_COPY_VALUE(result, value);
		if (IS_CV == IS_CONST) {
			if (UNEXPECTED(Z_OPT_REFCOUNTED_P(result))) Z_ADDREF_P(result);
		} else if (IS_CV == IS_CV) {
			if (Z_OPT_REFCOUNTED_P(result)) Z_ADDREF_P(result);
		} else if (IS_CV == IS_VAR && ref) {
			zend_reference *r = Z_REF_P(ref);

			if (UNEXPECTED(GC_DELREF(r) == 0)) {
				efree_size(r, sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(result)) {
				Z_ADDREF_P(result);
			}
		}
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_COALESCE_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *ref = NULL;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_IS(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_CV & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
		if (IS_CV & IS_VAR) {
			ref = value;
		}
		value = Z_REFVAL_P(value);
	}

	if (Z_TYPE_P(value) > IS_NULL) {
		zval *result = EX_VAR(opline->result.var);
		ZVAL_COPY_VALUE(result, value);
		if (IS_CV == IS_CONST) {
			if (UNEXPECTED(Z_OPT_REFCOUNTED_P(result))) Z_ADDREF_P(result);
		} else if (IS_CV == IS_CV) {
			if (Z_OPT_REFCOUNTED_P(result)) Z_ADDREF_P(result);
		} else if ((IS_CV & IS_VAR) && ref) {
			zend_reference *r = Z_REF_P(ref);

			if (UNEXPECTED(GC_DELREF(r) == 0)) {
				efree_size(r, sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(result)) {
				Z_ADDREF_P(result);
			}
		}
		ZEND_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_QM_ASSIGN_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *result = EX_VAR(opline->result.var);

	value = EX_VAR(opline->op1.var);
	if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(value) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(result);
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_CV == IS_CV) {
		ZVAL_COPY_DEREF(result, value);
	} else if (IS_CV == IS_VAR) {
		if (UNEXPECTED(Z_ISREF_P(value))) {
			ZVAL_COPY_VALUE(result, Z_REFVAL_P(value));
			if (UNEXPECTED(Z_DELREF_P(value) == 0)) {
				efree_size(Z_REF_P(value), sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(result)) {
				Z_ADDREF_P(result);
			}
		} else {
			ZVAL_COPY_VALUE(result, value);
		}
	} else {
		ZVAL_COPY_VALUE(result, value);
		if (IS_CV == IS_CONST) {
			if (UNEXPECTED(Z_OPT_REFCOUNTED_P(result))) {
				Z_ADDREF_P(result);
			}
		}
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_YIELD_FROM_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);
	zval *val;

	SAVE_OPLINE();
	val = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);

	if (UNEXPECTED(generator->flags & ZEND_GENERATOR_FORCED_CLOSE)) {
		zend_throw_error(NULL, "Cannot use \"yield from\" in a force-closed generator");

		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

yield_from_try_again:
	if (Z_TYPE_P(val) == IS_ARRAY) {
		ZVAL_COPY_VALUE(&generator->values, val);
		if (Z_OPT_REFCOUNTED_P(val)) {
			Z_ADDREF_P(val);
		}
		Z_FE_POS(generator->values) = 0;

	} else if (IS_CV != IS_CONST && Z_TYPE_P(val) == IS_OBJECT && Z_OBJCE_P(val)->get_iterator) {
		zend_class_entry *ce = Z_OBJCE_P(val);
		if (ce == zend_ce_generator) {
			zend_generator *new_gen = (zend_generator *) Z_OBJ_P(val);

			Z_ADDREF_P(val);

			if (UNEXPECTED(new_gen->execute_data == NULL)) {
				zend_throw_error(NULL, "Generator passed to yield from was aborted without proper return and is unable to continue");
				zval_ptr_dtor(val);
				UNDEF_RESULT();
				HANDLE_EXCEPTION();
			} else if (Z_ISUNDEF(new_gen->retval)) {
				if (UNEXPECTED(zend_generator_get_current(new_gen) == generator)) {
					zend_throw_error(NULL, "Impossible to yield from the Generator being currently run");
					zval_ptr_dtor(val);
					UNDEF_RESULT();
					HANDLE_EXCEPTION();
				} else {
					zend_generator_yield_from(generator, new_gen);
				}
			} else {
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), &new_gen->retval);
				}
				ZEND_VM_NEXT_OPCODE();
			}
		} else {
			zend_object_iterator *iter = ce->get_iterator(ce, val, 0);

			if (UNEXPECTED(!iter) || UNEXPECTED(EG(exception))) {
				if (!EG(exception)) {
					zend_throw_error(NULL, "Object of type %s did not create an Iterator", ZSTR_VAL(ce->name));
				}
				UNDEF_RESULT();
				HANDLE_EXCEPTION();
			}

			iter->index = 0;
			if (iter->funcs->rewind) {
				iter->funcs->rewind(iter);
				if (UNEXPECTED(EG(exception) != NULL)) {
					OBJ_RELEASE(&iter->std);
					UNDEF_RESULT();
					HANDLE_EXCEPTION();
				}
			}

			ZVAL_OBJ(&generator->values, &iter->std);
		}
	} else if ((IS_CV & (IS_VAR|IS_CV)) && Z_TYPE_P(val) == IS_REFERENCE) {
		val = Z_REFVAL_P(val);
		goto yield_from_try_again;
	} else {
		zend_throw_error(NULL, "Can use \"yield from\" only with arrays and Traversables");

		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

	/* This is the default return value
	 * when the expression is a Generator, it will be overwritten in zend_generator_resume() */
	if (RETURN_VALUE_USED(opline)) {
		ZVAL_NULL(EX_VAR(opline->result.var));
	}

	/* This generator has no send target (though the generator we delegate to might have one) */
	generator->send_target = NULL;

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_STRLEN_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	value = EX_VAR(opline->op1.var);
	if (EXPECTED(Z_TYPE_P(value) == IS_STRING)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_STRLEN_P(value));

		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_bool strict;

		if ((IS_CV & (IS_VAR|IS_CV)) && Z_TYPE_P(value) == IS_REFERENCE) {
			value = Z_REFVAL_P(value);
			if (EXPECTED(Z_TYPE_P(value) == IS_STRING)) {
				ZVAL_LONG(EX_VAR(opline->result.var), Z_STRLEN_P(value));

				ZEND_VM_NEXT_OPCODE();
			}
		}

		SAVE_OPLINE();
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(value) == IS_UNDEF)) {
			value = ZVAL_UNDEFINED_OP1();
		}
		strict = EX_USES_STRICT_TYPES();
		do {
			if (EXPECTED(!strict)) {
				zend_string *str;
				zval tmp;

				ZVAL_COPY(&tmp, value);
				if (zend_parse_arg_str_weak(&tmp, &str)) {
					ZVAL_LONG(EX_VAR(opline->result.var), ZSTR_LEN(str));
					zval_ptr_dtor(&tmp);
					break;
				}
				zval_ptr_dtor(&tmp);
			}
			if (!EG(exception)) {
				zend_type_error("strlen(): Argument #1 ($str) must be of type string, %s given", zend_zval_type_name(value));
			}
			ZVAL_UNDEF(EX_VAR(opline->result.var));
		} while (0);
	}

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_TYPE_CHECK_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	int result = 0;

	value = EX_VAR(opline->op1.var);
	if ((opline->extended_value >> (uint32_t)Z_TYPE_P(value)) & 1) {
type_check_resource:
		if (opline->extended_value != MAY_BE_RESOURCE
		 || EXPECTED(NULL != zend_rsrc_list_get_rsrc_type(Z_RES_P(value)))) {
			result = 1;
		}
	} else if ((IS_CV & (IS_CV|IS_VAR)) && Z_ISREF_P(value)) {
		value = Z_REFVAL_P(value);
		if ((opline->extended_value >> (uint32_t)Z_TYPE_P(value)) & 1) {
			goto type_check_resource;
		}
	} else if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(value) == IS_UNDEF)) {
		result = ((1 << IS_NULL) & opline->extended_value) != 0;
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		if (UNEXPECTED(EG(exception))) {
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		}
	}
	if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
		SAVE_OPLINE();

		ZEND_VM_SMART_BRANCH(result, 1);
	} else {
		ZEND_VM_SMART_BRANCH(result, 0);
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_CLASS_NAME_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	uint32_t fetch_type;
	zend_class_entry *called_scope, *scope;
	USE_OPLINE

	if (IS_CV != IS_UNUSED) {
		zval *op = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
		SAVE_OPLINE();
		if (UNEXPECTED(Z_TYPE_P(op) != IS_OBJECT)) {
			ZVAL_DEREF(op);
			if (Z_TYPE_P(op) != IS_OBJECT) {
				zend_type_error("Cannot use \"::class\" on value of type %s", zend_zval_type_name(op));
				ZVAL_UNDEF(EX_VAR(opline->result.var));

				HANDLE_EXCEPTION();
			}
		}

		ZVAL_STR_COPY(EX_VAR(opline->result.var), Z_OBJCE_P(op)->name);

		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	fetch_type = opline->op1.num;
	scope = EX(func)->op_array.scope;
	if (UNEXPECTED(scope == NULL)) {
		SAVE_OPLINE();
		zend_throw_error(NULL, "Cannot use \"%s\" in the global scope",
			fetch_type == ZEND_FETCH_CLASS_SELF ? "self" :
			fetch_type == ZEND_FETCH_CLASS_PARENT ? "parent" : "static");
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}

	switch (fetch_type) {
		case ZEND_FETCH_CLASS_SELF:
			ZVAL_STR_COPY(EX_VAR(opline->result.var), scope->name);
			break;
		case ZEND_FETCH_CLASS_PARENT:
			if (UNEXPECTED(scope->parent == NULL)) {
				SAVE_OPLINE();
				zend_throw_error(NULL,
					"Cannot use \"parent\" when current class scope has no parent");
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
			ZVAL_STR_COPY(EX_VAR(opline->result.var), scope->parent->name);
			break;
		case ZEND_FETCH_CLASS_STATIC:
			if (Z_TYPE(EX(This)) == IS_OBJECT) {
				called_scope = Z_OBJCE(EX(This));
			} else {
				called_scope = Z_CE(EX(This));
			}
			ZVAL_STR_COPY(EX_VAR(opline->result.var), called_scope->name);
			break;
		EMPTY_SWITCH_DEFAULT_CASE()
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	Z_LVAL_P(var_ptr)++;
	if (UNEXPECTED(0)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(var_ptr));
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	Z_LVAL_P(var_ptr)++;
	if (UNEXPECTED(1)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(var_ptr));
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_INC_LONG_SPEC_CV_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	fast_long_increment_function(var_ptr);
	if (UNEXPECTED(0)) {
		ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_INC_LONG_SPEC_CV_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	fast_long_increment_function(var_ptr);
	if (UNEXPECTED(1)) {
		ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	Z_LVAL_P(var_ptr)--;
	if (UNEXPECTED(0)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(var_ptr));
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	Z_LVAL_P(var_ptr)--;
	if (UNEXPECTED(1)) {
		ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(var_ptr));
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_DEC_LONG_SPEC_CV_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	fast_long_decrement_function(var_ptr);
	if (UNEXPECTED(0)) {
		ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_DEC_LONG_SPEC_CV_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	fast_long_decrement_function(var_ptr);
	if (UNEXPECTED(1)) {
		ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POST_INC_LONG_NO_OVERFLOW_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(var_ptr));
	Z_LVAL_P(var_ptr)++;
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POST_INC_LONG_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(var_ptr));
	fast_long_increment_function(var_ptr);
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POST_DEC_LONG_NO_OVERFLOW_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(var_ptr));
	Z_LVAL_P(var_ptr)--;
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POST_DEC_LONG_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	ZVAL_LONG(EX_VAR(opline->result.var), Z_LVAL_P(var_ptr));
	fast_long_decrement_function(var_ptr);
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAR_SIMPLE_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	varptr = EX_VAR(opline->op1.var);
	arg = ZEND_CALL_VAR(EX(call), opline->result.var);

	if (IS_CV == IS_CV) {
		ZVAL_COPY(arg, varptr);
	} else /* if (IS_CV == IS_VAR) */ {
		ZVAL_COPY_VALUE(arg, varptr);
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DIV_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	fast_div_function(EX_VAR(opline->result.var), op1, op2);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POW_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	pow_function(EX_VAR(opline->result.var), op1, op2);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);

	if ((IS_CV == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
	    (IS_CONST == IS_CONST || EXPECTED(Z_TYPE_P(op2) == IS_STRING))) {
		zend_string *op1_str = Z_STR_P(op1);
		zend_string *op2_str = Z_STR_P(op2);
		zend_string *str;

		if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if (IS_CONST == IS_CONST || IS_CONST == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
		} else if (IS_CONST != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else if (IS_CV != IS_CONST && IS_CV != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
		    size_t len = ZSTR_LEN(op1_str);

			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else {
			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		}
		ZEND_VM_NEXT_OPCODE();
	} else {
		SAVE_OPLINE();

		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
			op1 = ZVAL_UNDEFINED_OP1();
		}
		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
			op2 = ZVAL_UNDEFINED_OP2();
		}
		concat_function(EX_VAR(opline->result.var), op1, op2);


		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_IDENTICAL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_identical_function(op1, op2);


	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_IDENTICAL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_not_identical_function(op1, op2);


	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CV == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) == Z_LVAL_P(op2))) {
is_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_SPEC_CV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CV == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) == Z_LVAL_P(op2))) {
is_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_SPEC_CV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CV == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) == Z_LVAL_P(op2))) {
is_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CV == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) != Z_LVAL_P(op2))) {
is_not_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_not_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_not_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CV == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) != Z_LVAL_P(op2))) {
is_not_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_not_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_not_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CV == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) != Z_LVAL_P(op2))) {
is_not_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_not_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_not_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SPACESHIP_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	compare_function(EX_VAR(opline->result.var), op1, op2);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BOOL_XOR_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	boolean_xor_function(EX_VAR(opline->result.var), op1, op2);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_OP_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *value;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = RT_CONSTANT(opline, opline->op2);

	do {
		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto assign_op_object;
			}
			if (IS_CV == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

assign_op_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if (IS_CONST == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CONST == IS_CONST) ? CACHE_ADDR((opline+1)->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				zval *orig_zptr = zptr;
				zend_reference *ref;

				do {
					if (UNEXPECTED(Z_ISREF_P(zptr))) {
						ref = Z_REF_P(zptr);
						zptr = Z_REFVAL_P(zptr);
						if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
							zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
							break;
						}
					}

					if (IS_CONST == IS_CONST) {
						prop_info = (zend_property_info*)CACHED_PTR_EX(cache_slot + 2);
					} else {
						prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), orig_zptr);
					}
					if (UNEXPECTED(prop_info)) {
						/* special case for typed properties */
						zend_binary_assign_op_typed_prop(prop_info, zptr, value OPLINE_CC EXECUTE_DATA_CC);
					} else {
						zend_binary_op(zptr, zptr, value OPLINE_CC);
					}
				} while (0);

				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		} else {
			zend_assign_op_overloaded_property(zobj, name, cache_slot, value OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CONST != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);


	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMP|VAR|CV, UNUSED|CONST|TMPVAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_OP_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value, *container, *dim;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
assign_dim_op_array:
		SEPARATE_ARRAY(container);
assign_dim_op_new_array:
		dim = RT_CONSTANT(opline, opline->op2);
		if (IS_CONST == IS_UNUSED) {
			var_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(container), &EG(uninitialized_zval));
			if (UNEXPECTED(!var_ptr)) {
				zend_cannot_add_element();
				goto assign_dim_op_ret_null;
			}
		} else {
			if (IS_CONST == IS_CONST) {
				var_ptr = zend_fetch_dimension_address_inner_RW_CONST(Z_ARRVAL_P(container), dim EXECUTE_DATA_CC);
			} else {
				var_ptr = zend_fetch_dimension_address_inner_RW(Z_ARRVAL_P(container), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(!var_ptr)) {
				goto assign_dim_op_ret_null;
			}
		}

		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		do {
			if (IS_CONST != IS_UNUSED && UNEXPECTED(Z_ISREF_P(var_ptr))) {
				zend_reference *ref = Z_REF_P(var_ptr);
				var_ptr = Z_REFVAL_P(var_ptr);
				if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
					zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
					break;
				}
			}
			zend_binary_op(var_ptr, var_ptr, value OPLINE_CC);
		} while (0);

		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
		}
		FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	} else {
		if (EXPECTED(Z_ISREF_P(container))) {
			container = Z_REFVAL_P(container);
			if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				goto assign_dim_op_array;
			}
		}

		dim = RT_CONSTANT(opline, opline->op2);

		if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
			if (IS_CONST == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_binary_assign_op_obj_dim(container, dim OPLINE_CC EXECUTE_DATA_CC);
		} else if (EXPECTED(Z_TYPE_P(container) <= IS_FALSE)) {
			if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			ZVAL_ARR(container, zend_new_array(8));
			goto assign_dim_op_new_array;
		} else {
			zend_binary_assign_op_dim_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
assign_dim_op_ret_null:
			FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}


	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OP_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = RT_CONSTANT(opline, opline->op2);
	var_ptr = _get_zval_ptr_cv_BP_VAR_RW(opline->op1.var EXECUTE_DATA_CC);

	do {
		if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_REFERENCE)) {
			zend_reference *ref = Z_REF_P(var_ptr);
			var_ptr = Z_REFVAL_P(var_ptr);
			if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
				zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		zend_binary_op(var_ptr, var_ptr, value OPLINE_CC);
	} while (0);

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_INC_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = RT_CONSTANT(opline, opline->op2);

	do {
		if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto pre_incdec_object;
			}
			if (IS_CV == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

pre_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if (IS_CONST == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				if (IS_CONST == IS_CONST) {
					prop_info = (zend_property_info *) CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), zptr);
				}
				zend_pre_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			zend_pre_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CONST != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POST_INC_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = RT_CONSTANT(opline, opline->op2);

	do {
		if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto post_incdec_object;
			}
			if (IS_CV == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

post_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if (IS_CONST == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}
		cache_slot = (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			} else {
				if (IS_CONST == IS_CONST) {
					prop_info = (zend_property_info*)CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), zptr);
				}

				zend_post_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			zend_post_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CONST != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_R_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	dim = RT_CONSTANT(opline, opline->op2);
	if (IS_CV != IS_CONST) {
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_array:
			value = zend_fetch_dimension_address_inner(Z_ARRVAL_P(container), dim, IS_CONST, BP_VAR_R EXECUTE_DATA_CC);
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		} else if (EXPECTED(Z_TYPE_P(container) == IS_REFERENCE)) {
			container = Z_REFVAL_P(container);
			if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				goto fetch_dim_r_array;
			} else {
				goto fetch_dim_r_slow;
			}
		} else {
fetch_dim_r_slow:
			if (IS_CONST == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
		}
	} else {
		zend_fetch_dimension_address_read_R(container, dim, IS_CONST OPLINE_CC EXECUTE_DATA_CC);
	}


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_W_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	zend_fetch_dimension_address_W(container, RT_CONSTANT(opline, opline->op2), IS_CONST OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_RW_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	zend_fetch_dimension_address_RW(container, RT_CONSTANT(opline, opline->op2), IS_CONST OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_IS_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	zend_fetch_dimension_address_read_IS(container, RT_CONSTANT(opline, opline->op2), IS_CONST OPLINE_CC EXECUTE_DATA_CC);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
        if ((IS_CV & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
        }
		ZEND_VM_TAIL_CALL(ZEND_FETCH_DIM_W_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_CONST == IS_UNUSED) {
			ZEND_VM_TAIL_CALL(zend_use_undef_in_read_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_FETCH_DIM_R_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_UNSET_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	zend_fetch_dimension_address_UNSET(container, RT_CONSTANT(opline, opline->op2), IS_CONST OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static zend_always_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_R_SPEC_CV_CONST_INLINE_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	offset = RT_CONSTANT(opline, opline->op2);

	if (IS_CV == IS_CONST ||
	    (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
	    do {
			if ((IS_CV & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			zend_wrong_property_read(container, offset);
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if (IS_CONST == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value & ~ZEND_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
		} else {
			if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));

		if (IS_CONST != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_R_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_R_SPEC_CV_CONST_INLINE_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_W_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();

	container = EX_VAR(opline->op1.var);
	property = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(
		result, container, IS_CV, property, IS_CONST,
		((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_FETCH_OBJ_FLAGS) : NULL),
		BP_VAR_W, opline->extended_value & ZEND_FETCH_OBJ_FLAGS, 1 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_RW_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	property = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(result, container, IS_CV, property, IS_CONST, ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_RW, 0, 1 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_IS_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(opline->op1.var EXECUTE_DATA_CC);
	offset = RT_CONSTANT(opline, opline->op2);

	if (IS_CV == IS_CONST ||
	    (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_CV & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if (IS_CONST == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if (IS_CONST != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_CV & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_W_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_R_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_UNSET_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *property, *result;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	property = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(result, container, IS_CV, property, IS_CONST, ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_UNSET, 0, 1 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = RT_CONSTANT(opline, opline->op2);
	value = RT_CONSTANT((opline+1), (opline+1)->op1);

	if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CONST == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_CONST == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_CONST == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_CONST, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_CONST != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_CONST == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_CONST == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CONST == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:


	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = RT_CONSTANT(opline, opline->op2);
	value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CONST == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_TMP_VAR == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_TMP_VAR == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_TMP_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_TMP_VAR != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_TMP_VAR == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_TMP_VAR == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CONST == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:


	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = RT_CONSTANT(opline, opline->op2);
	value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CONST == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_VAR == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_VAR == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_VAR, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_VAR != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_VAR == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_VAR == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CONST == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:


	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = RT_CONSTANT(opline, opline->op2);
	value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CONST == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_CV == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_CV == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_CV, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_CV != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_CV == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_CV == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_CV == IS_CV || IS_CV == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CONST == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:


	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CONST == IS_UNUSED) {
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CONST == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_CONST == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CONST == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			value = zend_assign_to_variable(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = RT_CONSTANT(opline, opline->op2);
			value = RT_CONSTANT((opline+1), (opline+1)->op1);

			if (IS_CONST == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CONST == IS_UNUSED) {
				zend_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = RT_CONSTANT(opline, opline->op2);
				value = RT_CONSTANT((opline+1), (opline+1)->op1);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = RT_CONSTANT(opline, opline->op2);

				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = RT_CONSTANT(opline, opline->op2);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CONST != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CONST == IS_UNUSED) {
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_TMP_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_TMP_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_TMP_VAR == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = RT_CONSTANT(opline, opline->op2);
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

			if (IS_CONST == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CONST == IS_UNUSED) {
				zend_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = RT_CONSTANT(opline, opline->op2);
				value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = RT_CONSTANT(opline, opline->op2);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = RT_CONSTANT(opline, opline->op2);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CONST != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CONST == IS_UNUSED) {
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_VAR == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = RT_CONSTANT(opline, opline->op2);
			value = _get_zval_ptr_var_deref((opline+1)->op1.var EXECUTE_DATA_CC);

			if (IS_CONST == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CONST == IS_UNUSED) {
				zend_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = RT_CONSTANT(opline, opline->op2);
				value = _get_zval_ptr_var_deref((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = RT_CONSTANT(opline, opline->op2);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = RT_CONSTANT(opline, opline->op2);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CONST != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CONST == IS_UNUSED) {
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_CV == IS_CV || IS_CV == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CV == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_CV == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CV == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = RT_CONSTANT(opline, opline->op2);
			value = _get_zval_ptr_cv_deref_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

			if (IS_CONST == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CONST == IS_UNUSED) {
				zend_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = RT_CONSTANT(opline, opline->op2);
				value = _get_zval_ptr_cv_deref_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = RT_CONSTANT(opline, opline->op2);

				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = RT_CONSTANT(opline, opline->op2);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CONST != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_SPEC_CV_CONST_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = RT_CONSTANT(opline, opline->op2);
	variable_ptr = EX_VAR(opline->op1.var);

	value = zend_assign_to_variable(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES());
	if (UNEXPECTED(0)) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_SPEC_CV_CONST_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = RT_CONSTANT(opline, opline->op2);
	variable_ptr = EX_VAR(opline->op1.var);

	value = zend_assign_to_variable(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES());
	if (UNEXPECTED(1)) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = EX_VAR(opline->op1.var);
	property = RT_CONSTANT(opline, opline->op2);

	value_ptr = _get_zval_ptr_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_CV == IS_UNUSED) {
			if (IS_CONST == IS_CONST) {
				zend_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CONST == IS_CONST) {
				zend_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		zend_assign_to_property_reference(container, IS_CV, property, IS_CONST, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}


	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));;
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = EX_VAR(opline->op1.var);
	property = RT_CONSTANT(opline, opline->op2);

	value_ptr = _get_zval_ptr_cv_BP_VAR_W((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_CV == IS_UNUSED) {
			if (IS_CONST == IS_CONST) {
				zend_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CONST == IS_CONST) {
				zend_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		zend_assign_to_property_reference(container, IS_CV, property, IS_CONST, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}



	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_string *op1_str, *op2_str, *str;


	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if ((IS_CV == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
	    (IS_CONST == IS_CONST || EXPECTED(Z_TYPE_P(op2) == IS_STRING))) {
		zend_string *op1_str = Z_STR_P(op1);
		zend_string *op2_str = Z_STR_P(op2);
		zend_string *str;

		if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if (IS_CONST == IS_CONST || IS_CONST == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
		} else if (IS_CONST != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else if (IS_CV != IS_CONST && IS_CV != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
		    size_t len = ZSTR_LEN(op1_str);

			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else {
			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	if (IS_CV == IS_CONST) {
		op1_str = Z_STR_P(op1);
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		op1_str = zend_string_copy(Z_STR_P(op1));
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		op1_str = zval_get_string_func(op1);
	}
	if (IS_CONST == IS_CONST) {
		op2_str = Z_STR_P(op2);
	} else if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
		op2_str = zend_string_copy(Z_STR_P(op2));
	} else {
		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP2();
		}
		op2_str = zval_get_string_func(op2);
	}
	do {
		if (IS_CV != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(Z_REFCOUNTED_P(op2))) {
						GC_ADDREF(op2_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
				zend_string_release_ex(op1_str, 0);
				break;
			}
		}
		if (IS_CONST != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(Z_REFCOUNTED_P(op1))) {
						GC_ADDREF(op1_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
				zend_string_release_ex(op2_str, 0);
				break;
			}
		}
		str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
		memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
		memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
		ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
		if (IS_CV != IS_CONST) {
			zend_string_release_ex(op1_str, 0);
		}
		if (IS_CONST != IS_CONST) {
			zend_string_release_ex(op2_str, 0);
		}
	} while (0);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_METHOD_CALL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	zend_function *fbc;
	zend_class_entry *called_scope;
	zend_object *obj;
	zend_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = EX_VAR(opline->op1.var);

	if (IS_CONST != IS_CONST) {
		function_name = RT_CONSTANT(opline, opline->op2);
	}

	if (IS_CONST != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		do {
			if ((IS_CONST & (IS_VAR|IS_CV)) && Z_ISREF_P(function_name)) {
				function_name = Z_REFVAL_P(function_name);
				if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {

					HANDLE_EXCEPTION();
				}
			}
			zend_throw_error(NULL, "Method name must be a string");


			HANDLE_EXCEPTION();
		} while (0);
	}

	if (IS_CV == IS_UNUSED) {
		obj = Z_OBJ_P(object);
	} else {
		do {
			if (IS_CV != IS_CONST && EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
				obj = Z_OBJ_P(object);
			} else {
				if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(object))) {
					zend_reference *ref = Z_REF_P(object);

					object = &ref->val;
					if (EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
						obj = Z_OBJ_P(object);
						if (IS_CV & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(zend_reference));
							} else {
								Z_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if (IS_CONST != IS_CONST) {

						}
						HANDLE_EXCEPTION();
					}
				}
				if (IS_CONST == IS_CONST) {
					function_name = RT_CONSTANT(opline, opline->op2);
				}
				zend_invalid_method_call(object, function_name);


				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if (IS_CONST == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
	    fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
	    zend_object *orig_obj = obj;

		if (IS_CONST == IS_CONST) {
			function_name = RT_CONSTANT(opline, opline->op2);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, Z_STR_P(function_name), ((IS_CONST == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(obj->ce, Z_STR_P(function_name));
			}

			if ((IS_CV & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if (IS_CONST == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if ((IS_CV & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (IS_CONST != IS_CONST) {

	}

	call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_STATIC) != 0)) {
		if ((IS_CV & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			zend_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (zend_object*)called_scope;
		call_info = ZEND_CALL_NESTED_FUNCTION;
	} else if (IS_CV & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if (IS_CV == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS | ZEND_CALL_RELEASE_THIS;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAR_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	if (IS_CONST == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
	}

	varptr = EX_VAR(opline->op1.var);
	if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(varptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(arg);
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_CV == IS_CV) {
		ZVAL_COPY_DEREF(arg, varptr);
	} else /* if (IS_CV == IS_VAR) */ {
		if (UNEXPECTED(Z_ISREF_P(varptr))) {
			zend_refcounted *ref = Z_COUNTED_P(varptr);

			varptr = Z_REFVAL_P(varptr);
			ZVAL_COPY_VALUE(arg, varptr);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(arg)) {
				Z_ADDREF_P(arg);
			}
		} else {
			ZVAL_COPY_VALUE(arg, varptr);
		}
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_REF_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	SAVE_OPLINE();
	if (IS_CONST == IS_CONST) {
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
	}

	varptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);
	if (Z_ISREF_P(varptr)) {
		Z_ADDREF_P(varptr);
	} else {
		ZVAL_MAKE_REF_EX(varptr, 2);
	}
	ZVAL_REF(arg, Z_REF_P(varptr));

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAR_EX_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;
	uint32_t arg_num;

	if (IS_CONST == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(arg_num <= MAX_ARG_FLAG_NUM)) {
		if (QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var_by_ref;
		}
	} else if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_var_by_ref:
		varptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);
		if (Z_ISREF_P(varptr)) {
			Z_ADDREF_P(varptr);
		} else {
			ZVAL_MAKE_REF_EX(varptr, 2);
		}
		ZVAL_REF(arg, Z_REF_P(varptr));

		ZEND_VM_NEXT_OPCODE();
	}

	varptr = EX_VAR(opline->op1.var);
	if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(varptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(arg);
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_CV == IS_CV) {
		ZVAL_COPY_DEREF(arg, varptr);
	} else /* if (IS_CV == IS_VAR) */ {
		if (UNEXPECTED(Z_ISREF_P(varptr))) {
			zend_refcounted *ref = Z_COUNTED_P(varptr);

			varptr = Z_REFVAL_P(varptr);
			ZVAL_COPY_VALUE(arg, varptr);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(arg)) {
				Z_ADDREF_P(arg);
			}
		} else {
			ZVAL_COPY_VALUE(arg, varptr);
		}
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) &&
	    UNEXPECTED(opline->extended_value & ZEND_ARRAY_ELEMENT_REF)) {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);
		if (Z_ISREF_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}

	} else {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
		if (IS_CV == IS_TMP_VAR) {
			/* pass */
		} else if (IS_CV == IS_CONST) {
			Z_TRY_ADDREF_P(expr_ptr);
		} else if (IS_CV == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			Z_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_CV == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(expr_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(expr_ptr);

				expr_ptr = Z_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(expr_ptr)) {
					Z_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_CONST != IS_UNUSED) {
		zval *offset = RT_CONSTANT(opline, opline->op2);
		zend_string *str;
		zend_ulong hval;

add_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if (IS_CONST != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index:
			zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(offset) == IS_REFERENCE)) {
			offset = Z_REFVAL_P(offset);
			goto add_again;
		} else if (Z_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (Z_TYPE_P(offset) == IS_DOUBLE) {
			hval = zend_dval_to_lval(Z_DVAL_P(offset));
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_RESOURCE) {
			zend_use_resource_as_offset(offset);
			hval = Z_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_CONST == IS_CV && Z_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			zend_illegal_offset();
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			zend_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_ARRAY_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_CV != IS_UNUSED) {
		size = opline->extended_value >> ZEND_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, zend_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & ZEND_ARRAY_NOT_PACKED) {
			zend_hash_real_init_mixed(Z_ARRVAL_P(array));
		}
		ZEND_VM_TAIL_CALL(ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, zend_new_array(0));
		ZEND_VM_NEXT_OPCODE();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_UNSET_DIM_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	zend_ulong hval;
	zend_string *key;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	offset = RT_CONSTANT(opline, opline->op2);

	do {
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
			HashTable *ht;

unset_dim_array:
			SEPARATE_ARRAY(container);
			ht = Z_ARRVAL_P(container);
offset_again:
			if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
				key = Z_STR_P(offset);
				if (IS_CONST != IS_CONST) {
					if (ZEND_HANDLE_NUMERIC(key, hval)) {
						goto num_index_dim;
					}
				}
str_index_dim:
				if (ht == &EG(symbol_table)) {
					zend_delete_global_variable(key);
				} else {
					zend_hash_del(ht, key);
				}
			} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
				hval = Z_LVAL_P(offset);
num_index_dim:
				zend_hash_index_del(ht, hval);
			} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(offset) == IS_REFERENCE)) {
				offset = Z_REFVAL_P(offset);
				goto offset_again;
			} else if (Z_TYPE_P(offset) == IS_DOUBLE) {
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_dim;
			} else if (Z_TYPE_P(offset) == IS_NULL) {
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else if (Z_TYPE_P(offset) == IS_FALSE) {
				hval = 0;
				goto num_index_dim;
			} else if (Z_TYPE_P(offset) == IS_TRUE) {
				hval = 1;
				goto num_index_dim;
			} else if (Z_TYPE_P(offset) == IS_RESOURCE) {
				hval = Z_RES_HANDLE_P(offset);
				goto num_index_dim;
			} else if (IS_CONST == IS_CV && Z_TYPE_P(offset) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else {
				zend_type_error("Illegal offset type in unset");
			}
			break;
		} else if (Z_ISREF_P(container)) {
			container = Z_REFVAL_P(container);
			if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				goto unset_dim_array;
			}
		}
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
			container = ZVAL_UNDEFINED_OP1();
		}
		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(offset) == IS_UNDEF)) {
			offset = ZVAL_UNDEFINED_OP2();
		}
		if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
			if (IS_CONST == IS_CONST && Z_EXTRA_P(offset) == ZEND_EXTRA_VALUE) {
				offset++;
			}
			Z_OBJ_HT_P(container)->unset_dimension(Z_OBJ_P(container), offset);
		} else if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) == IS_STRING)) {
			zend_throw_error(NULL, "Cannot unset string offsets");
		}
	} while (0);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_UNSET_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	offset = RT_CONSTANT(opline, opline->op2);

	do {
		if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT)) {
			if (Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (Z_TYPE_P(container) != IS_OBJECT) {
					if (IS_CV == IS_CV
					 && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP1();
					}
					break;
				}
			} else {
				break;
			}
		}
		if (IS_CONST == IS_CONST) {
			name = Z_STR_P(offset);
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				break;
			}
		}
		Z_OBJ_HT_P(container)->unset_property(Z_OBJ_P(container), name, ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL));
		if (IS_CONST != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	bool result;
	zend_ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	offset = RT_CONSTANT(opline, opline->op2);

	if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
		HashTable *ht;
		zval *value;
		zend_string *str;

isset_dim_obj_array:
		ht = Z_ARRVAL_P(container);
isset_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if (IS_CONST != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index_prop;
				}
			}
			value = zend_hash_find_ex_ind(ht, str, IS_CONST == IS_CONST);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index_prop:
			value = zend_hash_index_find(ht, hval);
		} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(offset))) {
			offset = Z_REFVAL_P(offset);
			goto isset_again;
		} else {
			value = zend_find_array_dim_slow(ht, offset EXECUTE_DATA_CC);
			if (UNEXPECTED(EG(exception))) {
				result = 0;
				goto isset_dim_obj_exit;
			}
		}

		if (!(opline->extended_value & ZEND_ISEMPTY)) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = value != NULL && Z_TYPE_P(value) > IS_NULL &&
			    (!Z_ISREF_P(value) || Z_TYPE_P(Z_REFVAL_P(value)) != IS_NULL);

			if (IS_CV & (IS_CONST|IS_CV)) {
				/* avoid exception check */

				ZEND_VM_SMART_BRANCH(result, 0);
			}
		} else {
			result = (value == NULL || !i_zend_is_true(value));
		}
		goto isset_dim_obj_exit;
	} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(container))) {
		container = Z_REFVAL_P(container);
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
			goto isset_dim_obj_array;
		}
	}

	if (IS_CONST == IS_CONST && Z_EXTRA_P(offset) == ZEND_EXTRA_VALUE) {
		offset++;
	}
	if (!(opline->extended_value & ZEND_ISEMPTY)) {
		result = zend_isset_dim_slow(container, offset EXECUTE_DATA_CC);
	} else {
		result = zend_isempty_dim_slow(container, offset EXECUTE_DATA_CC);
	}

isset_dim_obj_exit:


	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(opline->op1.var EXECUTE_DATA_CC);
	offset = RT_CONSTANT(opline, opline->op2);

	if (IS_CV == IS_CONST ||
	    (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		if ((IS_CV & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
			container = Z_REFVAL_P(container);
			if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & ZEND_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & ZEND_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if (IS_CONST == IS_CONST) {
		name = Z_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & ZEND_ISEMPTY) ^
		Z_OBJ_HT_P(container)->has_property(Z_OBJ_P(container), name, (opline->extended_value & ZEND_ISEMPTY), ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_ISEMPTY) : NULL));

	if (IS_CONST != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

isset_object_finish:


	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ARRAY_KEY_EXISTS_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *key, *subject;
	HashTable *ht;
	zend_bool result;

	SAVE_OPLINE();

	key = EX_VAR(opline->op1.var);
	subject = RT_CONSTANT(opline, opline->op2);

	if (EXPECTED(Z_TYPE_P(subject) == IS_ARRAY)) {
array_key_exists_array:
		ht = Z_ARRVAL_P(subject);
		result = zend_array_key_exists_fast(ht, key OPLINE_CC EXECUTE_DATA_CC);
	} else {
		if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(subject))) {
			subject = Z_REFVAL_P(subject);
			if (EXPECTED(Z_TYPE_P(subject) == IS_ARRAY)) {
				goto array_key_exists_array;
			}
		}
		zend_array_key_exists_error(subject, key OPLINE_CC EXECUTE_DATA_CC);
		result = 0;
	}


	ZEND_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|UNUSED|CV, ANY) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INSTANCEOF_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr;
	zend_bool result;

	SAVE_OPLINE();
	expr = EX_VAR(opline->op1.var);

try_instanceof:
	if (Z_TYPE_P(expr) == IS_OBJECT) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			ce = CACHED_PTR(opline->extended_value);
			if (UNEXPECTED(ce == NULL)) {
				ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op2)), Z_STR_P(RT_CONSTANT(opline, opline->op2) + 1), ZEND_FETCH_CLASS_NO_AUTOLOAD);
				if (EXPECTED(ce)) {
					CACHE_PTR(opline->extended_value, ce);
				}
			}
		} else if (IS_CONST == IS_UNUSED) {
			ce = zend_fetch_class(NULL, opline->op2.num);
			if (UNEXPECTED(ce == NULL)) {

				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		result = ce && instanceof_function(Z_OBJCE_P(expr), ce);
	} else if ((IS_CV & (IS_VAR|IS_CV)) && Z_TYPE_P(expr) == IS_REFERENCE) {
		expr = Z_REFVAL_P(expr);
		goto try_instanceof;
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(expr) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		result = 0;
	}

	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_YIELD_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & ZEND_GENERATOR_FORCED_CLOSE)) {
		ZEND_VM_TAIL_CALL(zend_yield_in_closed_generator_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CV != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CV & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
						Z_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_CV == IS_VAR) {
						ZEND_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == ZEND_RETURNS_FUNCTION
						 && !Z_ISREF_P(value_ptr)) {
							zend_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (Z_ISREF_P(value_ptr)) {
						Z_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, Z_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_CV == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
					Z_ADDREF(generator->value);
				}
			} else if (IS_CV == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if ((IS_CV & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, Z_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CV == IS_CV) {
					if (Z_OPT_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {
		zval *key = RT_CONSTANT(opline, opline->op2);
		if ((IS_CONST & (IS_CV|IS_VAR)) && UNEXPECTED(Z_TYPE_P(key)) == IS_REFERENCE) {
			key = Z_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BIND_GLOBAL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_string *varname;
	zval *value;
	zval *variable_ptr;
	uintptr_t idx;
	zend_reference *ref;

	ZEND_VM_REPEATABLE_OPCODE

	varname = Z_STR_P(RT_CONSTANT(opline, opline->op2));

	/* We store "hash slot index" + 1 (NULL is a mark of uninitialized cache slot) */
	idx = (uintptr_t)CACHED_PTR(opline->extended_value) - 1;
	if (EXPECTED(idx < EG(symbol_table).nNumUsed * sizeof(Bucket))) {
		Bucket *p = (Bucket*)((char*)EG(symbol_table).arData + idx);

		if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
	        (EXPECTED(p->key == varname) ||
	         (EXPECTED(p->h == ZSTR_H(varname)) &&
	          EXPECTED(p->key != NULL) &&
	          EXPECTED(zend_string_equal_content(p->key, varname))))) {

			value = (zval*)p; /* value = &p->val; */
			goto check_indirect;
		}
	}

	value = zend_hash_find_ex(&EG(symbol_table), varname, 1);
	if (UNEXPECTED(value == NULL)) {
		value = zend_hash_add_new(&EG(symbol_table), varname, &EG(uninitialized_zval));
		idx = (char*)value - (char*)EG(symbol_table).arData;
		/* Store "hash slot index" + 1 (NULL is a mark of uninitialized cache slot) */
		CACHE_PTR(opline->extended_value, (void*)(idx + 1));
	} else {
		idx = (char*)value - (char*)EG(symbol_table).arData;
		/* Store "hash slot index" + 1 (NULL is a mark of uninitialized cache slot) */
		CACHE_PTR(opline->extended_value, (void*)(idx + 1));
check_indirect:
		/* GLOBAL variable may be an INDIRECT pointer to CV */
		if (UNEXPECTED(Z_TYPE_P(value) == IS_INDIRECT)) {
			value = Z_INDIRECT_P(value);
			if (UNEXPECTED(Z_TYPE_P(value) == IS_UNDEF)) {
				ZVAL_NULL(value);
			}
		}
	}

	if (UNEXPECTED(!Z_ISREF_P(value))) {
		ZVAL_MAKE_REF_EX(value, 2);
		ref = Z_REF_P(value);
	} else {
		ref = Z_REF_P(value);
		GC_ADDREF(ref);
	}

	variable_ptr = EX_VAR(opline->op1.var);

	if (UNEXPECTED(Z_REFCOUNTED_P(variable_ptr))) {
		zend_refcounted *garbage = Z_COUNTED_P(variable_ptr);

		ZVAL_REF(variable_ptr, ref);
		if (GC_DELREF(garbage) == 0) {
			SAVE_OPLINE();
			rc_dtor_func(garbage);
			if (UNEXPECTED(EG(exception))) {
				ZVAL_NULL(variable_ptr);
				HANDLE_EXCEPTION();
			}
		} else {
			gc_check_possible_root(garbage);
		}
	} else {
		ZVAL_REF(variable_ptr, ref);
	}

	ZEND_VM_REPEAT_OPCODE(ZEND_BIND_GLOBAL);
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IN_ARRAY_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;
	HashTable *ht = Z_ARRVAL_P(RT_CONSTANT(opline, opline->op2));
	zval *result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		result = zend_hash_find_ex(ht, Z_STR_P(op1), IS_CV == IS_CONST);
	} else if (opline->extended_value) {
		if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
			result = zend_hash_index_find(ht, Z_LVAL_P(op1));
		} else {
			result = NULL;
		}
	} else if (Z_TYPE_P(op1) <= IS_FALSE) {
		result = zend_hash_find_ex(ht, ZSTR_EMPTY_ALLOC(), 1);
	} else {
		zend_string *key;
		zval key_tmp, *val;

		result = NULL;
		ZEND_HASH_FOREACH_STR_KEY_VAL(ht, key, val) {
			ZVAL_STR(&key_tmp, key);
			if (zend_compare(op1, &key_tmp) == 0) {
				result = val;
				break;
			}
		} ZEND_HASH_FOREACH_END();
	}

	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_IDENTICAL_NOTHROW_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	/* This is declared below the specializations for MAY_BE_LONG/MAY_BE_DOUBLE so those will be used instead if possible. */
	/* This optimizes $x === SOME_CONST_EXPR and $x === $y for non-refs and non-undef, which can't throw. */
	/* (Infinite recursion when comparing arrays is an uncatchable fatal error) */
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_identical_function(op1, op2);
	/* Free is a no-op for const/cv */
	ZEND_VM_SMART_BRANCH(result, 0);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_identical_function(op1, op2);
	/* Free is a no-op for const/cv */
	ZEND_VM_SMART_BRANCH(!result, 0);
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_R_INDEX_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;
	zend_long offset;
	HashTable *ht;

	container = EX_VAR(opline->op1.var);
	dim = RT_CONSTANT(opline, opline->op2);
	if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_index_array:
		if (EXPECTED(Z_TYPE_P(dim) == IS_LONG)) {
			offset = Z_LVAL_P(dim);
		} else {
			offset = zval_get_long(dim);
		}
		ht = Z_ARRVAL_P(container);
		ZEND_HASH_INDEX_FIND(ht, offset, value, fetch_dim_r_index_undef);
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
			SAVE_OPLINE();

			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			ZEND_VM_NEXT_OPCODE();
		}
	} else if (IS_CV != IS_CONST && EXPECTED(Z_TYPE_P(container) == IS_REFERENCE)) {
		container = Z_REFVAL_P(container);
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
			goto fetch_dim_r_index_array;
		} else {
			goto fetch_dim_r_index_slow;
		}
	} else {
fetch_dim_r_index_slow:
		SAVE_OPLINE();
		if (IS_CONST == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
			dim++;
		}
		zend_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);

		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

fetch_dim_r_index_undef:
	ZVAL_NULL(EX_VAR(opline->result.var));
	SAVE_OPLINE();
	zend_undefined_offset(offset);

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_R_INDEX_SPEC_CV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;
	zend_long offset;
	HashTable *ht;

	container = EX_VAR(opline->op1.var);
	dim = EX_VAR(opline->op2.var);
	if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_index_array:
		if (EXPECTED(Z_TYPE_P(dim) == IS_LONG)) {
			offset = Z_LVAL_P(dim);
		} else {
			offset = zval_get_long(dim);
		}
		ht = Z_ARRVAL_P(container);
		ZEND_HASH_INDEX_FIND(ht, offset, value, fetch_dim_r_index_undef);
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
			SAVE_OPLINE();

			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			ZEND_VM_NEXT_OPCODE();
		}
	} else if (IS_CV != IS_CONST && EXPECTED(Z_TYPE_P(container) == IS_REFERENCE)) {
		container = Z_REFVAL_P(container);
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
			goto fetch_dim_r_index_array;
		} else {
			goto fetch_dim_r_index_slow;
		}
	} else {
fetch_dim_r_index_slow:
		SAVE_OPLINE();
		if ((IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
			dim++;
		}
		zend_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);

		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

fetch_dim_r_index_undef:
	ZVAL_NULL(EX_VAR(opline->result.var));
	SAVE_OPLINE();
	zend_undefined_offset(offset);

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DIV_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	fast_div_function(EX_VAR(opline->result.var), op1, op2);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POW_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	pow_function(EX_VAR(opline->result.var), op1, op2);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if ((IS_CV == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
	    ((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(Z_TYPE_P(op2) == IS_STRING))) {
		zend_string *op1_str = Z_STR_P(op1);
		zend_string *op2_str = Z_STR_P(op2);
		zend_string *str;

		if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else if (IS_CV != IS_CONST && IS_CV != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
		    size_t len = ZSTR_LEN(op1_str);

			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else {
			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		}
		ZEND_VM_NEXT_OPCODE();
	} else {
		SAVE_OPLINE();

		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
			op1 = ZVAL_UNDEFINED_OP1();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
			op2 = ZVAL_UNDEFINED_OP2();
		}
		concat_function(EX_VAR(opline->result.var), op1, op2);

		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && IS_CV == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) == Z_LVAL_P(op2))) {
is_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_SPEC_CV_TMPVAR_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && IS_CV == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) == Z_LVAL_P(op2))) {
is_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_SPEC_CV_TMPVAR_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && IS_CV == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) == Z_LVAL_P(op2))) {
is_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && IS_CV == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) != Z_LVAL_P(op2))) {
is_not_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_not_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_not_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && IS_CV == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) != Z_LVAL_P(op2))) {
is_not_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_not_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_not_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && IS_CV == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) != Z_LVAL_P(op2))) {
is_not_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_not_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_not_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SPACESHIP_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	compare_function(EX_VAR(opline->result.var), op1, op2);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BOOL_XOR_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	boolean_xor_function(EX_VAR(opline->result.var), op1, op2);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_OP_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *value;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto assign_op_object;
			}
			if (IS_CV == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

assign_op_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR((opline+1)->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				zval *orig_zptr = zptr;
				zend_reference *ref;

				do {
					if (UNEXPECTED(Z_ISREF_P(zptr))) {
						ref = Z_REF_P(zptr);
						zptr = Z_REFVAL_P(zptr);
						if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
							zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
							break;
						}
					}

					if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
						prop_info = (zend_property_info*)CACHED_PTR_EX(cache_slot + 2);
					} else {
						prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), orig_zptr);
					}
					if (UNEXPECTED(prop_info)) {
						/* special case for typed properties */
						zend_binary_assign_op_typed_prop(prop_info, zptr, value OPLINE_CC EXECUTE_DATA_CC);
					} else {
						zend_binary_op(zptr, zptr, value OPLINE_CC);
					}
				} while (0);

				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		} else {
			zend_assign_op_overloaded_property(zobj, name, cache_slot, value OPLINE_CC EXECUTE_DATA_CC);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMP|VAR|CV, UNUSED|CONST|TMPVAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_OP_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value, *container, *dim;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
assign_dim_op_array:
		SEPARATE_ARRAY(container);
assign_dim_op_new_array:
		dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			var_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(container), &EG(uninitialized_zval));
			if (UNEXPECTED(!var_ptr)) {
				zend_cannot_add_element();
				goto assign_dim_op_ret_null;
			}
		} else {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				var_ptr = zend_fetch_dimension_address_inner_RW_CONST(Z_ARRVAL_P(container), dim EXECUTE_DATA_CC);
			} else {
				var_ptr = zend_fetch_dimension_address_inner_RW(Z_ARRVAL_P(container), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(!var_ptr)) {
				goto assign_dim_op_ret_null;
			}
		}

		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		do {
			if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(Z_ISREF_P(var_ptr))) {
				zend_reference *ref = Z_REF_P(var_ptr);
				var_ptr = Z_REFVAL_P(var_ptr);
				if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
					zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
					break;
				}
			}
			zend_binary_op(var_ptr, var_ptr, value OPLINE_CC);
		} while (0);

		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
		}
		FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	} else {
		if (EXPECTED(Z_ISREF_P(container))) {
			container = Z_REFVAL_P(container);
			if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				goto assign_dim_op_array;
			}
		}

		dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

		if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_binary_assign_op_obj_dim(container, dim OPLINE_CC EXECUTE_DATA_CC);
		} else if (EXPECTED(Z_TYPE_P(container) <= IS_FALSE)) {
			if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			ZVAL_ARR(container, zend_new_array(8));
			goto assign_dim_op_new_array;
		} else {
			zend_binary_assign_op_dim_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
assign_dim_op_ret_null:
			FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OP_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	var_ptr = _get_zval_ptr_cv_BP_VAR_RW(opline->op1.var EXECUTE_DATA_CC);

	do {
		if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_REFERENCE)) {
			zend_reference *ref = Z_REF_P(var_ptr);
			var_ptr = Z_REFVAL_P(var_ptr);
			if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
				zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		zend_binary_op(var_ptr, var_ptr, value OPLINE_CC);
	} while (0);

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_INC_OBJ_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto pre_incdec_object;
			}
			if (IS_CV == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

pre_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					prop_info = (zend_property_info *) CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), zptr);
				}
				zend_pre_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			zend_pre_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POST_INC_OBJ_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto post_incdec_object;
			}
			if (IS_CV == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

post_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}
		cache_slot = ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			} else {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					prop_info = (zend_property_info*)CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), zptr);
				}

				zend_post_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			zend_post_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_R_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (IS_CV != IS_CONST) {
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_array:
			value = zend_fetch_dimension_address_inner(Z_ARRVAL_P(container), dim, (IS_TMP_VAR|IS_VAR), BP_VAR_R EXECUTE_DATA_CC);
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		} else if (EXPECTED(Z_TYPE_P(container) == IS_REFERENCE)) {
			container = Z_REFVAL_P(container);
			if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				goto fetch_dim_r_array;
			} else {
				goto fetch_dim_r_slow;
			}
		} else {
fetch_dim_r_slow:
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
		}
	} else {
		zend_fetch_dimension_address_read_R(container, dim, (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_W_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	zend_fetch_dimension_address_W(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_RW_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	zend_fetch_dimension_address_RW(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_IS_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	zend_fetch_dimension_address_read_IS(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
        if ((IS_CV & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
        }
		ZEND_VM_TAIL_CALL(ZEND_FETCH_DIM_W_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			ZEND_VM_TAIL_CALL(zend_use_undef_in_read_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_FETCH_DIM_R_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_UNSET_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	zend_fetch_dimension_address_UNSET(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_R_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (IS_CV == IS_CONST ||
	    (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
	    do {
			if ((IS_CV & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			zend_wrong_property_read(container, offset);
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value & ~ZEND_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
		} else {
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_W_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();

	container = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(
		result, container, IS_CV, property, (IS_TMP_VAR|IS_VAR),
		(((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_FETCH_OBJ_FLAGS) : NULL),
		BP_VAR_W, opline->extended_value & ZEND_FETCH_OBJ_FLAGS, 1 OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_RW_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(result, container, IS_CV, property, (IS_TMP_VAR|IS_VAR), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_RW, 0, 1 OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_IS_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(opline->op1.var EXECUTE_DATA_CC);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (IS_CV == IS_CONST ||
	    (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_CV & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_CV & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_W_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_R_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_UNSET_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *property, *result;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(result, container, IS_CV, property, (IS_TMP_VAR|IS_VAR), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_UNSET, 0, 1 OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	value = RT_CONSTANT((opline+1), (opline+1)->op1);

	if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_CONST == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_CONST == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_CONST, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_CONST != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_CONST == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_CONST == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_TMP_VAR == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_TMP_VAR == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_TMP_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_TMP_VAR != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_TMP_VAR == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_TMP_VAR == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_VAR == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_VAR == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_VAR, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_VAR != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_VAR == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_VAR == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_CV == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_CV == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_CV, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_CV != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_CV == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_CV == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_CV == IS_CV || IS_CV == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CONST == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_CONST == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CONST == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			value = zend_assign_to_variable(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			value = RT_CONSTANT((opline+1), (opline+1)->op1);

			if ((IS_TMP_VAR|IS_VAR) == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
				zend_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				value = RT_CONSTANT((opline+1), (opline+1)->op1);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}

	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_TMP_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_TMP_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_TMP_VAR == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

			if ((IS_TMP_VAR|IS_VAR) == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
				zend_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}

	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_VAR == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			value = _get_zval_ptr_var_deref((opline+1)->op1.var EXECUTE_DATA_CC);

			if ((IS_TMP_VAR|IS_VAR) == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
				zend_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				value = _get_zval_ptr_var_deref((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}

	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_CV == IS_CV || IS_CV == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CV == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_CV == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CV == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			value = _get_zval_ptr_cv_deref_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

			if ((IS_TMP_VAR|IS_VAR) == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
				zend_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				value = _get_zval_ptr_cv_deref_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}

	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_CV == IS_UNUSED) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				zend_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				zend_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		zend_assign_to_property_reference(container, IS_CV, property, (IS_TMP_VAR|IS_VAR), value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));;
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_cv_BP_VAR_W((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_CV == IS_UNUSED) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				zend_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				zend_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		zend_assign_to_property_reference(container, IS_CV, property, (IS_TMP_VAR|IS_VAR), value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_string *op1_str, *op2_str, *str;


	op1 = EX_VAR(opline->op1.var);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if ((IS_CV == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
	    ((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(Z_TYPE_P(op2) == IS_STRING))) {
		zend_string *op1_str = Z_STR_P(op1);
		zend_string *op2_str = Z_STR_P(op2);
		zend_string *str;

		if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else if (IS_CV != IS_CONST && IS_CV != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
		    size_t len = ZSTR_LEN(op1_str);

			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else {
			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	if (IS_CV == IS_CONST) {
		op1_str = Z_STR_P(op1);
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		op1_str = zend_string_copy(Z_STR_P(op1));
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		op1_str = zval_get_string_func(op1);
	}
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		op2_str = Z_STR_P(op2);
	} else if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
		op2_str = zend_string_copy(Z_STR_P(op2));
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP2();
		}
		op2_str = zval_get_string_func(op2);
	}
	do {
		if (IS_CV != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					if (UNEXPECTED(Z_REFCOUNTED_P(op2))) {
						GC_ADDREF(op2_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
				zend_string_release_ex(op1_str, 0);
				break;
			}
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(Z_REFCOUNTED_P(op1))) {
						GC_ADDREF(op1_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
				zend_string_release_ex(op2_str, 0);
				break;
			}
		}
		str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
		memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
		memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
		ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
		if (IS_CV != IS_CONST) {
			zend_string_release_ex(op1_str, 0);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_string_release_ex(op2_str, 0);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_METHOD_CALL_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	zend_function *fbc;
	zend_class_entry *called_scope;
	zend_object *obj;
	zend_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = EX_VAR(opline->op1.var);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		do {
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && Z_ISREF_P(function_name)) {
				function_name = Z_REFVAL_P(function_name);
				if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {

					HANDLE_EXCEPTION();
				}
			}
			zend_throw_error(NULL, "Method name must be a string");
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

			HANDLE_EXCEPTION();
		} while (0);
	}

	if (IS_CV == IS_UNUSED) {
		obj = Z_OBJ_P(object);
	} else {
		do {
			if (IS_CV != IS_CONST && EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
				obj = Z_OBJ_P(object);
			} else {
				if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(object))) {
					zend_reference *ref = Z_REF_P(object);

					object = &ref->val;
					if (EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
						obj = Z_OBJ_P(object);
						if (IS_CV & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(zend_reference));
							} else {
								Z_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
							zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
						}
						HANDLE_EXCEPTION();
					}
				}
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				}
				zend_invalid_method_call(object, function_name);
				zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
	    fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
	    zend_object *orig_obj = obj;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, Z_STR_P(function_name), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(obj->ce, Z_STR_P(function_name));
			}
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			if ((IS_CV & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if ((IS_CV & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}

	call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_STATIC) != 0)) {
		if ((IS_CV & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			zend_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (zend_object*)called_scope;
		call_info = ZEND_CALL_NESTED_FUNCTION;
	} else if (IS_CV & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if (IS_CV == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS | ZEND_CALL_RELEASE_THIS;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) &&
	    UNEXPECTED(opline->extended_value & ZEND_ARRAY_ELEMENT_REF)) {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);
		if (Z_ISREF_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}

	} else {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
		if (IS_CV == IS_TMP_VAR) {
			/* pass */
		} else if (IS_CV == IS_CONST) {
			Z_TRY_ADDREF_P(expr_ptr);
		} else if (IS_CV == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			Z_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_CV == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(expr_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(expr_ptr);

				expr_ptr = Z_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(expr_ptr)) {
					Z_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval *offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		zend_string *str;
		zend_ulong hval;

add_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index:
			zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(offset) == IS_REFERENCE)) {
			offset = Z_REFVAL_P(offset);
			goto add_again;
		} else if (Z_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (Z_TYPE_P(offset) == IS_DOUBLE) {
			hval = zend_dval_to_lval(Z_DVAL_P(offset));
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_RESOURCE) {
			zend_use_resource_as_offset(offset);
			hval = Z_RES_HANDLE_P(offset);
			goto num_index;
		} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && Z_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			zend_illegal_offset();
			zval_ptr_dtor_nogc(expr_ptr);
		}
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	} else {
		if (!zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			zend_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_ARRAY_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_CV != IS_UNUSED) {
		size = opline->extended_value >> ZEND_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, zend_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & ZEND_ARRAY_NOT_PACKED) {
			zend_hash_real_init_mixed(Z_ARRVAL_P(array));
		}
		ZEND_VM_TAIL_CALL(ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, zend_new_array(0));
		ZEND_VM_NEXT_OPCODE();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_UNSET_DIM_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	zend_ulong hval;
	zend_string *key;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
			HashTable *ht;

unset_dim_array:
			SEPARATE_ARRAY(container);
			ht = Z_ARRVAL_P(container);
offset_again:
			if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
				key = Z_STR_P(offset);
				if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
					if (ZEND_HANDLE_NUMERIC(key, hval)) {
						goto num_index_dim;
					}
				}
str_index_dim:
				if (ht == &EG(symbol_table)) {
					zend_delete_global_variable(key);
				} else {
					zend_hash_del(ht, key);
				}
			} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
				hval = Z_LVAL_P(offset);
num_index_dim:
				zend_hash_index_del(ht, hval);
			} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(offset) == IS_REFERENCE)) {
				offset = Z_REFVAL_P(offset);
				goto offset_again;
			} else if (Z_TYPE_P(offset) == IS_DOUBLE) {
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_dim;
			} else if (Z_TYPE_P(offset) == IS_NULL) {
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else if (Z_TYPE_P(offset) == IS_FALSE) {
				hval = 0;
				goto num_index_dim;
			} else if (Z_TYPE_P(offset) == IS_TRUE) {
				hval = 1;
				goto num_index_dim;
			} else if (Z_TYPE_P(offset) == IS_RESOURCE) {
				hval = Z_RES_HANDLE_P(offset);
				goto num_index_dim;
			} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && Z_TYPE_P(offset) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else {
				zend_type_error("Illegal offset type in unset");
			}
			break;
		} else if (Z_ISREF_P(container)) {
			container = Z_REFVAL_P(container);
			if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				goto unset_dim_array;
			}
		}
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
			container = ZVAL_UNDEFINED_OP1();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(offset) == IS_UNDEF)) {
			offset = ZVAL_UNDEFINED_OP2();
		}
		if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST && Z_EXTRA_P(offset) == ZEND_EXTRA_VALUE) {
				offset++;
			}
			Z_OBJ_HT_P(container)->unset_dimension(Z_OBJ_P(container), offset);
		} else if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) == IS_STRING)) {
			zend_throw_error(NULL, "Cannot unset string offsets");
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_UNSET_OBJ_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT)) {
			if (Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (Z_TYPE_P(container) != IS_OBJECT) {
					if (IS_CV == IS_CV
					 && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP1();
					}
					break;
				}
			} else {
				break;
			}
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = Z_STR_P(offset);
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				break;
			}
		}
		Z_OBJ_HT_P(container)->unset_property(Z_OBJ_P(container), name, (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL));
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	bool result;
	zend_ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
		HashTable *ht;
		zval *value;
		zend_string *str;

isset_dim_obj_array:
		ht = Z_ARRVAL_P(container);
isset_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index_prop;
				}
			}
			value = zend_hash_find_ex_ind(ht, str, (IS_TMP_VAR|IS_VAR) == IS_CONST);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index_prop:
			value = zend_hash_index_find(ht, hval);
		} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(offset))) {
			offset = Z_REFVAL_P(offset);
			goto isset_again;
		} else {
			value = zend_find_array_dim_slow(ht, offset EXECUTE_DATA_CC);
			if (UNEXPECTED(EG(exception))) {
				result = 0;
				goto isset_dim_obj_exit;
			}
		}

		if (!(opline->extended_value & ZEND_ISEMPTY)) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = value != NULL && Z_TYPE_P(value) > IS_NULL &&
			    (!Z_ISREF_P(value) || Z_TYPE_P(Z_REFVAL_P(value)) != IS_NULL);

			if (IS_CV & (IS_CONST|IS_CV)) {
				/* avoid exception check */
				zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
				ZEND_VM_SMART_BRANCH(result, 0);
			}
		} else {
			result = (value == NULL || !i_zend_is_true(value));
		}
		goto isset_dim_obj_exit;
	} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(container))) {
		container = Z_REFVAL_P(container);
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
			goto isset_dim_obj_array;
		}
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST && Z_EXTRA_P(offset) == ZEND_EXTRA_VALUE) {
		offset++;
	}
	if (!(opline->extended_value & ZEND_ISEMPTY)) {
		result = zend_isset_dim_slow(container, offset EXECUTE_DATA_CC);
	} else {
		result = zend_isempty_dim_slow(container, offset EXECUTE_DATA_CC);
	}

isset_dim_obj_exit:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(opline->op1.var EXECUTE_DATA_CC);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (IS_CV == IS_CONST ||
	    (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		if ((IS_CV & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
			container = Z_REFVAL_P(container);
			if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & ZEND_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & ZEND_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = Z_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & ZEND_ISEMPTY) ^
		Z_OBJ_HT_P(container)->has_property(Z_OBJ_P(container), name, (opline->extended_value & ZEND_ISEMPTY), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_ISEMPTY) : NULL));

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

isset_object_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ARRAY_KEY_EXISTS_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *key, *subject;
	HashTable *ht;
	zend_bool result;

	SAVE_OPLINE();

	key = EX_VAR(opline->op1.var);
	subject = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (EXPECTED(Z_TYPE_P(subject) == IS_ARRAY)) {
array_key_exists_array:
		ht = Z_ARRVAL_P(subject);
		result = zend_array_key_exists_fast(ht, key OPLINE_CC EXECUTE_DATA_CC);
	} else {
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(subject))) {
			subject = Z_REFVAL_P(subject);
			if (EXPECTED(Z_TYPE_P(subject) == IS_ARRAY)) {
				goto array_key_exists_array;
			}
		}
		zend_array_key_exists_error(subject, key OPLINE_CC EXECUTE_DATA_CC);
		result = 0;
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|UNUSED|CV, ANY) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_YIELD_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & ZEND_GENERATOR_FORCED_CLOSE)) {
		ZEND_VM_TAIL_CALL(zend_yield_in_closed_generator_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CV != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CV & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
						Z_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_CV == IS_VAR) {
						ZEND_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == ZEND_RETURNS_FUNCTION
						 && !Z_ISREF_P(value_ptr)) {
							zend_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (Z_ISREF_P(value_ptr)) {
						Z_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, Z_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_CV == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
					Z_ADDREF(generator->value);
				}
			} else if (IS_CV == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if ((IS_CV & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, Z_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CV == IS_CV) {
					if (Z_OPT_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval *key = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if (((IS_TMP_VAR|IS_VAR) & (IS_CV|IS_VAR)) && UNEXPECTED(Z_TYPE_P(key)) == IS_REFERENCE) {
			key = Z_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_IDENTICAL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_IDENTICAL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_not_identical_function(op1, op2);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_SPEC_CV_TMP_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = EX_VAR(opline->op1.var);

	value = zend_assign_to_variable(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
	if (UNEXPECTED(0)) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_SPEC_CV_TMP_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = EX_VAR(opline->op1.var);

	value = zend_assign_to_variable(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
	if (UNEXPECTED(1)) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_IDENTICAL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var_deref(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_IDENTICAL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var_deref(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_not_identical_function(op1, op2);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_SPEC_CV_VAR_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = EX_VAR(opline->op1.var);

	value = zend_assign_to_variable(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES());
	if (UNEXPECTED(0)) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_SPEC_CV_VAR_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = EX_VAR(opline->op1.var);

	value = zend_assign_to_variable(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES());
	if (UNEXPECTED(1)) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_REF_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *variable_ptr;
	zval *value_ptr;

	SAVE_OPLINE();
	value_ptr = _get_zval_ptr_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = EX_VAR(opline->op1.var);

	if (IS_CV == IS_VAR &&
	           UNEXPECTED(Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT)) {

		zend_throw_error(NULL, "Cannot assign by reference to an array dimension of an object");
		variable_ptr = &EG(uninitialized_zval);
	} else if (IS_VAR == IS_VAR &&
	           opline->extended_value == ZEND_RETURNS_FUNCTION &&
			   UNEXPECTED(!Z_ISREF_P(value_ptr))) {

		if (UNEXPECTED(!zend_wrong_assign_to_variable_reference(variable_ptr, value_ptr OPLINE_CC EXECUTE_DATA_CC))) {
			variable_ptr = &EG(uninitialized_zval);
		}
	} else {
		zend_assign_to_variable_reference(variable_ptr, value_ptr);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INSTANCEOF_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr;
	zend_bool result;

	SAVE_OPLINE();
	expr = EX_VAR(opline->op1.var);

try_instanceof:
	if (Z_TYPE_P(expr) == IS_OBJECT) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			ce = CACHED_PTR(opline->extended_value);
			if (UNEXPECTED(ce == NULL)) {
				ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op2)), Z_STR_P(RT_CONSTANT(opline, opline->op2) + 1), ZEND_FETCH_CLASS_NO_AUTOLOAD);
				if (EXPECTED(ce)) {
					CACHE_PTR(opline->extended_value, ce);
				}
			}
		} else if (IS_VAR == IS_UNUSED) {
			ce = zend_fetch_class(NULL, opline->op2.num);
			if (UNEXPECTED(ce == NULL)) {

				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		result = ce && instanceof_function(Z_OBJCE_P(expr), ce);
	} else if ((IS_CV & (IS_VAR|IS_CV)) && Z_TYPE_P(expr) == IS_REFERENCE) {
		expr = Z_REFVAL_P(expr);
		goto try_instanceof;
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(expr) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		result = 0;
	}

	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_OP_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value, *container, *dim;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
assign_dim_op_array:
		SEPARATE_ARRAY(container);
assign_dim_op_new_array:
		dim = NULL;
		if (IS_UNUSED == IS_UNUSED) {
			var_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(container), &EG(uninitialized_zval));
			if (UNEXPECTED(!var_ptr)) {
				zend_cannot_add_element();
				goto assign_dim_op_ret_null;
			}
		} else {
			if (IS_UNUSED == IS_CONST) {
				var_ptr = zend_fetch_dimension_address_inner_RW_CONST(Z_ARRVAL_P(container), dim EXECUTE_DATA_CC);
			} else {
				var_ptr = zend_fetch_dimension_address_inner_RW(Z_ARRVAL_P(container), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(!var_ptr)) {
				goto assign_dim_op_ret_null;
			}
		}

		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		do {
			if (IS_UNUSED != IS_UNUSED && UNEXPECTED(Z_ISREF_P(var_ptr))) {
				zend_reference *ref = Z_REF_P(var_ptr);
				var_ptr = Z_REFVAL_P(var_ptr);
				if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
					zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
					break;
				}
			}
			zend_binary_op(var_ptr, var_ptr, value OPLINE_CC);
		} while (0);

		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
		}
		FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	} else {
		if (EXPECTED(Z_ISREF_P(container))) {
			container = Z_REFVAL_P(container);
			if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				goto assign_dim_op_array;
			}
		}

		dim = NULL;

		if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
			if (IS_UNUSED == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_binary_assign_op_obj_dim(container, dim OPLINE_CC EXECUTE_DATA_CC);
		} else if (EXPECTED(Z_TYPE_P(container) <= IS_FALSE)) {
			if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			ZVAL_ARR(container, zend_new_array(8));
			goto assign_dim_op_new_array;
		} else {
			zend_binary_assign_op_dim_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
assign_dim_op_ret_null:
			FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}


	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static zend_never_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_CV_UNUSED(int type ZEND_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE
	zval *varname;
	zval *retval;
	zend_string *name, *tmp_name;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = EX_VAR(opline->op1.var);

	if (IS_CV == IS_CONST) {
		name = Z_STR_P(varname);
	} else if (EXPECTED(Z_TYPE_P(varname) == IS_STRING)) {
		name = Z_STR_P(varname);
		tmp_name = NULL;
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(varname) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		name = zval_try_get_tmp_string(varname, &tmp_name);
		if (UNEXPECTED(!name)) {

			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		}
	}

	target_symbol_table = zend_get_target_symbol_table(opline->extended_value EXECUTE_DATA_CC);
	retval = zend_hash_find_ex(target_symbol_table, name, IS_CV == IS_CONST);
	if (retval == NULL) {
		if (UNEXPECTED(zend_string_equals(name, ZSTR_KNOWN(ZEND_STR_THIS)))) {
fetch_this:
			zend_fetch_this_var(type OPLINE_CC EXECUTE_DATA_CC);
			if (IS_CV != IS_CONST) {
				zend_tmp_string_release(tmp_name);
			}
			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
		if (type == BP_VAR_W) {
			retval = zend_hash_add_new(target_symbol_table, name, &EG(uninitialized_zval));
		} else if (type == BP_VAR_IS) {
			retval = &EG(uninitialized_zval);
		} else {
			zend_error(E_WARNING, "Undefined variable $%s", ZSTR_VAL(name));
			if (type == BP_VAR_RW) {
				retval = zend_hash_update(target_symbol_table, name, &EG(uninitialized_zval));
			} else {
				retval = &EG(uninitialized_zval);
			}
		}
	/* GLOBAL or $$name variable may be an INDIRECT pointer to CV */
	} else if (Z_TYPE_P(retval) == IS_INDIRECT) {
		retval = Z_INDIRECT_P(retval);
		if (Z_TYPE_P(retval) == IS_UNDEF) {
			if (UNEXPECTED(zend_string_equals(name, ZSTR_KNOWN(ZEND_STR_THIS)))) {
				goto fetch_this;
			}
			if (type == BP_VAR_W) {
				ZVAL_NULL(retval);
			} else if (type == BP_VAR_IS) {
				retval = &EG(uninitialized_zval);
			} else {
				zend_error(E_WARNING, "Undefined variable $%s", ZSTR_VAL(name));
				if (type == BP_VAR_RW) {
					ZVAL_NULL(retval);
				} else {
					retval = &EG(uninitialized_zval);
				}
			}
		}
	}

	if (!(opline->extended_value & ZEND_FETCH_GLOBAL_LOCK)) {

	}

	if (IS_CV != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

	ZEND_ASSERT(retval != NULL);
	if (type == BP_VAR_R || type == BP_VAR_IS) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
	} else {
		ZVAL_INDIRECT(EX_VAR(opline->result.var), retval);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_R_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_TAIL_CALL(zend_fetch_var_address_helper_SPEC_CV_UNUSED(BP_VAR_R ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_W_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_TAIL_CALL(zend_fetch_var_address_helper_SPEC_CV_UNUSED(BP_VAR_W ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_RW_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_TAIL_CALL(zend_fetch_var_address_helper_SPEC_CV_UNUSED(BP_VAR_RW ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_FUNC_ARG_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	int fetch_type =
		(UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) ?
			BP_VAR_W : BP_VAR_R;
	ZEND_VM_TAIL_CALL(zend_fetch_var_address_helper_SPEC_CV_UNUSED(fetch_type ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_UNSET_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_TAIL_CALL(zend_fetch_var_address_helper_SPEC_CV_UNUSED(BP_VAR_UNSET ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_IS_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_TAIL_CALL(zend_fetch_var_address_helper_SPEC_CV_UNUSED(BP_VAR_IS ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_W_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	zend_fetch_dimension_address_W(container, NULL, IS_UNUSED OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_RW_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	zend_fetch_dimension_address_RW(container, NULL, IS_UNUSED OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
        if ((IS_CV & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
        }
		ZEND_VM_TAIL_CALL(ZEND_FETCH_DIM_W_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_UNUSED == IS_UNUSED) {
			ZEND_VM_TAIL_CALL(zend_use_undef_in_read_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_UNUSED == IS_UNUSED) {
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CONST == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_CONST == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CONST == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = NULL;
			if (IS_UNUSED == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			value = zend_assign_to_variable(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = NULL;
			value = RT_CONSTANT((opline+1), (opline+1)->op1);

			if (IS_UNUSED == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_UNUSED == IS_UNUSED) {
				zend_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = NULL;
				value = RT_CONSTANT((opline+1), (opline+1)->op1);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = NULL;

				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = NULL;
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_UNUSED != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_UNUSED == IS_UNUSED) {
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_TMP_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_TMP_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_TMP_VAR == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = NULL;
			if (IS_UNUSED == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = NULL;
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

			if (IS_UNUSED == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_UNUSED == IS_UNUSED) {
				zend_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = NULL;
				value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = NULL;
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = NULL;
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_UNUSED != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_UNUSED == IS_UNUSED) {
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_VAR == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = NULL;
			if (IS_UNUSED == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = NULL;
			value = _get_zval_ptr_var_deref((opline+1)->op1.var EXECUTE_DATA_CC);

			if (IS_UNUSED == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_UNUSED == IS_UNUSED) {
				zend_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = NULL;
				value = _get_zval_ptr_var_deref((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = NULL;
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = NULL;
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_UNUSED != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_UNUSED == IS_UNUSED) {
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_CV == IS_CV || IS_CV == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CV == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_CV == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CV == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = NULL;
			if (IS_UNUSED == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = NULL;
			value = _get_zval_ptr_cv_deref_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

			if (IS_UNUSED == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_UNUSED == IS_UNUSED) {
				zend_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = NULL;
				value = _get_zval_ptr_cv_deref_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = NULL;

				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = NULL;
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_UNUSED != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_VERIFY_RETURN_TYPE_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	if (IS_CV == IS_UNUSED) {
		SAVE_OPLINE();
		zend_verify_missing_return_type(EX(func));
		HANDLE_EXCEPTION();
	} else {
/* prevents "undefined variable opline" errors */
#if 0 || (IS_CV != IS_UNUSED)
		USE_OPLINE
		zval *retval_ref, *retval_ptr;
		zend_arg_info *ret_info = EX(func)->common.arg_info - 1;
		retval_ref = retval_ptr = EX_VAR(opline->op1.var);

		if (IS_CV == IS_CONST) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval_ptr);
			retval_ref = retval_ptr = EX_VAR(opline->result.var);
		} else if (IS_CV == IS_VAR) {
			if (UNEXPECTED(Z_TYPE_P(retval_ptr) == IS_INDIRECT)) {
				retval_ptr = Z_INDIRECT_P(retval_ptr);
			}
			ZVAL_DEREF(retval_ptr);
		} else if (IS_CV == IS_CV) {
			ZVAL_DEREF(retval_ptr);
		}

		if (EXPECTED(ZEND_TYPE_CONTAINS_CODE(ret_info->type, Z_TYPE_P(retval_ptr)))) {
			ZEND_VM_NEXT_OPCODE();
		}

		if (IS_CV == IS_CV && UNEXPECTED(Z_ISUNDEF_P(retval_ptr))) {
			SAVE_OPLINE();
			retval_ref = retval_ptr = ZVAL_UNDEFINED_OP1();
			if (ZEND_TYPE_FULL_MASK(ret_info->type) & MAY_BE_NULL) {
				ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
			}
		}

		zend_reference *ref = NULL;
		void *cache_slot = CACHE_ADDR(opline->op2.num);
		if (UNEXPECTED(retval_ref != retval_ptr)) {
			if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
				ref = Z_REF_P(retval_ref);
			} else {
				/* A cast might happen - unwrap the reference if this is a by-value return */
				if (Z_REFCOUNT_P(retval_ref) == 1) {
					ZVAL_UNREF(retval_ref);
				} else {
					Z_DELREF_P(retval_ref);
					ZVAL_COPY(retval_ref, retval_ptr);
				}
				retval_ptr = retval_ref;
			}
		}

		SAVE_OPLINE();
		if (UNEXPECTED(!zend_check_type_slow(ret_info->type, retval_ptr, ref, cache_slot, NULL, 1, 0))) {
			zend_verify_return_error(EX(func), retval_ptr);
			HANDLE_EXCEPTION();
		}
		ZEND_VM_NEXT_OPCODE();
#endif
	}
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAR_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
	}

	varptr = EX_VAR(opline->op1.var);
	if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(varptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(arg);
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_CV == IS_CV) {
		ZVAL_COPY_DEREF(arg, varptr);
	} else /* if (IS_CV == IS_VAR) */ {
		if (UNEXPECTED(Z_ISREF_P(varptr))) {
			zend_refcounted *ref = Z_COUNTED_P(varptr);

			varptr = Z_REFVAL_P(varptr);
			ZVAL_COPY_VALUE(arg, varptr);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(arg)) {
				Z_ADDREF_P(arg);
			}
		} else {
			ZVAL_COPY_VALUE(arg, varptr);
		}
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_REF_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	SAVE_OPLINE();
	if (IS_UNUSED == IS_CONST) {
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
	}

	varptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);
	if (Z_ISREF_P(varptr)) {
		Z_ADDREF_P(varptr);
	} else {
		ZVAL_MAKE_REF_EX(varptr, 2);
	}
	ZVAL_REF(arg, Z_REF_P(varptr));

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAR_EX_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(0)) {
		if (QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var_by_ref;
		}
	} else if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_var_by_ref:
		varptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);
		if (Z_ISREF_P(varptr)) {
			Z_ADDREF_P(varptr);
		} else {
			ZVAL_MAKE_REF_EX(varptr, 2);
		}
		ZVAL_REF(arg, Z_REF_P(varptr));

		ZEND_VM_NEXT_OPCODE();
	}

	varptr = EX_VAR(opline->op1.var);
	if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(varptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(arg);
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_CV == IS_CV) {
		ZVAL_COPY_DEREF(arg, varptr);
	} else /* if (IS_CV == IS_VAR) */ {
		if (UNEXPECTED(Z_ISREF_P(varptr))) {
			zend_refcounted *ref = Z_COUNTED_P(varptr);

			varptr = Z_REFVAL_P(varptr);
			ZVAL_COPY_VALUE(arg, varptr);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(arg)) {
				Z_ADDREF_P(arg);
			}
		} else {
			ZVAL_COPY_VALUE(arg, varptr);
		}
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAR_EX_SPEC_CV_UNUSED_QUICK_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		zend_string *arg_name = Z_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = zend_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = ZEND_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(1)) {
		if (QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var_by_ref;
		}
	} else if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_var_by_ref:
		varptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);
		if (Z_ISREF_P(varptr)) {
			Z_ADDREF_P(varptr);
		} else {
			ZVAL_MAKE_REF_EX(varptr, 2);
		}
		ZVAL_REF(arg, Z_REF_P(varptr));

		ZEND_VM_NEXT_OPCODE();
	}

	varptr = EX_VAR(opline->op1.var);
	if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(varptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(arg);
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_CV == IS_CV) {
		ZVAL_COPY_DEREF(arg, varptr);
	} else /* if (IS_CV == IS_VAR) */ {
		if (UNEXPECTED(Z_ISREF_P(varptr))) {
			zend_refcounted *ref = Z_COUNTED_P(varptr);

			varptr = Z_REFVAL_P(varptr);
			ZVAL_COPY_VALUE(arg, varptr);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(zend_reference));
			} else if (Z_OPT_REFCOUNTED_P(arg)) {
				Z_ADDREF_P(arg);
			}
		} else {
			ZVAL_COPY_VALUE(arg, varptr);
		}
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) &&
	    UNEXPECTED(opline->extended_value & ZEND_ARRAY_ELEMENT_REF)) {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);
		if (Z_ISREF_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}

	} else {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
		if (IS_CV == IS_TMP_VAR) {
			/* pass */
		} else if (IS_CV == IS_CONST) {
			Z_TRY_ADDREF_P(expr_ptr);
		} else if (IS_CV == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			Z_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_CV == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(expr_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(expr_ptr);

				expr_ptr = Z_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(expr_ptr)) {
					Z_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_UNUSED != IS_UNUSED) {
		zval *offset = NULL;
		zend_string *str;
		zend_ulong hval;

add_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if (IS_UNUSED != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index:
			zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_UNUSED & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(offset) == IS_REFERENCE)) {
			offset = Z_REFVAL_P(offset);
			goto add_again;
		} else if (Z_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (Z_TYPE_P(offset) == IS_DOUBLE) {
			hval = zend_dval_to_lval(Z_DVAL_P(offset));
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_RESOURCE) {
			zend_use_resource_as_offset(offset);
			hval = Z_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_UNUSED == IS_CV && Z_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			zend_illegal_offset();
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			zend_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_ARRAY_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_CV != IS_UNUSED) {
		size = opline->extended_value >> ZEND_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, zend_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & ZEND_ARRAY_NOT_PACKED) {
			zend_hash_real_init_mixed(Z_ARRVAL_P(array));
		}
		ZEND_VM_TAIL_CALL(ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, zend_new_array(0));
		ZEND_VM_NEXT_OPCODE();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_UNSET_CV_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var = EX_VAR(opline->op1.var);

	if (Z_REFCOUNTED_P(var)) {
		zend_refcounted *garbage = Z_COUNTED_P(var);

		ZVAL_UNDEF(var);
		SAVE_OPLINE();
		if (!GC_DELREF(garbage)) {
			rc_dtor_func(garbage);
		} else {
			gc_check_possible_root(garbage);
		}
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	} else {
		ZVAL_UNDEF(var);
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_UNSET_VAR_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varname;
	zend_string *name, *tmp_name;
	HashTable *target_symbol_table;

	SAVE_OPLINE();

	varname = EX_VAR(opline->op1.var);

	if (IS_CV == IS_CONST) {
		name = Z_STR_P(varname);
	} else if (EXPECTED(Z_TYPE_P(varname) == IS_STRING)) {
		name = Z_STR_P(varname);
		tmp_name = NULL;
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(varname) == IS_UNDEF)) {
			varname = ZVAL_UNDEFINED_OP1();
		}
		name = zval_try_get_tmp_string(varname, &tmp_name);
		if (UNEXPECTED(!name)) {

			HANDLE_EXCEPTION();
		}
	}

	target_symbol_table = zend_get_target_symbol_table(opline->extended_value EXECUTE_DATA_CC);
	zend_hash_del_ind(target_symbol_table, name);

	if (IS_CV != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_SET_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	value = EX_VAR(opline->op1.var);
	if (!(0)) {
		if (Z_TYPE_P(value) > IS_NULL &&
		    (!Z_ISREF_P(value) || Z_TYPE_P(Z_REFVAL_P(value)) != IS_NULL)) {
			ZEND_VM_SMART_BRANCH_TRUE();
		} else {
			ZEND_VM_SMART_BRANCH_FALSE();
		}
	} else {
		bool result;

		SAVE_OPLINE();
		result = !i_zend_is_true(value);
		ZEND_VM_SMART_BRANCH(result, 1);
	}
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_EMPTY_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	value = EX_VAR(opline->op1.var);
	if (!(1)) {
		if (Z_TYPE_P(value) > IS_NULL &&
		    (!Z_ISREF_P(value) || Z_TYPE_P(Z_REFVAL_P(value)) != IS_NULL)) {
			ZEND_VM_SMART_BRANCH_TRUE();
		} else {
			ZEND_VM_SMART_BRANCH_FALSE();
		}
	} else {
		bool result;

		SAVE_OPLINE();
		result = !i_zend_is_true(value);
		ZEND_VM_SMART_BRANCH(result, 1);
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	/* Should be bool result? as below got: result = (opline->extended_value & ZEND_ISEMPTY) */
	int result;
	zval *varname;
	zend_string *name, *tmp_name;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = _get_zval_ptr_cv_BP_VAR_IS(opline->op1.var EXECUTE_DATA_CC);
	if (IS_CV == IS_CONST) {
		name = Z_STR_P(varname);
	} else {
		name = zval_get_tmp_string(varname, &tmp_name);
	}

	target_symbol_table = zend_get_target_symbol_table(opline->extended_value EXECUTE_DATA_CC);
	value = zend_hash_find_ex(target_symbol_table, name, IS_CV == IS_CONST);

	if (IS_CV != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

	if (!value) {
		result = (opline->extended_value & ZEND_ISEMPTY);
	} else {
		if (Z_TYPE_P(value) == IS_INDIRECT) {
			value = Z_INDIRECT_P(value);
		}
		if (!(opline->extended_value & ZEND_ISEMPTY)) {
			if (Z_ISREF_P(value)) {
				value = Z_REFVAL_P(value);
			}
			result = Z_TYPE_P(value) > IS_NULL;
		} else {
			result = !i_zend_is_true(value);
		}
	}

	ZEND_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INSTANCEOF_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr;
	zend_bool result;

	SAVE_OPLINE();
	expr = EX_VAR(opline->op1.var);

try_instanceof:
	if (Z_TYPE_P(expr) == IS_OBJECT) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			ce = CACHED_PTR(opline->extended_value);
			if (UNEXPECTED(ce == NULL)) {
				ce = zend_fetch_class_by_name(Z_STR_P(RT_CONSTANT(opline, opline->op2)), Z_STR_P(RT_CONSTANT(opline, opline->op2) + 1), ZEND_FETCH_CLASS_NO_AUTOLOAD);
				if (EXPECTED(ce)) {
					CACHE_PTR(opline->extended_value, ce);
				}
			}
		} else if (IS_UNUSED == IS_UNUSED) {
			ce = zend_fetch_class(NULL, opline->op2.num);
			if (UNEXPECTED(ce == NULL)) {

				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		result = ce && instanceof_function(Z_OBJCE_P(expr), ce);
	} else if ((IS_CV & (IS_VAR|IS_CV)) && Z_TYPE_P(expr) == IS_REFERENCE) {
		expr = Z_REFVAL_P(expr);
		goto try_instanceof;
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(expr) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		result = 0;
	}

	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_YIELD_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & ZEND_GENERATOR_FORCED_CLOSE)) {
		ZEND_VM_TAIL_CALL(zend_yield_in_closed_generator_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CV != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CV & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
						Z_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_CV == IS_VAR) {
						ZEND_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == ZEND_RETURNS_FUNCTION
						 && !Z_ISREF_P(value_ptr)) {
							zend_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (Z_ISREF_P(value_ptr)) {
						Z_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, Z_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_CV == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
					Z_ADDREF(generator->value);
				}
			} else if (IS_CV == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if ((IS_CV & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, Z_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CV == IS_CV) {
					if (Z_OPT_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {
		zval *key = NULL;
		if ((IS_UNUSED & (IS_CV|IS_VAR)) && UNEXPECTED(Z_TYPE_P(key)) == IS_REFERENCE) {
			key = Z_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BIND_STATIC_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	HashTable *ht;
	zval *value;
	zval *variable_ptr;

	variable_ptr = EX_VAR(opline->op1.var);

	ht = ZEND_MAP_PTR_GET(EX(func)->op_array.static_variables_ptr);
	if (!ht) {
		ZEND_ASSERT(EX(func)->op_array.fn_flags & (ZEND_ACC_IMMUTABLE|ZEND_ACC_PRELOADED));
		ht = zend_array_dup(EX(func)->op_array.static_variables);
		ZEND_MAP_PTR_SET(EX(func)->op_array.static_variables_ptr, ht);
	} else if (GC_REFCOUNT(ht) > 1) {
		if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
			GC_DELREF(ht);
		}
		ht = zend_array_dup(ht);
		ZEND_MAP_PTR_SET(EX(func)->op_array.static_variables_ptr, ht);
	}

	value = (zval*)((char*)ht->arData + (opline->extended_value & ~(ZEND_BIND_REF|ZEND_BIND_IMPLICIT)));

	if (opline->extended_value & ZEND_BIND_REF) {
		if (Z_TYPE_P(value) == IS_CONSTANT_AST) {
			SAVE_OPLINE();
			if (UNEXPECTED(zval_update_constant_ex(value, EX(func)->op_array.scope) != SUCCESS)) {
				HANDLE_EXCEPTION();
			}
		}

		i_zval_ptr_dtor(variable_ptr);
		if (UNEXPECTED(!Z_ISREF_P(value))) {
			zend_reference *ref = (zend_reference*)emalloc(sizeof(zend_reference));
			GC_SET_REFCOUNT(ref, 2);
			GC_TYPE_INFO(ref) = GC_REFERENCE;
			ZVAL_COPY_VALUE(&ref->val, value);
			ref->sources.ptr = NULL;
			Z_REF_P(value) = ref;
			Z_TYPE_INFO_P(value) = IS_REFERENCE_EX;
			ZVAL_REF(variable_ptr, ref);
		} else {
			Z_ADDREF_P(value);
			ZVAL_REF(variable_ptr, Z_REF_P(value));
		}
	} else {
		i_zval_ptr_dtor(variable_ptr);
		ZVAL_COPY(variable_ptr, value);
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CHECK_VAR_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1 = EX_VAR(opline->op1.var);

	if (UNEXPECTED(Z_TYPE_INFO_P(op1) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_MAKE_REF_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1 = EX_VAR(opline->op1.var);

	if (IS_CV == IS_CV) {
		if (UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_NEW_EMPTY_REF(op1);
			Z_SET_REFCOUNT_P(op1, 2);
			ZVAL_NULL(Z_REFVAL_P(op1));
			ZVAL_REF(EX_VAR(opline->result.var), Z_REF_P(op1));
		} else {
			if (Z_ISREF_P(op1)) {
				Z_ADDREF_P(op1);
			} else {
				ZVAL_MAKE_REF_EX(op1, 2);
			}
			ZVAL_REF(EX_VAR(opline->result.var), Z_REF_P(op1));
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_INDIRECT)) {
		op1 = Z_INDIRECT_P(op1);
		if (EXPECTED(!Z_ISREF_P(op1))) {
			ZVAL_MAKE_REF_EX(op1, 2);
		} else {
			GC_ADDREF(Z_REF_P(op1));
		}
		ZVAL_REF(EX_VAR(opline->result.var), Z_REF_P(op1));
	} else {
		ZVAL_COPY_VALUE(EX_VAR(opline->result.var), op1);
	}
	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_COUNT_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;
	zend_long count;

	SAVE_OPLINE();
	op1 = EX_VAR(opline->op1.var);

	while (1) {
		if (Z_TYPE_P(op1) == IS_ARRAY) {
			count = zend_array_count(Z_ARRVAL_P(op1));
			break;
		} else if (Z_TYPE_P(op1) == IS_OBJECT) {
			zend_object *zobj = Z_OBJ_P(op1);

			/* first, we check if the handler is defined */
			if (zobj->handlers->count_elements) {
				if (SUCCESS == zobj->handlers->count_elements(zobj, &count)) {
					break;
				}
				if (UNEXPECTED(EG(exception))) {
					count = 0;
					break;
				}
			}

			/* if not and the object implements Countable we call its count() method */
			if (zend_class_implements_interface(zobj->ce, zend_ce_countable)) {
				zval retval;

				zend_call_method_with_0_params(zobj, NULL, NULL, "count", &retval);
				count = zval_get_long(&retval);
				zval_ptr_dtor(&retval);
				break;
			}

			/* If There's no handler and it doesn't implement Countable then emit a TypeError */
		} else if ((IS_CV & (IS_VAR|IS_CV)) != 0 && Z_TYPE_P(op1) == IS_REFERENCE) {
			op1 = Z_REFVAL_P(op1);
			continue;
		} else if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		count = 0;
		zend_type_error("%s(): Argument #1 ($var) must be of type Countable|array, %s given", opline->extended_value ? "sizeof" : "count", zend_zval_type_name(op1));
		break;
	}

	ZVAL_LONG(EX_VAR(opline->result.var), count);

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_GET_CLASS_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (IS_CV == IS_UNUSED) {
		if (UNEXPECTED(!EX(func)->common.scope)) {
			SAVE_OPLINE();
			zend_throw_error(NULL, "get_class() without arguments must be called from within a class");
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		} else {
			ZVAL_STR_COPY(EX_VAR(opline->result.var), EX(func)->common.scope->name);
			ZEND_VM_NEXT_OPCODE();
		}
	} else {
		zval *op1;

		SAVE_OPLINE();
		op1 = EX_VAR(opline->op1.var);
		while (1) {
			if (Z_TYPE_P(op1) == IS_OBJECT) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), Z_OBJCE_P(op1)->name);
			} else if ((IS_CV & (IS_VAR|IS_CV)) != 0 && Z_TYPE_P(op1) == IS_REFERENCE) {
				op1 = Z_REFVAL_P(op1);
				continue;
			} else {
				if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
					ZVAL_UNDEFINED_OP1();
				}
				zend_type_error("get_class(): Argument #1 ($object) must be of type object, %s given", zend_zval_type_name(op1));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
			}
			break;
		}

		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_GET_TYPE_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;
	zend_string *type;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	type = zend_zval_get_legacy_type(op1);
	if (EXPECTED(type)) {
		ZVAL_INTERNED_STR(EX_VAR(opline->result.var), type);
	} else {
		ZVAL_STRING(EX_VAR(opline->result.var), "unknown type");
	}

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SEND_VAR_EX_SIMPLE_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;
	uint32_t arg_num = opline->op2.num;

	if (QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
		ZEND_VM_TAIL_CALL(ZEND_SEND_REF_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	varptr = EX_VAR(opline->op1.var);
	arg = ZEND_CALL_VAR(EX(call), opline->result.var);

	if (IS_CV == IS_CV) {
		ZVAL_COPY(arg, varptr);
	} else /* if (IS_CV == IS_VAR) */ {
		ZVAL_COPY_VALUE(arg, varptr);
	}

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_DIV_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	fast_div_function(EX_VAR(opline->result.var), op1, op2);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POW_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	pow_function(EX_VAR(opline->result.var), op1, op2);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);

	if ((IS_CV == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
	    (IS_CV == IS_CONST || EXPECTED(Z_TYPE_P(op2) == IS_STRING))) {
		zend_string *op1_str = Z_STR_P(op1);
		zend_string *op2_str = Z_STR_P(op2);
		zend_string *str;

		if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
		} else if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else if (IS_CV != IS_CONST && IS_CV != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
		    size_t len = ZSTR_LEN(op1_str);

			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else {
			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		}
		ZEND_VM_NEXT_OPCODE();
	} else {
		SAVE_OPLINE();

		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
			op1 = ZVAL_UNDEFINED_OP1();
		}
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
			op2 = ZVAL_UNDEFINED_OP2();
		}
		concat_function(EX_VAR(opline->result.var), op1, op2);


		ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_IDENTICAL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);


	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_IDENTICAL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_not_identical_function(op1, op2);


	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CV == IS_CONST && IS_CV == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) == Z_LVAL_P(op2))) {
is_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_SPEC_CV_CV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CV == IS_CONST && IS_CV == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) == Z_LVAL_P(op2))) {
is_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_EQUAL_SPEC_CV_CV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CV == IS_CONST && IS_CV == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) == Z_LVAL_P(op2))) {
is_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CV == IS_CONST && IS_CV == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) != Z_LVAL_P(op2))) {
is_not_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_not_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_not_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_SPEC_CV_CV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CV == IS_CONST && IS_CV == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) != Z_LVAL_P(op2))) {
is_not_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_not_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_not_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_EQUAL_SPEC_CV_CV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CV == IS_CONST && IS_CV == IS_CONST) {
		/* pass */
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(Z_LVAL_P(op1) != Z_LVAL_P(op2))) {
is_not_equal_true:
				ZEND_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_not_equal_false:
				ZEND_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)Z_LVAL_P(op1);
			d2 = Z_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = Z_DVAL_P(op1);
			d2 = Z_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(Z_TYPE_P(op2) == IS_LONG)) {
			d1 = Z_DVAL_P(op1);
			d2 = (double)Z_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
			bool result = zend_fast_equal_strings(Z_STR_P(op1), Z_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	ZEND_VM_TAIL_CALL(zend_is_not_equal_helper_SPEC(op1, op2 ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_SPACESHIP_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	compare_function(EX_VAR(opline->result.var), op1, op2);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_BOOL_XOR_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	boolean_xor_function(EX_VAR(opline->result.var), op1, op2);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_OP_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *value;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto assign_op_object;
			}
			if (IS_CV == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

assign_op_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if (IS_CV == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CV == IS_CONST) ? CACHE_ADDR((opline+1)->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				zval *orig_zptr = zptr;
				zend_reference *ref;

				do {
					if (UNEXPECTED(Z_ISREF_P(zptr))) {
						ref = Z_REF_P(zptr);
						zptr = Z_REFVAL_P(zptr);
						if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
							zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
							break;
						}
					}

					if (IS_CV == IS_CONST) {
						prop_info = (zend_property_info*)CACHED_PTR_EX(cache_slot + 2);
					} else {
						prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), orig_zptr);
					}
					if (UNEXPECTED(prop_info)) {
						/* special case for typed properties */
						zend_binary_assign_op_typed_prop(prop_info, zptr, value OPLINE_CC EXECUTE_DATA_CC);
					} else {
						zend_binary_op(zptr, zptr, value OPLINE_CC);
					}
				} while (0);

				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		} else {
			zend_assign_op_overloaded_property(zobj, name, cache_slot, value OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CV != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);

	FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);


	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMP|VAR|CV, UNUSED|CONST|TMPVAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_OP_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value, *container, *dim;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
assign_dim_op_array:
		SEPARATE_ARRAY(container);
assign_dim_op_new_array:
		dim = EX_VAR(opline->op2.var);
		if (IS_CV == IS_UNUSED) {
			var_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(container), &EG(uninitialized_zval));
			if (UNEXPECTED(!var_ptr)) {
				zend_cannot_add_element();
				goto assign_dim_op_ret_null;
			}
		} else {
			if (IS_CV == IS_CONST) {
				var_ptr = zend_fetch_dimension_address_inner_RW_CONST(Z_ARRVAL_P(container), dim EXECUTE_DATA_CC);
			} else {
				var_ptr = zend_fetch_dimension_address_inner_RW(Z_ARRVAL_P(container), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(!var_ptr)) {
				goto assign_dim_op_ret_null;
			}
		}

		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		do {
			if (IS_CV != IS_UNUSED && UNEXPECTED(Z_ISREF_P(var_ptr))) {
				zend_reference *ref = Z_REF_P(var_ptr);
				var_ptr = Z_REFVAL_P(var_ptr);
				if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
					zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
					break;
				}
			}
			zend_binary_op(var_ptr, var_ptr, value OPLINE_CC);
		} while (0);

		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
		}
		FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	} else {
		if (EXPECTED(Z_ISREF_P(container))) {
			container = Z_REFVAL_P(container);
			if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				goto assign_dim_op_array;
			}
		}

		dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

		if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
			if (IS_CV == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_binary_assign_op_obj_dim(container, dim OPLINE_CC EXECUTE_DATA_CC);
		} else if (EXPECTED(Z_TYPE_P(container) <= IS_FALSE)) {
			if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			ZVAL_ARR(container, zend_new_array(8));
			goto assign_dim_op_new_array;
		} else {
			zend_binary_assign_op_dim_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
assign_dim_op_ret_null:
			FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}


	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OP_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	var_ptr = _get_zval_ptr_cv_BP_VAR_RW(opline->op1.var EXECUTE_DATA_CC);

	do {
		if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_REFERENCE)) {
			zend_reference *ref = Z_REF_P(var_ptr);
			var_ptr = Z_REFVAL_P(var_ptr);
			if (UNEXPECTED(ZEND_REF_HAS_TYPE_SOURCES(ref))) {
				zend_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		zend_binary_op(var_ptr, var_ptr, value OPLINE_CC);
	} while (0);

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_PRE_INC_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto pre_incdec_object;
			}
			if (IS_CV == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

pre_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if (IS_CV == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				if (IS_CV == IS_CONST) {
					prop_info = (zend_property_info *) CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), zptr);
				}
				zend_pre_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			zend_pre_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CV != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_POST_INC_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	zend_property_info *prop_info;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
			if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
				object = Z_REFVAL_P(object);
				goto post_incdec_object;
			}
			if (IS_CV == IS_CV
			 && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

post_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = Z_OBJ_P(object);
		if (IS_CV == IS_CONST) {
			name = Z_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}
		cache_slot = (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(Z_ISERROR_P(zptr))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			} else {
				if (IS_CV == IS_CONST) {
					prop_info = (zend_property_info*)CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = zend_object_fetch_property_type_info(Z_OBJ_P(object), zptr);
				}

				zend_post_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			zend_post_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CV != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_R_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	dim = EX_VAR(opline->op2.var);
	if (IS_CV != IS_CONST) {
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_array:
			value = zend_fetch_dimension_address_inner(Z_ARRVAL_P(container), dim, IS_CV, BP_VAR_R EXECUTE_DATA_CC);
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		} else if (EXPECTED(Z_TYPE_P(container) == IS_REFERENCE)) {
			container = Z_REFVAL_P(container);
			if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				goto fetch_dim_r_array;
			} else {
				goto fetch_dim_r_slow;
			}
		} else {
fetch_dim_r_slow:
			if (IS_CV == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
		}
	} else {
		zend_fetch_dimension_address_read_R(container, dim, IS_CV OPLINE_CC EXECUTE_DATA_CC);
	}


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_W_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	zend_fetch_dimension_address_W(container, EX_VAR(opline->op2.var), IS_CV OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_RW_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	zend_fetch_dimension_address_RW(container, EX_VAR(opline->op2.var), IS_CV OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_IS_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	zend_fetch_dimension_address_read_IS(container, EX_VAR(opline->op2.var), IS_CV OPLINE_CC EXECUTE_DATA_CC);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
        if ((IS_CV & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
        }
		ZEND_VM_TAIL_CALL(ZEND_FETCH_DIM_W_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_CV == IS_UNUSED) {
			ZEND_VM_TAIL_CALL(zend_use_undef_in_read_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_FETCH_DIM_R_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_DIM_UNSET_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	zend_fetch_dimension_address_UNSET(container, EX_VAR(opline->op2.var), IS_CV OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_R_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	offset = EX_VAR(opline->op2.var);

	if (IS_CV == IS_CONST ||
	    (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
	    do {
			if ((IS_CV & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			zend_wrong_property_read(container, offset);
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if (IS_CV == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value & ~ZEND_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
		} else {
			if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(offset) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));

		if (IS_CV != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_W_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();

	container = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(
		result, container, IS_CV, property, IS_CV,
		((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_FETCH_OBJ_FLAGS) : NULL),
		BP_VAR_W, opline->extended_value & ZEND_FETCH_OBJ_FLAGS, 1 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_RW_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(result, container, IS_CV, property, IS_CV, ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_RW, 0, 1 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_IS_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(opline->op1.var EXECUTE_DATA_CC);
	offset = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	if (IS_CV == IS_CONST ||
	    (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_CV & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		zend_object *zobj = Z_OBJ_P(container);
		zend_string *name, *tmp_name;
		zval *retval;

		if (IS_CV == IS_CONST) {
			name = Z_STR_P(offset);
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(Z_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							ZEND_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = ZEND_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(Z_TYPE(p->val) != IS_UNDEF) &&
						        (EXPECTED(p->key == name) ||
						         (EXPECTED(p->h == ZSTR_H(name)) &&
						          EXPECTED(p->key != NULL) &&
						          EXPECTED(zend_string_equal_content(p->key, name))))) {
								retval = &p->val;
								if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = zend_hash_find_ex(zobj->properties, name, 1);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)ZEND_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if (IS_CV != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(Z_ISREF_P(retval))) {
			zend_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(ZEND_CALL_INFO(EX(call)) & ZEND_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_CV & (IS_CONST|IS_TMP_VAR))) {
			ZEND_VM_TAIL_CALL(zend_use_tmp_in_write_context_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_W_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZEND_VM_TAIL_CALL(ZEND_FETCH_OBJ_R_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FETCH_OBJ_UNSET_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *property, *result;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	zend_fetch_property_address(result, container, IS_CV, property, IS_CV, ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_UNSET, 0, 1 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	value = RT_CONSTANT((opline+1), (opline+1)->op1);

	if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CV == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_CONST == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_CONST == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_CONST, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_CONST != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_CONST == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_CONST == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CV == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:


	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CV == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_TMP_VAR == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_TMP_VAR == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_TMP_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_TMP_VAR != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_TMP_VAR == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_TMP_VAR == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CV == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:


	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CV == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_VAR == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_VAR == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_VAR, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_VAR == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_VAR != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_VAR == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_VAR == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CV == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:


	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *property, *value, tmp;
	zend_object *zobj;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		if (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {
			object = Z_REFVAL_P(object);
			goto assign_object;
		}
		zend_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = Z_OBJ_P(object);
	if (IS_CV == IS_CONST &&
	    EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
		void **cache_slot = CACHE_ADDR(opline->extended_value);
		uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
		zend_object *zobj = Z_OBJ_P(object);
		zval *property_val;

		if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
			property_val = OBJ_PROP(zobj, prop_offset);
			if (Z_TYPE_P(property_val) != IS_UNDEF) {
				zend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);

				if (UNEXPECTED(prop_info != NULL)) {
					zend_uchar orig_type = IS_UNDEF;

					if (IS_CV == IS_CONST) {
						orig_type = Z_TYPE_P(value);
					}

					value = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);

					/* will remain valid, thus no need to check prop_info in future here */
					if (IS_CV == IS_CONST && Z_TYPE_P(value) == orig_type) {
						CACHE_PTR_EX(cache_slot + 2, NULL);
					}
					goto free_and_exit_assign_obj;
				} else {
fast_assign_obj:
					value = zend_assign_to_variable(property_val, value, IS_CV, EX_USES_STRICT_TYPES());
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		} else {
			if (EXPECTED(zobj->properties != NULL)) {
				if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(zobj->properties);
					}
					zobj->properties = zend_array_dup(zobj->properties);
				}
				property_val = zend_hash_find_ex(zobj->properties, Z_STR_P(property), 1);
				if (property_val) {
					goto fast_assign_obj;
				}
			}

			if (!zobj->ce->__set) {

				if (EXPECTED(zobj->properties == NULL)) {
					rebuild_object_properties(zobj);
				}
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {
						Z_ADDREF_P(value);
					}
				} else if (IS_CV != IS_TMP_VAR) {
					if (Z_ISREF_P(value)) {
						if (IS_CV == IS_VAR) {
							zend_reference *ref = Z_REF_P(value);
							if (GC_DELREF(ref) == 0) {
								ZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));
								efree_size(ref, sizeof(zend_reference));
								value = &tmp;
							} else {
								value = Z_REFVAL_P(value);
								Z_TRY_ADDREF_P(value);
							}
						} else {
							value = Z_REFVAL_P(value);
							Z_TRY_ADDREF_P(value);
						}
					} else if (IS_CV == IS_CV) {
						Z_TRY_ADDREF_P(value);
					}
				}
				zend_hash_add_new(zobj->properties, Z_STR_P(property), value);
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), value);
				}
				goto exit_assign_obj;
			}
		}
	}

	if (IS_CV == IS_CV || IS_CV == IS_VAR) {
		ZVAL_DEREF(value);
	}

	if (IS_CV == IS_CONST) {
		name = Z_STR_P(property);
	} else {
		name = zval_try_get_tmp_string(property, &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:


	/* assign_obj has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CV == IS_UNUSED) {
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CONST == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_CONST == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CONST == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			value = zend_assign_to_variable(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
			value = RT_CONSTANT((opline+1), (opline+1)->op1);

			if (IS_CV == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CV == IS_UNUSED) {
				zend_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
				value = RT_CONSTANT((opline+1), (opline+1)->op1);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CV != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CV == IS_UNUSED) {
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_TMP_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_TMP_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_TMP_VAR == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

			if (IS_CV == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CV == IS_UNUSED) {
				zend_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
				value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CV != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CV == IS_UNUSED) {
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_VAR == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
			value = _get_zval_ptr_var_deref((opline+1)->op1.var EXECUTE_DATA_CC);

			if (IS_CV == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CV == IS_UNUSED) {
				zend_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
				value = _get_zval_ptr_var_deref((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CV != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CV == IS_UNUSED) {
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_CV == IS_CV || IS_CV == IS_VAR) {
				ZVAL_DEREF(value);
			}
			variable_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(variable_ptr == NULL)) {
				zend_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CV == IS_CV) {
				if (Z_REFCOUNTED_P(value)) {
					Z_ADDREF_P(value);
				}
			} else if (IS_CV == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (value != free_op_data) {
					if (Z_REFCOUNTED_P(value)) {
						Z_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CV == IS_CONST) {
				if (UNEXPECTED(Z_REFCOUNTED_P(value))) {
					Z_ADDREF_P(value);
				}
			}
		} else {
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CONST) {
				variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = zend_fetch_dimension_address_inner_W(Z_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			value = zend_assign_to_variable(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES());
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
	} else {
		if (EXPECTED(Z_ISREF_P(object_ptr))) {
			object_ptr = Z_REFVAL_P(object_ptr);
			if (EXPECTED(Z_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(Z_TYPE_P(object_ptr) == IS_OBJECT)) {
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
			value = _get_zval_ptr_cv_deref_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

			if (IS_CV == IS_CONST && Z_EXTRA_P(dim) == ZEND_EXTRA_VALUE) {
				dim++;
			}
			zend_assign_to_object_dim(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

		} else if (EXPECTED(Z_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CV == IS_UNUSED) {
				zend_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
				value = _get_zval_ptr_cv_deref_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
				zend_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(Z_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (Z_ISREF_P(orig_object_ptr)
			 && ZEND_REF_HAS_TYPE_SOURCES(Z_REF_P(orig_object_ptr))
			 && !zend_verify_ref_array_assignable(Z_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

				UNDEF_RESULT();
			} else {
				ZVAL_ARR(object_ptr, zend_new_array(8));
				goto try_assign_dim_array;
			}
		} else {
			zend_use_scalar_as_array();
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CV != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_SPEC_CV_CV_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = EX_VAR(opline->op1.var);

	value = zend_assign_to_variable(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES());
	if (UNEXPECTED(0)) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_SPEC_CV_CV_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = EX_VAR(opline->op1.var);

	value = zend_assign_to_variable(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES());
	if (UNEXPECTED(1)) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_REF_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *variable_ptr;
	zval *value_ptr;

	SAVE_OPLINE();
	value_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = EX_VAR(opline->op1.var);

	if (IS_CV == IS_VAR &&
	           UNEXPECTED(Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT)) {

		zend_throw_error(NULL, "Cannot assign by reference to an array dimension of an object");
		variable_ptr = &EG(uninitialized_zval);
	} else if (IS_CV == IS_VAR &&
	           opline->extended_value == ZEND_RETURNS_FUNCTION &&
			   UNEXPECTED(!Z_ISREF_P(value_ptr))) {

		if (UNEXPECTED(!zend_wrong_assign_to_variable_reference(variable_ptr, value_ptr OPLINE_CC EXECUTE_DATA_CC))) {
			variable_ptr = &EG(uninitialized_zval);
		}
	} else {
		zend_assign_to_variable_reference(variable_ptr, value_ptr);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);
	}


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_CV == IS_UNUSED) {
			if (IS_CV == IS_CONST) {
				zend_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CV == IS_CONST) {
				zend_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		zend_assign_to_property_reference(container, IS_CV, property, IS_CV, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}


	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));;
	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_cv_BP_VAR_W((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_CV == IS_UNUSED) {
			if (IS_CV == IS_CONST) {
				zend_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CV == IS_CONST) {
				zend_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				zend_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		zend_assign_to_property_reference(container, IS_CV, property, IS_CV, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}



	ZEND_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_string *op1_str, *op2_str, *str;


	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if ((IS_CV == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
	    (IS_CV == IS_CONST || EXPECTED(Z_TYPE_P(op2) == IS_STRING))) {
		zend_string *op1_str = Z_STR_P(op1);
		zend_string *op2_str = Z_STR_P(op2);
		zend_string *str;

		if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
		} else if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else if (IS_CV != IS_CONST && IS_CV != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
		    size_t len = ZSTR_LEN(op1_str);

			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		} else {
			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op1_str, 0);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zend_string_release_ex(op2_str, 0);
			}
		}
		ZEND_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	if (IS_CV == IS_CONST) {
		op1_str = Z_STR_P(op1);
	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
		op1_str = zend_string_copy(Z_STR_P(op1));
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		op1_str = zval_get_string_func(op1);
	}
	if (IS_CV == IS_CONST) {
		op2_str = Z_STR_P(op2);
	} else if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
		op2_str = zend_string_copy(Z_STR_P(op2));
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP2();
		}
		op2_str = zval_get_string_func(op2);
	}
	do {
		if (IS_CV != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(Z_REFCOUNTED_P(op2))) {
						GC_ADDREF(op2_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
				zend_string_release_ex(op1_str, 0);
				break;
			}
		}
		if (IS_CV != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(Z_REFCOUNTED_P(op1))) {
						GC_ADDREF(op1_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
				zend_string_release_ex(op2_str, 0);
				break;
			}
		}
		str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
		memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
		memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
		ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
		if (IS_CV != IS_CONST) {
			zend_string_release_ex(op1_str, 0);
		}
		if (IS_CV != IS_CONST) {
			zend_string_release_ex(op2_str, 0);
		}
	} while (0);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_METHOD_CALL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	zend_function *fbc;
	zend_class_entry *called_scope;
	zend_object *obj;
	zend_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = EX_VAR(opline->op1.var);

	if (IS_CV != IS_CONST) {
		function_name = EX_VAR(opline->op2.var);
	}

	if (IS_CV != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		do {
			if ((IS_CV & (IS_VAR|IS_CV)) && Z_ISREF_P(function_name)) {
				function_name = Z_REFVAL_P(function_name);
				if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {

					HANDLE_EXCEPTION();
				}
			}
			zend_throw_error(NULL, "Method name must be a string");


			HANDLE_EXCEPTION();
		} while (0);
	}

	if (IS_CV == IS_UNUSED) {
		obj = Z_OBJ_P(object);
	} else {
		do {
			if (IS_CV != IS_CONST && EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
				obj = Z_OBJ_P(object);
			} else {
				if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(object))) {
					zend_reference *ref = Z_REF_P(object);

					object = &ref->val;
					if (EXPECTED(Z_TYPE_P(object) == IS_OBJECT)) {
						obj = Z_OBJ_P(object);
						if (IS_CV & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(zend_reference));
							} else {
								Z_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if (IS_CV != IS_CONST) {

						}
						HANDLE_EXCEPTION();
					}
				}
				if (IS_CV == IS_CONST) {
					function_name = EX_VAR(opline->op2.var);
				}
				zend_invalid_method_call(object, function_name);


				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if (IS_CV == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
	    fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
	    zend_object *orig_obj = obj;

		if (IS_CV == IS_CONST) {
			function_name = EX_VAR(opline->op2.var);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, Z_STR_P(function_name), ((IS_CV == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				zend_undefined_method(obj->ce, Z_STR_P(function_name));
			}

			if ((IS_CV & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if (IS_CV == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_TRAMPOLINE|ZEND_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if ((IS_CV & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				zend_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == ZEND_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (IS_CV != IS_CONST) {

	}

	call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_STATIC) != 0)) {
		if ((IS_CV & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			zend_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (zend_object*)called_scope;
		call_info = ZEND_CALL_NESTED_FUNCTION;
	} else if (IS_CV & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if (IS_CV == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = ZEND_CALL_NESTED_FUNCTION | ZEND_CALL_HAS_THIS | ZEND_CALL_RELEASE_THIS;
	}

	call = zend_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) &&
	    UNEXPECTED(opline->extended_value & ZEND_ARRAY_ELEMENT_REF)) {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);
		if (Z_ISREF_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}

	} else {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
		if (IS_CV == IS_TMP_VAR) {
			/* pass */
		} else if (IS_CV == IS_CONST) {
			Z_TRY_ADDREF_P(expr_ptr);
		} else if (IS_CV == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			Z_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_CV == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(expr_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(expr_ptr);

				expr_ptr = Z_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(expr_ptr)) {
					Z_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_CV != IS_UNUSED) {
		zval *offset = EX_VAR(opline->op2.var);
		zend_string *str;
		zend_ulong hval;

add_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if (IS_CV != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index:
			zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(offset) == IS_REFERENCE)) {
			offset = Z_REFVAL_P(offset);
			goto add_again;
		} else if (Z_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (Z_TYPE_P(offset) == IS_DOUBLE) {
			hval = zend_dval_to_lval(Z_DVAL_P(offset));
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (Z_TYPE_P(offset) == IS_RESOURCE) {
			zend_use_resource_as_offset(offset);
			hval = Z_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_CV == IS_CV && Z_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			zend_illegal_offset();
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			zend_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_INIT_ARRAY_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_CV != IS_UNUSED) {
		size = opline->extended_value >> ZEND_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, zend_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & ZEND_ARRAY_NOT_PACKED) {
			zend_hash_real_init_mixed(Z_ARRVAL_P(array));
		}
		ZEND_VM_TAIL_CALL(ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, zend_new_array(0));
		ZEND_VM_NEXT_OPCODE();
	}
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_UNSET_DIM_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	zend_ulong hval;
	zend_string *key;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	offset = EX_VAR(opline->op2.var);

	do {
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
			HashTable *ht;

unset_dim_array:
			SEPARATE_ARRAY(container);
			ht = Z_ARRVAL_P(container);
offset_again:
			if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
				key = Z_STR_P(offset);
				if (IS_CV != IS_CONST) {
					if (ZEND_HANDLE_NUMERIC(key, hval)) {
						goto num_index_dim;
					}
				}
str_index_dim:
				if (ht == &EG(symbol_table)) {
					zend_delete_global_variable(key);
				} else {
					zend_hash_del(ht, key);
				}
			} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
				hval = Z_LVAL_P(offset);
num_index_dim:
				zend_hash_index_del(ht, hval);
			} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(Z_TYPE_P(offset) == IS_REFERENCE)) {
				offset = Z_REFVAL_P(offset);
				goto offset_again;
			} else if (Z_TYPE_P(offset) == IS_DOUBLE) {
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_dim;
			} else if (Z_TYPE_P(offset) == IS_NULL) {
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else if (Z_TYPE_P(offset) == IS_FALSE) {
				hval = 0;
				goto num_index_dim;
			} else if (Z_TYPE_P(offset) == IS_TRUE) {
				hval = 1;
				goto num_index_dim;
			} else if (Z_TYPE_P(offset) == IS_RESOURCE) {
				hval = Z_RES_HANDLE_P(offset);
				goto num_index_dim;
			} else if (IS_CV == IS_CV && Z_TYPE_P(offset) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else {
				zend_type_error("Illegal offset type in unset");
			}
			break;
		} else if (Z_ISREF_P(container)) {
			container = Z_REFVAL_P(container);
			if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
				goto unset_dim_array;
			}
		}
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
			container = ZVAL_UNDEFINED_OP1();
		}
		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(offset) == IS_UNDEF)) {
			offset = ZVAL_UNDEFINED_OP2();
		}
		if (EXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
			if (IS_CV == IS_CONST && Z_EXTRA_P(offset) == ZEND_EXTRA_VALUE) {
				offset++;
			}
			Z_OBJ_HT_P(container)->unset_dimension(Z_OBJ_P(container), offset);
		} else if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) == IS_STRING)) {
			zend_throw_error(NULL, "Cannot unset string offsets");
		}
	} while (0);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_UNSET_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	offset = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT)) {
			if (Z_ISREF_P(container)) {
				container = Z_REFVAL_P(container);
				if (Z_TYPE_P(container) != IS_OBJECT) {
					if (IS_CV == IS_CV
					 && UNEXPECTED(Z_TYPE_P(container) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP1();
					}
					break;
				}
			} else {
				break;
			}
		}
		if (IS_CV == IS_CONST) {
			name = Z_STR_P(offset);
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				break;
			}
		}
		Z_OBJ_HT_P(container)->unset_property(Z_OBJ_P(container), name, ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL));
		if (IS_CV != IS_CONST) {
			zend_tmp_string_release(tmp_name);
		}
	} while (0);


	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	bool result;
	zend_ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	offset = EX_VAR(opline->op2.var);

	if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
		HashTable *ht;
		zval *value;
		zend_string *str;

isset_dim_obj_array:
		ht = Z_ARRVAL_P(container);
isset_again:
		if (EXPECTED(Z_TYPE_P(offset) == IS_STRING)) {
			str = Z_STR_P(offset);
			if (IS_CV != IS_CONST) {
				if (ZEND_HANDLE_NUMERIC(str, hval)) {
					goto num_index_prop;
				}
			}
			value = zend_hash_find_ex_ind(ht, str, IS_CV == IS_CONST);
		} else if (EXPECTED(Z_TYPE_P(offset) == IS_LONG)) {
			hval = Z_LVAL_P(offset);
num_index_prop:
			value = zend_hash_index_find(ht, hval);
		} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(offset))) {
			offset = Z_REFVAL_P(offset);
			goto isset_again;
		} else {
			value = zend_find_array_dim_slow(ht, offset EXECUTE_DATA_CC);
			if (UNEXPECTED(EG(exception))) {
				result = 0;
				goto isset_dim_obj_exit;
			}
		}

		if (!(opline->extended_value & ZEND_ISEMPTY)) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = value != NULL && Z_TYPE_P(value) > IS_NULL &&
			    (!Z_ISREF_P(value) || Z_TYPE_P(Z_REFVAL_P(value)) != IS_NULL);

			if (IS_CV & (IS_CONST|IS_CV)) {
				/* avoid exception check */

				ZEND_VM_SMART_BRANCH(result, 0);
			}
		} else {
			result = (value == NULL || !i_zend_is_true(value));
		}
		goto isset_dim_obj_exit;
	} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(container))) {
		container = Z_REFVAL_P(container);
		if (EXPECTED(Z_TYPE_P(container) == IS_ARRAY)) {
			goto isset_dim_obj_array;
		}
	}

	if (IS_CV == IS_CONST && Z_EXTRA_P(offset) == ZEND_EXTRA_VALUE) {
		offset++;
	}
	if (!(opline->extended_value & ZEND_ISEMPTY)) {
		result = zend_isset_dim_slow(container, offset EXECUTE_DATA_CC);
	} else {
		result = zend_isempty_dim_slow(container, offset EXECUTE_DATA_CC);
	}

isset_dim_obj_exit:


	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	zend_string *name, *tmp_name;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(opline->op1.var EXECUTE_DATA_CC);
	offset = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	if (IS_CV == IS_CONST ||
	    (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT))) {
		if ((IS_CV & (IS_VAR|IS_CV)) && Z_ISREF_P(container)) {
			container = Z_REFVAL_P(container);
			if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & ZEND_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & ZEND_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if (IS_CV == IS_CONST) {
		name = Z_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & ZEND_ISEMPTY) ^
		Z_OBJ_HT_P(container)->has_property(Z_OBJ_P(container), name, (opline->extended_value & ZEND_ISEMPTY), ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_ISEMPTY) : NULL));

	if (IS_CV != IS_CONST) {
		zend_tmp_string_release(tmp_name);
	}

isset_object_finish:


	ZEND_VM_SMART_BRANCH(result, 1);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ARRAY_KEY_EXISTS_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *key, *subject;
	HashTable *ht;
	zend_bool result;

	SAVE_OPLINE();

	key = EX_VAR(opline->op1.var);
	subject = EX_VAR(opline->op2.var);

	if (EXPECTED(Z_TYPE_P(subject) == IS_ARRAY)) {
array_key_exists_array:
		ht = Z_ARRVAL_P(subject);
		result = zend_array_key_exists_fast(ht, key OPLINE_CC EXECUTE_DATA_CC);
	} else {
		if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(Z_ISREF_P(subject))) {
			subject = Z_REFVAL_P(subject);
			if (EXPECTED(Z_TYPE_P(subject) == IS_ARRAY)) {
				goto array_key_exists_array;
			}
		}
		zend_array_key_exists_error(subject, key OPLINE_CC EXECUTE_DATA_CC);
		result = 0;
	}


	ZEND_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|UNUSED|CV, ANY) */
static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_YIELD_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zend_generator *generator = zend_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & ZEND_GENERATOR_FORCED_CLOSE)) {
		ZEND_VM_TAIL_CALL(zend_yield_in_closed_generator_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CV != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & ZEND_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CV & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
						Z_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_CV == IS_VAR) {
						ZEND_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == ZEND_RETURNS_FUNCTION
						 && !Z_ISREF_P(value_ptr)) {
							zend_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (Z_ISREF_P(value_ptr)) {
						Z_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, Z_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_CV == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(Z_OPT_REFCOUNTED(generator->value))) {
					Z_ADDREF(generator->value);
				}
			} else if (IS_CV == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if ((IS_CV & (IS_VAR|IS_CV)) && Z_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, Z_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CV == IS_CV) {
					if (Z_OPT_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {
		zval *key = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
		if ((IS_CV & (IS_CV|IS_VAR)) && UNEXPECTED(Z_TYPE_P(key)) == IS_REFERENCE) {
			key = Z_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_IDENTICAL_NOTHROW_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	/* This is declared below the specializations for MAY_BE_LONG/MAY_BE_DOUBLE so those will be used instead if possible. */
	/* This optimizes $x === SOME_CONST_EXPR and $x === $y for non-refs and non-undef, which can't throw. */
	/* (Infinite recursion when comparing arrays is an uncatchable fatal error) */
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = fast_is_identical_function(op1, op2);
	/* Free is a no-op for const/cv */
	ZEND_VM_SMART_BRANCH(result, 0);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	zend_bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = fast_is_identical_function(op1, op2);
	/* Free is a no-op for const/cv */
	ZEND_VM_SMART_BRANCH(!result, 0);
}

static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	zend_error_noreturn(E_ERROR, "Invalid opcode %d/%d/%d.", OPLINE->opcode, OPLINE->op1_type, OPLINE->op2_type);
	ZEND_VM_NEXT_OPCODE(); /* Never reached */
}


#if (ZEND_VM_KIND == ZEND_VM_KIND_HYBRID)
# undef ZEND_VM_TAIL_CALL
# undef ZEND_VM_CONTINUE
# undef ZEND_VM_RETURN

# define ZEND_VM_TAIL_CALL(call) call; ZEND_VM_CONTINUE()
# define ZEND_VM_CONTINUE()      HYBRID_NEXT()
# define ZEND_VM_RETURN()        goto HYBRID_HALT_LABEL
#endif


#if (ZEND_VM_KIND != ZEND_VM_KIND_CALL) && (ZEND_GCC_VERSION >= 4000) && !defined(__clang__)
# pragma GCC push_options
# pragma GCC optimize("no-gcse")
# pragma GCC optimize("no-ivopts")
#endif
ZEND_API void execute_ex(zend_execute_data *ex)
{
	DCL_OPLINE

#ifdef ZEND_VM_IP_GLOBAL_REG
	const zend_op *orig_opline = opline;
#endif
#ifdef ZEND_VM_FP_GLOBAL_REG
	zend_execute_data *orig_execute_data = execute_data;
	execute_data = ex;
#else
	zend_execute_data *execute_data = ex;
#endif

#if (ZEND_VM_KIND == ZEND_VM_KIND_HYBRID)
	if (UNEXPECTED(execute_data == NULL)) {
		static const void * const labels[] = {
			(void*)&&ZEND_NOP_SPEC_LABEL,
			(void*)&&ZEND_ADD_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_ADD_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_ADD_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ADD_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_ADD_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_ADD_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ADD_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_SUB_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SUB_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_SUB_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SUB_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_SUB_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SUB_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SUB_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_SUB_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SUB_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_MUL_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MUL_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_MUL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_MUL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MUL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_MUL_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_MUL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_MUL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MUL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MUL_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_MUL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_MUL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MUL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_DIV_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_DIV_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_DIV_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_DIV_SPEC_CONST_CV_LABEL,
			(void*)&&ZEND_DIV_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_DIV_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_DIV_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_DIV_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_DIV_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_DIV_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_DIV_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_DIV_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_DIV_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_DIV_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_DIV_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_DIV_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_MOD_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_MOD_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_MOD_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MOD_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_MOD_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_MOD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_MOD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MOD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_MOD_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_MOD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_MOD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MOD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MOD_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_MOD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_MOD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MOD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SL_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_SL_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_SL_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SL_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_SL_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_SL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SL_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_SL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SL_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_SL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SR_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_SR_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_SR_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SR_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_SR_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_SR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SR_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_SR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SR_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_SR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_CONCAT_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_CONCAT_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_CONCAT_SPEC_CONST_CV_LABEL,
			(void*)&&ZEND_CONCAT_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_CONCAT_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_CONCAT_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_CONCAT_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_CONCAT_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_CONCAT_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_CONCAT_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_CONCAT_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_CONCAT_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_CONCAT_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_CONCAT_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_CONCAT_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_BW_OR_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_BW_OR_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_BW_OR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_BW_OR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_BW_OR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_BW_OR_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_BW_OR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_BW_OR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_BW_OR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_BW_OR_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_BW_OR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_BW_OR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_BW_OR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_BW_AND_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_BW_AND_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_BW_AND_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_BW_AND_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_BW_AND_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_BW_AND_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_BW_AND_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_BW_AND_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_BW_AND_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_BW_AND_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_BW_AND_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_BW_AND_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_BW_AND_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_BW_XOR_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_BW_XOR_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_BW_XOR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_BW_XOR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_BW_XOR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_BW_XOR_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_BW_XOR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_BW_XOR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_BW_XOR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_BW_XOR_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_BW_XOR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_BW_XOR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_BW_XOR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_POW_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_POW_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_POW_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_POW_SPEC_CONST_CV_LABEL,
			(void*)&&ZEND_POW_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_POW_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_POW_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_POW_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_POW_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_POW_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_POW_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_POW_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_POW_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_POW_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_POW_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_POW_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_BW_NOT_SPEC_CONST_LABEL,
			(void*)&&ZEND_BW_NOT_SPEC_TMPVARCV_LABEL,
			(void*)&&ZEND_BW_NOT_SPEC_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_BW_NOT_SPEC_TMPVARCV_LABEL,
			(void*)&&ZEND_BOOL_NOT_SPEC_CONST_LABEL,
			(void*)&&ZEND_BOOL_NOT_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_BOOL_NOT_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_BOOL_NOT_SPEC_CV_LABEL,
			(void*)&&ZEND_BOOL_XOR_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_BOOL_XOR_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_BOOL_XOR_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_BOOL_XOR_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_BOOL_XOR_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_BOOL_XOR_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_BOOL_XOR_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_BOOL_XOR_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_BOOL_XOR_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_BOOL_XOR_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_BOOL_XOR_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_IS_IDENTICAL_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_IDENTICAL_SPEC_TMP_CONST_LABEL,
			(void*)&&ZEND_IS_IDENTICAL_SPEC_TMP_TMP_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_IDENTICAL_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_IS_IDENTICAL_SPEC_VAR_TMP_LABEL,
			(void*)&&ZEND_IS_IDENTICAL_SPEC_VAR_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_IDENTICAL_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_IS_IDENTICAL_SPEC_CV_TMP_LABEL,
			(void*)&&ZEND_IS_IDENTICAL_SPEC_CV_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_IDENTICAL_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CONST_LABEL,
			(void*)&&ZEND_IS_NOT_IDENTICAL_SPEC_TMP_TMP_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_IS_NOT_IDENTICAL_SPEC_VAR_TMP_LABEL,
			(void*)&&ZEND_IS_NOT_IDENTICAL_SPEC_VAR_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_NOT_IDENTICAL_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_IS_NOT_IDENTICAL_SPEC_CV_TMP_LABEL,
			(void*)&&ZEND_IS_NOT_IDENTICAL_SPEC_CV_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_NOT_IDENTICAL_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_CV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_CV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_CV_TMPVAR_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_CV_TMPVAR_JMPNZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_CV_TMPVAR_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_CV_TMPVAR_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_CV_CV_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_SPEC_CV_CV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPNZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_CV_CV_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_SPEC_CV_CV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_SPEC_VAR_CONST_RETVAL_UNUSED_LABEL,
			(void*)&&ZEND_ASSIGN_SPEC_VAR_CONST_RETVAL_USED_LABEL,
			(void*)&&ZEND_ASSIGN_SPEC_VAR_TMP_RETVAL_UNUSED_LABEL,
			(void*)&&ZEND_ASSIGN_SPEC_VAR_TMP_RETVAL_USED_LABEL,
			(void*)&&ZEND_ASSIGN_SPEC_VAR_VAR_RETVAL_UNUSED_LABEL,
			(void*)&&ZEND_ASSIGN_SPEC_VAR_VAR_RETVAL_USED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_SPEC_VAR_CV_RETVAL_UNUSED_LABEL,
			(void*)&&ZEND_ASSIGN_SPEC_VAR_CV_RETVAL_USED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_SPEC_CV_CONST_RETVAL_UNUSED_LABEL,
			(void*)&&ZEND_ASSIGN_SPEC_CV_CONST_RETVAL_USED_LABEL,
			(void*)&&ZEND_ASSIGN_SPEC_CV_TMP_RETVAL_UNUSED_LABEL,
			(void*)&&ZEND_ASSIGN_SPEC_CV_TMP_RETVAL_USED_LABEL,
			(void*)&&ZEND_ASSIGN_SPEC_CV_VAR_RETVAL_UNUSED_LABEL,
			(void*)&&ZEND_ASSIGN_SPEC_CV_VAR_RETVAL_USED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_SPEC_CV_CV_RETVAL_UNUSED_LABEL,
			(void*)&&ZEND_ASSIGN_SPEC_CV_CV_RETVAL_USED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_TMP_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CV_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_TMP_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_TMP_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_TMP_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CV_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_TMP_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_TMP_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CV_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_TMP_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_TMP_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_TMP_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CV_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_TMP_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_TMP_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CV_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_TMP_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_TMP_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_TMP_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CV_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_TMP_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CV_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_TMP_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_TMP_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_TMP_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CV_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_TMP_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CV_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_TMP_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_TMP_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_TMP_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CV_LABEL,
			(void*)&&ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_TMP_LABEL,
			(void*)&&ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OP_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_OP_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_ASSIGN_OP_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OP_SPEC_VAR_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OP_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_OP_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_ASSIGN_OP_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OP_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_OP_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_OP_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_OP_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_OP_SPEC_VAR_UNUSED_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_OP_SPEC_VAR_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_OP_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_OP_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_OP_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_OP_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_ASSIGN_DIM_OP_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_OP_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_OP_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_OP_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_OP_SPEC_VAR_CV_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_OP_SPEC_UNUSED_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_OP_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_OP_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_OP_SPEC_UNUSED_CV_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_OP_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_OP_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_OP_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_OP_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_ASSIGN_STATIC_PROP_OP_SPEC_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_REF_SPEC_VAR_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_REF_SPEC_VAR_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_REF_SPEC_CV_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_REF_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_QM_ASSIGN_SPEC_CONST_LABEL,
			(void*)&&ZEND_QM_ASSIGN_SPEC_TMP_LABEL,
			(void*)&&ZEND_QM_ASSIGN_SPEC_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_QM_ASSIGN_SPEC_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_CV_LABEL,
			(void*)&&ZEND_ASSIGN_STATIC_PROP_REF_SPEC_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_PRE_INC_SPEC_VAR_RETVAL_UNUSED_LABEL,
			(void*)&&ZEND_PRE_INC_SPEC_VAR_RETVAL_USED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_PRE_INC_SPEC_CV_RETVAL_UNUSED_LABEL,
			(void*)&&ZEND_PRE_INC_SPEC_CV_RETVAL_USED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_PRE_DEC_SPEC_VAR_RETVAL_UNUSED_LABEL,
			(void*)&&ZEND_PRE_DEC_SPEC_VAR_RETVAL_USED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_PRE_DEC_SPEC_CV_RETVAL_UNUSED_LABEL,
			(void*)&&ZEND_PRE_DEC_SPEC_CV_RETVAL_USED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_POST_INC_SPEC_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_POST_INC_SPEC_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_POST_DEC_SPEC_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_POST_DEC_SPEC_CV_LABEL,
			(void*)&&ZEND_PRE_INC_STATIC_PROP_SPEC_LABEL,
			(void*)&&ZEND_POST_INC_STATIC_PROP_SPEC_LABEL,
			(void*)&&ZEND_JMP_SPEC_LABEL,
			(void*)&&ZEND_JMPZ_SPEC_CONST_LABEL,
			(void*)&&ZEND_JMPZ_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_JMPZ_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_JMPZ_SPEC_CV_LABEL,
			(void*)&&ZEND_JMPNZ_SPEC_CONST_LABEL,
			(void*)&&ZEND_JMPNZ_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_JMPNZ_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_JMPNZ_SPEC_CV_LABEL,
			(void*)&&ZEND_JMPZNZ_SPEC_CONST_LABEL,
			(void*)&&ZEND_JMPZNZ_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_JMPZNZ_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_JMPZNZ_SPEC_CV_LABEL,
			(void*)&&ZEND_JMPZ_EX_SPEC_CONST_LABEL,
			(void*)&&ZEND_JMPZ_EX_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_JMPZ_EX_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_JMPZ_EX_SPEC_CV_LABEL,
			(void*)&&ZEND_JMPNZ_EX_SPEC_CONST_LABEL,
			(void*)&&ZEND_JMPNZ_EX_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_JMPNZ_EX_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_JMPNZ_EX_SPEC_CV_LABEL,
			(void*)&&ZEND_CASE_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_CASE_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_CASE_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_CASE_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_CHECK_VAR_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_SEND_VAR_NO_REF_EX_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_SEND_VAR_NO_REF_EX_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED_LABEL,
			(void*)&&ZEND_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED_QUICK_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_CAST_SPEC_CONST_LABEL,
			(void*)&&ZEND_CAST_SPEC_TMP_LABEL,
			(void*)&&ZEND_CAST_SPEC_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_CAST_SPEC_CV_LABEL,
			(void*)&&ZEND_BOOL_SPEC_CONST_LABEL,
			(void*)&&ZEND_BOOL_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_BOOL_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_BOOL_SPEC_CV_LABEL,
			(void*)&&ZEND_FAST_CONCAT_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_FAST_CONCAT_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_FAST_CONCAT_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FAST_CONCAT_SPEC_CONST_CV_LABEL,
			(void*)&&ZEND_FAST_CONCAT_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FAST_CONCAT_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_FAST_CONCAT_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FAST_CONCAT_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FAST_CONCAT_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_FAST_CONCAT_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_FAST_CONCAT_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FAST_CONCAT_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_ROPE_INIT_SPEC_UNUSED_CONST_LABEL,
			(void*)&&ZEND_ROPE_INIT_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_ROPE_INIT_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ROPE_INIT_SPEC_UNUSED_CV_LABEL,
			(void*)&&ZEND_ROPE_ADD_SPEC_TMP_CONST_LABEL,
			(void*)&&ZEND_ROPE_ADD_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&ZEND_ROPE_ADD_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ROPE_ADD_SPEC_TMP_CV_LABEL,
			(void*)&&ZEND_ROPE_END_SPEC_TMP_CONST_LABEL,
			(void*)&&ZEND_ROPE_END_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&ZEND_ROPE_END_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ROPE_END_SPEC_TMP_CV_LABEL,
			(void*)&&ZEND_BEGIN_SILENCE_SPEC_LABEL,
			(void*)&&ZEND_END_SILENCE_SPEC_TMP_LABEL,
			(void*)&&ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_LABEL,
			(void*)&&ZEND_DO_FCALL_SPEC_RETVAL_UNUSED_LABEL,
			(void*)&&ZEND_DO_FCALL_SPEC_RETVAL_USED_LABEL,
			(void*)&&ZEND_DO_FCALL_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_DO_FCALL_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_INIT_FCALL_SPEC_CONST_LABEL,
			(void*)&&ZEND_RETURN_SPEC_CONST_LABEL,
			(void*)&&ZEND_RETURN_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_RETURN_SPEC_TMP_LABEL,
			(void*)&&ZEND_RETURN_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_RETURN_SPEC_VAR_LABEL,
			(void*)&&ZEND_RETURN_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_RETURN_SPEC_CV_LABEL,
			(void*)&&ZEND_RETURN_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_RECV_SPEC_UNUSED_LABEL,
			(void*)&&ZEND_RECV_INIT_SPEC_CONST_LABEL,
			(void*)&&ZEND_SEND_VAL_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_VAL_SPEC_CONST_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_VAL_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_VAL_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_VAL_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_VAL_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_VAR_EX_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_SEND_VAR_EX_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_VAR_EX_SPEC_VAR_UNUSED_LABEL,
			(void*)&&ZEND_SEND_VAR_EX_SPEC_VAR_UNUSED_QUICK_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_VAR_EX_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_SEND_VAR_EX_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_VAR_EX_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_SEND_VAR_EX_SPEC_CV_UNUSED_QUICK_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_REF_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_REF_SPEC_VAR_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_REF_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_REF_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NEW_SPEC_CONST_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NEW_SPEC_VAR_UNUSED_LABEL,
			(void*)&&ZEND_NEW_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_LABEL,
			(void*)&&ZEND_FREE_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_CONST_UNUSED_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_CONST_CV_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_TMP_CONST_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_TMP_UNUSED_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_TMP_CV_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_VAR_UNUSED_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_VAR_CV_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_UNUSED_CONST_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_UNUSED_CV_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_INIT_ARRAY_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_LABEL,
			(void*)&&ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_LABEL,
			(void*)&&ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_LABEL,
			(void*)&&ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_LABEL,
			(void*)&&ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_LABEL,
			(void*)&&ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_LABEL,
			(void*)&&ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_INCLUDE_OR_EVAL_SPEC_CONST_LABEL,
			(void*)&&ZEND_INCLUDE_OR_EVAL_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_INCLUDE_OR_EVAL_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_INCLUDE_OR_EVAL_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_INCLUDE_OR_EVAL_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_INCLUDE_OR_EVAL_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_INCLUDE_OR_EVAL_SPEC_CV_LABEL,
			(void*)&&ZEND_INCLUDE_OR_EVAL_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_UNSET_VAR_SPEC_CONST_UNUSED_LABEL,
			(void*)&&ZEND_UNSET_VAR_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_UNSET_VAR_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_UNSET_VAR_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_UNSET_DIM_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_UNSET_DIM_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_UNSET_DIM_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_UNSET_DIM_SPEC_VAR_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_UNSET_DIM_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_UNSET_DIM_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_UNSET_DIM_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_UNSET_DIM_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_UNSET_OBJ_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_UNSET_OBJ_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_UNSET_OBJ_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_UNSET_OBJ_SPEC_VAR_CV_LABEL,
			(void*)&&ZEND_UNSET_OBJ_SPEC_UNUSED_CONST_LABEL,
			(void*)&&ZEND_UNSET_OBJ_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_UNSET_OBJ_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_UNSET_OBJ_SPEC_UNUSED_CV_LABEL,
			(void*)&&ZEND_UNSET_OBJ_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_UNSET_OBJ_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_UNSET_OBJ_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_UNSET_OBJ_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_FE_RESET_R_SPEC_CONST_LABEL,
			(void*)&&ZEND_FE_RESET_R_SPEC_TMP_LABEL,
			(void*)&&ZEND_FE_RESET_R_SPEC_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FE_RESET_R_SPEC_CV_LABEL,
			(void*)&&ZEND_FE_FETCH_R_SPEC_VAR_LABEL,
			(void*)&&ZEND_EXIT_SPEC_LABEL,
			(void*)&&ZEND_FETCH_R_SPEC_CONST_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_R_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_R_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_R_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_SPEC_CONST_CV_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_FETCH_OBJ_R_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_R_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_R_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_R_SPEC_CONST_CV_LABEL,
			(void*)&&ZEND_FETCH_OBJ_R_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_R_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_FETCH_OBJ_R_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_R_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_FETCH_OBJ_R_SPEC_UNUSED_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_R_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_R_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_R_SPEC_UNUSED_CV_LABEL,
			(void*)&&ZEND_FETCH_OBJ_R_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_R_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_R_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_R_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_FETCH_W_SPEC_CONST_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_W_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_W_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_W_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_W_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_FETCH_DIM_W_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_W_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_W_SPEC_VAR_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_DIM_W_SPEC_VAR_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_W_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_FETCH_DIM_W_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_W_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_W_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_DIM_W_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_W_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_W_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_W_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_W_SPEC_VAR_CV_LABEL,
			(void*)&&ZEND_FETCH_OBJ_W_SPEC_UNUSED_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_W_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_W_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_W_SPEC_UNUSED_CV_LABEL,
			(void*)&&ZEND_FETCH_OBJ_W_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_W_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_W_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_W_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_FETCH_RW_SPEC_CONST_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_RW_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_RW_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_RW_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_RW_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_FETCH_DIM_RW_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_RW_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_RW_SPEC_VAR_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_DIM_RW_SPEC_VAR_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_RW_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_FETCH_DIM_RW_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_RW_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_RW_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_DIM_RW_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_RW_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_RW_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_RW_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_RW_SPEC_VAR_CV_LABEL,
			(void*)&&ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_RW_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_RW_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CV_LABEL,
			(void*)&&ZEND_FETCH_OBJ_RW_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_RW_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_RW_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_RW_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_FETCH_IS_SPEC_CONST_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_IS_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_IS_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_IS_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_DIM_IS_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_FETCH_DIM_IS_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_IS_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_IS_SPEC_CONST_CV_LABEL,
			(void*)&&ZEND_FETCH_DIM_IS_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_IS_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_FETCH_DIM_IS_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_IS_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_IS_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_FETCH_DIM_IS_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_IS_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_IS_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_FETCH_OBJ_IS_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_IS_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_IS_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_IS_SPEC_CONST_CV_LABEL,
			(void*)&&ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_IS_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_IS_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CV_LABEL,
			(void*)&&ZEND_FETCH_OBJ_IS_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_IS_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_IS_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_IS_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_FETCH_FUNC_ARG_SPEC_CONST_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_FUNC_ARG_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_FUNC_ARG_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_FUNC_ARG_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_CV_LABEL,
			(void*)&&ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_CONST_LABEL,
			(void*)&&ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_CV_LABEL,
			(void*)&&ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CV_LABEL,
			(void*)&&ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CV_LABEL,
			(void*)&&ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV_LABEL,
			(void*)&&ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CV_LABEL,
			(void*)&&ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_FETCH_UNSET_SPEC_CONST_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_UNSET_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_UNSET_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_UNSET_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_UNSET_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_FETCH_DIM_UNSET_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_UNSET_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_UNSET_SPEC_VAR_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_UNSET_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_FETCH_DIM_UNSET_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_DIM_UNSET_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_UNSET_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_UNSET_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_UNSET_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CV_LABEL,
			(void*)&&ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CV_LABEL,
			(void*)&&ZEND_FETCH_OBJ_UNSET_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_FETCH_OBJ_UNSET_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_OBJ_UNSET_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_OBJ_UNSET_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_FETCH_LIST_R_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_FETCH_LIST_R_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_LIST_R_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_LIST_R_SPEC_CONST_CV_LABEL,
			(void*)&&ZEND_FETCH_LIST_R_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_LIST_R_SPEC_TMPVARCV_CV_LABEL,
			(void*)&&ZEND_FETCH_LIST_R_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_LIST_R_SPEC_TMPVARCV_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_LIST_R_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_LIST_R_SPEC_TMPVARCV_CV_LABEL,
			(void*)&&ZEND_FETCH_CONSTANT_SPEC_UNUSED_CONST_LABEL,
			(void*)&&ZEND_CHECK_FUNC_ARG_SPEC_UNUSED_CONST_LABEL,
			(void*)&&ZEND_CHECK_FUNC_ARG_SPEC_UNUSED_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&ZEND_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED_QUICK_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_EXT_STMT_SPEC_LABEL,
			(void*)&&ZEND_EXT_FCALL_BEGIN_SPEC_LABEL,
			(void*)&&ZEND_EXT_FCALL_END_SPEC_LABEL,
			(void*)&&ZEND_EXT_NOP_SPEC_LABEL,
			(void*)&&ZEND_TICKS_SPEC_LABEL,
			(void*)&&ZEND_SEND_VAR_NO_REF_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_VAR_NO_REF_SPEC_VAR_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_CATCH_SPEC_CONST_LABEL,
			(void*)&&ZEND_THROW_SPEC_CONST_LABEL,
			(void*)&&ZEND_THROW_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_THROW_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_THROW_SPEC_CV_LABEL,
			(void*)&&ZEND_FETCH_CLASS_SPEC_UNUSED_CONST_LABEL,
			(void*)&&ZEND_FETCH_CLASS_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_CLASS_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_CLASS_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_CLASS_SPEC_UNUSED_CV_LABEL,
			(void*)&&ZEND_CLONE_SPEC_CONST_LABEL,
			(void*)&&ZEND_CLONE_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_CLONE_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_CLONE_SPEC_UNUSED_LABEL,
			(void*)&&ZEND_CLONE_SPEC_CV_LABEL,
			(void*)&&ZEND_RETURN_BY_REF_SPEC_CONST_LABEL,
			(void*)&&ZEND_RETURN_BY_REF_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_RETURN_BY_REF_SPEC_TMP_LABEL,
			(void*)&&ZEND_RETURN_BY_REF_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_RETURN_BY_REF_SPEC_VAR_LABEL,
			(void*)&&ZEND_RETURN_BY_REF_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_RETURN_BY_REF_SPEC_CV_LABEL,
			(void*)&&ZEND_RETURN_BY_REF_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_INIT_METHOD_CALL_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_INIT_METHOD_CALL_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_METHOD_CALL_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_INIT_METHOD_CALL_SPEC_CONST_CV_LABEL,
			(void*)&&ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CONST_LABEL,
			(void*)&&ZEND_INIT_METHOD_CALL_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_METHOD_CALL_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CV_LABEL,
			(void*)&&ZEND_INIT_METHOD_CALL_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_INIT_METHOD_CALL_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_METHOD_CALL_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_INIT_METHOD_CALL_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_UNUSED_LABEL,
			(void*)&&ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_UNUSED_LABEL,
			(void*)&&ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CV_LABEL,
			(void*)&&ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CONST_LABEL,
			(void*)&&ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_UNUSED_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CV_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_SEND_VAL_EX_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_SEND_VAL_EX_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_VAL_EX_SPEC_CONST_UNUSED_LABEL,
			(void*)&&ZEND_SEND_VAL_EX_SPEC_CONST_UNUSED_QUICK_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_VAL_EX_SPEC_TMP_CONST_LABEL,
			(void*)&&ZEND_SEND_VAL_EX_SPEC_TMP_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_VAL_EX_SPEC_TMP_UNUSED_LABEL,
			(void*)&&ZEND_SEND_VAL_EX_SPEC_TMP_UNUSED_QUICK_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_VAR_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_VAR_SPEC_VAR_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_VAR_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_VAR_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_INIT_USER_CALL_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_INIT_USER_CALL_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_USER_CALL_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_INIT_USER_CALL_SPEC_CONST_CV_LABEL,
			(void*)&&ZEND_SEND_ARRAY_SPEC_LABEL,
			(void*)&&ZEND_SEND_USER_SPEC_CONST_LABEL,
			(void*)&&ZEND_SEND_USER_SPEC_TMP_LABEL,
			(void*)&&ZEND_SEND_USER_SPEC_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_USER_SPEC_CV_LABEL,
			(void*)&&ZEND_STRLEN_SPEC_CONST_LABEL,
			(void*)&&ZEND_STRLEN_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_STRLEN_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_STRLEN_SPEC_CV_LABEL,
			(void*)&&ZEND_DEFINED_SPEC_CONST_LABEL,
			(void*)&&ZEND_TYPE_CHECK_SPEC_CONST_LABEL,
			(void*)&&ZEND_TYPE_CHECK_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_TYPE_CHECK_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_TYPE_CHECK_SPEC_CV_LABEL,
			(void*)&&ZEND_VERIFY_RETURN_TYPE_SPEC_CONST_UNUSED_LABEL,
			(void*)&&ZEND_VERIFY_RETURN_TYPE_SPEC_TMP_UNUSED_LABEL,
			(void*)&&ZEND_VERIFY_RETURN_TYPE_SPEC_VAR_UNUSED_LABEL,
			(void*)&&ZEND_VERIFY_RETURN_TYPE_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&ZEND_VERIFY_RETURN_TYPE_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_FE_RESET_RW_SPEC_CONST_LABEL,
			(void*)&&ZEND_FE_RESET_RW_SPEC_TMP_LABEL,
			(void*)&&ZEND_FE_RESET_RW_SPEC_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FE_RESET_RW_SPEC_CV_LABEL,
			(void*)&&ZEND_FE_FETCH_RW_SPEC_VAR_LABEL,
			(void*)&&ZEND_FE_FREE_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_DYNAMIC_CALL_SPEC_CONST_LABEL,
			(void*)&&ZEND_INIT_DYNAMIC_CALL_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_INIT_DYNAMIC_CALL_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_INIT_DYNAMIC_CALL_SPEC_CV_LABEL,
			(void*)&&ZEND_DO_ICALL_SPEC_RETVAL_UNUSED_LABEL,
			(void*)&&ZEND_DO_ICALL_SPEC_RETVAL_USED_LABEL,
			(void*)&&ZEND_DO_UCALL_SPEC_RETVAL_UNUSED_LABEL,
			(void*)&&ZEND_DO_UCALL_SPEC_RETVAL_USED_LABEL,
			(void*)&&ZEND_DO_UCALL_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_DO_UCALL_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_DO_FCALL_BY_NAME_SPEC_RETVAL_UNUSED_LABEL,
			(void*)&&ZEND_DO_FCALL_BY_NAME_SPEC_RETVAL_USED_LABEL,
			(void*)&&ZEND_DO_FCALL_BY_NAME_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_DO_FCALL_BY_NAME_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_PRE_INC_OBJ_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_PRE_INC_OBJ_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_PRE_INC_OBJ_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_PRE_INC_OBJ_SPEC_VAR_CV_LABEL,
			(void*)&&ZEND_PRE_INC_OBJ_SPEC_UNUSED_CONST_LABEL,
			(void*)&&ZEND_PRE_INC_OBJ_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_PRE_INC_OBJ_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_PRE_INC_OBJ_SPEC_UNUSED_CV_LABEL,
			(void*)&&ZEND_PRE_INC_OBJ_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_PRE_INC_OBJ_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_PRE_INC_OBJ_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_PRE_INC_OBJ_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_POST_INC_OBJ_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_POST_INC_OBJ_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_POST_INC_OBJ_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_POST_INC_OBJ_SPEC_VAR_CV_LABEL,
			(void*)&&ZEND_POST_INC_OBJ_SPEC_UNUSED_CONST_LABEL,
			(void*)&&ZEND_POST_INC_OBJ_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_POST_INC_OBJ_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_POST_INC_OBJ_SPEC_UNUSED_CV_LABEL,
			(void*)&&ZEND_POST_INC_OBJ_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_POST_INC_OBJ_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_POST_INC_OBJ_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_POST_INC_OBJ_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_ECHO_SPEC_CONST_LABEL,
			(void*)&&ZEND_ECHO_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_ECHO_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ECHO_SPEC_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_INSTANCEOF_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_INSTANCEOF_SPEC_TMPVAR_VAR_LABEL,
			(void*)&&ZEND_INSTANCEOF_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_INSTANCEOF_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_INSTANCEOF_SPEC_TMPVAR_VAR_LABEL,
			(void*)&&ZEND_INSTANCEOF_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_INSTANCEOF_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_INSTANCEOF_SPEC_CV_VAR_LABEL,
			(void*)&&ZEND_INSTANCEOF_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_GENERATOR_CREATE_SPEC_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MAKE_REF_SPEC_VAR_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MAKE_REF_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_DECLARE_FUNCTION_SPEC_LABEL,
			(void*)&&ZEND_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_UNUSED_LABEL,
			(void*)&&ZEND_DECLARE_CONST_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_DECLARE_CLASS_SPEC_CONST_LABEL,
			(void*)&&ZEND_DECLARE_CLASS_DELAYED_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_DECLARE_ANON_CLASS_SPEC_LABEL,
			(void*)&&ZEND_ADD_ARRAY_UNPACK_SPEC_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CV_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CONST_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CV_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_HANDLE_EXCEPTION_SPEC_LABEL,
			(void*)&&ZEND_HANDLE_EXCEPTION_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_USER_OPCODE_SPEC_LABEL,
			(void*)&&ZEND_ASSERT_CHECK_SPEC_LABEL,
			(void*)&&ZEND_JMP_SET_SPEC_CONST_LABEL,
			(void*)&&ZEND_JMP_SET_SPEC_TMP_LABEL,
			(void*)&&ZEND_JMP_SET_SPEC_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_JMP_SET_SPEC_CV_LABEL,
			(void*)&&ZEND_UNSET_CV_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_SET_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_EMPTY_LABEL,
			(void*)&&ZEND_FETCH_LIST_W_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_FETCH_LIST_W_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_LIST_W_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_LIST_W_SPEC_VAR_CV_LABEL,
			(void*)&&ZEND_SEPARATE_SPEC_VAR_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_CLASS_NAME_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_CLASS_NAME_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_FETCH_CLASS_NAME_SPEC_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_CLASS_NAME_SPEC_CV_LABEL,
			(void*)&&ZEND_CALL_TRAMPOLINE_SPEC_LABEL,
			(void*)&&ZEND_CALL_TRAMPOLINE_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_DISCARD_EXCEPTION_SPEC_LABEL,
			(void*)&&ZEND_YIELD_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_YIELD_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_YIELD_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_YIELD_SPEC_CONST_UNUSED_LABEL,
			(void*)&&ZEND_YIELD_SPEC_CONST_CV_LABEL,
			(void*)&&ZEND_YIELD_SPEC_TMP_CONST_LABEL,
			(void*)&&ZEND_YIELD_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&ZEND_YIELD_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&ZEND_YIELD_SPEC_TMP_UNUSED_LABEL,
			(void*)&&ZEND_YIELD_SPEC_TMP_CV_LABEL,
			(void*)&&ZEND_YIELD_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_YIELD_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_YIELD_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&ZEND_YIELD_SPEC_VAR_UNUSED_LABEL,
			(void*)&&ZEND_YIELD_SPEC_VAR_CV_LABEL,
			(void*)&&ZEND_YIELD_SPEC_UNUSED_CONST_LABEL,
			(void*)&&ZEND_YIELD_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_YIELD_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&ZEND_YIELD_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&ZEND_YIELD_SPEC_UNUSED_CV_LABEL,
			(void*)&&ZEND_YIELD_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_YIELD_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_YIELD_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_YIELD_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_YIELD_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_GENERATOR_RETURN_SPEC_CONST_LABEL,
			(void*)&&ZEND_GENERATOR_RETURN_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_GENERATOR_RETURN_SPEC_TMP_LABEL,
			(void*)&&ZEND_GENERATOR_RETURN_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_GENERATOR_RETURN_SPEC_VAR_LABEL,
			(void*)&&ZEND_GENERATOR_RETURN_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_GENERATOR_RETURN_SPEC_CV_LABEL,
			(void*)&&ZEND_GENERATOR_RETURN_SPEC_OBSERVER_LABEL,
			(void*)&&ZEND_FAST_CALL_SPEC_LABEL,
			(void*)&&ZEND_FAST_RET_SPEC_LABEL,
			(void*)&&ZEND_RECV_VARIADIC_SPEC_UNUSED_LABEL,
			(void*)&&ZEND_SEND_UNPACK_SPEC_LABEL,
			(void*)&&ZEND_YIELD_FROM_SPEC_CONST_LABEL,
			(void*)&&ZEND_YIELD_FROM_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_YIELD_FROM_SPEC_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_YIELD_FROM_SPEC_CV_LABEL,
			(void*)&&ZEND_COPY_TMP_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_BIND_GLOBAL_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_COALESCE_SPEC_CONST_LABEL,
			(void*)&&ZEND_COALESCE_SPEC_TMP_LABEL,
			(void*)&&ZEND_COALESCE_SPEC_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_COALESCE_SPEC_CV_LABEL,
			(void*)&&ZEND_SPACESHIP_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_SPACESHIP_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_SPACESHIP_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SPACESHIP_SPEC_CONST_CV_LABEL,
			(void*)&&ZEND_SPACESHIP_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_SPACESHIP_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_SPACESHIP_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SPACESHIP_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_SPACESHIP_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_SPACESHIP_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_SPACESHIP_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SPACESHIP_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SPACESHIP_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_SPACESHIP_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_SPACESHIP_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SPACESHIP_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_FUNC_NUM_ARGS_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&ZEND_FUNC_GET_ARGS_SPEC_CONST_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FUNC_GET_ARGS_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_STATIC_PROP_R_SPEC_LABEL,
			(void*)&&ZEND_FETCH_STATIC_PROP_W_SPEC_LABEL,
			(void*)&&ZEND_FETCH_STATIC_PROP_RW_SPEC_LABEL,
			(void*)&&ZEND_FETCH_STATIC_PROP_IS_SPEC_LABEL,
			(void*)&&ZEND_FETCH_STATIC_PROP_FUNC_ARG_SPEC_LABEL,
			(void*)&&ZEND_FETCH_STATIC_PROP_UNSET_SPEC_LABEL,
			(void*)&&ZEND_UNSET_STATIC_PROP_SPEC_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_STATIC_PROP_SPEC_LABEL,
			(void*)&&ZEND_FETCH_CLASS_CONSTANT_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_CLASS_CONSTANT_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_FETCH_CLASS_CONSTANT_SPEC_UNUSED_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_BIND_LEXICAL_SPEC_TMP_CV_LABEL,
			(void*)&&ZEND_BIND_STATIC_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_FETCH_THIS_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&ZEND_SEND_FUNC_ARG_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_FUNC_ARG_SPEC_VAR_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ISSET_ISEMPTY_THIS_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&ZEND_SWITCH_LONG_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_SWITCH_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_SWITCH_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SWITCH_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_SWITCH_STRING_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_SWITCH_STRING_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_SWITCH_STRING_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SWITCH_STRING_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IN_ARRAY_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_IN_ARRAY_SPEC_TMP_CONST_LABEL,
			(void*)&&ZEND_IN_ARRAY_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IN_ARRAY_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_COUNT_SPEC_CONST_UNUSED_LABEL,
			(void*)&&ZEND_COUNT_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_COUNT_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_COUNT_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_GET_CLASS_SPEC_CONST_UNUSED_LABEL,
			(void*)&&ZEND_GET_CLASS_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_GET_CLASS_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&ZEND_GET_CLASS_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&ZEND_GET_CLASS_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_GET_CALLED_CLASS_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&ZEND_GET_TYPE_SPEC_CONST_UNUSED_LABEL,
			(void*)&&ZEND_GET_TYPE_SPEC_TMP_UNUSED_LABEL,
			(void*)&&ZEND_GET_TYPE_SPEC_VAR_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_GET_TYPE_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_ARRAY_KEY_EXISTS_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_ARRAY_KEY_EXISTS_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_ARRAY_KEY_EXISTS_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ARRAY_KEY_EXISTS_SPEC_CONST_CV_LABEL,
			(void*)&&ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ARRAY_KEY_EXISTS_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_ARRAY_KEY_EXISTS_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_ARRAY_KEY_EXISTS_SPEC_CV_TMPVAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ARRAY_KEY_EXISTS_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_MATCH_SPEC_CONST_CONST_LABEL,
			(void*)&&ZEND_MATCH_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_MATCH_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MATCH_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_CASE_STRICT_SPEC_TMP_CONST_LABEL,
			(void*)&&ZEND_CASE_STRICT_SPEC_TMP_TMP_LABEL,
			(void*)&&ZEND_CASE_STRICT_SPEC_TMP_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_CASE_STRICT_SPEC_TMP_CV_LABEL,
			(void*)&&ZEND_CASE_STRICT_SPEC_VAR_CONST_LABEL,
			(void*)&&ZEND_CASE_STRICT_SPEC_VAR_TMP_LABEL,
			(void*)&&ZEND_CASE_STRICT_SPEC_VAR_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_CASE_STRICT_SPEC_VAR_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MATCH_ERROR_SPEC_CONST_UNUSED_LABEL,
			(void*)&&ZEND_MATCH_ERROR_SPEC_TMPVARCV_UNUSED_LABEL,
			(void*)&&ZEND_MATCH_ERROR_SPEC_TMPVARCV_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MATCH_ERROR_SPEC_TMPVARCV_UNUSED_LABEL,
			(void*)&&ZEND_JMP_NULL_SPEC_CONST_LABEL,
			(void*)&&ZEND_JMP_NULL_SPEC_TMPVARCV_LABEL,
			(void*)&&ZEND_JMP_NULL_SPEC_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_JMP_NULL_SPEC_TMPVARCV_LABEL,
			(void*)&&ZEND_CHECK_UNDEF_ARGS_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&ZEND_RECV_NOTYPE_SPEC_LABEL,
			(void*)&&ZEND_JMP_FORWARD_SPEC_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ADD_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_ADD_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ADD_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ADD_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_ADD_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ADD_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SUB_LONG_NO_OVERFLOW_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_LONG_NO_OVERFLOW_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SUB_LONG_NO_OVERFLOW_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SUB_LONG_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_LONG_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SUB_LONG_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SUB_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SUB_DOUBLE_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_DOUBLE_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SUB_DOUBLE_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SUB_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MUL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_MUL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MUL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MUL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_MUL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MUL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_IDENTICAL_NOTHROW_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_IDENTICAL_NOTHROW_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_LABEL,
			(void*)&&ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_LABEL,
			(void*)&&ZEND_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED_LABEL,
			(void*)&&ZEND_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED_LABEL,
			(void*)&&ZEND_PRE_INC_LONG_SPEC_CV_RETVAL_UNUSED_LABEL,
			(void*)&&ZEND_PRE_INC_LONG_SPEC_CV_RETVAL_USED_LABEL,
			(void*)&&ZEND_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED_LABEL,
			(void*)&&ZEND_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED_LABEL,
			(void*)&&ZEND_PRE_DEC_LONG_SPEC_CV_RETVAL_UNUSED_LABEL,
			(void*)&&ZEND_PRE_DEC_LONG_SPEC_CV_RETVAL_USED_LABEL,
			(void*)&&ZEND_POST_INC_LONG_NO_OVERFLOW_SPEC_CV_LABEL,
			(void*)&&ZEND_POST_INC_LONG_SPEC_CV_LABEL,
			(void*)&&ZEND_POST_DEC_LONG_NO_OVERFLOW_SPEC_CV_LABEL,
			(void*)&&ZEND_POST_DEC_LONG_SPEC_CV_LABEL,
			(void*)&&ZEND_QM_ASSIGN_LONG_SPEC_CONST_LABEL,
			(void*)&&ZEND_QM_ASSIGN_LONG_SPEC_TMPVARCV_LABEL,
			(void*)&&ZEND_QM_ASSIGN_LONG_SPEC_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_QM_ASSIGN_LONG_SPEC_TMPVARCV_LABEL,
			(void*)&&ZEND_QM_ASSIGN_DOUBLE_SPEC_CONST_LABEL,
			(void*)&&ZEND_QM_ASSIGN_DOUBLE_SPEC_TMPVARCV_LABEL,
			(void*)&&ZEND_QM_ASSIGN_DOUBLE_SPEC_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_QM_ASSIGN_DOUBLE_SPEC_TMPVARCV_LABEL,
			(void*)&&ZEND_QM_ASSIGN_NOREF_SPEC_CONST_LABEL,
			(void*)&&ZEND_QM_ASSIGN_NOREF_SPEC_TMPVARCV_LABEL,
			(void*)&&ZEND_QM_ASSIGN_NOREF_SPEC_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_QM_ASSIGN_NOREF_SPEC_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_INDEX_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_INDEX_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_INDEX_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_INDEX_SPEC_CV_CONST_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_INDEX_SPEC_CV_TMPVARCV_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_INDEX_SPEC_CV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_FETCH_DIM_R_INDEX_SPEC_CV_TMPVARCV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_VAR_SIMPLE_SPEC_VAR_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_VAR_SIMPLE_SPEC_CV_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_VAR_EX_SIMPLE_SPEC_VAR_UNUSED_LABEL,
			(void*)&&ZEND_NULL_LABEL,
			(void*)&&ZEND_SEND_VAR_EX_SIMPLE_SPEC_CV_UNUSED_LABEL,
			(void*)&&ZEND_SEND_VAL_SIMPLE_SPEC_CONST_LABEL,
			(void*)&&ZEND_SEND_VAL_EX_SIMPLE_SPEC_CONST_LABEL,
			(void*)&&ZEND_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_UNUSED_LABEL,
			(void*)&&ZEND_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_USED_LABEL,
			(void*)&&ZEND_NULL_LABEL
		};
		zend_opcode_handlers = (const void **) labels;
		zend_handlers_count = sizeof(labels) / sizeof(void*);
		memset(&hybrid_halt_op, 0, sizeof(hybrid_halt_op));
		hybrid_halt_op.handler = (void*)&&HYBRID_HALT_LABEL;
		goto HYBRID_HALT_LABEL;
	}
#endif

	LOAD_OPLINE();
	ZEND_VM_LOOP_INTERRUPT_CHECK();

	while (1) {
#if !defined(ZEND_VM_FP_GLOBAL_REG) || !defined(ZEND_VM_IP_GLOBAL_REG)
			int ret;
#endif
#if (ZEND_VM_KIND == ZEND_VM_KIND_HYBRID)
		HYBRID_SWITCH() {
#else
#if defined(ZEND_VM_FP_GLOBAL_REG) && defined(ZEND_VM_IP_GLOBAL_REG)
		((opcode_handler_t)OPLINE->handler)(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
		if (UNEXPECTED(!OPLINE)) {
#else
		if (UNEXPECTED((ret = ((opcode_handler_t)OPLINE->handler)(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU)) != 0)) {
#endif
#endif
#if (ZEND_VM_KIND == ZEND_VM_KIND_HYBRID)
			HYBRID_CASE(ZEND_ASSIGN_STATIC_PROP_OP_SPEC):
				VM_TRACE(ZEND_ASSIGN_STATIC_PROP_OP_SPEC)
				ZEND_ASSIGN_STATIC_PROP_OP_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_INC_STATIC_PROP_SPEC):
				VM_TRACE(ZEND_PRE_INC_STATIC_PROP_SPEC)
				ZEND_PRE_INC_STATIC_PROP_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POST_INC_STATIC_PROP_SPEC):
				VM_TRACE(ZEND_POST_INC_STATIC_PROP_SPEC)
				ZEND_POST_INC_STATIC_PROP_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_STATIC_PROP_R_SPEC):
				VM_TRACE(ZEND_FETCH_STATIC_PROP_R_SPEC)
				ZEND_FETCH_STATIC_PROP_R_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_STATIC_PROP_W_SPEC):
				VM_TRACE(ZEND_FETCH_STATIC_PROP_W_SPEC)
				ZEND_FETCH_STATIC_PROP_W_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_STATIC_PROP_RW_SPEC):
				VM_TRACE(ZEND_FETCH_STATIC_PROP_RW_SPEC)
				ZEND_FETCH_STATIC_PROP_RW_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_STATIC_PROP_FUNC_ARG_SPEC):
				VM_TRACE(ZEND_FETCH_STATIC_PROP_FUNC_ARG_SPEC)
				ZEND_FETCH_STATIC_PROP_FUNC_ARG_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_STATIC_PROP_UNSET_SPEC):
				VM_TRACE(ZEND_FETCH_STATIC_PROP_UNSET_SPEC)
				ZEND_FETCH_STATIC_PROP_UNSET_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_STATIC_PROP_IS_SPEC):
				VM_TRACE(ZEND_FETCH_STATIC_PROP_IS_SPEC)
				ZEND_FETCH_STATIC_PROP_IS_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CONST):
				VM_TRACE(ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CONST)
				ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_TMP):
				VM_TRACE(ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_TMP)
				ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_VAR)
				ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CV)
				ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_STATIC_PROP_REF_SPEC):
				VM_TRACE(ZEND_ASSIGN_STATIC_PROP_REF_SPEC)
				ZEND_ASSIGN_STATIC_PROP_REF_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
zend_leave_helper_SPEC_LABEL:
{
	zend_execute_data *old_execute_data;
	uint32_t call_info = EX_CALL_INFO();
	SAVE_OPLINE();

	if (EXPECTED((call_info & (ZEND_CALL_CODE|ZEND_CALL_TOP|ZEND_CALL_HAS_SYMBOL_TABLE|ZEND_CALL_FREE_EXTRA_ARGS|ZEND_CALL_ALLOCATED|ZEND_CALL_HAS_EXTRA_NAMED_PARAMS)) == 0)) {
		EG(current_execute_data) = EX(prev_execute_data);
		i_free_compiled_variables(execute_data);

#ifdef ZEND_PREFER_RELOAD
		call_info = EX_CALL_INFO();
#endif
		if (UNEXPECTED(call_info & ZEND_CALL_RELEASE_THIS)) {
			OBJ_RELEASE(Z_OBJ(execute_data->This));
		} else if (UNEXPECTED(call_info & ZEND_CALL_CLOSURE)) {
			OBJ_RELEASE(ZEND_CLOSURE_OBJECT(EX(func)));
		}
		EG(vm_stack_top) = (zval*)execute_data;
		execute_data = EX(prev_execute_data);

		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_rethrow_exception(execute_data);
			HANDLE_EXCEPTION_LEAVE();
		}

		LOAD_NEXT_OPLINE();
		ZEND_VM_LEAVE();
	} else if (EXPECTED((call_info & (ZEND_CALL_CODE|ZEND_CALL_TOP)) == 0)) {
		EG(current_execute_data) = EX(prev_execute_data);
		i_free_compiled_variables(execute_data);

#ifdef ZEND_PREFER_RELOAD
		call_info = EX_CALL_INFO();
#endif
		if (UNEXPECTED(call_info & ZEND_CALL_HAS_SYMBOL_TABLE)) {
			zend_clean_and_cache_symbol_table(EX(symbol_table));
		}

		if (UNEXPECTED(call_info & ZEND_CALL_HAS_EXTRA_NAMED_PARAMS)) {
			zend_free_extra_named_params(EX(extra_named_params));
		}

		/* Free extra args before releasing the closure,
		 * as that may free the op_array. */
		zend_vm_stack_free_extra_args_ex(call_info, execute_data);

		if (UNEXPECTED(call_info & ZEND_CALL_RELEASE_THIS)) {
			OBJ_RELEASE(Z_OBJ(execute_data->This));
		} else if (UNEXPECTED(call_info & ZEND_CALL_CLOSURE)) {
			OBJ_RELEASE(ZEND_CLOSURE_OBJECT(EX(func)));
		}

		old_execute_data = execute_data;
		execute_data = EX(prev_execute_data);
		zend_vm_stack_free_call_frame_ex(call_info, old_execute_data);

		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_rethrow_exception(execute_data);
			HANDLE_EXCEPTION_LEAVE();
		}

		LOAD_NEXT_OPLINE();
		ZEND_VM_LEAVE();
	} else if (EXPECTED((call_info & ZEND_CALL_TOP) == 0)) {
		zend_detach_symbol_table(execute_data);
		destroy_op_array(&EX(func)->op_array);
		efree_size(EX(func), sizeof(zend_op_array));
#ifdef ZEND_PREFER_RELOAD
		call_info = EX_CALL_INFO();
#endif
		old_execute_data = execute_data;
		execute_data = EG(current_execute_data) = EX(prev_execute_data);
		zend_vm_stack_free_call_frame_ex(call_info, old_execute_data);

		zend_attach_symbol_table(execute_data);
		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_rethrow_exception(execute_data);
			HANDLE_EXCEPTION_LEAVE();
		}

		LOAD_NEXT_OPLINE();
		ZEND_VM_LEAVE();
	} else {
		if (EXPECTED((call_info & ZEND_CALL_CODE) == 0)) {
			EG(current_execute_data) = EX(prev_execute_data);
			i_free_compiled_variables(execute_data);
#ifdef ZEND_PREFER_RELOAD
			call_info = EX_CALL_INFO();
#endif
			if (UNEXPECTED(call_info & (ZEND_CALL_HAS_SYMBOL_TABLE|ZEND_CALL_FREE_EXTRA_ARGS|ZEND_CALL_HAS_EXTRA_NAMED_PARAMS))) {
				if (UNEXPECTED(call_info & ZEND_CALL_HAS_SYMBOL_TABLE)) {
					zend_clean_and_cache_symbol_table(EX(symbol_table));
				}
				zend_vm_stack_free_extra_args_ex(call_info, execute_data);
				if (UNEXPECTED(call_info & ZEND_CALL_HAS_EXTRA_NAMED_PARAMS)) {
					zend_free_extra_named_params(EX(extra_named_params));
				}
			}
			if (UNEXPECTED(call_info & ZEND_CALL_CLOSURE)) {
				OBJ_RELEASE(ZEND_CLOSURE_OBJECT(EX(func)));
			}
			ZEND_VM_RETURN();
		} else /* if (call_kind == ZEND_CALL_TOP_CODE) */ {
			zend_array *symbol_table = EX(symbol_table);

			zend_detach_symbol_table(execute_data);
			old_execute_data = EX(prev_execute_data);
			while (old_execute_data) {
				if (old_execute_data->func && (ZEND_CALL_INFO(old_execute_data) & ZEND_CALL_HAS_SYMBOL_TABLE)) {
					if (old_execute_data->symbol_table == symbol_table) {
						zend_attach_symbol_table(old_execute_data);
					}
					break;
				}
				old_execute_data = old_execute_data->prev_execute_data;
			}
			EG(current_execute_data) = EX(prev_execute_data);
			ZEND_VM_RETURN();
		}
	}
}

			HYBRID_CASE(ZEND_JMP_SPEC):
				VM_TRACE(ZEND_JMP_SPEC)
				ZEND_JMP_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DO_ICALL_SPEC_RETVAL_UNUSED):
				VM_TRACE(ZEND_DO_ICALL_SPEC_RETVAL_UNUSED)
				ZEND_DO_ICALL_SPEC_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DO_ICALL_SPEC_RETVAL_USED):
				VM_TRACE(ZEND_DO_ICALL_SPEC_RETVAL_USED)
				ZEND_DO_ICALL_SPEC_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DO_UCALL_SPEC_RETVAL_UNUSED):
				VM_TRACE(ZEND_DO_UCALL_SPEC_RETVAL_UNUSED)
				ZEND_DO_UCALL_SPEC_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DO_UCALL_SPEC_RETVAL_USED):
				VM_TRACE(ZEND_DO_UCALL_SPEC_RETVAL_USED)
				ZEND_DO_UCALL_SPEC_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DO_UCALL_SPEC_OBSERVER):
				VM_TRACE(ZEND_DO_UCALL_SPEC_OBSERVER)
				ZEND_DO_UCALL_SPEC_OBSERVER_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DO_FCALL_BY_NAME_SPEC_RETVAL_UNUSED):
				VM_TRACE(ZEND_DO_FCALL_BY_NAME_SPEC_RETVAL_UNUSED)
				ZEND_DO_FCALL_BY_NAME_SPEC_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DO_FCALL_BY_NAME_SPEC_RETVAL_USED):
				VM_TRACE(ZEND_DO_FCALL_BY_NAME_SPEC_RETVAL_USED)
				ZEND_DO_FCALL_BY_NAME_SPEC_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DO_FCALL_BY_NAME_SPEC_OBSERVER):
				VM_TRACE(ZEND_DO_FCALL_BY_NAME_SPEC_OBSERVER)
				ZEND_DO_FCALL_BY_NAME_SPEC_OBSERVER_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DO_FCALL_SPEC_RETVAL_UNUSED):
				VM_TRACE(ZEND_DO_FCALL_SPEC_RETVAL_UNUSED)
				ZEND_DO_FCALL_SPEC_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DO_FCALL_SPEC_RETVAL_USED):
				VM_TRACE(ZEND_DO_FCALL_SPEC_RETVAL_USED)
				ZEND_DO_FCALL_SPEC_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DO_FCALL_SPEC_OBSERVER):
				VM_TRACE(ZEND_DO_FCALL_SPEC_OBSERVER)
				ZEND_DO_FCALL_SPEC_OBSERVER_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_GENERATOR_CREATE_SPEC):
				VM_TRACE(ZEND_GENERATOR_CREATE_SPEC)
				ZEND_GENERATOR_CREATE_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_UNPACK_SPEC):
				VM_TRACE(ZEND_SEND_UNPACK_SPEC)
				ZEND_SEND_UNPACK_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_ARRAY_SPEC):
				VM_TRACE(ZEND_SEND_ARRAY_SPEC)
				ZEND_SEND_ARRAY_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_RECV_NOTYPE_SPEC):
				VM_TRACE(ZEND_RECV_NOTYPE_SPEC)
				ZEND_RECV_NOTYPE_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_ARRAY_UNPACK_SPEC):
				VM_TRACE(ZEND_ADD_ARRAY_UNPACK_SPEC)
				ZEND_ADD_ARRAY_UNPACK_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_UNSET_STATIC_PROP_SPEC):
				VM_TRACE(ZEND_UNSET_STATIC_PROP_SPEC)
				ZEND_UNSET_STATIC_PROP_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_STATIC_PROP_SPEC):
				VM_TRACE(ZEND_ISSET_ISEMPTY_STATIC_PROP_SPEC)
				ZEND_ISSET_ISEMPTY_STATIC_PROP_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_EXIT_SPEC):
				VM_TRACE(ZEND_EXIT_SPEC)
				ZEND_EXIT_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BEGIN_SILENCE_SPEC):
				VM_TRACE(ZEND_BEGIN_SILENCE_SPEC)
				ZEND_BEGIN_SILENCE_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_EXT_STMT_SPEC):
				VM_TRACE(ZEND_EXT_STMT_SPEC)
				ZEND_EXT_STMT_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_EXT_FCALL_BEGIN_SPEC):
				VM_TRACE(ZEND_EXT_FCALL_BEGIN_SPEC)
				ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_EXT_FCALL_END_SPEC):
				VM_TRACE(ZEND_EXT_FCALL_END_SPEC)
				ZEND_EXT_FCALL_END_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DECLARE_ANON_CLASS_SPEC):
				VM_TRACE(ZEND_DECLARE_ANON_CLASS_SPEC)
				ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DECLARE_FUNCTION_SPEC):
				VM_TRACE(ZEND_DECLARE_FUNCTION_SPEC)
				ZEND_DECLARE_FUNCTION_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_TICKS_SPEC):
				VM_TRACE(ZEND_TICKS_SPEC)
				ZEND_TICKS_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_EXT_NOP_SPEC):
				VM_TRACE(ZEND_EXT_NOP_SPEC)
				ZEND_EXT_NOP_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_NOP_SPEC):
				VM_TRACE(ZEND_NOP_SPEC)
				ZEND_NOP_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_HANDLE_EXCEPTION_SPEC):
				VM_TRACE(ZEND_HANDLE_EXCEPTION_SPEC)
				ZEND_HANDLE_EXCEPTION_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_HANDLE_EXCEPTION_SPEC_OBSERVER):
				VM_TRACE(ZEND_HANDLE_EXCEPTION_SPEC_OBSERVER)
				ZEND_HANDLE_EXCEPTION_SPEC_OBSERVER_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_USER_OPCODE_SPEC):
				VM_TRACE(ZEND_USER_OPCODE_SPEC)
				ZEND_USER_OPCODE_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DISCARD_EXCEPTION_SPEC):
				VM_TRACE(ZEND_DISCARD_EXCEPTION_SPEC)
				ZEND_DISCARD_EXCEPTION_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FAST_CALL_SPEC):
				VM_TRACE(ZEND_FAST_CALL_SPEC)
				ZEND_FAST_CALL_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FAST_RET_SPEC):
				VM_TRACE(ZEND_FAST_RET_SPEC)
				ZEND_FAST_RET_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSERT_CHECK_SPEC):
				VM_TRACE(ZEND_ASSERT_CHECK_SPEC)
				ZEND_ASSERT_CHECK_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CALL_TRAMPOLINE_SPEC):
				VM_TRACE(ZEND_CALL_TRAMPOLINE_SPEC)
				ZEND_CALL_TRAMPOLINE_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CALL_TRAMPOLINE_SPEC_OBSERVER):
				VM_TRACE(ZEND_CALL_TRAMPOLINE_SPEC_OBSERVER)
				ZEND_CALL_TRAMPOLINE_SPEC_OBSERVER_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_JMP_FORWARD_SPEC):
				VM_TRACE(ZEND_JMP_FORWARD_SPEC)
				ZEND_JMP_FORWARD_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_FCALL_BY_NAME_SPEC_CONST):
				VM_TRACE(ZEND_INIT_FCALL_BY_NAME_SPEC_CONST)
				ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_DYNAMIC_CALL_SPEC_CONST):
				VM_TRACE(ZEND_INIT_DYNAMIC_CALL_SPEC_CONST)
				ZEND_INIT_DYNAMIC_CALL_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST):
				VM_TRACE(ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST)
				ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_FCALL_SPEC_CONST):
				VM_TRACE(ZEND_INIT_FCALL_SPEC_CONST)
				ZEND_INIT_FCALL_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_RECV_INIT_SPEC_CONST):
				VM_TRACE(ZEND_RECV_INIT_SPEC_CONST)
				ZEND_RECV_INIT_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_DYNAMIC_CALL_SPEC_TMPVAR):
				VM_TRACE(ZEND_INIT_DYNAMIC_CALL_SPEC_TMPVAR)
				ZEND_INIT_DYNAMIC_CALL_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_RECV_SPEC_UNUSED):
				VM_TRACE(ZEND_RECV_SPEC_UNUSED)
				ZEND_RECV_SPEC_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_RECV_VARIADIC_SPEC_UNUSED):
				VM_TRACE(ZEND_RECV_VARIADIC_SPEC_UNUSED)
				ZEND_RECV_VARIADIC_SPEC_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_DYNAMIC_CALL_SPEC_CV):
				VM_TRACE(ZEND_INIT_DYNAMIC_CALL_SPEC_CV)
				ZEND_INIT_DYNAMIC_CALL_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BW_NOT_SPEC_CONST):
				VM_TRACE(ZEND_BW_NOT_SPEC_CONST)
				ZEND_BW_NOT_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BOOL_NOT_SPEC_CONST):
				VM_TRACE(ZEND_BOOL_NOT_SPEC_CONST)
				ZEND_BOOL_NOT_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ECHO_SPEC_CONST):
				VM_TRACE(ZEND_ECHO_SPEC_CONST)
				ZEND_ECHO_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_JMPZ_SPEC_CONST):
				VM_TRACE(ZEND_JMPZ_SPEC_CONST)
				ZEND_JMPZ_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_JMPNZ_SPEC_CONST):
				VM_TRACE(ZEND_JMPNZ_SPEC_CONST)
				ZEND_JMPNZ_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_JMPZNZ_SPEC_CONST):
				VM_TRACE(ZEND_JMPZNZ_SPEC_CONST)
				ZEND_JMPZNZ_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_JMPZ_EX_SPEC_CONST):
				VM_TRACE(ZEND_JMPZ_EX_SPEC_CONST)
				ZEND_JMPZ_EX_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_JMPNZ_EX_SPEC_CONST):
				VM_TRACE(ZEND_JMPNZ_EX_SPEC_CONST)
				ZEND_JMPNZ_EX_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_RETURN_SPEC_CONST):
				VM_TRACE(ZEND_RETURN_SPEC_CONST)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;

	retval_ptr = RT_CONSTANT(opline, opline->op1);
	return_value = EX(return_value);
	if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(retval_ptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		retval_ptr = ZVAL_UNDEFINED_OP1();
		if (return_value) {
			ZVAL_NULL(return_value);
		}
	} else if (!return_value) {
		if (IS_CONST & (IS_VAR|IS_TMP_VAR)) {
			if (Z_REFCOUNTED_P(retval_ptr) && !Z_DELREF_P(retval_ptr)) {
				SAVE_OPLINE();
				rc_dtor_func(Z_COUNTED_P(retval_ptr));
			}
		}
	} else {
		if ((IS_CONST & (IS_CONST|IS_TMP_VAR))) {
			ZVAL_COPY_VALUE(return_value, retval_ptr);
			if (IS_CONST == IS_CONST) {
				if (UNEXPECTED(Z_OPT_REFCOUNTED_P(return_value))) {
					Z_ADDREF_P(return_value);
				}
			}
		} else if (IS_CONST == IS_CV) {
			do {
				if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
					if (EXPECTED(!Z_OPT_ISREF_P(retval_ptr))) {
						if (EXPECTED(!(EX_CALL_INFO() & ZEND_CALL_CODE))) {
							zend_refcounted *ref = Z_COUNTED_P(retval_ptr);
							ZVAL_COPY_VALUE(return_value, retval_ptr);
							if (GC_MAY_LEAK(ref)) {
								gc_possible_root(ref);
							}
							ZVAL_NULL(retval_ptr);
							break;
						} else {
							Z_ADDREF_P(retval_ptr);
						}
					} else {
						retval_ptr = Z_REFVAL_P(retval_ptr);
						if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
							Z_ADDREF_P(retval_ptr);
						}
					}
				}
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			} while (0);
		} else /* if (IS_CONST == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(retval_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(retval_ptr);

				retval_ptr = Z_REFVAL_P(retval_ptr);
				ZVAL_COPY_VALUE(return_value, retval_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
					Z_ADDREF_P(retval_ptr);
				}
			} else {
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			}
		}
	}

	goto zend_leave_helper_SPEC_LABEL;
}

			HYBRID_CASE(ZEND_RETURN_SPEC_OBSERVER):
				VM_TRACE(ZEND_RETURN_SPEC_OBSERVER)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;

	retval_ptr = get_zval_ptr_undef(opline->op1_type, opline->op1, BP_VAR_R);
	return_value = EX(return_value);
	if (opline->op1_type == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(retval_ptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		retval_ptr = ZVAL_UNDEFINED_OP1();
		if (return_value) {
			ZVAL_NULL(return_value);
		}
	} else if (!return_value) {
		if (opline->op1_type & (IS_VAR|IS_TMP_VAR)) {
			if (Z_REFCOUNTED_P(retval_ptr) && !Z_DELREF_P(retval_ptr)) {
				SAVE_OPLINE();
				rc_dtor_func(Z_COUNTED_P(retval_ptr));
			}
		}
	} else {
		if ((opline->op1_type & (IS_CONST|IS_TMP_VAR))) {
			ZVAL_COPY_VALUE(return_value, retval_ptr);
			if (opline->op1_type == IS_CONST) {
				if (UNEXPECTED(Z_OPT_REFCOUNTED_P(return_value))) {
					Z_ADDREF_P(return_value);
				}
			}
		} else if (opline->op1_type == IS_CV) {
			do {
				if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
					if (EXPECTED(!Z_OPT_ISREF_P(retval_ptr))) {
						if (EXPECTED(!(EX_CALL_INFO() & ZEND_CALL_CODE))) {
							zend_refcounted *ref = Z_COUNTED_P(retval_ptr);
							ZVAL_COPY_VALUE(return_value, retval_ptr);
							if (GC_MAY_LEAK(ref)) {
								gc_possible_root(ref);
							}
							ZVAL_NULL(retval_ptr);
							break;
						} else {
							Z_ADDREF_P(retval_ptr);
						}
					} else {
						retval_ptr = Z_REFVAL_P(retval_ptr);
						if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
							Z_ADDREF_P(retval_ptr);
						}
					}
				}
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			} while (0);
		} else /* if (opline->op1_type == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(retval_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(retval_ptr);

				retval_ptr = Z_REFVAL_P(retval_ptr);
				ZVAL_COPY_VALUE(return_value, retval_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
					Z_ADDREF_P(retval_ptr);
				}
			} else {
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			}
		}
	}
	zend_observer_fcall_end(execute_data, return_value);
	goto zend_leave_helper_SPEC_LABEL;
}

			HYBRID_CASE(ZEND_RETURN_BY_REF_SPEC_CONST):
				VM_TRACE(ZEND_RETURN_BY_REF_SPEC_CONST)
				ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_RETURN_BY_REF_SPEC_OBSERVER):
				VM_TRACE(ZEND_RETURN_BY_REF_SPEC_OBSERVER)
				ZEND_RETURN_BY_REF_SPEC_OBSERVER_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_GENERATOR_RETURN_SPEC_CONST):
				VM_TRACE(ZEND_GENERATOR_RETURN_SPEC_CONST)
				ZEND_GENERATOR_RETURN_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_GENERATOR_RETURN_SPEC_OBSERVER):
				VM_TRACE(ZEND_GENERATOR_RETURN_SPEC_OBSERVER)
				ZEND_GENERATOR_RETURN_SPEC_OBSERVER_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_THROW_SPEC_CONST):
				VM_TRACE(ZEND_THROW_SPEC_CONST)
				ZEND_THROW_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CATCH_SPEC_CONST):
				VM_TRACE(ZEND_CATCH_SPEC_CONST)
				ZEND_CATCH_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_USER_SPEC_CONST):
				VM_TRACE(ZEND_SEND_USER_SPEC_CONST)
				ZEND_SEND_USER_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BOOL_SPEC_CONST):
				VM_TRACE(ZEND_BOOL_SPEC_CONST)
				ZEND_BOOL_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CLONE_SPEC_CONST):
				VM_TRACE(ZEND_CLONE_SPEC_CONST)
				ZEND_CLONE_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CAST_SPEC_CONST):
				VM_TRACE(ZEND_CAST_SPEC_CONST)
				ZEND_CAST_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INCLUDE_OR_EVAL_SPEC_CONST):
				VM_TRACE(ZEND_INCLUDE_OR_EVAL_SPEC_CONST)
				ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INCLUDE_OR_EVAL_SPEC_OBSERVER):
				VM_TRACE(ZEND_INCLUDE_OR_EVAL_SPEC_OBSERVER)
				ZEND_INCLUDE_OR_EVAL_SPEC_OBSERVER_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FE_RESET_R_SPEC_CONST):
				VM_TRACE(ZEND_FE_RESET_R_SPEC_CONST)
				ZEND_FE_RESET_R_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FE_RESET_RW_SPEC_CONST):
				VM_TRACE(ZEND_FE_RESET_RW_SPEC_CONST)
				ZEND_FE_RESET_RW_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_JMP_SET_SPEC_CONST):
				VM_TRACE(ZEND_JMP_SET_SPEC_CONST)
				ZEND_JMP_SET_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_COALESCE_SPEC_CONST):
				VM_TRACE(ZEND_COALESCE_SPEC_CONST)
				ZEND_COALESCE_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_JMP_NULL_SPEC_CONST):
				VM_TRACE(ZEND_JMP_NULL_SPEC_CONST)
				ZEND_JMP_NULL_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_QM_ASSIGN_SPEC_CONST):
				VM_TRACE(ZEND_QM_ASSIGN_SPEC_CONST)
				ZEND_QM_ASSIGN_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DECLARE_CLASS_SPEC_CONST):
				VM_TRACE(ZEND_DECLARE_CLASS_SPEC_CONST)
				ZEND_DECLARE_CLASS_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_YIELD_FROM_SPEC_CONST):
				VM_TRACE(ZEND_YIELD_FROM_SPEC_CONST)
				ZEND_YIELD_FROM_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_STRLEN_SPEC_CONST):
				VM_TRACE(ZEND_STRLEN_SPEC_CONST)
				ZEND_STRLEN_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_TYPE_CHECK_SPEC_CONST):
				VM_TRACE(ZEND_TYPE_CHECK_SPEC_CONST)
				ZEND_TYPE_CHECK_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DEFINED_SPEC_CONST):
				VM_TRACE(ZEND_DEFINED_SPEC_CONST)
				ZEND_DEFINED_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_QM_ASSIGN_LONG_SPEC_CONST):
				VM_TRACE(ZEND_QM_ASSIGN_LONG_SPEC_CONST)
				ZEND_QM_ASSIGN_LONG_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_QM_ASSIGN_DOUBLE_SPEC_CONST):
				VM_TRACE(ZEND_QM_ASSIGN_DOUBLE_SPEC_CONST)
				ZEND_QM_ASSIGN_DOUBLE_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_QM_ASSIGN_NOREF_SPEC_CONST):
				VM_TRACE(ZEND_QM_ASSIGN_NOREF_SPEC_CONST)
				ZEND_QM_ASSIGN_NOREF_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAL_SIMPLE_SPEC_CONST):
				VM_TRACE(ZEND_SEND_VAL_SIMPLE_SPEC_CONST)
				ZEND_SEND_VAL_SIMPLE_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAL_EX_SIMPLE_SPEC_CONST):
				VM_TRACE(ZEND_SEND_VAL_EX_SIMPLE_SPEC_CONST)
				ZEND_SEND_VAL_EX_SIMPLE_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_SPEC_CONST_CONST):
				VM_TRACE(ZEND_ADD_SPEC_CONST_CONST)
				ZEND_ADD_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SUB_SPEC_CONST_CONST):
				VM_TRACE(ZEND_SUB_SPEC_CONST_CONST)
				ZEND_SUB_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_MUL_SPEC_CONST_CONST):
				VM_TRACE(ZEND_MUL_SPEC_CONST_CONST)
				ZEND_MUL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DIV_SPEC_CONST_CONST):
				VM_TRACE(ZEND_DIV_SPEC_CONST_CONST)
				ZEND_DIV_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_MOD_SPEC_CONST_CONST):
				VM_TRACE(ZEND_MOD_SPEC_CONST_CONST)
				ZEND_MOD_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SL_SPEC_CONST_CONST):
				VM_TRACE(ZEND_SL_SPEC_CONST_CONST)
				ZEND_SL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SR_SPEC_CONST_CONST):
				VM_TRACE(ZEND_SR_SPEC_CONST_CONST)
				ZEND_SR_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POW_SPEC_CONST_CONST):
				VM_TRACE(ZEND_POW_SPEC_CONST_CONST)
				ZEND_POW_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_IDENTICAL_SPEC_CONST_CONST):
				VM_TRACE(ZEND_IS_IDENTICAL_SPEC_CONST_CONST)
				ZEND_IS_IDENTICAL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CONST):
				VM_TRACE(ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CONST)
				ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_SPEC_CONST_CONST):
				VM_TRACE(ZEND_IS_EQUAL_SPEC_CONST_CONST)
				ZEND_IS_EQUAL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_SPEC_CONST_CONST):
				VM_TRACE(ZEND_IS_NOT_EQUAL_SPEC_CONST_CONST)
				ZEND_IS_NOT_EQUAL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_SPEC_CONST_CONST):
				VM_TRACE(ZEND_IS_SMALLER_SPEC_CONST_CONST)
				ZEND_IS_SMALLER_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST)
				ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SPACESHIP_SPEC_CONST_CONST):
				VM_TRACE(ZEND_SPACESHIP_SPEC_CONST_CONST)
				ZEND_SPACESHIP_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BW_OR_SPEC_CONST_CONST):
				VM_TRACE(ZEND_BW_OR_SPEC_CONST_CONST)
				ZEND_BW_OR_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BW_AND_SPEC_CONST_CONST):
				VM_TRACE(ZEND_BW_AND_SPEC_CONST_CONST)
				ZEND_BW_AND_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BW_XOR_SPEC_CONST_CONST):
				VM_TRACE(ZEND_BW_XOR_SPEC_CONST_CONST)
				ZEND_BW_XOR_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BOOL_XOR_SPEC_CONST_CONST):
				VM_TRACE(ZEND_BOOL_XOR_SPEC_CONST_CONST)
				ZEND_BOOL_XOR_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_R_SPEC_CONST_CONST):
				VM_TRACE(ZEND_FETCH_DIM_R_SPEC_CONST_CONST)
				ZEND_FETCH_DIM_R_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_IS_SPEC_CONST_CONST):
				VM_TRACE(ZEND_FETCH_DIM_IS_SPEC_CONST_CONST)
				ZEND_FETCH_DIM_IS_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_CONST):
				VM_TRACE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_CONST)
				ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_R_SPEC_CONST_CONST):
				VM_TRACE(ZEND_FETCH_OBJ_R_SPEC_CONST_CONST)
				ZEND_FETCH_OBJ_R_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_IS_SPEC_CONST_CONST):
				VM_TRACE(ZEND_FETCH_OBJ_IS_SPEC_CONST_CONST)
				ZEND_FETCH_OBJ_IS_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CONST):
				VM_TRACE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CONST)
				ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_LIST_R_SPEC_CONST_CONST):
				VM_TRACE(ZEND_FETCH_LIST_R_SPEC_CONST_CONST)
				ZEND_FETCH_LIST_R_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FAST_CONCAT_SPEC_CONST_CONST):
				VM_TRACE(ZEND_FAST_CONCAT_SPEC_CONST_CONST)
				ZEND_FAST_CONCAT_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_METHOD_CALL_SPEC_CONST_CONST):
				VM_TRACE(ZEND_INIT_METHOD_CALL_SPEC_CONST_CONST)
				ZEND_INIT_METHOD_CALL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST):
				VM_TRACE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST)
				ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_USER_CALL_SPEC_CONST_CONST):
				VM_TRACE(ZEND_INIT_USER_CALL_SPEC_CONST_CONST)
				ZEND_INIT_USER_CALL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAL_SPEC_CONST_CONST):
				VM_TRACE(ZEND_SEND_VAL_SPEC_CONST_CONST)
				ZEND_SEND_VAL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAL_EX_SPEC_CONST_CONST):
				VM_TRACE(ZEND_SEND_VAL_EX_SPEC_CONST_CONST)
				ZEND_SEND_VAL_EX_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_CLASS_CONSTANT_SPEC_CONST_CONST):
				VM_TRACE(ZEND_FETCH_CLASS_CONSTANT_SPEC_CONST_CONST)
				ZEND_FETCH_CLASS_CONSTANT_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST):
				VM_TRACE(ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST)
				ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_ARRAY_SPEC_CONST_CONST):
				VM_TRACE(ZEND_INIT_ARRAY_SPEC_CONST_CONST)
				ZEND_INIT_ARRAY_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CONST):
				VM_TRACE(ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CONST)
				ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CONST):
				VM_TRACE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CONST)
				ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ARRAY_KEY_EXISTS_SPEC_CONST_CONST):
				VM_TRACE(ZEND_ARRAY_KEY_EXISTS_SPEC_CONST_CONST)
				ZEND_ARRAY_KEY_EXISTS_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DECLARE_CLASS_DELAYED_SPEC_CONST_CONST):
				VM_TRACE(ZEND_DECLARE_CLASS_DELAYED_SPEC_CONST_CONST)
				ZEND_DECLARE_CLASS_DELAYED_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DECLARE_CONST_SPEC_CONST_CONST):
				VM_TRACE(ZEND_DECLARE_CONST_SPEC_CONST_CONST)
				ZEND_DECLARE_CONST_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_YIELD_SPEC_CONST_CONST):
				VM_TRACE(ZEND_YIELD_SPEC_CONST_CONST)
				ZEND_YIELD_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SWITCH_LONG_SPEC_CONST_CONST):
				VM_TRACE(ZEND_SWITCH_LONG_SPEC_CONST_CONST)
				ZEND_SWITCH_LONG_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SWITCH_STRING_SPEC_CONST_CONST):
				VM_TRACE(ZEND_SWITCH_STRING_SPEC_CONST_CONST)
				ZEND_SWITCH_STRING_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_MATCH_SPEC_CONST_CONST):
				VM_TRACE(ZEND_MATCH_SPEC_CONST_CONST)
				ZEND_MATCH_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IN_ARRAY_SPEC_CONST_CONST):
				VM_TRACE(ZEND_IN_ARRAY_SPEC_CONST_CONST)
				ZEND_IN_ARRAY_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_SPEC_CONST_TMPVARCV):
				VM_TRACE(ZEND_ADD_SPEC_CONST_TMPVARCV)
				ZEND_ADD_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SUB_SPEC_CONST_TMPVARCV):
				VM_TRACE(ZEND_SUB_SPEC_CONST_TMPVARCV)
				ZEND_SUB_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_MOD_SPEC_CONST_TMPVARCV):
				VM_TRACE(ZEND_MOD_SPEC_CONST_TMPVARCV)
				ZEND_MOD_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SL_SPEC_CONST_TMPVARCV):
				VM_TRACE(ZEND_SL_SPEC_CONST_TMPVARCV)
				ZEND_SL_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SR_SPEC_CONST_TMPVARCV):
				VM_TRACE(ZEND_SR_SPEC_CONST_TMPVARCV)
				ZEND_SR_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV):
				VM_TRACE(ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV)
				ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPZ):
				VM_TRACE(ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPZ)
				ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPNZ):
				VM_TRACE(ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPNZ)
				ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV)
				ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPZ):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPZ)
				ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPNZ):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPNZ)
				ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SUB_LONG_NO_OVERFLOW_SPEC_CONST_TMPVARCV):
				VM_TRACE(ZEND_SUB_LONG_NO_OVERFLOW_SPEC_CONST_TMPVARCV)
				ZEND_SUB_LONG_NO_OVERFLOW_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SUB_LONG_SPEC_CONST_TMPVARCV):
				VM_TRACE(ZEND_SUB_LONG_SPEC_CONST_TMPVARCV)
				ZEND_SUB_LONG_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SUB_DOUBLE_SPEC_CONST_TMPVARCV):
				VM_TRACE(ZEND_SUB_DOUBLE_SPEC_CONST_TMPVARCV)
				ZEND_SUB_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV):
				VM_TRACE(ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV)
				ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPZ):
				VM_TRACE(ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPZ)
				ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPNZ):
				VM_TRACE(ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPNZ)
				ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV):
				VM_TRACE(ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV)
				ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ):
				VM_TRACE(ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ)
				ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ):
				VM_TRACE(ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ)
				ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV)
				ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPZ):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPZ)
				ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPNZ):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPNZ)
				ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV)
				ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ)
				ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ)
				ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_R_INDEX_SPEC_CONST_TMPVARCV):
				VM_TRACE(ZEND_FETCH_DIM_R_INDEX_SPEC_CONST_TMPVARCV)
				ZEND_FETCH_DIM_R_INDEX_SPEC_CONST_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DIV_SPEC_CONST_TMPVAR):
				VM_TRACE(ZEND_DIV_SPEC_CONST_TMPVAR)
				ZEND_DIV_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POW_SPEC_CONST_TMPVAR):
				VM_TRACE(ZEND_POW_SPEC_CONST_TMPVAR)
				ZEND_POW_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CONCAT_SPEC_CONST_TMPVAR):
				VM_TRACE(ZEND_CONCAT_SPEC_CONST_TMPVAR)
				ZEND_CONCAT_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SPACESHIP_SPEC_CONST_TMPVAR):
				VM_TRACE(ZEND_SPACESHIP_SPEC_CONST_TMPVAR)
				ZEND_SPACESHIP_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_R_SPEC_CONST_TMPVAR):
				VM_TRACE(ZEND_FETCH_DIM_R_SPEC_CONST_TMPVAR)
				ZEND_FETCH_DIM_R_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_IS_SPEC_CONST_TMPVAR):
				VM_TRACE(ZEND_FETCH_DIM_IS_SPEC_CONST_TMPVAR)
				ZEND_FETCH_DIM_IS_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_TMPVAR):
				VM_TRACE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_TMPVAR)
				ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_R_SPEC_CONST_TMPVAR):
				VM_TRACE(ZEND_FETCH_OBJ_R_SPEC_CONST_TMPVAR)
				ZEND_FETCH_OBJ_R_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_IS_SPEC_CONST_TMPVAR):
				VM_TRACE(ZEND_FETCH_OBJ_IS_SPEC_CONST_TMPVAR)
				ZEND_FETCH_OBJ_IS_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_TMPVAR):
				VM_TRACE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_TMPVAR)
				ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_LIST_R_SPEC_CONST_TMPVAR):
				VM_TRACE(ZEND_FETCH_LIST_R_SPEC_CONST_TMPVAR)
				ZEND_FETCH_LIST_R_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FAST_CONCAT_SPEC_CONST_TMPVAR):
				VM_TRACE(ZEND_FAST_CONCAT_SPEC_CONST_TMPVAR)
				ZEND_FAST_CONCAT_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_METHOD_CALL_SPEC_CONST_TMPVAR):
				VM_TRACE(ZEND_INIT_METHOD_CALL_SPEC_CONST_TMPVAR)
				ZEND_INIT_METHOD_CALL_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMPVAR):
				VM_TRACE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMPVAR)
				ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_USER_CALL_SPEC_CONST_TMPVAR):
				VM_TRACE(ZEND_INIT_USER_CALL_SPEC_CONST_TMPVAR)
				ZEND_INIT_USER_CALL_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMPVAR):
				VM_TRACE(ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMPVAR)
				ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_ARRAY_SPEC_CONST_TMPVAR):
				VM_TRACE(ZEND_INIT_ARRAY_SPEC_CONST_TMPVAR)
				ZEND_INIT_ARRAY_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_TMPVAR):
				VM_TRACE(ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_TMPVAR)
				ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_TMPVAR):
				VM_TRACE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_TMPVAR)
				ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ARRAY_KEY_EXISTS_SPEC_CONST_TMPVAR):
				VM_TRACE(ZEND_ARRAY_KEY_EXISTS_SPEC_CONST_TMPVAR)
				ZEND_ARRAY_KEY_EXISTS_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_YIELD_SPEC_CONST_TMPVAR):
				VM_TRACE(ZEND_YIELD_SPEC_CONST_TMPVAR)
				ZEND_YIELD_SPEC_CONST_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_R_SPEC_CONST_UNUSED):
				VM_TRACE(ZEND_FETCH_R_SPEC_CONST_UNUSED)
				ZEND_FETCH_R_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_W_SPEC_CONST_UNUSED):
				VM_TRACE(ZEND_FETCH_W_SPEC_CONST_UNUSED)
				ZEND_FETCH_W_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_RW_SPEC_CONST_UNUSED):
				VM_TRACE(ZEND_FETCH_RW_SPEC_CONST_UNUSED)
				ZEND_FETCH_RW_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_FUNC_ARG_SPEC_CONST_UNUSED):
				VM_TRACE(ZEND_FETCH_FUNC_ARG_SPEC_CONST_UNUSED)
				ZEND_FETCH_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_UNSET_SPEC_CONST_UNUSED):
				VM_TRACE(ZEND_FETCH_UNSET_SPEC_CONST_UNUSED)
				ZEND_FETCH_UNSET_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_IS_SPEC_CONST_UNUSED):
				VM_TRACE(ZEND_FETCH_IS_SPEC_CONST_UNUSED)
				ZEND_FETCH_IS_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_UNUSED):
				VM_TRACE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_UNUSED)
				ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_UNUSED):
				VM_TRACE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_UNUSED)
				ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_VERIFY_RETURN_TYPE_SPEC_CONST_UNUSED):
				VM_TRACE(ZEND_VERIFY_RETURN_TYPE_SPEC_CONST_UNUSED)
				ZEND_VERIFY_RETURN_TYPE_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAL_SPEC_CONST_UNUSED):
				VM_TRACE(ZEND_SEND_VAL_SPEC_CONST_UNUSED)
				ZEND_SEND_VAL_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAL_EX_SPEC_CONST_UNUSED):
				VM_TRACE(ZEND_SEND_VAL_EX_SPEC_CONST_UNUSED)
				ZEND_SEND_VAL_EX_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAL_EX_SPEC_CONST_UNUSED_QUICK):
				VM_TRACE(ZEND_SEND_VAL_EX_SPEC_CONST_UNUSED_QUICK)
				ZEND_SEND_VAL_EX_SPEC_CONST_UNUSED_QUICK_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_NEW_SPEC_CONST_UNUSED):
				VM_TRACE(ZEND_NEW_SPEC_CONST_UNUSED)
				ZEND_NEW_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED):
				VM_TRACE(ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED)
				ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_ARRAY_SPEC_CONST_UNUSED):
				VM_TRACE(ZEND_INIT_ARRAY_SPEC_CONST_UNUSED)
				ZEND_INIT_ARRAY_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_UNSET_VAR_SPEC_CONST_UNUSED):
				VM_TRACE(ZEND_UNSET_VAR_SPEC_CONST_UNUSED)
				ZEND_UNSET_VAR_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_UNUSED):
				VM_TRACE(ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_UNUSED)
				ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_UNUSED):
				VM_TRACE(ZEND_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_UNUSED)
				ZEND_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_YIELD_SPEC_CONST_UNUSED):
				VM_TRACE(ZEND_YIELD_SPEC_CONST_UNUSED)
				ZEND_YIELD_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_MATCH_ERROR_SPEC_CONST_UNUSED):
				VM_TRACE(ZEND_MATCH_ERROR_SPEC_CONST_UNUSED)
				ZEND_MATCH_ERROR_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_COUNT_SPEC_CONST_UNUSED):
				VM_TRACE(ZEND_COUNT_SPEC_CONST_UNUSED)
				ZEND_COUNT_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_GET_CLASS_SPEC_CONST_UNUSED):
				VM_TRACE(ZEND_GET_CLASS_SPEC_CONST_UNUSED)
				ZEND_GET_CLASS_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_GET_TYPE_SPEC_CONST_UNUSED):
				VM_TRACE(ZEND_GET_TYPE_SPEC_CONST_UNUSED)
				ZEND_GET_TYPE_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FUNC_GET_ARGS_SPEC_CONST_UNUSED):
				VM_TRACE(ZEND_FUNC_GET_ARGS_SPEC_CONST_UNUSED)
				ZEND_FUNC_GET_ARGS_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DIV_SPEC_CONST_CV):
				VM_TRACE(ZEND_DIV_SPEC_CONST_CV)
				ZEND_DIV_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POW_SPEC_CONST_CV):
				VM_TRACE(ZEND_POW_SPEC_CONST_CV)
				ZEND_POW_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CONCAT_SPEC_CONST_CV):
				VM_TRACE(ZEND_CONCAT_SPEC_CONST_CV)
				ZEND_CONCAT_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SPACESHIP_SPEC_CONST_CV):
				VM_TRACE(ZEND_SPACESHIP_SPEC_CONST_CV)
				ZEND_SPACESHIP_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_R_SPEC_CONST_CV):
				VM_TRACE(ZEND_FETCH_DIM_R_SPEC_CONST_CV)
				ZEND_FETCH_DIM_R_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_IS_SPEC_CONST_CV):
				VM_TRACE(ZEND_FETCH_DIM_IS_SPEC_CONST_CV)
				ZEND_FETCH_DIM_IS_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_CV):
				VM_TRACE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_CV)
				ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_R_SPEC_CONST_CV):
				VM_TRACE(ZEND_FETCH_OBJ_R_SPEC_CONST_CV)
				ZEND_FETCH_OBJ_R_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_IS_SPEC_CONST_CV):
				VM_TRACE(ZEND_FETCH_OBJ_IS_SPEC_CONST_CV)
				ZEND_FETCH_OBJ_IS_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CV):
				VM_TRACE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CV)
				ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_LIST_R_SPEC_CONST_CV):
				VM_TRACE(ZEND_FETCH_LIST_R_SPEC_CONST_CV)
				ZEND_FETCH_LIST_R_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FAST_CONCAT_SPEC_CONST_CV):
				VM_TRACE(ZEND_FAST_CONCAT_SPEC_CONST_CV)
				ZEND_FAST_CONCAT_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_METHOD_CALL_SPEC_CONST_CV):
				VM_TRACE(ZEND_INIT_METHOD_CALL_SPEC_CONST_CV)
				ZEND_INIT_METHOD_CALL_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CV):
				VM_TRACE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CV)
				ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_USER_CALL_SPEC_CONST_CV):
				VM_TRACE(ZEND_INIT_USER_CALL_SPEC_CONST_CV)
				ZEND_INIT_USER_CALL_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV):
				VM_TRACE(ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV)
				ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_ARRAY_SPEC_CONST_CV):
				VM_TRACE(ZEND_INIT_ARRAY_SPEC_CONST_CV)
				ZEND_INIT_ARRAY_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CV):
				VM_TRACE(ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CV)
				ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CV):
				VM_TRACE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CV)
				ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ARRAY_KEY_EXISTS_SPEC_CONST_CV):
				VM_TRACE(ZEND_ARRAY_KEY_EXISTS_SPEC_CONST_CV)
				ZEND_ARRAY_KEY_EXISTS_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_YIELD_SPEC_CONST_CV):
				VM_TRACE(ZEND_YIELD_SPEC_CONST_CV)
				ZEND_YIELD_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BW_NOT_SPEC_TMPVARCV):
				VM_TRACE(ZEND_BW_NOT_SPEC_TMPVARCV)
				ZEND_BW_NOT_SPEC_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_JMP_NULL_SPEC_TMPVARCV):
				VM_TRACE(ZEND_JMP_NULL_SPEC_TMPVARCV)
				ZEND_JMP_NULL_SPEC_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_QM_ASSIGN_LONG_SPEC_TMPVARCV):
				VM_TRACE(ZEND_QM_ASSIGN_LONG_SPEC_TMPVARCV)
				ZEND_QM_ASSIGN_LONG_SPEC_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_QM_ASSIGN_DOUBLE_SPEC_TMPVARCV):
				VM_TRACE(ZEND_QM_ASSIGN_DOUBLE_SPEC_TMPVARCV)
				ZEND_QM_ASSIGN_DOUBLE_SPEC_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_QM_ASSIGN_NOREF_SPEC_TMPVARCV):
				VM_TRACE(ZEND_QM_ASSIGN_NOREF_SPEC_TMPVARCV)
				ZEND_QM_ASSIGN_NOREF_SPEC_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_ADD_SPEC_TMPVARCV_CONST)
				ZEND_ADD_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SUB_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_SUB_SPEC_TMPVARCV_CONST)
				ZEND_SUB_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_MUL_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_MUL_SPEC_TMPVARCV_CONST)
				ZEND_MUL_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_MOD_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_MOD_SPEC_TMPVARCV_CONST)
				ZEND_MOD_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SL_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_SL_SPEC_TMPVARCV_CONST)
				ZEND_SL_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SR_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_SR_SPEC_TMPVARCV_CONST)
				ZEND_SR_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST)
				ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPZ):
				VM_TRACE(ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPZ)
				ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPNZ):
				VM_TRACE(ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPNZ)
				ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST)
				ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPZ):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPZ)
				ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPNZ):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPNZ)
				ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BW_OR_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_BW_OR_SPEC_TMPVARCV_CONST)
				ZEND_BW_OR_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BW_AND_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_BW_AND_SPEC_TMPVARCV_CONST)
				ZEND_BW_AND_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BW_XOR_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_BW_XOR_SPEC_TMPVARCV_CONST)
				ZEND_BW_XOR_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_LIST_R_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_FETCH_LIST_R_SPEC_TMPVARCV_CONST)
				ZEND_FETCH_LIST_R_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SWITCH_LONG_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_SWITCH_LONG_SPEC_TMPVARCV_CONST)
				ZEND_SWITCH_LONG_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SWITCH_STRING_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_SWITCH_STRING_SPEC_TMPVARCV_CONST)
				ZEND_SWITCH_STRING_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_MATCH_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_MATCH_SPEC_TMPVARCV_CONST)
				ZEND_MATCH_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST)
				ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_LONG_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_ADD_LONG_SPEC_TMPVARCV_CONST)
				ZEND_ADD_LONG_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_DOUBLE_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_ADD_DOUBLE_SPEC_TMPVARCV_CONST)
				ZEND_ADD_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST)
				ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SUB_LONG_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_SUB_LONG_SPEC_TMPVARCV_CONST)
				ZEND_SUB_LONG_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SUB_DOUBLE_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_SUB_DOUBLE_SPEC_TMPVARCV_CONST)
				ZEND_SUB_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST)
				ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_MUL_LONG_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_MUL_LONG_SPEC_TMPVARCV_CONST)
				ZEND_MUL_LONG_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_MUL_DOUBLE_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_MUL_DOUBLE_SPEC_TMPVARCV_CONST)
				ZEND_MUL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST)
				ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ):
				VM_TRACE(ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ)
				ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ):
				VM_TRACE(ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ)
				ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST)
				ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ):
				VM_TRACE(ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ)
				ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ):
				VM_TRACE(ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ)
				ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST)
				ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ):
				VM_TRACE(ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ)
				ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ):
				VM_TRACE(ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ)
				ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST)
				ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ):
				VM_TRACE(ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ)
				ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ):
				VM_TRACE(ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ)
				ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST)
				ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPZ):
				VM_TRACE(ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPZ)
				ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPNZ):
				VM_TRACE(ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPNZ)
				ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST)
				ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ):
				VM_TRACE(ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ)
				ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ):
				VM_TRACE(ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ)
				ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST)
				ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ)
				ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ)
				ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST)
				ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ)
				ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ)
				ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_ADD_SPEC_TMPVARCV_TMPVARCV)
				ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SUB_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_SUB_SPEC_TMPVARCV_TMPVARCV)
				ZEND_SUB_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_MUL_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_MUL_SPEC_TMPVARCV_TMPVARCV)
				ZEND_MUL_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_MOD_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_MOD_SPEC_TMPVARCV_TMPVARCV)
				ZEND_MOD_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SL_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_SL_SPEC_TMPVARCV_TMPVARCV)
				ZEND_SL_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SR_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_SR_SPEC_TMPVARCV_TMPVARCV)
				ZEND_SR_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV)
				ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ):
				VM_TRACE(ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ)
				ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ):
				VM_TRACE(ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ)
				ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV)
				ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ)
				ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ)
				ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BW_OR_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_BW_OR_SPEC_TMPVARCV_TMPVARCV)
				ZEND_BW_OR_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BW_AND_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_BW_AND_SPEC_TMPVARCV_TMPVARCV)
				ZEND_BW_AND_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BW_XOR_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_BW_XOR_SPEC_TMPVARCV_TMPVARCV)
				ZEND_BW_XOR_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV)
				ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_LONG_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_ADD_LONG_SPEC_TMPVARCV_TMPVARCV)
				ZEND_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV)
				ZEND_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV)
				ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SUB_LONG_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_SUB_LONG_SPEC_TMPVARCV_TMPVARCV)
				ZEND_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV)
				ZEND_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV)
				ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_MUL_LONG_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_MUL_LONG_SPEC_TMPVARCV_TMPVARCV)
				ZEND_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV)
				ZEND_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV)
				ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ):
				VM_TRACE(ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ)
				ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ):
				VM_TRACE(ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ)
				ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV)
				ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ):
				VM_TRACE(ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ)
				ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ):
				VM_TRACE(ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ)
				ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV)
				ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ):
				VM_TRACE(ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ)
				ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ):
				VM_TRACE(ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ)
				ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV)
				ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ):
				VM_TRACE(ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ)
				ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ):
				VM_TRACE(ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ)
				ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV)
				ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ):
				VM_TRACE(ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ)
				ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ):
				VM_TRACE(ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ)
				ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV)
				ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ):
				VM_TRACE(ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ)
				ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ):
				VM_TRACE(ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ)
				ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV)
				ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ)
				ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ)
				ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV)
				ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ)
				ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ):
				VM_TRACE(ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ)
				ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR):
				VM_TRACE(ZEND_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR)
				ZEND_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_MATCH_ERROR_SPEC_TMPVARCV_UNUSED):
				VM_TRACE(ZEND_MATCH_ERROR_SPEC_TMPVARCV_UNUSED)
				ZEND_MATCH_ERROR_SPEC_TMPVARCV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_LIST_R_SPEC_TMPVARCV_CV):
				VM_TRACE(ZEND_FETCH_LIST_R_SPEC_TMPVARCV_CV)
				ZEND_FETCH_LIST_R_SPEC_TMPVARCV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BOOL_NOT_SPEC_TMPVAR):
				VM_TRACE(ZEND_BOOL_NOT_SPEC_TMPVAR)
				ZEND_BOOL_NOT_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ECHO_SPEC_TMPVAR):
				VM_TRACE(ZEND_ECHO_SPEC_TMPVAR)
				ZEND_ECHO_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_JMPZ_SPEC_TMPVAR):
				VM_TRACE(ZEND_JMPZ_SPEC_TMPVAR)
				ZEND_JMPZ_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_JMPNZ_SPEC_TMPVAR):
				VM_TRACE(ZEND_JMPNZ_SPEC_TMPVAR)
				ZEND_JMPNZ_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_JMPZNZ_SPEC_TMPVAR):
				VM_TRACE(ZEND_JMPZNZ_SPEC_TMPVAR)
				ZEND_JMPZNZ_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_JMPZ_EX_SPEC_TMPVAR):
				VM_TRACE(ZEND_JMPZ_EX_SPEC_TMPVAR)
				ZEND_JMPZ_EX_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_JMPNZ_EX_SPEC_TMPVAR):
				VM_TRACE(ZEND_JMPNZ_EX_SPEC_TMPVAR)
				ZEND_JMPNZ_EX_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FREE_SPEC_TMPVAR):
				VM_TRACE(ZEND_FREE_SPEC_TMPVAR)
				ZEND_FREE_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FE_FREE_SPEC_TMPVAR):
				VM_TRACE(ZEND_FE_FREE_SPEC_TMPVAR)
				ZEND_FE_FREE_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_THROW_SPEC_TMPVAR):
				VM_TRACE(ZEND_THROW_SPEC_TMPVAR)
				ZEND_THROW_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BOOL_SPEC_TMPVAR):
				VM_TRACE(ZEND_BOOL_SPEC_TMPVAR)
				ZEND_BOOL_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CLONE_SPEC_TMPVAR):
				VM_TRACE(ZEND_CLONE_SPEC_TMPVAR)
				ZEND_CLONE_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INCLUDE_OR_EVAL_SPEC_TMPVAR):
				VM_TRACE(ZEND_INCLUDE_OR_EVAL_SPEC_TMPVAR)
				ZEND_INCLUDE_OR_EVAL_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_YIELD_FROM_SPEC_TMPVAR):
				VM_TRACE(ZEND_YIELD_FROM_SPEC_TMPVAR)
				ZEND_YIELD_FROM_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_STRLEN_SPEC_TMPVAR):
				VM_TRACE(ZEND_STRLEN_SPEC_TMPVAR)
				ZEND_STRLEN_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_TYPE_CHECK_SPEC_TMPVAR):
				VM_TRACE(ZEND_TYPE_CHECK_SPEC_TMPVAR)
				ZEND_TYPE_CHECK_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_CLASS_NAME_SPEC_TMPVAR):
				VM_TRACE(ZEND_FETCH_CLASS_NAME_SPEC_TMPVAR)
				ZEND_FETCH_CLASS_NAME_SPEC_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DIV_SPEC_TMPVAR_CONST):
				VM_TRACE(ZEND_DIV_SPEC_TMPVAR_CONST)
				ZEND_DIV_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POW_SPEC_TMPVAR_CONST):
				VM_TRACE(ZEND_POW_SPEC_TMPVAR_CONST)
				ZEND_POW_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CONCAT_SPEC_TMPVAR_CONST):
				VM_TRACE(ZEND_CONCAT_SPEC_TMPVAR_CONST)
				ZEND_CONCAT_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_SPEC_TMPVAR_CONST):
				VM_TRACE(ZEND_IS_EQUAL_SPEC_TMPVAR_CONST)
				ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_JMPZ):
				VM_TRACE(ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_JMPZ)
				ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_JMPNZ):
				VM_TRACE(ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_JMPNZ)
				ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST):
				VM_TRACE(ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST)
				ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPZ):
				VM_TRACE(ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPZ)
				ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPNZ):
				VM_TRACE(ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPNZ)
				ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SPACESHIP_SPEC_TMPVAR_CONST):
				VM_TRACE(ZEND_SPACESHIP_SPEC_TMPVAR_CONST)
				ZEND_SPACESHIP_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BOOL_XOR_SPEC_TMPVAR_CONST):
				VM_TRACE(ZEND_BOOL_XOR_SPEC_TMPVAR_CONST)
				ZEND_BOOL_XOR_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_R_SPEC_TMPVAR_CONST):
				VM_TRACE(ZEND_FETCH_DIM_R_SPEC_TMPVAR_CONST)
				ZEND_FETCH_DIM_R_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_IS_SPEC_TMPVAR_CONST):
				VM_TRACE(ZEND_FETCH_DIM_IS_SPEC_TMPVAR_CONST)
				ZEND_FETCH_DIM_IS_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_R_SPEC_TMPVAR_CONST):
				VM_TRACE(ZEND_FETCH_OBJ_R_SPEC_TMPVAR_CONST)
				ZEND_FETCH_OBJ_R_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_CONST):
				VM_TRACE(ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_CONST)
				ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FAST_CONCAT_SPEC_TMPVAR_CONST):
				VM_TRACE(ZEND_FAST_CONCAT_SPEC_TMPVAR_CONST)
				ZEND_FAST_CONCAT_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_CONST):
				VM_TRACE(ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_CONST)
				ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAL_SPEC_TMPVAR_CONST):
				VM_TRACE(ZEND_SEND_VAL_SPEC_TMPVAR_CONST)
				ZEND_SEND_VAL_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CASE_SPEC_TMPVAR_CONST):
				VM_TRACE(ZEND_CASE_SPEC_TMPVAR_CONST)
				ZEND_CASE_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CONST):
				VM_TRACE(ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CONST)
				ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CONST):
				VM_TRACE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CONST)
				ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CONST):
				VM_TRACE(ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CONST)
				ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INSTANCEOF_SPEC_TMPVAR_CONST):
				VM_TRACE(ZEND_INSTANCEOF_SPEC_TMPVAR_CONST)
				ZEND_INSTANCEOF_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_CONST):
				VM_TRACE(ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_CONST)
				ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV):
				VM_TRACE(ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV)
				ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DIV_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(ZEND_DIV_SPEC_TMPVAR_TMPVAR)
				ZEND_DIV_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POW_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(ZEND_POW_SPEC_TMPVAR_TMPVAR)
				ZEND_POW_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CONCAT_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(ZEND_CONCAT_SPEC_TMPVAR_TMPVAR)
				ZEND_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR)
				ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ):
				VM_TRACE(ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ)
				ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ):
				VM_TRACE(ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ)
				ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR)
				ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ):
				VM_TRACE(ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ)
				ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ):
				VM_TRACE(ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ)
				ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SPACESHIP_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(ZEND_SPACESHIP_SPEC_TMPVAR_TMPVAR)
				ZEND_SPACESHIP_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BOOL_XOR_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(ZEND_BOOL_XOR_SPEC_TMPVAR_TMPVAR)
				ZEND_BOOL_XOR_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(ZEND_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR)
				ZEND_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(ZEND_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR)
				ZEND_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(ZEND_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR)
				ZEND_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR)
				ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FAST_CONCAT_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(ZEND_FAST_CONCAT_SPEC_TMPVAR_TMPVAR)
				ZEND_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR)
				ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CASE_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(ZEND_CASE_SPEC_TMPVAR_TMPVAR)
				ZEND_CASE_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR)
				ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR)
				ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR)
				ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INSTANCEOF_SPEC_TMPVAR_VAR):
				VM_TRACE(ZEND_INSTANCEOF_SPEC_TMPVAR_VAR)
				ZEND_INSTANCEOF_SPEC_TMPVAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_R_SPEC_TMPVAR_UNUSED):
				VM_TRACE(ZEND_FETCH_R_SPEC_TMPVAR_UNUSED)
				ZEND_FETCH_R_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_W_SPEC_TMPVAR_UNUSED):
				VM_TRACE(ZEND_FETCH_W_SPEC_TMPVAR_UNUSED)
				ZEND_FETCH_W_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_RW_SPEC_TMPVAR_UNUSED):
				VM_TRACE(ZEND_FETCH_RW_SPEC_TMPVAR_UNUSED)
				ZEND_FETCH_RW_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_FUNC_ARG_SPEC_TMPVAR_UNUSED):
				VM_TRACE(ZEND_FETCH_FUNC_ARG_SPEC_TMPVAR_UNUSED)
				ZEND_FETCH_FUNC_ARG_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_UNSET_SPEC_TMPVAR_UNUSED):
				VM_TRACE(ZEND_FETCH_UNSET_SPEC_TMPVAR_UNUSED)
				ZEND_FETCH_UNSET_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_IS_SPEC_TMPVAR_UNUSED):
				VM_TRACE(ZEND_FETCH_IS_SPEC_TMPVAR_UNUSED)
				ZEND_FETCH_IS_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAL_SPEC_TMPVAR_UNUSED):
				VM_TRACE(ZEND_SEND_VAL_SPEC_TMPVAR_UNUSED)
				ZEND_SEND_VAL_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_UNSET_VAR_SPEC_TMPVAR_UNUSED):
				VM_TRACE(ZEND_UNSET_VAR_SPEC_TMPVAR_UNUSED)
				ZEND_UNSET_VAR_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_UNUSED):
				VM_TRACE(ZEND_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_UNUSED)
				ZEND_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INSTANCEOF_SPEC_TMPVAR_UNUSED):
				VM_TRACE(ZEND_INSTANCEOF_SPEC_TMPVAR_UNUSED)
				ZEND_INSTANCEOF_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_COUNT_SPEC_TMPVAR_UNUSED):
				VM_TRACE(ZEND_COUNT_SPEC_TMPVAR_UNUSED)
				ZEND_COUNT_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_GET_CLASS_SPEC_TMPVAR_UNUSED):
				VM_TRACE(ZEND_GET_CLASS_SPEC_TMPVAR_UNUSED)
				ZEND_GET_CLASS_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_COPY_TMP_SPEC_TMPVAR_UNUSED):
				VM_TRACE(ZEND_COPY_TMP_SPEC_TMPVAR_UNUSED)
				ZEND_COPY_TMP_SPEC_TMPVAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DIV_SPEC_TMPVAR_CV):
				VM_TRACE(ZEND_DIV_SPEC_TMPVAR_CV)
				ZEND_DIV_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POW_SPEC_TMPVAR_CV):
				VM_TRACE(ZEND_POW_SPEC_TMPVAR_CV)
				ZEND_POW_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CONCAT_SPEC_TMPVAR_CV):
				VM_TRACE(ZEND_CONCAT_SPEC_TMPVAR_CV)
				ZEND_CONCAT_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SPACESHIP_SPEC_TMPVAR_CV):
				VM_TRACE(ZEND_SPACESHIP_SPEC_TMPVAR_CV)
				ZEND_SPACESHIP_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_R_SPEC_TMPVAR_CV):
				VM_TRACE(ZEND_FETCH_DIM_R_SPEC_TMPVAR_CV)
				ZEND_FETCH_DIM_R_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_IS_SPEC_TMPVAR_CV):
				VM_TRACE(ZEND_FETCH_DIM_IS_SPEC_TMPVAR_CV)
				ZEND_FETCH_DIM_IS_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_R_SPEC_TMPVAR_CV):
				VM_TRACE(ZEND_FETCH_OBJ_R_SPEC_TMPVAR_CV)
				ZEND_FETCH_OBJ_R_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_CV):
				VM_TRACE(ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_CV)
				ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FAST_CONCAT_SPEC_TMPVAR_CV):
				VM_TRACE(ZEND_FAST_CONCAT_SPEC_TMPVAR_CV)
				ZEND_FAST_CONCAT_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_CV):
				VM_TRACE(ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_CV)
				ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CASE_SPEC_TMPVAR_CV):
				VM_TRACE(ZEND_CASE_SPEC_TMPVAR_CV)
				ZEND_CASE_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CV):
				VM_TRACE(ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CV)
				ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CV):
				VM_TRACE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CV)
				ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CV):
				VM_TRACE(ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CV)
				ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_RETURN_SPEC_TMP):
				VM_TRACE(ZEND_RETURN_SPEC_TMP)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;

	retval_ptr = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	return_value = EX(return_value);
	if (IS_TMP_VAR == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(retval_ptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		retval_ptr = ZVAL_UNDEFINED_OP1();
		if (return_value) {
			ZVAL_NULL(return_value);
		}
	} else if (!return_value) {
		if (IS_TMP_VAR & (IS_VAR|IS_TMP_VAR)) {
			if (Z_REFCOUNTED_P(retval_ptr) && !Z_DELREF_P(retval_ptr)) {
				SAVE_OPLINE();
				rc_dtor_func(Z_COUNTED_P(retval_ptr));
			}
		}
	} else {
		if ((IS_TMP_VAR & (IS_CONST|IS_TMP_VAR))) {
			ZVAL_COPY_VALUE(return_value, retval_ptr);
			if (IS_TMP_VAR == IS_CONST) {
				if (UNEXPECTED(Z_OPT_REFCOUNTED_P(return_value))) {
					Z_ADDREF_P(return_value);
				}
			}
		} else if (IS_TMP_VAR == IS_CV) {
			do {
				if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
					if (EXPECTED(!Z_OPT_ISREF_P(retval_ptr))) {
						if (EXPECTED(!(EX_CALL_INFO() & ZEND_CALL_CODE))) {
							zend_refcounted *ref = Z_COUNTED_P(retval_ptr);
							ZVAL_COPY_VALUE(return_value, retval_ptr);
							if (GC_MAY_LEAK(ref)) {
								gc_possible_root(ref);
							}
							ZVAL_NULL(retval_ptr);
							break;
						} else {
							Z_ADDREF_P(retval_ptr);
						}
					} else {
						retval_ptr = Z_REFVAL_P(retval_ptr);
						if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
							Z_ADDREF_P(retval_ptr);
						}
					}
				}
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			} while (0);
		} else /* if (IS_TMP_VAR == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(retval_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(retval_ptr);

				retval_ptr = Z_REFVAL_P(retval_ptr);
				ZVAL_COPY_VALUE(return_value, retval_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
					Z_ADDREF_P(retval_ptr);
				}
			} else {
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			}
		}
	}

	goto zend_leave_helper_SPEC_LABEL;
}

			HYBRID_CASE(ZEND_RETURN_BY_REF_SPEC_TMP):
				VM_TRACE(ZEND_RETURN_BY_REF_SPEC_TMP)
				ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_GENERATOR_RETURN_SPEC_TMP):
				VM_TRACE(ZEND_GENERATOR_RETURN_SPEC_TMP)
				ZEND_GENERATOR_RETURN_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_USER_SPEC_TMP):
				VM_TRACE(ZEND_SEND_USER_SPEC_TMP)
				ZEND_SEND_USER_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CAST_SPEC_TMP):
				VM_TRACE(ZEND_CAST_SPEC_TMP)
				ZEND_CAST_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FE_RESET_R_SPEC_TMP):
				VM_TRACE(ZEND_FE_RESET_R_SPEC_TMP)
				ZEND_FE_RESET_R_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FE_RESET_RW_SPEC_TMP):
				VM_TRACE(ZEND_FE_RESET_RW_SPEC_TMP)
				ZEND_FE_RESET_RW_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_END_SILENCE_SPEC_TMP):
				VM_TRACE(ZEND_END_SILENCE_SPEC_TMP)
				ZEND_END_SILENCE_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_JMP_SET_SPEC_TMP):
				VM_TRACE(ZEND_JMP_SET_SPEC_TMP)
				ZEND_JMP_SET_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_COALESCE_SPEC_TMP):
				VM_TRACE(ZEND_COALESCE_SPEC_TMP)
				ZEND_COALESCE_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_QM_ASSIGN_SPEC_TMP):
				VM_TRACE(ZEND_QM_ASSIGN_SPEC_TMP)
				ZEND_QM_ASSIGN_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_IDENTICAL_SPEC_TMP_CONST):
				VM_TRACE(ZEND_IS_IDENTICAL_SPEC_TMP_CONST)
				ZEND_IS_IDENTICAL_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CASE_STRICT_SPEC_TMP_CONST):
				VM_TRACE(ZEND_CASE_STRICT_SPEC_TMP_CONST)
				ZEND_CASE_STRICT_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CONST):
				VM_TRACE(ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CONST)
				ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_CONST):
				VM_TRACE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_CONST)
				ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CONST):
				VM_TRACE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CONST)
				ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ROPE_ADD_SPEC_TMP_CONST):
				VM_TRACE(ZEND_ROPE_ADD_SPEC_TMP_CONST)
				ZEND_ROPE_ADD_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ROPE_END_SPEC_TMP_CONST):
				VM_TRACE(ZEND_ROPE_END_SPEC_TMP_CONST)
				ZEND_ROPE_END_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAL_EX_SPEC_TMP_CONST):
				VM_TRACE(ZEND_SEND_VAL_EX_SPEC_TMP_CONST)
				ZEND_SEND_VAL_EX_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST):
				VM_TRACE(ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST)
				ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_ARRAY_SPEC_TMP_CONST):
				VM_TRACE(ZEND_INIT_ARRAY_SPEC_TMP_CONST)
				ZEND_INIT_ARRAY_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_YIELD_SPEC_TMP_CONST):
				VM_TRACE(ZEND_YIELD_SPEC_TMP_CONST)
				ZEND_YIELD_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IN_ARRAY_SPEC_TMP_CONST):
				VM_TRACE(ZEND_IN_ARRAY_SPEC_TMP_CONST)
				ZEND_IN_ARRAY_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_TMPVAR):
				VM_TRACE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_TMPVAR)
				ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_TMPVAR):
				VM_TRACE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_TMPVAR)
				ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ROPE_ADD_SPEC_TMP_TMPVAR):
				VM_TRACE(ZEND_ROPE_ADD_SPEC_TMP_TMPVAR)
				ZEND_ROPE_ADD_SPEC_TMP_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ROPE_END_SPEC_TMP_TMPVAR):
				VM_TRACE(ZEND_ROPE_END_SPEC_TMP_TMPVAR)
				ZEND_ROPE_END_SPEC_TMP_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMPVAR):
				VM_TRACE(ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMPVAR)
				ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_ARRAY_SPEC_TMP_TMPVAR):
				VM_TRACE(ZEND_INIT_ARRAY_SPEC_TMP_TMPVAR)
				ZEND_INIT_ARRAY_SPEC_TMP_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_YIELD_SPEC_TMP_TMPVAR):
				VM_TRACE(ZEND_YIELD_SPEC_TMP_TMPVAR)
				ZEND_YIELD_SPEC_TMP_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_IDENTICAL_SPEC_TMP_TMP):
				VM_TRACE(ZEND_IS_IDENTICAL_SPEC_TMP_TMP)
				ZEND_IS_IDENTICAL_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CASE_STRICT_SPEC_TMP_TMP):
				VM_TRACE(ZEND_CASE_STRICT_SPEC_TMP_TMP)
				ZEND_CASE_STRICT_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_IDENTICAL_SPEC_TMP_TMP):
				VM_TRACE(ZEND_IS_NOT_IDENTICAL_SPEC_TMP_TMP)
				ZEND_IS_NOT_IDENTICAL_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CASE_STRICT_SPEC_TMP_VAR):
				VM_TRACE(ZEND_CASE_STRICT_SPEC_TMP_VAR)
				ZEND_CASE_STRICT_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_UNUSED):
				VM_TRACE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_UNUSED)
				ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_VERIFY_RETURN_TYPE_SPEC_TMP_UNUSED):
				VM_TRACE(ZEND_VERIFY_RETURN_TYPE_SPEC_TMP_UNUSED)
				ZEND_VERIFY_RETURN_TYPE_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAL_EX_SPEC_TMP_UNUSED):
				VM_TRACE(ZEND_SEND_VAL_EX_SPEC_TMP_UNUSED)
				ZEND_SEND_VAL_EX_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAL_EX_SPEC_TMP_UNUSED_QUICK):
				VM_TRACE(ZEND_SEND_VAL_EX_SPEC_TMP_UNUSED_QUICK)
				ZEND_SEND_VAL_EX_SPEC_TMP_UNUSED_QUICK_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED):
				VM_TRACE(ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED)
				ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_ARRAY_SPEC_TMP_UNUSED):
				VM_TRACE(ZEND_INIT_ARRAY_SPEC_TMP_UNUSED)
				ZEND_INIT_ARRAY_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_YIELD_SPEC_TMP_UNUSED):
				VM_TRACE(ZEND_YIELD_SPEC_TMP_UNUSED)
				ZEND_YIELD_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_GET_TYPE_SPEC_TMP_UNUSED):
				VM_TRACE(ZEND_GET_TYPE_SPEC_TMP_UNUSED)
				ZEND_GET_TYPE_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CASE_STRICT_SPEC_TMP_CV):
				VM_TRACE(ZEND_CASE_STRICT_SPEC_TMP_CV)
				ZEND_CASE_STRICT_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_CV):
				VM_TRACE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_CV)
				ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CV):
				VM_TRACE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CV)
				ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ROPE_ADD_SPEC_TMP_CV):
				VM_TRACE(ZEND_ROPE_ADD_SPEC_TMP_CV)
				ZEND_ROPE_ADD_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ROPE_END_SPEC_TMP_CV):
				VM_TRACE(ZEND_ROPE_END_SPEC_TMP_CV)
				ZEND_ROPE_END_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV):
				VM_TRACE(ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV)
				ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_ARRAY_SPEC_TMP_CV):
				VM_TRACE(ZEND_INIT_ARRAY_SPEC_TMP_CV)
				ZEND_INIT_ARRAY_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_YIELD_SPEC_TMP_CV):
				VM_TRACE(ZEND_YIELD_SPEC_TMP_CV)
				ZEND_YIELD_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BIND_LEXICAL_SPEC_TMP_CV):
				VM_TRACE(ZEND_BIND_LEXICAL_SPEC_TMP_CV)
				ZEND_BIND_LEXICAL_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_INC_SPEC_VAR_RETVAL_UNUSED):
				VM_TRACE(ZEND_PRE_INC_SPEC_VAR_RETVAL_UNUSED)
				ZEND_PRE_INC_SPEC_VAR_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_INC_SPEC_VAR_RETVAL_USED):
				VM_TRACE(ZEND_PRE_INC_SPEC_VAR_RETVAL_USED)
				ZEND_PRE_INC_SPEC_VAR_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_DEC_SPEC_VAR_RETVAL_UNUSED):
				VM_TRACE(ZEND_PRE_DEC_SPEC_VAR_RETVAL_UNUSED)
				ZEND_PRE_DEC_SPEC_VAR_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_DEC_SPEC_VAR_RETVAL_USED):
				VM_TRACE(ZEND_PRE_DEC_SPEC_VAR_RETVAL_USED)
				ZEND_PRE_DEC_SPEC_VAR_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POST_INC_SPEC_VAR):
				VM_TRACE(ZEND_POST_INC_SPEC_VAR)
				ZEND_POST_INC_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POST_DEC_SPEC_VAR):
				VM_TRACE(ZEND_POST_DEC_SPEC_VAR)
				ZEND_POST_DEC_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_RETURN_SPEC_VAR):
				VM_TRACE(ZEND_RETURN_SPEC_VAR)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;

	retval_ptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	return_value = EX(return_value);
	if (IS_VAR == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(retval_ptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		retval_ptr = ZVAL_UNDEFINED_OP1();
		if (return_value) {
			ZVAL_NULL(return_value);
		}
	} else if (!return_value) {
		if (IS_VAR & (IS_VAR|IS_TMP_VAR)) {
			if (Z_REFCOUNTED_P(retval_ptr) && !Z_DELREF_P(retval_ptr)) {
				SAVE_OPLINE();
				rc_dtor_func(Z_COUNTED_P(retval_ptr));
			}
		}
	} else {
		if ((IS_VAR & (IS_CONST|IS_TMP_VAR))) {
			ZVAL_COPY_VALUE(return_value, retval_ptr);
			if (IS_VAR == IS_CONST) {
				if (UNEXPECTED(Z_OPT_REFCOUNTED_P(return_value))) {
					Z_ADDREF_P(return_value);
				}
			}
		} else if (IS_VAR == IS_CV) {
			do {
				if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
					if (EXPECTED(!Z_OPT_ISREF_P(retval_ptr))) {
						if (EXPECTED(!(EX_CALL_INFO() & ZEND_CALL_CODE))) {
							zend_refcounted *ref = Z_COUNTED_P(retval_ptr);
							ZVAL_COPY_VALUE(return_value, retval_ptr);
							if (GC_MAY_LEAK(ref)) {
								gc_possible_root(ref);
							}
							ZVAL_NULL(retval_ptr);
							break;
						} else {
							Z_ADDREF_P(retval_ptr);
						}
					} else {
						retval_ptr = Z_REFVAL_P(retval_ptr);
						if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
							Z_ADDREF_P(retval_ptr);
						}
					}
				}
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			} while (0);
		} else /* if (IS_VAR == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(retval_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(retval_ptr);

				retval_ptr = Z_REFVAL_P(retval_ptr);
				ZVAL_COPY_VALUE(return_value, retval_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
					Z_ADDREF_P(retval_ptr);
				}
			} else {
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			}
		}
	}

	goto zend_leave_helper_SPEC_LABEL;
}

			HYBRID_CASE(ZEND_RETURN_BY_REF_SPEC_VAR):
				VM_TRACE(ZEND_RETURN_BY_REF_SPEC_VAR)
				ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_GENERATOR_RETURN_SPEC_VAR):
				VM_TRACE(ZEND_GENERATOR_RETURN_SPEC_VAR)
				ZEND_GENERATOR_RETURN_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_USER_SPEC_VAR):
				VM_TRACE(ZEND_SEND_USER_SPEC_VAR)
				ZEND_SEND_USER_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CAST_SPEC_VAR):
				VM_TRACE(ZEND_CAST_SPEC_VAR)
				ZEND_CAST_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FE_RESET_R_SPEC_VAR):
				VM_TRACE(ZEND_FE_RESET_R_SPEC_VAR)
				ZEND_FE_RESET_R_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FE_RESET_RW_SPEC_VAR):
				VM_TRACE(ZEND_FE_RESET_RW_SPEC_VAR)
				ZEND_FE_RESET_RW_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FE_FETCH_R_SPEC_VAR):
				VM_TRACE(ZEND_FE_FETCH_R_SPEC_VAR)
				ZEND_FE_FETCH_R_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FE_FETCH_RW_SPEC_VAR):
				VM_TRACE(ZEND_FE_FETCH_RW_SPEC_VAR)
				ZEND_FE_FETCH_RW_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_JMP_SET_SPEC_VAR):
				VM_TRACE(ZEND_JMP_SET_SPEC_VAR)
				ZEND_JMP_SET_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_COALESCE_SPEC_VAR):
				VM_TRACE(ZEND_COALESCE_SPEC_VAR)
				ZEND_COALESCE_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_QM_ASSIGN_SPEC_VAR):
				VM_TRACE(ZEND_QM_ASSIGN_SPEC_VAR)
				ZEND_QM_ASSIGN_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAR_SIMPLE_SPEC_VAR):
				VM_TRACE(ZEND_SEND_VAR_SIMPLE_SPEC_VAR)
				ZEND_SEND_VAR_SIMPLE_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_IDENTICAL_SPEC_VAR_CONST):
				VM_TRACE(ZEND_IS_IDENTICAL_SPEC_VAR_CONST)
				ZEND_IS_IDENTICAL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CASE_STRICT_SPEC_VAR_CONST):
				VM_TRACE(ZEND_CASE_STRICT_SPEC_VAR_CONST)
				ZEND_CASE_STRICT_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CONST):
				VM_TRACE(ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CONST)
				ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_OP_SPEC_VAR_CONST):
				VM_TRACE(ZEND_ASSIGN_OBJ_OP_SPEC_VAR_CONST)
				ZEND_ASSIGN_OBJ_OP_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_OP_SPEC_VAR_CONST):
				VM_TRACE(ZEND_ASSIGN_DIM_OP_SPEC_VAR_CONST)
				ZEND_ASSIGN_DIM_OP_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OP_SPEC_VAR_CONST):
				VM_TRACE(ZEND_ASSIGN_OP_SPEC_VAR_CONST)
				ZEND_ASSIGN_OP_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_INC_OBJ_SPEC_VAR_CONST):
				VM_TRACE(ZEND_PRE_INC_OBJ_SPEC_VAR_CONST)
				ZEND_PRE_INC_OBJ_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POST_INC_OBJ_SPEC_VAR_CONST):
				VM_TRACE(ZEND_POST_INC_OBJ_SPEC_VAR_CONST)
				ZEND_POST_INC_OBJ_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_W_SPEC_VAR_CONST):
				VM_TRACE(ZEND_FETCH_DIM_W_SPEC_VAR_CONST)
				ZEND_FETCH_DIM_W_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_RW_SPEC_VAR_CONST):
				VM_TRACE(ZEND_FETCH_DIM_RW_SPEC_VAR_CONST)
				ZEND_FETCH_DIM_RW_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CONST):
				VM_TRACE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CONST)
				ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_UNSET_SPEC_VAR_CONST):
				VM_TRACE(ZEND_FETCH_DIM_UNSET_SPEC_VAR_CONST)
				ZEND_FETCH_DIM_UNSET_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_W_SPEC_VAR_CONST):
				VM_TRACE(ZEND_FETCH_OBJ_W_SPEC_VAR_CONST)
				ZEND_FETCH_OBJ_W_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_RW_SPEC_VAR_CONST):
				VM_TRACE(ZEND_FETCH_OBJ_RW_SPEC_VAR_CONST)
				ZEND_FETCH_OBJ_RW_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CONST):
				VM_TRACE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CONST)
				ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CONST):
				VM_TRACE(ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CONST)
				ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_LIST_W_SPEC_VAR_CONST):
				VM_TRACE(ZEND_FETCH_LIST_W_SPEC_VAR_CONST)
				ZEND_FETCH_LIST_W_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CONST):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CONST)
				ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_TMP):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_TMP)
				ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_VAR)
				ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CV)
				ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CONST):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CONST)
				ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_TMP):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_TMP)
				ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_VAR)
				ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CV)
				ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_SPEC_VAR_CONST_RETVAL_UNUSED):
				VM_TRACE(ZEND_ASSIGN_SPEC_VAR_CONST_RETVAL_UNUSED)
				ZEND_ASSIGN_SPEC_VAR_CONST_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_SPEC_VAR_CONST_RETVAL_USED):
				VM_TRACE(ZEND_ASSIGN_SPEC_VAR_CONST_RETVAL_USED)
				ZEND_ASSIGN_SPEC_VAR_CONST_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_VAR)
				ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_CV)
				ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CONST):
				VM_TRACE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CONST)
				ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAR_SPEC_VAR_CONST):
				VM_TRACE(ZEND_SEND_VAR_SPEC_VAR_CONST)
				ZEND_SEND_VAR_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAR_NO_REF_SPEC_VAR_CONST):
				VM_TRACE(ZEND_SEND_VAR_NO_REF_SPEC_VAR_CONST)
				ZEND_SEND_VAR_NO_REF_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAR_NO_REF_EX_SPEC_VAR_CONST):
				VM_TRACE(ZEND_SEND_VAR_NO_REF_EX_SPEC_VAR_CONST)
				ZEND_SEND_VAR_NO_REF_EX_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_REF_SPEC_VAR_CONST):
				VM_TRACE(ZEND_SEND_REF_SPEC_VAR_CONST)
				ZEND_SEND_REF_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAR_EX_SPEC_VAR_CONST):
				VM_TRACE(ZEND_SEND_VAR_EX_SPEC_VAR_CONST)
				ZEND_SEND_VAR_EX_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_FUNC_ARG_SPEC_VAR_CONST):
				VM_TRACE(ZEND_SEND_FUNC_ARG_SPEC_VAR_CONST)
				ZEND_SEND_FUNC_ARG_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_CLASS_CONSTANT_SPEC_VAR_CONST):
				VM_TRACE(ZEND_FETCH_CLASS_CONSTANT_SPEC_VAR_CONST)
				ZEND_FETCH_CLASS_CONSTANT_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST):
				VM_TRACE(ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST)
				ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_ARRAY_SPEC_VAR_CONST):
				VM_TRACE(ZEND_INIT_ARRAY_SPEC_VAR_CONST)
				ZEND_INIT_ARRAY_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_UNSET_DIM_SPEC_VAR_CONST):
				VM_TRACE(ZEND_UNSET_DIM_SPEC_VAR_CONST)
				ZEND_UNSET_DIM_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_UNSET_OBJ_SPEC_VAR_CONST):
				VM_TRACE(ZEND_UNSET_OBJ_SPEC_VAR_CONST)
				ZEND_UNSET_OBJ_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_YIELD_SPEC_VAR_CONST):
				VM_TRACE(ZEND_YIELD_SPEC_VAR_CONST)
				ZEND_YIELD_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IN_ARRAY_SPEC_VAR_CONST):
				VM_TRACE(ZEND_IN_ARRAY_SPEC_VAR_CONST)
				ZEND_IN_ARRAY_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_OP_SPEC_VAR_TMPVAR):
				VM_TRACE(ZEND_ASSIGN_OBJ_OP_SPEC_VAR_TMPVAR)
				ZEND_ASSIGN_OBJ_OP_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_OP_SPEC_VAR_TMPVAR):
				VM_TRACE(ZEND_ASSIGN_DIM_OP_SPEC_VAR_TMPVAR)
				ZEND_ASSIGN_DIM_OP_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OP_SPEC_VAR_TMPVAR):
				VM_TRACE(ZEND_ASSIGN_OP_SPEC_VAR_TMPVAR)
				ZEND_ASSIGN_OP_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_INC_OBJ_SPEC_VAR_TMPVAR):
				VM_TRACE(ZEND_PRE_INC_OBJ_SPEC_VAR_TMPVAR)
				ZEND_PRE_INC_OBJ_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POST_INC_OBJ_SPEC_VAR_TMPVAR):
				VM_TRACE(ZEND_POST_INC_OBJ_SPEC_VAR_TMPVAR)
				ZEND_POST_INC_OBJ_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_W_SPEC_VAR_TMPVAR):
				VM_TRACE(ZEND_FETCH_DIM_W_SPEC_VAR_TMPVAR)
				ZEND_FETCH_DIM_W_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_RW_SPEC_VAR_TMPVAR):
				VM_TRACE(ZEND_FETCH_DIM_RW_SPEC_VAR_TMPVAR)
				ZEND_FETCH_DIM_RW_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMPVAR):
				VM_TRACE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMPVAR)
				ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_UNSET_SPEC_VAR_TMPVAR):
				VM_TRACE(ZEND_FETCH_DIM_UNSET_SPEC_VAR_TMPVAR)
				ZEND_FETCH_DIM_UNSET_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_W_SPEC_VAR_TMPVAR):
				VM_TRACE(ZEND_FETCH_OBJ_W_SPEC_VAR_TMPVAR)
				ZEND_FETCH_OBJ_W_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_RW_SPEC_VAR_TMPVAR):
				VM_TRACE(ZEND_FETCH_OBJ_RW_SPEC_VAR_TMPVAR)
				ZEND_FETCH_OBJ_RW_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMPVAR):
				VM_TRACE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMPVAR)
				ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_UNSET_SPEC_VAR_TMPVAR):
				VM_TRACE(ZEND_FETCH_OBJ_UNSET_SPEC_VAR_TMPVAR)
				ZEND_FETCH_OBJ_UNSET_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_LIST_W_SPEC_VAR_TMPVAR):
				VM_TRACE(ZEND_FETCH_LIST_W_SPEC_VAR_TMPVAR)
				ZEND_FETCH_LIST_W_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CONST):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CONST)
				ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_TMP):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_TMP)
				ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_VAR)
				ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CV)
				ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CONST):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CONST)
				ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_TMP):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_TMP)
				ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_VAR)
				ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CV)
				ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_VAR)
				ZEND_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_CV)
				ZEND_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMPVAR):
				VM_TRACE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMPVAR)
				ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMPVAR):
				VM_TRACE(ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMPVAR)
				ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_ARRAY_SPEC_VAR_TMPVAR):
				VM_TRACE(ZEND_INIT_ARRAY_SPEC_VAR_TMPVAR)
				ZEND_INIT_ARRAY_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_UNSET_DIM_SPEC_VAR_TMPVAR):
				VM_TRACE(ZEND_UNSET_DIM_SPEC_VAR_TMPVAR)
				ZEND_UNSET_DIM_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_UNSET_OBJ_SPEC_VAR_TMPVAR):
				VM_TRACE(ZEND_UNSET_OBJ_SPEC_VAR_TMPVAR)
				ZEND_UNSET_OBJ_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_YIELD_SPEC_VAR_TMPVAR):
				VM_TRACE(ZEND_YIELD_SPEC_VAR_TMPVAR)
				ZEND_YIELD_SPEC_VAR_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_IDENTICAL_SPEC_VAR_TMP):
				VM_TRACE(ZEND_IS_IDENTICAL_SPEC_VAR_TMP)
				ZEND_IS_IDENTICAL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CASE_STRICT_SPEC_VAR_TMP):
				VM_TRACE(ZEND_CASE_STRICT_SPEC_VAR_TMP)
				ZEND_CASE_STRICT_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_IDENTICAL_SPEC_VAR_TMP):
				VM_TRACE(ZEND_IS_NOT_IDENTICAL_SPEC_VAR_TMP)
				ZEND_IS_NOT_IDENTICAL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_SPEC_VAR_TMP_RETVAL_UNUSED):
				VM_TRACE(ZEND_ASSIGN_SPEC_VAR_TMP_RETVAL_UNUSED)
				ZEND_ASSIGN_SPEC_VAR_TMP_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_SPEC_VAR_TMP_RETVAL_USED):
				VM_TRACE(ZEND_ASSIGN_SPEC_VAR_TMP_RETVAL_USED)
				ZEND_ASSIGN_SPEC_VAR_TMP_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_IDENTICAL_SPEC_VAR_VAR):
				VM_TRACE(ZEND_IS_IDENTICAL_SPEC_VAR_VAR)
				ZEND_IS_IDENTICAL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CASE_STRICT_SPEC_VAR_VAR):
				VM_TRACE(ZEND_CASE_STRICT_SPEC_VAR_VAR)
				ZEND_CASE_STRICT_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_IDENTICAL_SPEC_VAR_VAR):
				VM_TRACE(ZEND_IS_NOT_IDENTICAL_SPEC_VAR_VAR)
				ZEND_IS_NOT_IDENTICAL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_SPEC_VAR_VAR_RETVAL_UNUSED):
				VM_TRACE(ZEND_ASSIGN_SPEC_VAR_VAR_RETVAL_UNUSED)
				ZEND_ASSIGN_SPEC_VAR_VAR_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_SPEC_VAR_VAR_RETVAL_USED):
				VM_TRACE(ZEND_ASSIGN_SPEC_VAR_VAR_RETVAL_USED)
				ZEND_ASSIGN_SPEC_VAR_VAR_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_REF_SPEC_VAR_VAR):
				VM_TRACE(ZEND_ASSIGN_REF_SPEC_VAR_VAR)
				ZEND_ASSIGN_REF_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_OP_SPEC_VAR_UNUSED):
				VM_TRACE(ZEND_ASSIGN_DIM_OP_SPEC_VAR_UNUSED)
				ZEND_ASSIGN_DIM_OP_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_W_SPEC_VAR_UNUSED):
				VM_TRACE(ZEND_FETCH_DIM_W_SPEC_VAR_UNUSED)
				ZEND_FETCH_DIM_W_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_RW_SPEC_VAR_UNUSED):
				VM_TRACE(ZEND_FETCH_DIM_RW_SPEC_VAR_UNUSED)
				ZEND_FETCH_DIM_RW_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_UNUSED):
				VM_TRACE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_UNUSED)
				ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CONST):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CONST)
				ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_TMP):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_TMP)
				ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_VAR)
				ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CV)
				ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_UNUSED):
				VM_TRACE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_UNUSED)
				ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_VERIFY_RETURN_TYPE_SPEC_VAR_UNUSED):
				VM_TRACE(ZEND_VERIFY_RETURN_TYPE_SPEC_VAR_UNUSED)
				ZEND_VERIFY_RETURN_TYPE_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAR_SPEC_VAR_UNUSED):
				VM_TRACE(ZEND_SEND_VAR_SPEC_VAR_UNUSED)
				ZEND_SEND_VAR_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAR_NO_REF_SPEC_VAR_UNUSED):
				VM_TRACE(ZEND_SEND_VAR_NO_REF_SPEC_VAR_UNUSED)
				ZEND_SEND_VAR_NO_REF_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED):
				VM_TRACE(ZEND_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED)
				ZEND_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED_QUICK):
				VM_TRACE(ZEND_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED_QUICK)
				ZEND_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED_QUICK_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_REF_SPEC_VAR_UNUSED):
				VM_TRACE(ZEND_SEND_REF_SPEC_VAR_UNUSED)
				ZEND_SEND_REF_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAR_EX_SPEC_VAR_UNUSED):
				VM_TRACE(ZEND_SEND_VAR_EX_SPEC_VAR_UNUSED)
				ZEND_SEND_VAR_EX_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAR_EX_SPEC_VAR_UNUSED_QUICK):
				VM_TRACE(ZEND_SEND_VAR_EX_SPEC_VAR_UNUSED_QUICK)
				ZEND_SEND_VAR_EX_SPEC_VAR_UNUSED_QUICK_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_FUNC_ARG_SPEC_VAR_UNUSED):
				VM_TRACE(ZEND_SEND_FUNC_ARG_SPEC_VAR_UNUSED)
				ZEND_SEND_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_NEW_SPEC_VAR_UNUSED):
				VM_TRACE(ZEND_NEW_SPEC_VAR_UNUSED)
				ZEND_NEW_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED):
				VM_TRACE(ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED)
				ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_ARRAY_SPEC_VAR_UNUSED):
				VM_TRACE(ZEND_INIT_ARRAY_SPEC_VAR_UNUSED)
				ZEND_INIT_ARRAY_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEPARATE_SPEC_VAR_UNUSED):
				VM_TRACE(ZEND_SEPARATE_SPEC_VAR_UNUSED)
				ZEND_SEPARATE_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_YIELD_SPEC_VAR_UNUSED):
				VM_TRACE(ZEND_YIELD_SPEC_VAR_UNUSED)
				ZEND_YIELD_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_MAKE_REF_SPEC_VAR_UNUSED):
				VM_TRACE(ZEND_MAKE_REF_SPEC_VAR_UNUSED)
				ZEND_MAKE_REF_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_GET_TYPE_SPEC_VAR_UNUSED):
				VM_TRACE(ZEND_GET_TYPE_SPEC_VAR_UNUSED)
				ZEND_GET_TYPE_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAR_EX_SIMPLE_SPEC_VAR_UNUSED):
				VM_TRACE(ZEND_SEND_VAR_EX_SIMPLE_SPEC_VAR_UNUSED)
				ZEND_SEND_VAR_EX_SIMPLE_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CASE_STRICT_SPEC_VAR_CV):
				VM_TRACE(ZEND_CASE_STRICT_SPEC_VAR_CV)
				ZEND_CASE_STRICT_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_OP_SPEC_VAR_CV):
				VM_TRACE(ZEND_ASSIGN_OBJ_OP_SPEC_VAR_CV)
				ZEND_ASSIGN_OBJ_OP_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_OP_SPEC_VAR_CV):
				VM_TRACE(ZEND_ASSIGN_DIM_OP_SPEC_VAR_CV)
				ZEND_ASSIGN_DIM_OP_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OP_SPEC_VAR_CV):
				VM_TRACE(ZEND_ASSIGN_OP_SPEC_VAR_CV)
				ZEND_ASSIGN_OP_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_INC_OBJ_SPEC_VAR_CV):
				VM_TRACE(ZEND_PRE_INC_OBJ_SPEC_VAR_CV)
				ZEND_PRE_INC_OBJ_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POST_INC_OBJ_SPEC_VAR_CV):
				VM_TRACE(ZEND_POST_INC_OBJ_SPEC_VAR_CV)
				ZEND_POST_INC_OBJ_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_W_SPEC_VAR_CV):
				VM_TRACE(ZEND_FETCH_DIM_W_SPEC_VAR_CV)
				ZEND_FETCH_DIM_W_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_RW_SPEC_VAR_CV):
				VM_TRACE(ZEND_FETCH_DIM_RW_SPEC_VAR_CV)
				ZEND_FETCH_DIM_RW_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CV):
				VM_TRACE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CV)
				ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_UNSET_SPEC_VAR_CV):
				VM_TRACE(ZEND_FETCH_DIM_UNSET_SPEC_VAR_CV)
				ZEND_FETCH_DIM_UNSET_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_W_SPEC_VAR_CV):
				VM_TRACE(ZEND_FETCH_OBJ_W_SPEC_VAR_CV)
				ZEND_FETCH_OBJ_W_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_RW_SPEC_VAR_CV):
				VM_TRACE(ZEND_FETCH_OBJ_RW_SPEC_VAR_CV)
				ZEND_FETCH_OBJ_RW_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV):
				VM_TRACE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV)
				ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CV):
				VM_TRACE(ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CV)
				ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_LIST_W_SPEC_VAR_CV):
				VM_TRACE(ZEND_FETCH_LIST_W_SPEC_VAR_CV)
				ZEND_FETCH_LIST_W_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CONST):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CONST)
				ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_TMP):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_TMP)
				ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_VAR)
				ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CV)
				ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CONST):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CONST)
				ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_TMP):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_TMP)
				ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_VAR)
				ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CV)
				ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_SPEC_VAR_CV_RETVAL_UNUSED):
				VM_TRACE(ZEND_ASSIGN_SPEC_VAR_CV_RETVAL_UNUSED)
				ZEND_ASSIGN_SPEC_VAR_CV_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_SPEC_VAR_CV_RETVAL_USED):
				VM_TRACE(ZEND_ASSIGN_SPEC_VAR_CV_RETVAL_USED)
				ZEND_ASSIGN_SPEC_VAR_CV_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_REF_SPEC_VAR_CV):
				VM_TRACE(ZEND_ASSIGN_REF_SPEC_VAR_CV)
				ZEND_ASSIGN_REF_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_VAR)
				ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_CV)
				ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CV):
				VM_TRACE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CV)
				ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV):
				VM_TRACE(ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV)
				ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_ARRAY_SPEC_VAR_CV):
				VM_TRACE(ZEND_INIT_ARRAY_SPEC_VAR_CV)
				ZEND_INIT_ARRAY_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_UNSET_DIM_SPEC_VAR_CV):
				VM_TRACE(ZEND_UNSET_DIM_SPEC_VAR_CV)
				ZEND_UNSET_DIM_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_UNSET_OBJ_SPEC_VAR_CV):
				VM_TRACE(ZEND_UNSET_OBJ_SPEC_VAR_CV)
				ZEND_UNSET_OBJ_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_YIELD_SPEC_VAR_CV):
				VM_TRACE(ZEND_YIELD_SPEC_VAR_CV)
				ZEND_YIELD_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_UNUSED):
				VM_TRACE(ZEND_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_UNUSED)
				ZEND_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_USED):
				VM_TRACE(ZEND_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_USED)
				ZEND_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CLONE_SPEC_UNUSED):
				VM_TRACE(ZEND_CLONE_SPEC_UNUSED)
				ZEND_CLONE_SPEC_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_CLASS_NAME_SPEC_UNUSED):
				VM_TRACE(ZEND_FETCH_CLASS_NAME_SPEC_UNUSED)
				ZEND_FETCH_CLASS_NAME_SPEC_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_OP_SPEC_UNUSED_CONST):
				VM_TRACE(ZEND_ASSIGN_OBJ_OP_SPEC_UNUSED_CONST)
				ZEND_ASSIGN_OBJ_OP_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_INC_OBJ_SPEC_UNUSED_CONST):
				VM_TRACE(ZEND_PRE_INC_OBJ_SPEC_UNUSED_CONST)
				ZEND_PRE_INC_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POST_INC_OBJ_SPEC_UNUSED_CONST):
				VM_TRACE(ZEND_POST_INC_OBJ_SPEC_UNUSED_CONST)
				ZEND_POST_INC_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_R_SPEC_UNUSED_CONST):
				VM_TRACE(ZEND_FETCH_OBJ_R_SPEC_UNUSED_CONST)
				ZEND_FETCH_OBJ_R_SPEC_UNUSED_CONST_INLINE_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_W_SPEC_UNUSED_CONST):
				VM_TRACE(ZEND_FETCH_OBJ_W_SPEC_UNUSED_CONST)
				ZEND_FETCH_OBJ_W_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CONST):
				VM_TRACE(ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CONST)
				ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CONST):
				VM_TRACE(ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CONST)
				ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CONST):
				VM_TRACE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CONST)
				ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CONST):
				VM_TRACE(ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CONST)
				ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CONST):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CONST)
				ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_TMP):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_TMP)
				ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_VAR)
				ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CV)
				ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_VAR)
				ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_CV)
				ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ROPE_INIT_SPEC_UNUSED_CONST):
				VM_TRACE(ZEND_ROPE_INIT_SPEC_UNUSED_CONST)
				ZEND_ROPE_INIT_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_CLASS_SPEC_UNUSED_CONST):
				VM_TRACE(ZEND_FETCH_CLASS_SPEC_UNUSED_CONST)
				ZEND_FETCH_CLASS_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CONST):
				VM_TRACE(ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CONST)
				ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CONST):
				VM_TRACE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CONST)
				ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CHECK_FUNC_ARG_SPEC_UNUSED_CONST):
				VM_TRACE(ZEND_CHECK_FUNC_ARG_SPEC_UNUSED_CONST)
				ZEND_CHECK_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_CONSTANT_SPEC_UNUSED_CONST):
				VM_TRACE(ZEND_FETCH_CONSTANT_SPEC_UNUSED_CONST)
				ZEND_FETCH_CONSTANT_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_CLASS_CONSTANT_SPEC_UNUSED_CONST):
				VM_TRACE(ZEND_FETCH_CLASS_CONSTANT_SPEC_UNUSED_CONST)
				ZEND_FETCH_CLASS_CONSTANT_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_ARRAY_SPEC_UNUSED_CONST):
				VM_TRACE(ZEND_INIT_ARRAY_SPEC_UNUSED_CONST)
				ZEND_INIT_ARRAY_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_UNSET_OBJ_SPEC_UNUSED_CONST):
				VM_TRACE(ZEND_UNSET_OBJ_SPEC_UNUSED_CONST)
				ZEND_UNSET_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CONST):
				VM_TRACE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CONST)
				ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_YIELD_SPEC_UNUSED_CONST):
				VM_TRACE(ZEND_YIELD_SPEC_UNUSED_CONST)
				ZEND_YIELD_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_OP_SPEC_UNUSED_TMPVAR):
				VM_TRACE(ZEND_ASSIGN_OBJ_OP_SPEC_UNUSED_TMPVAR)
				ZEND_ASSIGN_OBJ_OP_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_INC_OBJ_SPEC_UNUSED_TMPVAR):
				VM_TRACE(ZEND_PRE_INC_OBJ_SPEC_UNUSED_TMPVAR)
				ZEND_PRE_INC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POST_INC_OBJ_SPEC_UNUSED_TMPVAR):
				VM_TRACE(ZEND_POST_INC_OBJ_SPEC_UNUSED_TMPVAR)
				ZEND_POST_INC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_R_SPEC_UNUSED_TMPVAR):
				VM_TRACE(ZEND_FETCH_OBJ_R_SPEC_UNUSED_TMPVAR)
				ZEND_FETCH_OBJ_R_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_W_SPEC_UNUSED_TMPVAR):
				VM_TRACE(ZEND_FETCH_OBJ_W_SPEC_UNUSED_TMPVAR)
				ZEND_FETCH_OBJ_W_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_RW_SPEC_UNUSED_TMPVAR):
				VM_TRACE(ZEND_FETCH_OBJ_RW_SPEC_UNUSED_TMPVAR)
				ZEND_FETCH_OBJ_RW_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_IS_SPEC_UNUSED_TMPVAR):
				VM_TRACE(ZEND_FETCH_OBJ_IS_SPEC_UNUSED_TMPVAR)
				ZEND_FETCH_OBJ_IS_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMPVAR):
				VM_TRACE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMPVAR)
				ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_TMPVAR):
				VM_TRACE(ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_TMPVAR)
				ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CONST):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CONST)
				ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_TMP):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_TMP)
				ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_VAR)
				ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CV)
				ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_VAR)
				ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_CV)
				ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ROPE_INIT_SPEC_UNUSED_TMPVAR):
				VM_TRACE(ZEND_ROPE_INIT_SPEC_UNUSED_TMPVAR)
				ZEND_ROPE_INIT_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_CLASS_SPEC_UNUSED_TMPVAR):
				VM_TRACE(ZEND_FETCH_CLASS_SPEC_UNUSED_TMPVAR)
				ZEND_FETCH_CLASS_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_METHOD_CALL_SPEC_UNUSED_TMPVAR):
				VM_TRACE(ZEND_INIT_METHOD_CALL_SPEC_UNUSED_TMPVAR)
				ZEND_INIT_METHOD_CALL_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_TMPVAR):
				VM_TRACE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_TMPVAR)
				ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_ARRAY_SPEC_UNUSED_TMPVAR):
				VM_TRACE(ZEND_INIT_ARRAY_SPEC_UNUSED_TMPVAR)
				ZEND_INIT_ARRAY_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_UNSET_OBJ_SPEC_UNUSED_TMPVAR):
				VM_TRACE(ZEND_UNSET_OBJ_SPEC_UNUSED_TMPVAR)
				ZEND_UNSET_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMPVAR):
				VM_TRACE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMPVAR)
				ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_YIELD_SPEC_UNUSED_TMPVAR):
				VM_TRACE(ZEND_YIELD_SPEC_UNUSED_TMPVAR)
				ZEND_YIELD_SPEC_UNUSED_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_CLASS_SPEC_UNUSED_UNUSED):
				VM_TRACE(ZEND_FETCH_CLASS_SPEC_UNUSED_UNUSED)
				ZEND_FETCH_CLASS_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_UNUSED):
				VM_TRACE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_UNUSED)
				ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_VERIFY_RETURN_TYPE_SPEC_UNUSED_UNUSED):
				VM_TRACE(ZEND_VERIFY_RETURN_TYPE_SPEC_UNUSED_UNUSED)
				ZEND_VERIFY_RETURN_TYPE_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED):
				VM_TRACE(ZEND_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED)
				ZEND_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED_QUICK):
				VM_TRACE(ZEND_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED_QUICK)
				ZEND_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED_QUICK_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CHECK_UNDEF_ARGS_SPEC_UNUSED_UNUSED):
				VM_TRACE(ZEND_CHECK_UNDEF_ARGS_SPEC_UNUSED_UNUSED)
				ZEND_CHECK_UNDEF_ARGS_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_NEW_SPEC_UNUSED_UNUSED):
				VM_TRACE(ZEND_NEW_SPEC_UNUSED_UNUSED)
				ZEND_NEW_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_ARRAY_SPEC_UNUSED_UNUSED):
				VM_TRACE(ZEND_INIT_ARRAY_SPEC_UNUSED_UNUSED)
				ZEND_INIT_ARRAY_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_YIELD_SPEC_UNUSED_UNUSED):
				VM_TRACE(ZEND_YIELD_SPEC_UNUSED_UNUSED)
				ZEND_YIELD_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_THIS_SPEC_UNUSED_UNUSED):
				VM_TRACE(ZEND_FETCH_THIS_SPEC_UNUSED_UNUSED)
				ZEND_FETCH_THIS_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_THIS_SPEC_UNUSED_UNUSED):
				VM_TRACE(ZEND_ISSET_ISEMPTY_THIS_SPEC_UNUSED_UNUSED)
				ZEND_ISSET_ISEMPTY_THIS_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_GET_CLASS_SPEC_UNUSED_UNUSED):
				VM_TRACE(ZEND_GET_CLASS_SPEC_UNUSED_UNUSED)
				ZEND_GET_CLASS_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_GET_CALLED_CLASS_SPEC_UNUSED_UNUSED):
				VM_TRACE(ZEND_GET_CALLED_CLASS_SPEC_UNUSED_UNUSED)
				ZEND_GET_CALLED_CLASS_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FUNC_NUM_ARGS_SPEC_UNUSED_UNUSED):
				VM_TRACE(ZEND_FUNC_NUM_ARGS_SPEC_UNUSED_UNUSED)
				ZEND_FUNC_NUM_ARGS_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FUNC_GET_ARGS_SPEC_UNUSED_UNUSED):
				VM_TRACE(ZEND_FUNC_GET_ARGS_SPEC_UNUSED_UNUSED)
				ZEND_FUNC_GET_ARGS_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_OP_SPEC_UNUSED_CV):
				VM_TRACE(ZEND_ASSIGN_OBJ_OP_SPEC_UNUSED_CV)
				ZEND_ASSIGN_OBJ_OP_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_INC_OBJ_SPEC_UNUSED_CV):
				VM_TRACE(ZEND_PRE_INC_OBJ_SPEC_UNUSED_CV)
				ZEND_PRE_INC_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POST_INC_OBJ_SPEC_UNUSED_CV):
				VM_TRACE(ZEND_POST_INC_OBJ_SPEC_UNUSED_CV)
				ZEND_POST_INC_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_R_SPEC_UNUSED_CV):
				VM_TRACE(ZEND_FETCH_OBJ_R_SPEC_UNUSED_CV)
				ZEND_FETCH_OBJ_R_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_W_SPEC_UNUSED_CV):
				VM_TRACE(ZEND_FETCH_OBJ_W_SPEC_UNUSED_CV)
				ZEND_FETCH_OBJ_W_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CV):
				VM_TRACE(ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CV)
				ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CV):
				VM_TRACE(ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CV)
				ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CV):
				VM_TRACE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CV)
				ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CV):
				VM_TRACE(ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CV)
				ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CONST):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CONST)
				ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_TMP):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_TMP)
				ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_VAR)
				ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CV)
				ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_VAR)
				ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_CV)
				ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ROPE_INIT_SPEC_UNUSED_CV):
				VM_TRACE(ZEND_ROPE_INIT_SPEC_UNUSED_CV)
				ZEND_ROPE_INIT_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_CLASS_SPEC_UNUSED_CV):
				VM_TRACE(ZEND_FETCH_CLASS_SPEC_UNUSED_CV)
				ZEND_FETCH_CLASS_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CV):
				VM_TRACE(ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CV)
				ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CV):
				VM_TRACE(ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CV)
				ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_ARRAY_SPEC_UNUSED_CV):
				VM_TRACE(ZEND_INIT_ARRAY_SPEC_UNUSED_CV)
				ZEND_INIT_ARRAY_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_UNSET_OBJ_SPEC_UNUSED_CV):
				VM_TRACE(ZEND_UNSET_OBJ_SPEC_UNUSED_CV)
				ZEND_UNSET_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CV):
				VM_TRACE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CV)
				ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_YIELD_SPEC_UNUSED_CV):
				VM_TRACE(ZEND_YIELD_SPEC_UNUSED_CV)
				ZEND_YIELD_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BOOL_NOT_SPEC_CV):
				VM_TRACE(ZEND_BOOL_NOT_SPEC_CV)
				ZEND_BOOL_NOT_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_INC_SPEC_CV_RETVAL_UNUSED):
				VM_TRACE(ZEND_PRE_INC_SPEC_CV_RETVAL_UNUSED)
				ZEND_PRE_INC_SPEC_CV_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_INC_SPEC_CV_RETVAL_USED):
				VM_TRACE(ZEND_PRE_INC_SPEC_CV_RETVAL_USED)
				ZEND_PRE_INC_SPEC_CV_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_DEC_SPEC_CV_RETVAL_UNUSED):
				VM_TRACE(ZEND_PRE_DEC_SPEC_CV_RETVAL_UNUSED)
				ZEND_PRE_DEC_SPEC_CV_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_DEC_SPEC_CV_RETVAL_USED):
				VM_TRACE(ZEND_PRE_DEC_SPEC_CV_RETVAL_USED)
				ZEND_PRE_DEC_SPEC_CV_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POST_INC_SPEC_CV):
				VM_TRACE(ZEND_POST_INC_SPEC_CV)
				ZEND_POST_INC_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POST_DEC_SPEC_CV):
				VM_TRACE(ZEND_POST_DEC_SPEC_CV)
				ZEND_POST_DEC_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ECHO_SPEC_CV):
				VM_TRACE(ZEND_ECHO_SPEC_CV)
				ZEND_ECHO_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_JMPZ_SPEC_CV):
				VM_TRACE(ZEND_JMPZ_SPEC_CV)
				ZEND_JMPZ_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_JMPNZ_SPEC_CV):
				VM_TRACE(ZEND_JMPNZ_SPEC_CV)
				ZEND_JMPNZ_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_JMPZNZ_SPEC_CV):
				VM_TRACE(ZEND_JMPZNZ_SPEC_CV)
				ZEND_JMPZNZ_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_JMPZ_EX_SPEC_CV):
				VM_TRACE(ZEND_JMPZ_EX_SPEC_CV)
				ZEND_JMPZ_EX_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_JMPNZ_EX_SPEC_CV):
				VM_TRACE(ZEND_JMPNZ_EX_SPEC_CV)
				ZEND_JMPNZ_EX_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_RETURN_SPEC_CV):
				VM_TRACE(ZEND_RETURN_SPEC_CV)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;

	retval_ptr = EX_VAR(opline->op1.var);
	return_value = EX(return_value);
	if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_INFO_P(retval_ptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		retval_ptr = ZVAL_UNDEFINED_OP1();
		if (return_value) {
			ZVAL_NULL(return_value);
		}
	} else if (!return_value) {
		if (IS_CV & (IS_VAR|IS_TMP_VAR)) {
			if (Z_REFCOUNTED_P(retval_ptr) && !Z_DELREF_P(retval_ptr)) {
				SAVE_OPLINE();
				rc_dtor_func(Z_COUNTED_P(retval_ptr));
			}
		}
	} else {
		if ((IS_CV & (IS_CONST|IS_TMP_VAR))) {
			ZVAL_COPY_VALUE(return_value, retval_ptr);
			if (IS_CV == IS_CONST) {
				if (UNEXPECTED(Z_OPT_REFCOUNTED_P(return_value))) {
					Z_ADDREF_P(return_value);
				}
			}
		} else if (IS_CV == IS_CV) {
			do {
				if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
					if (EXPECTED(!Z_OPT_ISREF_P(retval_ptr))) {
						if (EXPECTED(!(EX_CALL_INFO() & ZEND_CALL_CODE))) {
							zend_refcounted *ref = Z_COUNTED_P(retval_ptr);
							ZVAL_COPY_VALUE(return_value, retval_ptr);
							if (GC_MAY_LEAK(ref)) {
								gc_possible_root(ref);
							}
							ZVAL_NULL(retval_ptr);
							break;
						} else {
							Z_ADDREF_P(retval_ptr);
						}
					} else {
						retval_ptr = Z_REFVAL_P(retval_ptr);
						if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
							Z_ADDREF_P(retval_ptr);
						}
					}
				}
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			} while (0);
		} else /* if (IS_CV == IS_VAR) */ {
			if (UNEXPECTED(Z_ISREF_P(retval_ptr))) {
				zend_refcounted *ref = Z_COUNTED_P(retval_ptr);

				retval_ptr = Z_REFVAL_P(retval_ptr);
				ZVAL_COPY_VALUE(return_value, retval_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					efree_size(ref, sizeof(zend_reference));
				} else if (Z_OPT_REFCOUNTED_P(retval_ptr)) {
					Z_ADDREF_P(retval_ptr);
				}
			} else {
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			}
		}
	}

	goto zend_leave_helper_SPEC_LABEL;
}

			HYBRID_CASE(ZEND_RETURN_BY_REF_SPEC_CV):
				VM_TRACE(ZEND_RETURN_BY_REF_SPEC_CV)
				ZEND_RETURN_BY_REF_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_GENERATOR_RETURN_SPEC_CV):
				VM_TRACE(ZEND_GENERATOR_RETURN_SPEC_CV)
				ZEND_GENERATOR_RETURN_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_THROW_SPEC_CV):
				VM_TRACE(ZEND_THROW_SPEC_CV)
				ZEND_THROW_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_USER_SPEC_CV):
				VM_TRACE(ZEND_SEND_USER_SPEC_CV)
				ZEND_SEND_USER_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BOOL_SPEC_CV):
				VM_TRACE(ZEND_BOOL_SPEC_CV)
				ZEND_BOOL_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CLONE_SPEC_CV):
				VM_TRACE(ZEND_CLONE_SPEC_CV)
				ZEND_CLONE_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CAST_SPEC_CV):
				VM_TRACE(ZEND_CAST_SPEC_CV)
				ZEND_CAST_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INCLUDE_OR_EVAL_SPEC_CV):
				VM_TRACE(ZEND_INCLUDE_OR_EVAL_SPEC_CV)
				ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FE_RESET_R_SPEC_CV):
				VM_TRACE(ZEND_FE_RESET_R_SPEC_CV)
				ZEND_FE_RESET_R_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FE_RESET_RW_SPEC_CV):
				VM_TRACE(ZEND_FE_RESET_RW_SPEC_CV)
				ZEND_FE_RESET_RW_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_JMP_SET_SPEC_CV):
				VM_TRACE(ZEND_JMP_SET_SPEC_CV)
				ZEND_JMP_SET_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_COALESCE_SPEC_CV):
				VM_TRACE(ZEND_COALESCE_SPEC_CV)
				ZEND_COALESCE_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_QM_ASSIGN_SPEC_CV):
				VM_TRACE(ZEND_QM_ASSIGN_SPEC_CV)
				ZEND_QM_ASSIGN_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_YIELD_FROM_SPEC_CV):
				VM_TRACE(ZEND_YIELD_FROM_SPEC_CV)
				ZEND_YIELD_FROM_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_STRLEN_SPEC_CV):
				VM_TRACE(ZEND_STRLEN_SPEC_CV)
				ZEND_STRLEN_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_TYPE_CHECK_SPEC_CV):
				VM_TRACE(ZEND_TYPE_CHECK_SPEC_CV)
				ZEND_TYPE_CHECK_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_CLASS_NAME_SPEC_CV):
				VM_TRACE(ZEND_FETCH_CLASS_NAME_SPEC_CV)
				ZEND_FETCH_CLASS_NAME_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED):
				VM_TRACE(ZEND_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED)
				ZEND_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED):
				VM_TRACE(ZEND_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED)
				ZEND_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_INC_LONG_SPEC_CV_RETVAL_UNUSED):
				VM_TRACE(ZEND_PRE_INC_LONG_SPEC_CV_RETVAL_UNUSED)
				ZEND_PRE_INC_LONG_SPEC_CV_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_INC_LONG_SPEC_CV_RETVAL_USED):
				VM_TRACE(ZEND_PRE_INC_LONG_SPEC_CV_RETVAL_USED)
				ZEND_PRE_INC_LONG_SPEC_CV_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED):
				VM_TRACE(ZEND_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED)
				ZEND_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED):
				VM_TRACE(ZEND_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED)
				ZEND_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_DEC_LONG_SPEC_CV_RETVAL_UNUSED):
				VM_TRACE(ZEND_PRE_DEC_LONG_SPEC_CV_RETVAL_UNUSED)
				ZEND_PRE_DEC_LONG_SPEC_CV_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_DEC_LONG_SPEC_CV_RETVAL_USED):
				VM_TRACE(ZEND_PRE_DEC_LONG_SPEC_CV_RETVAL_USED)
				ZEND_PRE_DEC_LONG_SPEC_CV_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POST_INC_LONG_NO_OVERFLOW_SPEC_CV):
				VM_TRACE(ZEND_POST_INC_LONG_NO_OVERFLOW_SPEC_CV)
				ZEND_POST_INC_LONG_NO_OVERFLOW_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POST_INC_LONG_SPEC_CV):
				VM_TRACE(ZEND_POST_INC_LONG_SPEC_CV)
				ZEND_POST_INC_LONG_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POST_DEC_LONG_NO_OVERFLOW_SPEC_CV):
				VM_TRACE(ZEND_POST_DEC_LONG_NO_OVERFLOW_SPEC_CV)
				ZEND_POST_DEC_LONG_NO_OVERFLOW_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POST_DEC_LONG_SPEC_CV):
				VM_TRACE(ZEND_POST_DEC_LONG_SPEC_CV)
				ZEND_POST_DEC_LONG_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAR_SIMPLE_SPEC_CV):
				VM_TRACE(ZEND_SEND_VAR_SIMPLE_SPEC_CV)
				ZEND_SEND_VAR_SIMPLE_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DIV_SPEC_CV_CONST):
				VM_TRACE(ZEND_DIV_SPEC_CV_CONST)
				ZEND_DIV_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POW_SPEC_CV_CONST):
				VM_TRACE(ZEND_POW_SPEC_CV_CONST)
				ZEND_POW_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CONCAT_SPEC_CV_CONST):
				VM_TRACE(ZEND_CONCAT_SPEC_CV_CONST)
				ZEND_CONCAT_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_IDENTICAL_SPEC_CV_CONST):
				VM_TRACE(ZEND_IS_IDENTICAL_SPEC_CV_CONST)
				ZEND_IS_IDENTICAL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_IDENTICAL_SPEC_CV_CONST):
				VM_TRACE(ZEND_IS_NOT_IDENTICAL_SPEC_CV_CONST)
				ZEND_IS_NOT_IDENTICAL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_SPEC_CV_CONST):
				VM_TRACE(ZEND_IS_EQUAL_SPEC_CV_CONST)
				ZEND_IS_EQUAL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_SPEC_CV_CONST_JMPZ):
				VM_TRACE(ZEND_IS_EQUAL_SPEC_CV_CONST_JMPZ)
				ZEND_IS_EQUAL_SPEC_CV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_SPEC_CV_CONST_JMPNZ):
				VM_TRACE(ZEND_IS_EQUAL_SPEC_CV_CONST_JMPNZ)
				ZEND_IS_EQUAL_SPEC_CV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_SPEC_CV_CONST):
				VM_TRACE(ZEND_IS_NOT_EQUAL_SPEC_CV_CONST)
				ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_JMPZ):
				VM_TRACE(ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_JMPZ)
				ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_JMPNZ):
				VM_TRACE(ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_JMPNZ)
				ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SPACESHIP_SPEC_CV_CONST):
				VM_TRACE(ZEND_SPACESHIP_SPEC_CV_CONST)
				ZEND_SPACESHIP_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BOOL_XOR_SPEC_CV_CONST):
				VM_TRACE(ZEND_BOOL_XOR_SPEC_CV_CONST)
				ZEND_BOOL_XOR_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_OP_SPEC_CV_CONST):
				VM_TRACE(ZEND_ASSIGN_OBJ_OP_SPEC_CV_CONST)
				ZEND_ASSIGN_OBJ_OP_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_OP_SPEC_CV_CONST):
				VM_TRACE(ZEND_ASSIGN_DIM_OP_SPEC_CV_CONST)
				ZEND_ASSIGN_DIM_OP_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OP_SPEC_CV_CONST):
				VM_TRACE(ZEND_ASSIGN_OP_SPEC_CV_CONST)
				ZEND_ASSIGN_OP_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_INC_OBJ_SPEC_CV_CONST):
				VM_TRACE(ZEND_PRE_INC_OBJ_SPEC_CV_CONST)
				ZEND_PRE_INC_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POST_INC_OBJ_SPEC_CV_CONST):
				VM_TRACE(ZEND_POST_INC_OBJ_SPEC_CV_CONST)
				ZEND_POST_INC_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_R_SPEC_CV_CONST):
				VM_TRACE(ZEND_FETCH_DIM_R_SPEC_CV_CONST)
				ZEND_FETCH_DIM_R_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_W_SPEC_CV_CONST):
				VM_TRACE(ZEND_FETCH_DIM_W_SPEC_CV_CONST)
				ZEND_FETCH_DIM_W_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_RW_SPEC_CV_CONST):
				VM_TRACE(ZEND_FETCH_DIM_RW_SPEC_CV_CONST)
				ZEND_FETCH_DIM_RW_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_IS_SPEC_CV_CONST):
				VM_TRACE(ZEND_FETCH_DIM_IS_SPEC_CV_CONST)
				ZEND_FETCH_DIM_IS_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CONST):
				VM_TRACE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CONST)
				ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_UNSET_SPEC_CV_CONST):
				VM_TRACE(ZEND_FETCH_DIM_UNSET_SPEC_CV_CONST)
				ZEND_FETCH_DIM_UNSET_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_R_SPEC_CV_CONST):
				VM_TRACE(ZEND_FETCH_OBJ_R_SPEC_CV_CONST)
				ZEND_FETCH_OBJ_R_SPEC_CV_CONST_INLINE_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_W_SPEC_CV_CONST):
				VM_TRACE(ZEND_FETCH_OBJ_W_SPEC_CV_CONST)
				ZEND_FETCH_OBJ_W_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_RW_SPEC_CV_CONST):
				VM_TRACE(ZEND_FETCH_OBJ_RW_SPEC_CV_CONST)
				ZEND_FETCH_OBJ_RW_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_IS_SPEC_CV_CONST):
				VM_TRACE(ZEND_FETCH_OBJ_IS_SPEC_CV_CONST)
				ZEND_FETCH_OBJ_IS_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CONST):
				VM_TRACE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CONST)
				ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_UNSET_SPEC_CV_CONST):
				VM_TRACE(ZEND_FETCH_OBJ_UNSET_SPEC_CV_CONST)
				ZEND_FETCH_OBJ_UNSET_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CONST):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CONST)
				ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_TMP):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_TMP)
				ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_VAR)
				ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CV)
				ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CONST):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CONST)
				ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_TMP):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_TMP)
				ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_VAR)
				ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CV)
				ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_SPEC_CV_CONST_RETVAL_UNUSED):
				VM_TRACE(ZEND_ASSIGN_SPEC_CV_CONST_RETVAL_UNUSED)
				ZEND_ASSIGN_SPEC_CV_CONST_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_SPEC_CV_CONST_RETVAL_USED):
				VM_TRACE(ZEND_ASSIGN_SPEC_CV_CONST_RETVAL_USED)
				ZEND_ASSIGN_SPEC_CV_CONST_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_VAR)
				ZEND_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_CV)
				ZEND_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FAST_CONCAT_SPEC_CV_CONST):
				VM_TRACE(ZEND_FAST_CONCAT_SPEC_CV_CONST)
				ZEND_FAST_CONCAT_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_METHOD_CALL_SPEC_CV_CONST):
				VM_TRACE(ZEND_INIT_METHOD_CALL_SPEC_CV_CONST)
				ZEND_INIT_METHOD_CALL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAR_SPEC_CV_CONST):
				VM_TRACE(ZEND_SEND_VAR_SPEC_CV_CONST)
				ZEND_SEND_VAR_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_REF_SPEC_CV_CONST):
				VM_TRACE(ZEND_SEND_REF_SPEC_CV_CONST)
				ZEND_SEND_REF_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAR_EX_SPEC_CV_CONST):
				VM_TRACE(ZEND_SEND_VAR_EX_SPEC_CV_CONST)
				ZEND_SEND_VAR_EX_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST):
				VM_TRACE(ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST)
				ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_ARRAY_SPEC_CV_CONST):
				VM_TRACE(ZEND_INIT_ARRAY_SPEC_CV_CONST)
				ZEND_INIT_ARRAY_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_UNSET_DIM_SPEC_CV_CONST):
				VM_TRACE(ZEND_UNSET_DIM_SPEC_CV_CONST)
				ZEND_UNSET_DIM_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_UNSET_OBJ_SPEC_CV_CONST):
				VM_TRACE(ZEND_UNSET_OBJ_SPEC_CV_CONST)
				ZEND_UNSET_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CONST):
				VM_TRACE(ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CONST)
				ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CONST):
				VM_TRACE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CONST)
				ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ARRAY_KEY_EXISTS_SPEC_CV_CONST):
				VM_TRACE(ZEND_ARRAY_KEY_EXISTS_SPEC_CV_CONST)
				ZEND_ARRAY_KEY_EXISTS_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INSTANCEOF_SPEC_CV_CONST):
				VM_TRACE(ZEND_INSTANCEOF_SPEC_CV_CONST)
				ZEND_INSTANCEOF_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_YIELD_SPEC_CV_CONST):
				VM_TRACE(ZEND_YIELD_SPEC_CV_CONST)
				ZEND_YIELD_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BIND_GLOBAL_SPEC_CV_CONST):
				VM_TRACE(ZEND_BIND_GLOBAL_SPEC_CV_CONST)
				ZEND_BIND_GLOBAL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IN_ARRAY_SPEC_CV_CONST):
				VM_TRACE(ZEND_IN_ARRAY_SPEC_CV_CONST)
				ZEND_IN_ARRAY_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_IDENTICAL_NOTHROW_SPEC_CV_CONST):
				VM_TRACE(ZEND_IS_IDENTICAL_NOTHROW_SPEC_CV_CONST)
				ZEND_IS_IDENTICAL_NOTHROW_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CONST):
				VM_TRACE(ZEND_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CONST)
				ZEND_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_R_INDEX_SPEC_CV_CONST):
				VM_TRACE(ZEND_FETCH_DIM_R_INDEX_SPEC_CV_CONST)
				ZEND_FETCH_DIM_R_INDEX_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_R_INDEX_SPEC_CV_TMPVARCV):
				VM_TRACE(ZEND_FETCH_DIM_R_INDEX_SPEC_CV_TMPVARCV)
				ZEND_FETCH_DIM_R_INDEX_SPEC_CV_TMPVARCV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DIV_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_DIV_SPEC_CV_TMPVAR)
				ZEND_DIV_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POW_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_POW_SPEC_CV_TMPVAR)
				ZEND_POW_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CONCAT_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_CONCAT_SPEC_CV_TMPVAR)
				ZEND_CONCAT_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_IS_EQUAL_SPEC_CV_TMPVAR)
				ZEND_IS_EQUAL_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_SPEC_CV_TMPVAR_JMPZ):
				VM_TRACE(ZEND_IS_EQUAL_SPEC_CV_TMPVAR_JMPZ)
				ZEND_IS_EQUAL_SPEC_CV_TMPVAR_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_SPEC_CV_TMPVAR_JMPNZ):
				VM_TRACE(ZEND_IS_EQUAL_SPEC_CV_TMPVAR_JMPNZ)
				ZEND_IS_EQUAL_SPEC_CV_TMPVAR_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR)
				ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPZ):
				VM_TRACE(ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPZ)
				ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPNZ):
				VM_TRACE(ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPNZ)
				ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SPACESHIP_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_SPACESHIP_SPEC_CV_TMPVAR)
				ZEND_SPACESHIP_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BOOL_XOR_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_BOOL_XOR_SPEC_CV_TMPVAR)
				ZEND_BOOL_XOR_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_OP_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_ASSIGN_OBJ_OP_SPEC_CV_TMPVAR)
				ZEND_ASSIGN_OBJ_OP_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_OP_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_ASSIGN_DIM_OP_SPEC_CV_TMPVAR)
				ZEND_ASSIGN_DIM_OP_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OP_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_ASSIGN_OP_SPEC_CV_TMPVAR)
				ZEND_ASSIGN_OP_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_INC_OBJ_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_PRE_INC_OBJ_SPEC_CV_TMPVAR)
				ZEND_PRE_INC_OBJ_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POST_INC_OBJ_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_POST_INC_OBJ_SPEC_CV_TMPVAR)
				ZEND_POST_INC_OBJ_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_R_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_FETCH_DIM_R_SPEC_CV_TMPVAR)
				ZEND_FETCH_DIM_R_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_W_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_FETCH_DIM_W_SPEC_CV_TMPVAR)
				ZEND_FETCH_DIM_W_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_RW_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_FETCH_DIM_RW_SPEC_CV_TMPVAR)
				ZEND_FETCH_DIM_RW_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_IS_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_FETCH_DIM_IS_SPEC_CV_TMPVAR)
				ZEND_FETCH_DIM_IS_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_TMPVAR)
				ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_UNSET_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_FETCH_DIM_UNSET_SPEC_CV_TMPVAR)
				ZEND_FETCH_DIM_UNSET_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_R_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_FETCH_OBJ_R_SPEC_CV_TMPVAR)
				ZEND_FETCH_OBJ_R_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_W_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_FETCH_OBJ_W_SPEC_CV_TMPVAR)
				ZEND_FETCH_OBJ_W_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_RW_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_FETCH_OBJ_RW_SPEC_CV_TMPVAR)
				ZEND_FETCH_OBJ_RW_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_IS_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_FETCH_OBJ_IS_SPEC_CV_TMPVAR)
				ZEND_FETCH_OBJ_IS_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMPVAR)
				ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_UNSET_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_FETCH_OBJ_UNSET_SPEC_CV_TMPVAR)
				ZEND_FETCH_OBJ_UNSET_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CONST):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CONST)
				ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_TMP):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_TMP)
				ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_VAR)
				ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CV)
				ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CONST):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CONST)
				ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_TMP):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_TMP)
				ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_VAR)
				ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CV)
				ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_VAR)
				ZEND_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_CV)
				ZEND_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FAST_CONCAT_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_FAST_CONCAT_SPEC_CV_TMPVAR)
				ZEND_FAST_CONCAT_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_METHOD_CALL_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_INIT_METHOD_CALL_SPEC_CV_TMPVAR)
				ZEND_INIT_METHOD_CALL_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMPVAR)
				ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_ARRAY_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_INIT_ARRAY_SPEC_CV_TMPVAR)
				ZEND_INIT_ARRAY_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_UNSET_DIM_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_UNSET_DIM_SPEC_CV_TMPVAR)
				ZEND_UNSET_DIM_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_UNSET_OBJ_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_UNSET_OBJ_SPEC_CV_TMPVAR)
				ZEND_UNSET_OBJ_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMPVAR)
				ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMPVAR)
				ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ARRAY_KEY_EXISTS_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_ARRAY_KEY_EXISTS_SPEC_CV_TMPVAR)
				ZEND_ARRAY_KEY_EXISTS_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_YIELD_SPEC_CV_TMPVAR):
				VM_TRACE(ZEND_YIELD_SPEC_CV_TMPVAR)
				ZEND_YIELD_SPEC_CV_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_IDENTICAL_SPEC_CV_TMP):
				VM_TRACE(ZEND_IS_IDENTICAL_SPEC_CV_TMP)
				ZEND_IS_IDENTICAL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_IDENTICAL_SPEC_CV_TMP):
				VM_TRACE(ZEND_IS_NOT_IDENTICAL_SPEC_CV_TMP)
				ZEND_IS_NOT_IDENTICAL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_SPEC_CV_TMP_RETVAL_UNUSED):
				VM_TRACE(ZEND_ASSIGN_SPEC_CV_TMP_RETVAL_UNUSED)
				ZEND_ASSIGN_SPEC_CV_TMP_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_SPEC_CV_TMP_RETVAL_USED):
				VM_TRACE(ZEND_ASSIGN_SPEC_CV_TMP_RETVAL_USED)
				ZEND_ASSIGN_SPEC_CV_TMP_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_IDENTICAL_SPEC_CV_VAR):
				VM_TRACE(ZEND_IS_IDENTICAL_SPEC_CV_VAR)
				ZEND_IS_IDENTICAL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_IDENTICAL_SPEC_CV_VAR):
				VM_TRACE(ZEND_IS_NOT_IDENTICAL_SPEC_CV_VAR)
				ZEND_IS_NOT_IDENTICAL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_SPEC_CV_VAR_RETVAL_UNUSED):
				VM_TRACE(ZEND_ASSIGN_SPEC_CV_VAR_RETVAL_UNUSED)
				ZEND_ASSIGN_SPEC_CV_VAR_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_SPEC_CV_VAR_RETVAL_USED):
				VM_TRACE(ZEND_ASSIGN_SPEC_CV_VAR_RETVAL_USED)
				ZEND_ASSIGN_SPEC_CV_VAR_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_REF_SPEC_CV_VAR):
				VM_TRACE(ZEND_ASSIGN_REF_SPEC_CV_VAR)
				ZEND_ASSIGN_REF_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INSTANCEOF_SPEC_CV_VAR):
				VM_TRACE(ZEND_INSTANCEOF_SPEC_CV_VAR)
				ZEND_INSTANCEOF_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_OP_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_ASSIGN_DIM_OP_SPEC_CV_UNUSED)
				ZEND_ASSIGN_DIM_OP_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_R_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_FETCH_R_SPEC_CV_UNUSED)
				ZEND_FETCH_R_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_W_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_FETCH_W_SPEC_CV_UNUSED)
				ZEND_FETCH_W_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_RW_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_FETCH_RW_SPEC_CV_UNUSED)
				ZEND_FETCH_RW_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_FUNC_ARG_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_FETCH_FUNC_ARG_SPEC_CV_UNUSED)
				ZEND_FETCH_FUNC_ARG_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_UNSET_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_FETCH_UNSET_SPEC_CV_UNUSED)
				ZEND_FETCH_UNSET_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_IS_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_FETCH_IS_SPEC_CV_UNUSED)
				ZEND_FETCH_IS_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_W_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_FETCH_DIM_W_SPEC_CV_UNUSED)
				ZEND_FETCH_DIM_W_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_RW_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_FETCH_DIM_RW_SPEC_CV_UNUSED)
				ZEND_FETCH_DIM_RW_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_UNUSED)
				ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CONST):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CONST)
				ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_TMP):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_TMP)
				ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_VAR)
				ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CV)
				ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_VERIFY_RETURN_TYPE_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_VERIFY_RETURN_TYPE_SPEC_CV_UNUSED)
				ZEND_VERIFY_RETURN_TYPE_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAR_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_SEND_VAR_SPEC_CV_UNUSED)
				ZEND_SEND_VAR_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_REF_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_SEND_REF_SPEC_CV_UNUSED)
				ZEND_SEND_REF_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAR_EX_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_SEND_VAR_EX_SPEC_CV_UNUSED)
				ZEND_SEND_VAR_EX_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAR_EX_SPEC_CV_UNUSED_QUICK):
				VM_TRACE(ZEND_SEND_VAR_EX_SPEC_CV_UNUSED_QUICK)
				ZEND_SEND_VAR_EX_SPEC_CV_UNUSED_QUICK_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED)
				ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_ARRAY_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_INIT_ARRAY_SPEC_CV_UNUSED)
				ZEND_INIT_ARRAY_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_UNSET_CV_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_UNSET_CV_SPEC_CV_UNUSED)
				ZEND_UNSET_CV_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_UNSET_VAR_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_UNSET_VAR_SPEC_CV_UNUSED)
				ZEND_UNSET_VAR_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_SET):
				VM_TRACE(ZEND_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_SET)
				ZEND_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_SET_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_EMPTY):
				VM_TRACE(ZEND_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_EMPTY)
				ZEND_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_EMPTY_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_UNUSED)
				ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INSTANCEOF_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_INSTANCEOF_SPEC_CV_UNUSED)
				ZEND_INSTANCEOF_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_YIELD_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_YIELD_SPEC_CV_UNUSED)
				ZEND_YIELD_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BIND_STATIC_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_BIND_STATIC_SPEC_CV_UNUSED)
				ZEND_BIND_STATIC_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CHECK_VAR_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_CHECK_VAR_SPEC_CV_UNUSED)
				ZEND_CHECK_VAR_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_MAKE_REF_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_MAKE_REF_SPEC_CV_UNUSED)
				ZEND_MAKE_REF_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_COUNT_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_COUNT_SPEC_CV_UNUSED)
				ZEND_COUNT_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_GET_CLASS_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_GET_CLASS_SPEC_CV_UNUSED)
				ZEND_GET_CLASS_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_GET_TYPE_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_GET_TYPE_SPEC_CV_UNUSED)
				ZEND_GET_TYPE_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SEND_VAR_EX_SIMPLE_SPEC_CV_UNUSED):
				VM_TRACE(ZEND_SEND_VAR_EX_SIMPLE_SPEC_CV_UNUSED)
				ZEND_SEND_VAR_EX_SIMPLE_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_DIV_SPEC_CV_CV):
				VM_TRACE(ZEND_DIV_SPEC_CV_CV)
				ZEND_DIV_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POW_SPEC_CV_CV):
				VM_TRACE(ZEND_POW_SPEC_CV_CV)
				ZEND_POW_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_CONCAT_SPEC_CV_CV):
				VM_TRACE(ZEND_CONCAT_SPEC_CV_CV)
				ZEND_CONCAT_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_IDENTICAL_SPEC_CV_CV):
				VM_TRACE(ZEND_IS_IDENTICAL_SPEC_CV_CV)
				ZEND_IS_IDENTICAL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_IDENTICAL_SPEC_CV_CV):
				VM_TRACE(ZEND_IS_NOT_IDENTICAL_SPEC_CV_CV)
				ZEND_IS_NOT_IDENTICAL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_SPEC_CV_CV):
				VM_TRACE(ZEND_IS_EQUAL_SPEC_CV_CV)
				ZEND_IS_EQUAL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_SPEC_CV_CV_JMPZ):
				VM_TRACE(ZEND_IS_EQUAL_SPEC_CV_CV_JMPZ)
				ZEND_IS_EQUAL_SPEC_CV_CV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_EQUAL_SPEC_CV_CV_JMPNZ):
				VM_TRACE(ZEND_IS_EQUAL_SPEC_CV_CV_JMPNZ)
				ZEND_IS_EQUAL_SPEC_CV_CV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_SPEC_CV_CV):
				VM_TRACE(ZEND_IS_NOT_EQUAL_SPEC_CV_CV)
				ZEND_IS_NOT_EQUAL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_SPEC_CV_CV_JMPZ):
				VM_TRACE(ZEND_IS_NOT_EQUAL_SPEC_CV_CV_JMPZ)
				ZEND_IS_NOT_EQUAL_SPEC_CV_CV_JMPZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_EQUAL_SPEC_CV_CV_JMPNZ):
				VM_TRACE(ZEND_IS_NOT_EQUAL_SPEC_CV_CV_JMPNZ)
				ZEND_IS_NOT_EQUAL_SPEC_CV_CV_JMPNZ_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_SPACESHIP_SPEC_CV_CV):
				VM_TRACE(ZEND_SPACESHIP_SPEC_CV_CV)
				ZEND_SPACESHIP_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_BOOL_XOR_SPEC_CV_CV):
				VM_TRACE(ZEND_BOOL_XOR_SPEC_CV_CV)
				ZEND_BOOL_XOR_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_OP_SPEC_CV_CV):
				VM_TRACE(ZEND_ASSIGN_OBJ_OP_SPEC_CV_CV)
				ZEND_ASSIGN_OBJ_OP_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_OP_SPEC_CV_CV):
				VM_TRACE(ZEND_ASSIGN_DIM_OP_SPEC_CV_CV)
				ZEND_ASSIGN_DIM_OP_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OP_SPEC_CV_CV):
				VM_TRACE(ZEND_ASSIGN_OP_SPEC_CV_CV)
				ZEND_ASSIGN_OP_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_PRE_INC_OBJ_SPEC_CV_CV):
				VM_TRACE(ZEND_PRE_INC_OBJ_SPEC_CV_CV)
				ZEND_PRE_INC_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_POST_INC_OBJ_SPEC_CV_CV):
				VM_TRACE(ZEND_POST_INC_OBJ_SPEC_CV_CV)
				ZEND_POST_INC_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_R_SPEC_CV_CV):
				VM_TRACE(ZEND_FETCH_DIM_R_SPEC_CV_CV)
				ZEND_FETCH_DIM_R_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_W_SPEC_CV_CV):
				VM_TRACE(ZEND_FETCH_DIM_W_SPEC_CV_CV)
				ZEND_FETCH_DIM_W_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_RW_SPEC_CV_CV):
				VM_TRACE(ZEND_FETCH_DIM_RW_SPEC_CV_CV)
				ZEND_FETCH_DIM_RW_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_IS_SPEC_CV_CV):
				VM_TRACE(ZEND_FETCH_DIM_IS_SPEC_CV_CV)
				ZEND_FETCH_DIM_IS_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CV):
				VM_TRACE(ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CV)
				ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_DIM_UNSET_SPEC_CV_CV):
				VM_TRACE(ZEND_FETCH_DIM_UNSET_SPEC_CV_CV)
				ZEND_FETCH_DIM_UNSET_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_R_SPEC_CV_CV):
				VM_TRACE(ZEND_FETCH_OBJ_R_SPEC_CV_CV)
				ZEND_FETCH_OBJ_R_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_W_SPEC_CV_CV):
				VM_TRACE(ZEND_FETCH_OBJ_W_SPEC_CV_CV)
				ZEND_FETCH_OBJ_W_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_RW_SPEC_CV_CV):
				VM_TRACE(ZEND_FETCH_OBJ_RW_SPEC_CV_CV)
				ZEND_FETCH_OBJ_RW_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_IS_SPEC_CV_CV):
				VM_TRACE(ZEND_FETCH_OBJ_IS_SPEC_CV_CV)
				ZEND_FETCH_OBJ_IS_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CV):
				VM_TRACE(ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CV)
				ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FETCH_OBJ_UNSET_SPEC_CV_CV):
				VM_TRACE(ZEND_FETCH_OBJ_UNSET_SPEC_CV_CV)
				ZEND_FETCH_OBJ_UNSET_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CONST):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CONST)
				ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_TMP):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_TMP)
				ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_VAR)
				ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CV)
				ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CONST):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CONST)
				ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_TMP):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_TMP)
				ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_VAR)
				ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CV)
				ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_SPEC_CV_CV_RETVAL_UNUSED):
				VM_TRACE(ZEND_ASSIGN_SPEC_CV_CV_RETVAL_UNUSED)
				ZEND_ASSIGN_SPEC_CV_CV_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_SPEC_CV_CV_RETVAL_USED):
				VM_TRACE(ZEND_ASSIGN_SPEC_CV_CV_RETVAL_USED)
				ZEND_ASSIGN_SPEC_CV_CV_RETVAL_USED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_REF_SPEC_CV_CV):
				VM_TRACE(ZEND_ASSIGN_REF_SPEC_CV_CV)
				ZEND_ASSIGN_REF_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_VAR):
				VM_TRACE(ZEND_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_VAR)
				ZEND_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_CV):
				VM_TRACE(ZEND_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_CV)
				ZEND_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_FAST_CONCAT_SPEC_CV_CV):
				VM_TRACE(ZEND_FAST_CONCAT_SPEC_CV_CV)
				ZEND_FAST_CONCAT_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_METHOD_CALL_SPEC_CV_CV):
				VM_TRACE(ZEND_INIT_METHOD_CALL_SPEC_CV_CV)
				ZEND_INIT_METHOD_CALL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV):
				VM_TRACE(ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV)
				ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_INIT_ARRAY_SPEC_CV_CV):
				VM_TRACE(ZEND_INIT_ARRAY_SPEC_CV_CV)
				ZEND_INIT_ARRAY_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_UNSET_DIM_SPEC_CV_CV):
				VM_TRACE(ZEND_UNSET_DIM_SPEC_CV_CV)
				ZEND_UNSET_DIM_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_UNSET_OBJ_SPEC_CV_CV):
				VM_TRACE(ZEND_UNSET_OBJ_SPEC_CV_CV)
				ZEND_UNSET_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CV):
				VM_TRACE(ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CV)
				ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CV):
				VM_TRACE(ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CV)
				ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_ARRAY_KEY_EXISTS_SPEC_CV_CV):
				VM_TRACE(ZEND_ARRAY_KEY_EXISTS_SPEC_CV_CV)
				ZEND_ARRAY_KEY_EXISTS_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_YIELD_SPEC_CV_CV):
				VM_TRACE(ZEND_YIELD_SPEC_CV_CV)
				ZEND_YIELD_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_IDENTICAL_NOTHROW_SPEC_CV_CV):
				VM_TRACE(ZEND_IS_IDENTICAL_NOTHROW_SPEC_CV_CV)
				ZEND_IS_IDENTICAL_NOTHROW_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(ZEND_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CV):
				VM_TRACE(ZEND_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CV)
				ZEND_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(HYBRID_HALT):
#ifdef ZEND_VM_FP_GLOBAL_REG
				execute_data = orig_execute_data;
#endif
#ifdef ZEND_VM_IP_GLOBAL_REG
				opline = orig_opline;
#endif
				return;
			HYBRID_DEFAULT:
				VM_TRACE(ZEND_NULL)
				ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK(); /* Never reached */
#else
#ifdef ZEND_VM_FP_GLOBAL_REG
			execute_data = orig_execute_data;
# ifdef ZEND_VM_IP_GLOBAL_REG
			opline = orig_opline;
# endif
			return;
#else
			if (EXPECTED(ret > 0)) {
				execute_data = EG(current_execute_data);
				ZEND_VM_LOOP_INTERRUPT_CHECK();
			} else {
# ifdef ZEND_VM_IP_GLOBAL_REG
				opline = orig_opline;
# endif
				return;
			}
#endif
#endif
		}

	}
	zend_error_noreturn(E_CORE_ERROR, "Arrived at end of main loop which shouldn't happen");
}
#if (ZEND_VM_KIND != ZEND_VM_KIND_CALL) && (ZEND_GCC_VERSION >= 4000) && !defined(__clang__)
# pragma GCC pop_options
#endif

ZEND_API void zend_execute(zend_op_array *op_array, zval *return_value)
{
	zend_execute_data *execute_data;
	void *object_or_called_scope;
	uint32_t call_info;

	if (EG(exception) != NULL) {
		return;
	}

	object_or_called_scope = zend_get_this_object(EG(current_execute_data));
	if (EXPECTED(!object_or_called_scope)) {
		object_or_called_scope = zend_get_called_scope(EG(current_execute_data));
		call_info = ZEND_CALL_TOP_CODE | ZEND_CALL_HAS_SYMBOL_TABLE;
	} else {
		call_info = ZEND_CALL_TOP_CODE | ZEND_CALL_HAS_SYMBOL_TABLE | ZEND_CALL_HAS_THIS;
	}
	execute_data = zend_vm_stack_push_call_frame(call_info,
		(zend_function*)op_array, 0, object_or_called_scope);
	if (EG(current_execute_data)) {
		execute_data->symbol_table = zend_rebuild_symbol_table();
	} else {
		execute_data->symbol_table = &EG(symbol_table);
	}
	EX(prev_execute_data) = EG(current_execute_data);
	i_init_code_execute_data(execute_data, op_array, return_value);
	ZEND_OBSERVER_FCALL_BEGIN(execute_data);
	zend_execute_ex(execute_data);
	/* Observer end handlers are called from ZEND_RETURN */
	zend_vm_stack_free_call_frame(execute_data);
}


void zend_vm_init(void)
{
	static const void * const labels[] = {
		ZEND_NOP_SPEC_HANDLER,
		ZEND_ADD_SPEC_CONST_CONST_HANDLER,
		ZEND_ADD_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_ADD_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ADD_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_ADD_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_ADD_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ADD_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SUB_SPEC_CONST_CONST_HANDLER,
		ZEND_SUB_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_SUB_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SUB_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_SUB_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_SUB_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SUB_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SUB_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SUB_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_SUB_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SUB_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SUB_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SUB_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_SUB_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SUB_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SUB_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_MUL_SPEC_CONST_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MUL_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_MUL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_MUL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MUL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_MUL_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_MUL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_MUL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MUL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MUL_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_MUL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_MUL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MUL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_DIV_SPEC_CONST_CONST_HANDLER,
		ZEND_DIV_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_DIV_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_DIV_SPEC_CONST_CV_HANDLER,
		ZEND_DIV_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_DIV_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_DIV_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_DIV_SPEC_TMPVAR_CV_HANDLER,
		ZEND_DIV_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_DIV_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_DIV_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_DIV_SPEC_TMPVAR_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_DIV_SPEC_CV_CONST_HANDLER,
		ZEND_DIV_SPEC_CV_TMPVAR_HANDLER,
		ZEND_DIV_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_DIV_SPEC_CV_CV_HANDLER,
		ZEND_MOD_SPEC_CONST_CONST_HANDLER,
		ZEND_MOD_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_MOD_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MOD_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_MOD_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_MOD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_MOD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MOD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_MOD_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_MOD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_MOD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MOD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MOD_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_MOD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_MOD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MOD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SL_SPEC_CONST_CONST_HANDLER,
		ZEND_SL_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_SL_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SL_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_SL_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_SL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SL_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_SL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SL_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_SL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SR_SPEC_CONST_CONST_HANDLER,
		ZEND_SR_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_SR_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SR_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_SR_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_SR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SR_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_SR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SR_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_SR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_CONCAT_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_CONCAT_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_CONCAT_SPEC_CONST_CV_HANDLER,
		ZEND_CONCAT_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_CONCAT_SPEC_TMPVAR_CV_HANDLER,
		ZEND_CONCAT_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_CONCAT_SPEC_TMPVAR_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_CONCAT_SPEC_CV_CONST_HANDLER,
		ZEND_CONCAT_SPEC_CV_TMPVAR_HANDLER,
		ZEND_CONCAT_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_CONCAT_SPEC_CV_CV_HANDLER,
		ZEND_BW_OR_SPEC_CONST_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_BW_OR_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_BW_OR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_BW_OR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_BW_OR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_BW_OR_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_BW_OR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_BW_OR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_BW_OR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_BW_OR_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_BW_OR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_BW_OR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_BW_OR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_BW_AND_SPEC_CONST_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_BW_AND_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_BW_AND_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_BW_AND_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_BW_AND_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_BW_AND_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_BW_AND_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_BW_AND_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_BW_AND_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_BW_AND_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_BW_AND_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_BW_AND_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_BW_AND_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_BW_XOR_SPEC_CONST_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_BW_XOR_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_BW_XOR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_BW_XOR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_BW_XOR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_BW_XOR_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_BW_XOR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_BW_XOR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_BW_XOR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_BW_XOR_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_BW_XOR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_BW_XOR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_BW_XOR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_POW_SPEC_CONST_CONST_HANDLER,
		ZEND_POW_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_POW_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_POW_SPEC_CONST_CV_HANDLER,
		ZEND_POW_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_POW_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_POW_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_POW_SPEC_TMPVAR_CV_HANDLER,
		ZEND_POW_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_POW_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_POW_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_POW_SPEC_TMPVAR_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_POW_SPEC_CV_CONST_HANDLER,
		ZEND_POW_SPEC_CV_TMPVAR_HANDLER,
		ZEND_POW_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_POW_SPEC_CV_CV_HANDLER,
		ZEND_BW_NOT_SPEC_CONST_HANDLER,
		ZEND_BW_NOT_SPEC_TMPVARCV_HANDLER,
		ZEND_BW_NOT_SPEC_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_BW_NOT_SPEC_TMPVARCV_HANDLER,
		ZEND_BOOL_NOT_SPEC_CONST_HANDLER,
		ZEND_BOOL_NOT_SPEC_TMPVAR_HANDLER,
		ZEND_BOOL_NOT_SPEC_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_BOOL_NOT_SPEC_CV_HANDLER,
		ZEND_BOOL_XOR_SPEC_CONST_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_BOOL_XOR_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_BOOL_XOR_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_BOOL_XOR_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_BOOL_XOR_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_BOOL_XOR_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_BOOL_XOR_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_BOOL_XOR_SPEC_CV_CONST_HANDLER,
		ZEND_BOOL_XOR_SPEC_CV_TMPVAR_HANDLER,
		ZEND_BOOL_XOR_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_BOOL_XOR_SPEC_CV_CV_HANDLER,
		ZEND_IS_IDENTICAL_SPEC_CONST_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_IDENTICAL_SPEC_TMP_CONST_HANDLER,
		ZEND_IS_IDENTICAL_SPEC_TMP_TMP_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_IDENTICAL_SPEC_VAR_CONST_HANDLER,
		ZEND_IS_IDENTICAL_SPEC_VAR_TMP_HANDLER,
		ZEND_IS_IDENTICAL_SPEC_VAR_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_IDENTICAL_SPEC_CV_CONST_HANDLER,
		ZEND_IS_IDENTICAL_SPEC_CV_TMP_HANDLER,
		ZEND_IS_IDENTICAL_SPEC_CV_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_IDENTICAL_SPEC_CV_CV_HANDLER,
		ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CONST_HANDLER,
		ZEND_IS_NOT_IDENTICAL_SPEC_TMP_TMP_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CONST_HANDLER,
		ZEND_IS_NOT_IDENTICAL_SPEC_VAR_TMP_HANDLER,
		ZEND_IS_NOT_IDENTICAL_SPEC_VAR_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_NOT_IDENTICAL_SPEC_CV_CONST_HANDLER,
		ZEND_IS_NOT_IDENTICAL_SPEC_CV_TMP_HANDLER,
		ZEND_IS_NOT_IDENTICAL_SPEC_CV_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_NOT_IDENTICAL_SPEC_CV_CV_HANDLER,
		ZEND_IS_EQUAL_SPEC_CONST_CONST_HANDLER,
		ZEND_IS_EQUAL_SPEC_CONST_CONST_HANDLER,
		ZEND_IS_EQUAL_SPEC_CONST_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_JMPZ_HANDLER,
		ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_JMPNZ_HANDLER,
		ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ_HANDLER,
		ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ_HANDLER,
		ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ_HANDLER,
		ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_JMPZ_HANDLER,
		ZEND_IS_EQUAL_SPEC_TMPVAR_CONST_JMPNZ_HANDLER,
		ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ_HANDLER,
		ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ_HANDLER,
		ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ_HANDLER,
		ZEND_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_EQUAL_SPEC_CV_CONST_HANDLER,
		ZEND_IS_EQUAL_SPEC_CV_CONST_JMPZ_HANDLER,
		ZEND_IS_EQUAL_SPEC_CV_CONST_JMPNZ_HANDLER,
		ZEND_IS_EQUAL_SPEC_CV_TMPVAR_HANDLER,
		ZEND_IS_EQUAL_SPEC_CV_TMPVAR_JMPZ_HANDLER,
		ZEND_IS_EQUAL_SPEC_CV_TMPVAR_JMPNZ_HANDLER,
		ZEND_IS_EQUAL_SPEC_CV_TMPVAR_HANDLER,
		ZEND_IS_EQUAL_SPEC_CV_TMPVAR_JMPZ_HANDLER,
		ZEND_IS_EQUAL_SPEC_CV_TMPVAR_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_EQUAL_SPEC_CV_CV_HANDLER,
		ZEND_IS_EQUAL_SPEC_CV_CV_JMPZ_HANDLER,
		ZEND_IS_EQUAL_SPEC_CV_CV_JMPNZ_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_CONST_CONST_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_CONST_CONST_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_CONST_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPNZ_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPNZ_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_JMPNZ_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPNZ_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_CV_CV_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_CV_CV_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_SPEC_CV_CV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_CONST_CONST_HANDLER,
		ZEND_IS_SMALLER_SPEC_CONST_CONST_HANDLER,
		ZEND_IS_SMALLER_SPEC_CONST_CONST_HANDLER,
		ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_SPEC_VAR_CONST_RETVAL_UNUSED_HANDLER,
		ZEND_ASSIGN_SPEC_VAR_CONST_RETVAL_USED_HANDLER,
		ZEND_ASSIGN_SPEC_VAR_TMP_RETVAL_UNUSED_HANDLER,
		ZEND_ASSIGN_SPEC_VAR_TMP_RETVAL_USED_HANDLER,
		ZEND_ASSIGN_SPEC_VAR_VAR_RETVAL_UNUSED_HANDLER,
		ZEND_ASSIGN_SPEC_VAR_VAR_RETVAL_USED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_SPEC_VAR_CV_RETVAL_UNUSED_HANDLER,
		ZEND_ASSIGN_SPEC_VAR_CV_RETVAL_USED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_SPEC_CV_CONST_RETVAL_UNUSED_HANDLER,
		ZEND_ASSIGN_SPEC_CV_CONST_RETVAL_USED_HANDLER,
		ZEND_ASSIGN_SPEC_CV_TMP_RETVAL_UNUSED_HANDLER,
		ZEND_ASSIGN_SPEC_CV_TMP_RETVAL_USED_HANDLER,
		ZEND_ASSIGN_SPEC_CV_VAR_RETVAL_UNUSED_HANDLER,
		ZEND_ASSIGN_SPEC_CV_VAR_RETVAL_USED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_SPEC_CV_CV_RETVAL_UNUSED_HANDLER,
		ZEND_ASSIGN_SPEC_CV_CV_RETVAL_USED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CONST_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_TMP_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CV_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CONST_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_TMP_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CONST_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_TMP_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CONST_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_TMP_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CV_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CONST_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_TMP_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CONST_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_TMP_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CV_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CONST_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_TMP_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CONST_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_TMP_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CONST_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_TMP_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CV_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CONST_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_TMP_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CONST_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_TMP_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CV_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CONST_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_TMP_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CONST_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_TMP_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CONST_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_TMP_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CV_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CONST_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_TMP_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CV_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CONST_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_TMP_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CV_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CONST_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_TMP_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CONST_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_TMP_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CV_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CONST_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_TMP_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CV_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CONST_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_TMP_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CONST_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_TMP_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CONST_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_TMP_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CV_HANDLER,
		ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CONST_HANDLER,
		ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_TMP_HANDLER,
		ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OP_SPEC_VAR_CONST_HANDLER,
		ZEND_ASSIGN_OP_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_ASSIGN_OP_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OP_SPEC_VAR_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OP_SPEC_CV_CONST_HANDLER,
		ZEND_ASSIGN_OP_SPEC_CV_TMPVAR_HANDLER,
		ZEND_ASSIGN_OP_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OP_SPEC_CV_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_DIM_OP_SPEC_VAR_CONST_HANDLER,
		ZEND_ASSIGN_DIM_OP_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_ASSIGN_DIM_OP_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_ASSIGN_DIM_OP_SPEC_VAR_UNUSED_HANDLER,
		ZEND_ASSIGN_DIM_OP_SPEC_VAR_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_DIM_OP_SPEC_CV_CONST_HANDLER,
		ZEND_ASSIGN_DIM_OP_SPEC_CV_TMPVAR_HANDLER,
		ZEND_ASSIGN_DIM_OP_SPEC_CV_TMPVAR_HANDLER,
		ZEND_ASSIGN_DIM_OP_SPEC_CV_UNUSED_HANDLER,
		ZEND_ASSIGN_DIM_OP_SPEC_CV_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_OP_SPEC_VAR_CONST_HANDLER,
		ZEND_ASSIGN_OBJ_OP_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_ASSIGN_OBJ_OP_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_OP_SPEC_VAR_CV_HANDLER,
		ZEND_ASSIGN_OBJ_OP_SPEC_UNUSED_CONST_HANDLER,
		ZEND_ASSIGN_OBJ_OP_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_ASSIGN_OBJ_OP_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_OP_SPEC_UNUSED_CV_HANDLER,
		ZEND_ASSIGN_OBJ_OP_SPEC_CV_CONST_HANDLER,
		ZEND_ASSIGN_OBJ_OP_SPEC_CV_TMPVAR_HANDLER,
		ZEND_ASSIGN_OBJ_OP_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_OP_SPEC_CV_CV_HANDLER,
		ZEND_ASSIGN_STATIC_PROP_OP_SPEC_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_REF_SPEC_VAR_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_REF_SPEC_VAR_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_REF_SPEC_CV_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_REF_SPEC_CV_CV_HANDLER,
		ZEND_QM_ASSIGN_SPEC_CONST_HANDLER,
		ZEND_QM_ASSIGN_SPEC_TMP_HANDLER,
		ZEND_QM_ASSIGN_SPEC_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_QM_ASSIGN_SPEC_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_CV_HANDLER,
		ZEND_ASSIGN_STATIC_PROP_REF_SPEC_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_PRE_INC_SPEC_VAR_RETVAL_UNUSED_HANDLER,
		ZEND_PRE_INC_SPEC_VAR_RETVAL_USED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_PRE_INC_SPEC_CV_RETVAL_UNUSED_HANDLER,
		ZEND_PRE_INC_SPEC_CV_RETVAL_USED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_PRE_DEC_SPEC_VAR_RETVAL_UNUSED_HANDLER,
		ZEND_PRE_DEC_SPEC_VAR_RETVAL_USED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_PRE_DEC_SPEC_CV_RETVAL_UNUSED_HANDLER,
		ZEND_PRE_DEC_SPEC_CV_RETVAL_USED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_POST_INC_SPEC_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_POST_INC_SPEC_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_POST_DEC_SPEC_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_POST_DEC_SPEC_CV_HANDLER,
		ZEND_PRE_INC_STATIC_PROP_SPEC_HANDLER,
		ZEND_POST_INC_STATIC_PROP_SPEC_HANDLER,
		ZEND_JMP_SPEC_HANDLER,
		ZEND_JMPZ_SPEC_CONST_HANDLER,
		ZEND_JMPZ_SPEC_TMPVAR_HANDLER,
		ZEND_JMPZ_SPEC_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_JMPZ_SPEC_CV_HANDLER,
		ZEND_JMPNZ_SPEC_CONST_HANDLER,
		ZEND_JMPNZ_SPEC_TMPVAR_HANDLER,
		ZEND_JMPNZ_SPEC_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_JMPNZ_SPEC_CV_HANDLER,
		ZEND_JMPZNZ_SPEC_CONST_HANDLER,
		ZEND_JMPZNZ_SPEC_TMPVAR_HANDLER,
		ZEND_JMPZNZ_SPEC_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_JMPZNZ_SPEC_CV_HANDLER,
		ZEND_JMPZ_EX_SPEC_CONST_HANDLER,
		ZEND_JMPZ_EX_SPEC_TMPVAR_HANDLER,
		ZEND_JMPZ_EX_SPEC_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_JMPZ_EX_SPEC_CV_HANDLER,
		ZEND_JMPNZ_EX_SPEC_CONST_HANDLER,
		ZEND_JMPNZ_EX_SPEC_TMPVAR_HANDLER,
		ZEND_JMPNZ_EX_SPEC_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_JMPNZ_EX_SPEC_CV_HANDLER,
		ZEND_CASE_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_CASE_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_CASE_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_CASE_SPEC_TMPVAR_CV_HANDLER,
		ZEND_CHECK_VAR_SPEC_CV_UNUSED_HANDLER,
		ZEND_SEND_VAR_NO_REF_EX_SPEC_VAR_CONST_HANDLER,
		ZEND_SEND_VAR_NO_REF_EX_SPEC_VAR_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED_HANDLER,
		ZEND_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED_QUICK_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_CAST_SPEC_CONST_HANDLER,
		ZEND_CAST_SPEC_TMP_HANDLER,
		ZEND_CAST_SPEC_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_CAST_SPEC_CV_HANDLER,
		ZEND_BOOL_SPEC_CONST_HANDLER,
		ZEND_BOOL_SPEC_TMPVAR_HANDLER,
		ZEND_BOOL_SPEC_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_BOOL_SPEC_CV_HANDLER,
		ZEND_FAST_CONCAT_SPEC_CONST_CONST_HANDLER,
		ZEND_FAST_CONCAT_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_FAST_CONCAT_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FAST_CONCAT_SPEC_CONST_CV_HANDLER,
		ZEND_FAST_CONCAT_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FAST_CONCAT_SPEC_TMPVAR_CV_HANDLER,
		ZEND_FAST_CONCAT_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FAST_CONCAT_SPEC_TMPVAR_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FAST_CONCAT_SPEC_CV_CONST_HANDLER,
		ZEND_FAST_CONCAT_SPEC_CV_TMPVAR_HANDLER,
		ZEND_FAST_CONCAT_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FAST_CONCAT_SPEC_CV_CV_HANDLER,
		ZEND_ROPE_INIT_SPEC_UNUSED_CONST_HANDLER,
		ZEND_ROPE_INIT_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_ROPE_INIT_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ROPE_INIT_SPEC_UNUSED_CV_HANDLER,
		ZEND_ROPE_ADD_SPEC_TMP_CONST_HANDLER,
		ZEND_ROPE_ADD_SPEC_TMP_TMPVAR_HANDLER,
		ZEND_ROPE_ADD_SPEC_TMP_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ROPE_ADD_SPEC_TMP_CV_HANDLER,
		ZEND_ROPE_END_SPEC_TMP_CONST_HANDLER,
		ZEND_ROPE_END_SPEC_TMP_TMPVAR_HANDLER,
		ZEND_ROPE_END_SPEC_TMP_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ROPE_END_SPEC_TMP_CV_HANDLER,
		ZEND_BEGIN_SILENCE_SPEC_HANDLER,
		ZEND_END_SILENCE_SPEC_TMP_HANDLER,
		ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER,
		ZEND_DO_FCALL_SPEC_RETVAL_UNUSED_HANDLER,
		ZEND_DO_FCALL_SPEC_RETVAL_USED_HANDLER,
		ZEND_DO_FCALL_SPEC_OBSERVER_HANDLER,
		ZEND_DO_FCALL_SPEC_OBSERVER_HANDLER,
		ZEND_INIT_FCALL_SPEC_CONST_HANDLER,
		ZEND_RETURN_SPEC_CONST_HANDLER,
		ZEND_RETURN_SPEC_OBSERVER_HANDLER,
		ZEND_RETURN_SPEC_TMP_HANDLER,
		ZEND_RETURN_SPEC_OBSERVER_HANDLER,
		ZEND_RETURN_SPEC_VAR_HANDLER,
		ZEND_RETURN_SPEC_OBSERVER_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_RETURN_SPEC_CV_HANDLER,
		ZEND_RETURN_SPEC_OBSERVER_HANDLER,
		ZEND_RECV_SPEC_UNUSED_HANDLER,
		ZEND_RECV_INIT_SPEC_CONST_HANDLER,
		ZEND_SEND_VAL_SPEC_CONST_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_VAL_SPEC_CONST_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_VAL_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_VAL_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_VAL_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_VAL_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_VAR_EX_SPEC_VAR_CONST_HANDLER,
		ZEND_SEND_VAR_EX_SPEC_VAR_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_VAR_EX_SPEC_VAR_UNUSED_HANDLER,
		ZEND_SEND_VAR_EX_SPEC_VAR_UNUSED_QUICK_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_VAR_EX_SPEC_CV_CONST_HANDLER,
		ZEND_SEND_VAR_EX_SPEC_CV_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_VAR_EX_SPEC_CV_UNUSED_HANDLER,
		ZEND_SEND_VAR_EX_SPEC_CV_UNUSED_QUICK_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_REF_SPEC_VAR_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_REF_SPEC_VAR_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_REF_SPEC_CV_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_REF_SPEC_CV_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NEW_SPEC_CONST_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NEW_SPEC_VAR_UNUSED_HANDLER,
		ZEND_NEW_SPEC_UNUSED_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER,
		ZEND_FREE_SPEC_TMPVAR_HANDLER,
		ZEND_INIT_ARRAY_SPEC_CONST_CONST_HANDLER,
		ZEND_INIT_ARRAY_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_INIT_ARRAY_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_INIT_ARRAY_SPEC_CONST_UNUSED_HANDLER,
		ZEND_INIT_ARRAY_SPEC_CONST_CV_HANDLER,
		ZEND_INIT_ARRAY_SPEC_TMP_CONST_HANDLER,
		ZEND_INIT_ARRAY_SPEC_TMP_TMPVAR_HANDLER,
		ZEND_INIT_ARRAY_SPEC_TMP_TMPVAR_HANDLER,
		ZEND_INIT_ARRAY_SPEC_TMP_UNUSED_HANDLER,
		ZEND_INIT_ARRAY_SPEC_TMP_CV_HANDLER,
		ZEND_INIT_ARRAY_SPEC_VAR_CONST_HANDLER,
		ZEND_INIT_ARRAY_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_INIT_ARRAY_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_INIT_ARRAY_SPEC_VAR_UNUSED_HANDLER,
		ZEND_INIT_ARRAY_SPEC_VAR_CV_HANDLER,
		ZEND_INIT_ARRAY_SPEC_UNUSED_CONST_HANDLER,
		ZEND_INIT_ARRAY_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_INIT_ARRAY_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_INIT_ARRAY_SPEC_UNUSED_UNUSED_HANDLER,
		ZEND_INIT_ARRAY_SPEC_UNUSED_CV_HANDLER,
		ZEND_INIT_ARRAY_SPEC_CV_CONST_HANDLER,
		ZEND_INIT_ARRAY_SPEC_CV_TMPVAR_HANDLER,
		ZEND_INIT_ARRAY_SPEC_CV_TMPVAR_HANDLER,
		ZEND_INIT_ARRAY_SPEC_CV_UNUSED_HANDLER,
		ZEND_INIT_ARRAY_SPEC_CV_CV_HANDLER,
		ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER,
		ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER,
		ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER,
		ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER,
		ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMPVAR_HANDLER,
		ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMPVAR_HANDLER,
		ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER,
		ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER,
		ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER,
		ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER,
		ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER,
		ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMPVAR_HANDLER,
		ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMPVAR_HANDLER,
		ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER,
		ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER,
		ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER,
		ZEND_INCLUDE_OR_EVAL_SPEC_OBSERVER_HANDLER,
		ZEND_INCLUDE_OR_EVAL_SPEC_TMPVAR_HANDLER,
		ZEND_INCLUDE_OR_EVAL_SPEC_OBSERVER_HANDLER,
		ZEND_INCLUDE_OR_EVAL_SPEC_TMPVAR_HANDLER,
		ZEND_INCLUDE_OR_EVAL_SPEC_OBSERVER_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER,
		ZEND_INCLUDE_OR_EVAL_SPEC_OBSERVER_HANDLER,
		ZEND_UNSET_VAR_SPEC_CONST_UNUSED_HANDLER,
		ZEND_UNSET_VAR_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_UNSET_VAR_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_UNSET_VAR_SPEC_CV_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_UNSET_DIM_SPEC_VAR_CONST_HANDLER,
		ZEND_UNSET_DIM_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_UNSET_DIM_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_UNSET_DIM_SPEC_VAR_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_UNSET_DIM_SPEC_CV_CONST_HANDLER,
		ZEND_UNSET_DIM_SPEC_CV_TMPVAR_HANDLER,
		ZEND_UNSET_DIM_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_UNSET_DIM_SPEC_CV_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_UNSET_OBJ_SPEC_VAR_CONST_HANDLER,
		ZEND_UNSET_OBJ_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_UNSET_OBJ_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_UNSET_OBJ_SPEC_VAR_CV_HANDLER,
		ZEND_UNSET_OBJ_SPEC_UNUSED_CONST_HANDLER,
		ZEND_UNSET_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_UNSET_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_UNSET_OBJ_SPEC_UNUSED_CV_HANDLER,
		ZEND_UNSET_OBJ_SPEC_CV_CONST_HANDLER,
		ZEND_UNSET_OBJ_SPEC_CV_TMPVAR_HANDLER,
		ZEND_UNSET_OBJ_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_UNSET_OBJ_SPEC_CV_CV_HANDLER,
		ZEND_FE_RESET_R_SPEC_CONST_HANDLER,
		ZEND_FE_RESET_R_SPEC_TMP_HANDLER,
		ZEND_FE_RESET_R_SPEC_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FE_RESET_R_SPEC_CV_HANDLER,
		ZEND_FE_FETCH_R_SPEC_VAR_HANDLER,
		ZEND_EXIT_SPEC_HANDLER,
		ZEND_FETCH_R_SPEC_CONST_UNUSED_HANDLER,
		ZEND_FETCH_R_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_FETCH_R_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_R_SPEC_CV_UNUSED_HANDLER,
		ZEND_FETCH_DIM_R_SPEC_CONST_CONST_HANDLER,
		ZEND_FETCH_DIM_R_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_R_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_R_SPEC_CONST_CV_HANDLER,
		ZEND_FETCH_DIM_R_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_R_SPEC_TMPVAR_CV_HANDLER,
		ZEND_FETCH_DIM_R_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_R_SPEC_TMPVAR_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_R_SPEC_CV_CONST_HANDLER,
		ZEND_FETCH_DIM_R_SPEC_CV_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_R_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_R_SPEC_CV_CV_HANDLER,
		ZEND_FETCH_OBJ_R_SPEC_CONST_CONST_HANDLER,
		ZEND_FETCH_OBJ_R_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_R_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_R_SPEC_CONST_CV_HANDLER,
		ZEND_FETCH_OBJ_R_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_R_SPEC_TMPVAR_CV_HANDLER,
		ZEND_FETCH_OBJ_R_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_R_SPEC_TMPVAR_CV_HANDLER,
		ZEND_FETCH_OBJ_R_SPEC_UNUSED_CONST_HANDLER,
		ZEND_FETCH_OBJ_R_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_R_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_R_SPEC_UNUSED_CV_HANDLER,
		ZEND_FETCH_OBJ_R_SPEC_CV_CONST_HANDLER,
		ZEND_FETCH_OBJ_R_SPEC_CV_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_R_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_R_SPEC_CV_CV_HANDLER,
		ZEND_FETCH_W_SPEC_CONST_UNUSED_HANDLER,
		ZEND_FETCH_W_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_FETCH_W_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_W_SPEC_CV_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_W_SPEC_VAR_CONST_HANDLER,
		ZEND_FETCH_DIM_W_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_W_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_W_SPEC_VAR_UNUSED_HANDLER,
		ZEND_FETCH_DIM_W_SPEC_VAR_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_W_SPEC_CV_CONST_HANDLER,
		ZEND_FETCH_DIM_W_SPEC_CV_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_W_SPEC_CV_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_W_SPEC_CV_UNUSED_HANDLER,
		ZEND_FETCH_DIM_W_SPEC_CV_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_W_SPEC_VAR_CONST_HANDLER,
		ZEND_FETCH_OBJ_W_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_W_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_W_SPEC_VAR_CV_HANDLER,
		ZEND_FETCH_OBJ_W_SPEC_UNUSED_CONST_HANDLER,
		ZEND_FETCH_OBJ_W_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_W_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_W_SPEC_UNUSED_CV_HANDLER,
		ZEND_FETCH_OBJ_W_SPEC_CV_CONST_HANDLER,
		ZEND_FETCH_OBJ_W_SPEC_CV_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_W_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_W_SPEC_CV_CV_HANDLER,
		ZEND_FETCH_RW_SPEC_CONST_UNUSED_HANDLER,
		ZEND_FETCH_RW_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_FETCH_RW_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_RW_SPEC_CV_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_RW_SPEC_VAR_CONST_HANDLER,
		ZEND_FETCH_DIM_RW_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_RW_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_RW_SPEC_VAR_UNUSED_HANDLER,
		ZEND_FETCH_DIM_RW_SPEC_VAR_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_RW_SPEC_CV_CONST_HANDLER,
		ZEND_FETCH_DIM_RW_SPEC_CV_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_RW_SPEC_CV_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_RW_SPEC_CV_UNUSED_HANDLER,
		ZEND_FETCH_DIM_RW_SPEC_CV_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_RW_SPEC_VAR_CONST_HANDLER,
		ZEND_FETCH_OBJ_RW_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_RW_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_RW_SPEC_VAR_CV_HANDLER,
		ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CONST_HANDLER,
		ZEND_FETCH_OBJ_RW_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_RW_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CV_HANDLER,
		ZEND_FETCH_OBJ_RW_SPEC_CV_CONST_HANDLER,
		ZEND_FETCH_OBJ_RW_SPEC_CV_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_RW_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_RW_SPEC_CV_CV_HANDLER,
		ZEND_FETCH_IS_SPEC_CONST_UNUSED_HANDLER,
		ZEND_FETCH_IS_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_FETCH_IS_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_IS_SPEC_CV_UNUSED_HANDLER,
		ZEND_FETCH_DIM_IS_SPEC_CONST_CONST_HANDLER,
		ZEND_FETCH_DIM_IS_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_IS_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_IS_SPEC_CONST_CV_HANDLER,
		ZEND_FETCH_DIM_IS_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_IS_SPEC_TMPVAR_CV_HANDLER,
		ZEND_FETCH_DIM_IS_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_IS_SPEC_TMPVAR_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_IS_SPEC_CV_CONST_HANDLER,
		ZEND_FETCH_DIM_IS_SPEC_CV_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_IS_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_IS_SPEC_CV_CV_HANDLER,
		ZEND_FETCH_OBJ_IS_SPEC_CONST_CONST_HANDLER,
		ZEND_FETCH_OBJ_IS_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_IS_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_IS_SPEC_CONST_CV_HANDLER,
		ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_CV_HANDLER,
		ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_IS_SPEC_TMPVAR_CV_HANDLER,
		ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CONST_HANDLER,
		ZEND_FETCH_OBJ_IS_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_IS_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CV_HANDLER,
		ZEND_FETCH_OBJ_IS_SPEC_CV_CONST_HANDLER,
		ZEND_FETCH_OBJ_IS_SPEC_CV_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_IS_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_IS_SPEC_CV_CV_HANDLER,
		ZEND_FETCH_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER,
		ZEND_FETCH_FUNC_ARG_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_FETCH_FUNC_ARG_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_FUNC_ARG_SPEC_CV_UNUSED_HANDLER,
		ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_CONST_HANDLER,
		ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER,
		ZEND_FETCH_DIM_FUNC_ARG_SPEC_CONST_CV_HANDLER,
		ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_CONST_HANDLER,
		ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_UNUSED_HANDLER,
		ZEND_FETCH_DIM_FUNC_ARG_SPEC_TMP_CV_HANDLER,
		ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CONST_HANDLER,
		ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER,
		ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CONST_HANDLER,
		ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_UNUSED_HANDLER,
		ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CV_HANDLER,
		ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CONST_HANDLER,
		ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CV_HANDLER,
		ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CONST_HANDLER,
		ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CV_HANDLER,
		ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CONST_HANDLER,
		ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV_HANDLER,
		ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER,
		ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CV_HANDLER,
		ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CONST_HANDLER,
		ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CV_HANDLER,
		ZEND_FETCH_UNSET_SPEC_CONST_UNUSED_HANDLER,
		ZEND_FETCH_UNSET_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_FETCH_UNSET_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_UNSET_SPEC_CV_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_UNSET_SPEC_VAR_CONST_HANDLER,
		ZEND_FETCH_DIM_UNSET_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_UNSET_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_UNSET_SPEC_VAR_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_UNSET_SPEC_CV_CONST_HANDLER,
		ZEND_FETCH_DIM_UNSET_SPEC_CV_TMPVAR_HANDLER,
		ZEND_FETCH_DIM_UNSET_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_UNSET_SPEC_CV_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CONST_HANDLER,
		ZEND_FETCH_OBJ_UNSET_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_UNSET_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CV_HANDLER,
		ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CONST_HANDLER,
		ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CV_HANDLER,
		ZEND_FETCH_OBJ_UNSET_SPEC_CV_CONST_HANDLER,
		ZEND_FETCH_OBJ_UNSET_SPEC_CV_TMPVAR_HANDLER,
		ZEND_FETCH_OBJ_UNSET_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_OBJ_UNSET_SPEC_CV_CV_HANDLER,
		ZEND_FETCH_LIST_R_SPEC_CONST_CONST_HANDLER,
		ZEND_FETCH_LIST_R_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_FETCH_LIST_R_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_LIST_R_SPEC_CONST_CV_HANDLER,
		ZEND_FETCH_LIST_R_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_HANDLER,
		ZEND_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_LIST_R_SPEC_TMPVARCV_CV_HANDLER,
		ZEND_FETCH_LIST_R_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_HANDLER,
		ZEND_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_LIST_R_SPEC_TMPVARCV_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_LIST_R_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_HANDLER,
		ZEND_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_LIST_R_SPEC_TMPVARCV_CV_HANDLER,
		ZEND_FETCH_CONSTANT_SPEC_UNUSED_CONST_HANDLER,
		ZEND_CHECK_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER,
		ZEND_CHECK_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED_HANDLER,
		ZEND_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED_QUICK_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_EXT_STMT_SPEC_HANDLER,
		ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
		ZEND_EXT_FCALL_END_SPEC_HANDLER,
		ZEND_EXT_NOP_SPEC_HANDLER,
		ZEND_TICKS_SPEC_HANDLER,
		ZEND_SEND_VAR_NO_REF_SPEC_VAR_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_VAR_NO_REF_SPEC_VAR_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_CATCH_SPEC_CONST_HANDLER,
		ZEND_THROW_SPEC_CONST_HANDLER,
		ZEND_THROW_SPEC_TMPVAR_HANDLER,
		ZEND_THROW_SPEC_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_THROW_SPEC_CV_HANDLER,
		ZEND_FETCH_CLASS_SPEC_UNUSED_CONST_HANDLER,
		ZEND_FETCH_CLASS_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_FETCH_CLASS_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_FETCH_CLASS_SPEC_UNUSED_UNUSED_HANDLER,
		ZEND_FETCH_CLASS_SPEC_UNUSED_CV_HANDLER,
		ZEND_CLONE_SPEC_CONST_HANDLER,
		ZEND_CLONE_SPEC_TMPVAR_HANDLER,
		ZEND_CLONE_SPEC_TMPVAR_HANDLER,
		ZEND_CLONE_SPEC_UNUSED_HANDLER,
		ZEND_CLONE_SPEC_CV_HANDLER,
		ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER,
		ZEND_RETURN_BY_REF_SPEC_OBSERVER_HANDLER,
		ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER,
		ZEND_RETURN_BY_REF_SPEC_OBSERVER_HANDLER,
		ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER,
		ZEND_RETURN_BY_REF_SPEC_OBSERVER_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_RETURN_BY_REF_SPEC_CV_HANDLER,
		ZEND_RETURN_BY_REF_SPEC_OBSERVER_HANDLER,
		ZEND_INIT_METHOD_CALL_SPEC_CONST_CONST_HANDLER,
		ZEND_INIT_METHOD_CALL_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_INIT_METHOD_CALL_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_INIT_METHOD_CALL_SPEC_CONST_CV_HANDLER,
		ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_CV_HANDLER,
		ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_INIT_METHOD_CALL_SPEC_TMPVAR_CV_HANDLER,
		ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER,
		ZEND_INIT_METHOD_CALL_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_INIT_METHOD_CALL_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CV_HANDLER,
		ZEND_INIT_METHOD_CALL_SPEC_CV_CONST_HANDLER,
		ZEND_INIT_METHOD_CALL_SPEC_CV_TMPVAR_HANDLER,
		ZEND_INIT_METHOD_CALL_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_INIT_METHOD_CALL_SPEC_CV_CV_HANDLER,
		ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST_HANDLER,
		ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_UNUSED_HANDLER,
		ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CONST_HANDLER,
		ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_UNUSED_HANDLER,
		ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CV_HANDLER,
		ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER,
		ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_UNUSED_HANDLER,
		ZEND_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_UNUSED_HANDLER,
		ZEND_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_UNUSED_HANDLER,
		ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CONST_HANDLER,
		ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CV_HANDLER,
		ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CV_HANDLER,
		ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CONST_HANDLER,
		ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMPVAR_HANDLER,
		ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CV_HANDLER,
		ZEND_SEND_VAL_EX_SPEC_CONST_CONST_HANDLER,
		ZEND_SEND_VAL_EX_SPEC_CONST_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_VAL_EX_SPEC_CONST_UNUSED_HANDLER,
		ZEND_SEND_VAL_EX_SPEC_CONST_UNUSED_QUICK_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_VAL_EX_SPEC_TMP_CONST_HANDLER,
		ZEND_SEND_VAL_EX_SPEC_TMP_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_VAL_EX_SPEC_TMP_UNUSED_HANDLER,
		ZEND_SEND_VAL_EX_SPEC_TMP_UNUSED_QUICK_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_VAR_SPEC_VAR_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_VAR_SPEC_VAR_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_VAR_SPEC_CV_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_VAR_SPEC_CV_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_INIT_USER_CALL_SPEC_CONST_CONST_HANDLER,
		ZEND_INIT_USER_CALL_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_INIT_USER_CALL_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_INIT_USER_CALL_SPEC_CONST_CV_HANDLER,
		ZEND_SEND_ARRAY_SPEC_HANDLER,
		ZEND_SEND_USER_SPEC_CONST_HANDLER,
		ZEND_SEND_USER_SPEC_TMP_HANDLER,
		ZEND_SEND_USER_SPEC_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_USER_SPEC_CV_HANDLER,
		ZEND_STRLEN_SPEC_CONST_HANDLER,
		ZEND_STRLEN_SPEC_TMPVAR_HANDLER,
		ZEND_STRLEN_SPEC_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_STRLEN_SPEC_CV_HANDLER,
		ZEND_DEFINED_SPEC_CONST_HANDLER,
		ZEND_TYPE_CHECK_SPEC_CONST_HANDLER,
		ZEND_TYPE_CHECK_SPEC_TMPVAR_HANDLER,
		ZEND_TYPE_CHECK_SPEC_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_TYPE_CHECK_SPEC_CV_HANDLER,
		ZEND_VERIFY_RETURN_TYPE_SPEC_CONST_UNUSED_HANDLER,
		ZEND_VERIFY_RETURN_TYPE_SPEC_TMP_UNUSED_HANDLER,
		ZEND_VERIFY_RETURN_TYPE_SPEC_VAR_UNUSED_HANDLER,
		ZEND_VERIFY_RETURN_TYPE_SPEC_UNUSED_UNUSED_HANDLER,
		ZEND_VERIFY_RETURN_TYPE_SPEC_CV_UNUSED_HANDLER,
		ZEND_FE_RESET_RW_SPEC_CONST_HANDLER,
		ZEND_FE_RESET_RW_SPEC_TMP_HANDLER,
		ZEND_FE_RESET_RW_SPEC_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FE_RESET_RW_SPEC_CV_HANDLER,
		ZEND_FE_FETCH_RW_SPEC_VAR_HANDLER,
		ZEND_FE_FREE_SPEC_TMPVAR_HANDLER,
		ZEND_INIT_DYNAMIC_CALL_SPEC_CONST_HANDLER,
		ZEND_INIT_DYNAMIC_CALL_SPEC_TMPVAR_HANDLER,
		ZEND_INIT_DYNAMIC_CALL_SPEC_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_INIT_DYNAMIC_CALL_SPEC_CV_HANDLER,
		ZEND_DO_ICALL_SPEC_RETVAL_UNUSED_HANDLER,
		ZEND_DO_ICALL_SPEC_RETVAL_USED_HANDLER,
		ZEND_DO_UCALL_SPEC_RETVAL_UNUSED_HANDLER,
		ZEND_DO_UCALL_SPEC_RETVAL_USED_HANDLER,
		ZEND_DO_UCALL_SPEC_OBSERVER_HANDLER,
		ZEND_DO_UCALL_SPEC_OBSERVER_HANDLER,
		ZEND_DO_FCALL_BY_NAME_SPEC_RETVAL_UNUSED_HANDLER,
		ZEND_DO_FCALL_BY_NAME_SPEC_RETVAL_USED_HANDLER,
		ZEND_DO_FCALL_BY_NAME_SPEC_OBSERVER_HANDLER,
		ZEND_DO_FCALL_BY_NAME_SPEC_OBSERVER_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_PRE_INC_OBJ_SPEC_VAR_CONST_HANDLER,
		ZEND_PRE_INC_OBJ_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_PRE_INC_OBJ_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_PRE_INC_OBJ_SPEC_VAR_CV_HANDLER,
		ZEND_PRE_INC_OBJ_SPEC_UNUSED_CONST_HANDLER,
		ZEND_PRE_INC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_PRE_INC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_PRE_INC_OBJ_SPEC_UNUSED_CV_HANDLER,
		ZEND_PRE_INC_OBJ_SPEC_CV_CONST_HANDLER,
		ZEND_PRE_INC_OBJ_SPEC_CV_TMPVAR_HANDLER,
		ZEND_PRE_INC_OBJ_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_PRE_INC_OBJ_SPEC_CV_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_POST_INC_OBJ_SPEC_VAR_CONST_HANDLER,
		ZEND_POST_INC_OBJ_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_POST_INC_OBJ_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_POST_INC_OBJ_SPEC_VAR_CV_HANDLER,
		ZEND_POST_INC_OBJ_SPEC_UNUSED_CONST_HANDLER,
		ZEND_POST_INC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_POST_INC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_POST_INC_OBJ_SPEC_UNUSED_CV_HANDLER,
		ZEND_POST_INC_OBJ_SPEC_CV_CONST_HANDLER,
		ZEND_POST_INC_OBJ_SPEC_CV_TMPVAR_HANDLER,
		ZEND_POST_INC_OBJ_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_POST_INC_OBJ_SPEC_CV_CV_HANDLER,
		ZEND_ECHO_SPEC_CONST_HANDLER,
		ZEND_ECHO_SPEC_TMPVAR_HANDLER,
		ZEND_ECHO_SPEC_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ECHO_SPEC_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_INSTANCEOF_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_INSTANCEOF_SPEC_TMPVAR_VAR_HANDLER,
		ZEND_INSTANCEOF_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_INSTANCEOF_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_INSTANCEOF_SPEC_TMPVAR_VAR_HANDLER,
		ZEND_INSTANCEOF_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_INSTANCEOF_SPEC_CV_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_INSTANCEOF_SPEC_CV_VAR_HANDLER,
		ZEND_INSTANCEOF_SPEC_CV_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_GENERATOR_CREATE_SPEC_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MAKE_REF_SPEC_VAR_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MAKE_REF_SPEC_CV_UNUSED_HANDLER,
		ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
		ZEND_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_UNUSED_HANDLER,
		ZEND_DECLARE_CONST_SPEC_CONST_CONST_HANDLER,
		ZEND_DECLARE_CLASS_SPEC_CONST_HANDLER,
		ZEND_DECLARE_CLASS_DELAYED_SPEC_CONST_CONST_HANDLER,
		ZEND_DECLARE_ANON_CLASS_SPEC_HANDLER,
		ZEND_ADD_ARRAY_UNPACK_SPEC_HANDLER,
		ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CONST_HANDLER,
		ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CV_HANDLER,
		ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CV_HANDLER,
		ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CV_HANDLER,
		ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CONST_HANDLER,
		ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CV_HANDLER,
		ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CONST_HANDLER,
		ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMPVAR_HANDLER,
		ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CV_HANDLER,
		ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
		ZEND_HANDLE_EXCEPTION_SPEC_OBSERVER_HANDLER,
		ZEND_USER_OPCODE_SPEC_HANDLER,
		ZEND_ASSERT_CHECK_SPEC_HANDLER,
		ZEND_JMP_SET_SPEC_CONST_HANDLER,
		ZEND_JMP_SET_SPEC_TMP_HANDLER,
		ZEND_JMP_SET_SPEC_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_JMP_SET_SPEC_CV_HANDLER,
		ZEND_UNSET_CV_SPEC_CV_UNUSED_HANDLER,
		ZEND_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_SET_HANDLER,
		ZEND_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_EMPTY_HANDLER,
		ZEND_FETCH_LIST_W_SPEC_VAR_CONST_HANDLER,
		ZEND_FETCH_LIST_W_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_FETCH_LIST_W_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_LIST_W_SPEC_VAR_CV_HANDLER,
		ZEND_SEPARATE_SPEC_VAR_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_CLASS_NAME_SPEC_TMPVAR_HANDLER,
		ZEND_FETCH_CLASS_NAME_SPEC_TMPVAR_HANDLER,
		ZEND_FETCH_CLASS_NAME_SPEC_UNUSED_HANDLER,
		ZEND_FETCH_CLASS_NAME_SPEC_CV_HANDLER,
		ZEND_CALL_TRAMPOLINE_SPEC_HANDLER,
		ZEND_CALL_TRAMPOLINE_SPEC_OBSERVER_HANDLER,
		ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
		ZEND_YIELD_SPEC_CONST_CONST_HANDLER,
		ZEND_YIELD_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_YIELD_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_YIELD_SPEC_CONST_UNUSED_HANDLER,
		ZEND_YIELD_SPEC_CONST_CV_HANDLER,
		ZEND_YIELD_SPEC_TMP_CONST_HANDLER,
		ZEND_YIELD_SPEC_TMP_TMPVAR_HANDLER,
		ZEND_YIELD_SPEC_TMP_TMPVAR_HANDLER,
		ZEND_YIELD_SPEC_TMP_UNUSED_HANDLER,
		ZEND_YIELD_SPEC_TMP_CV_HANDLER,
		ZEND_YIELD_SPEC_VAR_CONST_HANDLER,
		ZEND_YIELD_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_YIELD_SPEC_VAR_TMPVAR_HANDLER,
		ZEND_YIELD_SPEC_VAR_UNUSED_HANDLER,
		ZEND_YIELD_SPEC_VAR_CV_HANDLER,
		ZEND_YIELD_SPEC_UNUSED_CONST_HANDLER,
		ZEND_YIELD_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_YIELD_SPEC_UNUSED_TMPVAR_HANDLER,
		ZEND_YIELD_SPEC_UNUSED_UNUSED_HANDLER,
		ZEND_YIELD_SPEC_UNUSED_CV_HANDLER,
		ZEND_YIELD_SPEC_CV_CONST_HANDLER,
		ZEND_YIELD_SPEC_CV_TMPVAR_HANDLER,
		ZEND_YIELD_SPEC_CV_TMPVAR_HANDLER,
		ZEND_YIELD_SPEC_CV_UNUSED_HANDLER,
		ZEND_YIELD_SPEC_CV_CV_HANDLER,
		ZEND_GENERATOR_RETURN_SPEC_CONST_HANDLER,
		ZEND_GENERATOR_RETURN_SPEC_OBSERVER_HANDLER,
		ZEND_GENERATOR_RETURN_SPEC_TMP_HANDLER,
		ZEND_GENERATOR_RETURN_SPEC_OBSERVER_HANDLER,
		ZEND_GENERATOR_RETURN_SPEC_VAR_HANDLER,
		ZEND_GENERATOR_RETURN_SPEC_OBSERVER_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_GENERATOR_RETURN_SPEC_CV_HANDLER,
		ZEND_GENERATOR_RETURN_SPEC_OBSERVER_HANDLER,
		ZEND_FAST_CALL_SPEC_HANDLER,
		ZEND_FAST_RET_SPEC_HANDLER,
		ZEND_RECV_VARIADIC_SPEC_UNUSED_HANDLER,
		ZEND_SEND_UNPACK_SPEC_HANDLER,
		ZEND_YIELD_FROM_SPEC_CONST_HANDLER,
		ZEND_YIELD_FROM_SPEC_TMPVAR_HANDLER,
		ZEND_YIELD_FROM_SPEC_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_YIELD_FROM_SPEC_CV_HANDLER,
		ZEND_COPY_TMP_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_BIND_GLOBAL_SPEC_CV_CONST_HANDLER,
		ZEND_COALESCE_SPEC_CONST_HANDLER,
		ZEND_COALESCE_SPEC_TMP_HANDLER,
		ZEND_COALESCE_SPEC_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_COALESCE_SPEC_CV_HANDLER,
		ZEND_SPACESHIP_SPEC_CONST_CONST_HANDLER,
		ZEND_SPACESHIP_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_SPACESHIP_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SPACESHIP_SPEC_CONST_CV_HANDLER,
		ZEND_SPACESHIP_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_SPACESHIP_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_SPACESHIP_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SPACESHIP_SPEC_TMPVAR_CV_HANDLER,
		ZEND_SPACESHIP_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_SPACESHIP_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_SPACESHIP_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SPACESHIP_SPEC_TMPVAR_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SPACESHIP_SPEC_CV_CONST_HANDLER,
		ZEND_SPACESHIP_SPEC_CV_TMPVAR_HANDLER,
		ZEND_SPACESHIP_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SPACESHIP_SPEC_CV_CV_HANDLER,
		ZEND_FUNC_NUM_ARGS_SPEC_UNUSED_UNUSED_HANDLER,
		ZEND_FUNC_GET_ARGS_SPEC_CONST_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FUNC_GET_ARGS_SPEC_UNUSED_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_STATIC_PROP_R_SPEC_HANDLER,
		ZEND_FETCH_STATIC_PROP_W_SPEC_HANDLER,
		ZEND_FETCH_STATIC_PROP_RW_SPEC_HANDLER,
		ZEND_FETCH_STATIC_PROP_IS_SPEC_HANDLER,
		ZEND_FETCH_STATIC_PROP_FUNC_ARG_SPEC_HANDLER,
		ZEND_FETCH_STATIC_PROP_UNSET_SPEC_HANDLER,
		ZEND_UNSET_STATIC_PROP_SPEC_HANDLER,
		ZEND_ISSET_ISEMPTY_STATIC_PROP_SPEC_HANDLER,
		ZEND_FETCH_CLASS_CONSTANT_SPEC_CONST_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_CLASS_CONSTANT_SPEC_VAR_CONST_HANDLER,
		ZEND_FETCH_CLASS_CONSTANT_SPEC_UNUSED_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_BIND_LEXICAL_SPEC_TMP_CV_HANDLER,
		ZEND_BIND_STATIC_SPEC_CV_UNUSED_HANDLER,
		ZEND_FETCH_THIS_SPEC_UNUSED_UNUSED_HANDLER,
		ZEND_SEND_FUNC_ARG_SPEC_VAR_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ISSET_ISEMPTY_THIS_SPEC_UNUSED_UNUSED_HANDLER,
		ZEND_SWITCH_LONG_SPEC_CONST_CONST_HANDLER,
		ZEND_SWITCH_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_SWITCH_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SWITCH_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_SWITCH_STRING_SPEC_CONST_CONST_HANDLER,
		ZEND_SWITCH_STRING_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_SWITCH_STRING_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SWITCH_STRING_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IN_ARRAY_SPEC_CONST_CONST_HANDLER,
		ZEND_IN_ARRAY_SPEC_TMP_CONST_HANDLER,
		ZEND_IN_ARRAY_SPEC_VAR_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IN_ARRAY_SPEC_CV_CONST_HANDLER,
		ZEND_COUNT_SPEC_CONST_UNUSED_HANDLER,
		ZEND_COUNT_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_COUNT_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_COUNT_SPEC_CV_UNUSED_HANDLER,
		ZEND_GET_CLASS_SPEC_CONST_UNUSED_HANDLER,
		ZEND_GET_CLASS_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_GET_CLASS_SPEC_TMPVAR_UNUSED_HANDLER,
		ZEND_GET_CLASS_SPEC_UNUSED_UNUSED_HANDLER,
		ZEND_GET_CLASS_SPEC_CV_UNUSED_HANDLER,
		ZEND_GET_CALLED_CLASS_SPEC_UNUSED_UNUSED_HANDLER,
		ZEND_GET_TYPE_SPEC_CONST_UNUSED_HANDLER,
		ZEND_GET_TYPE_SPEC_TMP_UNUSED_HANDLER,
		ZEND_GET_TYPE_SPEC_VAR_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_GET_TYPE_SPEC_CV_UNUSED_HANDLER,
		ZEND_ARRAY_KEY_EXISTS_SPEC_CONST_CONST_HANDLER,
		ZEND_ARRAY_KEY_EXISTS_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_ARRAY_KEY_EXISTS_SPEC_CONST_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ARRAY_KEY_EXISTS_SPEC_CONST_CV_HANDLER,
		ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CV_HANDLER,
		ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ARRAY_KEY_EXISTS_SPEC_CV_CONST_HANDLER,
		ZEND_ARRAY_KEY_EXISTS_SPEC_CV_TMPVAR_HANDLER,
		ZEND_ARRAY_KEY_EXISTS_SPEC_CV_TMPVAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ARRAY_KEY_EXISTS_SPEC_CV_CV_HANDLER,
		ZEND_MATCH_SPEC_CONST_CONST_HANDLER,
		ZEND_MATCH_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_MATCH_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MATCH_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_CASE_STRICT_SPEC_TMP_CONST_HANDLER,
		ZEND_CASE_STRICT_SPEC_TMP_TMP_HANDLER,
		ZEND_CASE_STRICT_SPEC_TMP_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_CASE_STRICT_SPEC_TMP_CV_HANDLER,
		ZEND_CASE_STRICT_SPEC_VAR_CONST_HANDLER,
		ZEND_CASE_STRICT_SPEC_VAR_TMP_HANDLER,
		ZEND_CASE_STRICT_SPEC_VAR_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_CASE_STRICT_SPEC_VAR_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MATCH_ERROR_SPEC_CONST_UNUSED_HANDLER,
		ZEND_MATCH_ERROR_SPEC_TMPVARCV_UNUSED_HANDLER,
		ZEND_MATCH_ERROR_SPEC_TMPVARCV_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MATCH_ERROR_SPEC_TMPVARCV_UNUSED_HANDLER,
		ZEND_JMP_NULL_SPEC_CONST_HANDLER,
		ZEND_JMP_NULL_SPEC_TMPVARCV_HANDLER,
		ZEND_JMP_NULL_SPEC_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_JMP_NULL_SPEC_TMPVARCV_HANDLER,
		ZEND_CHECK_UNDEF_ARGS_SPEC_UNUSED_UNUSED_HANDLER,
		ZEND_RECV_NOTYPE_SPEC_HANDLER,
		ZEND_JMP_FORWARD_SPEC_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ADD_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_ADD_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ADD_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ADD_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_ADD_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ADD_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SUB_LONG_NO_OVERFLOW_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_SUB_LONG_NO_OVERFLOW_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SUB_LONG_NO_OVERFLOW_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SUB_LONG_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_SUB_LONG_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SUB_LONG_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_SUB_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SUB_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SUB_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SUB_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_SUB_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SUB_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_SUB_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SUB_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SUB_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MUL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_MUL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MUL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MUL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_MUL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MUL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_IDENTICAL_NOTHROW_SPEC_CV_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_IDENTICAL_NOTHROW_SPEC_CV_CV_HANDLER,
		ZEND_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CONST_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ_HANDLER,
		ZEND_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ_HANDLER,
		ZEND_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED_HANDLER,
		ZEND_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED_HANDLER,
		ZEND_PRE_INC_LONG_SPEC_CV_RETVAL_UNUSED_HANDLER,
		ZEND_PRE_INC_LONG_SPEC_CV_RETVAL_USED_HANDLER,
		ZEND_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED_HANDLER,
		ZEND_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED_HANDLER,
		ZEND_PRE_DEC_LONG_SPEC_CV_RETVAL_UNUSED_HANDLER,
		ZEND_PRE_DEC_LONG_SPEC_CV_RETVAL_USED_HANDLER,
		ZEND_POST_INC_LONG_NO_OVERFLOW_SPEC_CV_HANDLER,
		ZEND_POST_INC_LONG_SPEC_CV_HANDLER,
		ZEND_POST_DEC_LONG_NO_OVERFLOW_SPEC_CV_HANDLER,
		ZEND_POST_DEC_LONG_SPEC_CV_HANDLER,
		ZEND_QM_ASSIGN_LONG_SPEC_CONST_HANDLER,
		ZEND_QM_ASSIGN_LONG_SPEC_TMPVARCV_HANDLER,
		ZEND_QM_ASSIGN_LONG_SPEC_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_QM_ASSIGN_LONG_SPEC_TMPVARCV_HANDLER,
		ZEND_QM_ASSIGN_DOUBLE_SPEC_CONST_HANDLER,
		ZEND_QM_ASSIGN_DOUBLE_SPEC_TMPVARCV_HANDLER,
		ZEND_QM_ASSIGN_DOUBLE_SPEC_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_QM_ASSIGN_DOUBLE_SPEC_TMPVARCV_HANDLER,
		ZEND_QM_ASSIGN_NOREF_SPEC_CONST_HANDLER,
		ZEND_QM_ASSIGN_NOREF_SPEC_TMPVARCV_HANDLER,
		ZEND_QM_ASSIGN_NOREF_SPEC_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_QM_ASSIGN_NOREF_SPEC_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_R_INDEX_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_FETCH_DIM_R_INDEX_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_R_INDEX_SPEC_CONST_TMPVARCV_HANDLER,
		ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_HANDLER,
		ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_HANDLER,
		ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_CONST_HANDLER,
		ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_HANDLER,
		ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_R_INDEX_SPEC_CV_CONST_HANDLER,
		ZEND_FETCH_DIM_R_INDEX_SPEC_CV_TMPVARCV_HANDLER,
		ZEND_FETCH_DIM_R_INDEX_SPEC_CV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_FETCH_DIM_R_INDEX_SPEC_CV_TMPVARCV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_VAR_SIMPLE_SPEC_VAR_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_VAR_SIMPLE_SPEC_CV_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_VAR_EX_SIMPLE_SPEC_VAR_UNUSED_HANDLER,
		ZEND_NULL_HANDLER,
		ZEND_SEND_VAR_EX_SIMPLE_SPEC_CV_UNUSED_HANDLER,
		ZEND_SEND_VAL_SIMPLE_SPEC_CONST_HANDLER,
		ZEND_SEND_VAL_EX_SIMPLE_SPEC_CONST_HANDLER,
		ZEND_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_UNUSED_HANDLER,
		ZEND_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_USED_HANDLER,
		ZEND_NULL_HANDLER
	};
	static const uint32_t specs[] = {
		0,
		1 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		26 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		51 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE,
		76 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		101 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		126 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		151 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		176 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		201 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE,
		226 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE,
		251 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE,
		276 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		301 | SPEC_RULE_OP1,
		306 | SPEC_RULE_OP1,
		311 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE,
		336 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE,
		361 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE,
		386 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH | SPEC_RULE_COMMUTATIVE,
		461 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH | SPEC_RULE_COMMUTATIVE,
		536 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH,
		611 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH,
		686 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_RETVAL,
		736 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_OP_DATA,
		861 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_OP_DATA,
		986 | SPEC_RULE_OP_DATA,
		991 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1016 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1041 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1066,
		1067 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1092 | SPEC_RULE_OP1,
		1097 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_OP_DATA,
		1222,
		1223 | SPEC_RULE_OP1 | SPEC_RULE_RETVAL,
		1233 | SPEC_RULE_OP1 | SPEC_RULE_RETVAL,
		1243 | SPEC_RULE_OP1,
		1248 | SPEC_RULE_OP1,
		1253,
		1253,
		1254,
		1254,
		1255,
		1256 | SPEC_RULE_OP1,
		1261 | SPEC_RULE_OP1,
		1266 | SPEC_RULE_OP1,
		1271 | SPEC_RULE_OP1,
		1276 | SPEC_RULE_OP1,
		1281 | SPEC_RULE_OP2,
		1286,
		1287 | SPEC_RULE_OP2 | SPEC_RULE_QUICK_ARG,
		1297 | SPEC_RULE_OP1,
		1302 | SPEC_RULE_OP1,
		1307 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1332 | SPEC_RULE_OP2,
		1337 | SPEC_RULE_OP2,
		1342 | SPEC_RULE_OP2,
		1347,
		1348,
		1349,
		1350 | SPEC_RULE_RETVAL | SPEC_RULE_OBSERVER,
		1354,
		1355 | SPEC_RULE_OP1 | SPEC_RULE_OBSERVER,
		1365,
		1366,
		1367 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1392 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_QUICK_ARG,
		1442 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1467 | SPEC_RULE_OP1,
		1472,
		1473,
		1474 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1499 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1524 | SPEC_RULE_OP1 | SPEC_RULE_OBSERVER,
		1534 | SPEC_RULE_OP1,
		1539 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1564 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1589 | SPEC_RULE_OP1,
		1594,
		1595,
		1596 | SPEC_RULE_OP1,
		1601 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1626 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1651 | SPEC_RULE_OP1,
		1656 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1681 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1706 | SPEC_RULE_OP1,
		1711 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1736 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1761 | SPEC_RULE_OP1,
		1766 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1791 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1816 | SPEC_RULE_OP1,
		1821 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1846 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1871 | SPEC_RULE_OP1,
		1876 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1901 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1926 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1951,
		1952 | SPEC_RULE_OP2 | SPEC_RULE_QUICK_ARG,
		1962,
		1963,
		1964,
		1965,
		1966,
		1967 | SPEC_RULE_OP2,
		1972,
		1973 | SPEC_RULE_OP1,
		1978 | SPEC_RULE_OP2,
		1983 | SPEC_RULE_OP1,
		1988 | SPEC_RULE_OP1 | SPEC_RULE_OBSERVER,
		1998 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2023 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2048 | SPEC_RULE_OP1,
		2053 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2078 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_QUICK_ARG,
		2128 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2153 | SPEC_RULE_OP2,
		2158,
		2159 | SPEC_RULE_OP1,
		2164 | SPEC_RULE_OP1,
		2169,
		2170 | SPEC_RULE_OP1,
		2175 | SPEC_RULE_OP1,
		2180 | SPEC_RULE_OP1,
		2185,
		2186,
		2187 | SPEC_RULE_OP2,
		2192 | SPEC_RULE_RETVAL,
		2194 | SPEC_RULE_RETVAL | SPEC_RULE_OBSERVER,
		2198 | SPEC_RULE_RETVAL | SPEC_RULE_OBSERVER,
		2202 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2202 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2227 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2227 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2252 | SPEC_RULE_OP1,
		2257,
		2258 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2283,
		2284 | SPEC_RULE_OP1,
		2289,
		2290,
		2291,
		2292,
		2293,
		2294,
		2295,
		2296 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2321 | SPEC_RULE_OBSERVER,
		2323,
		2324,
		2325 | SPEC_RULE_OP1,
		2330,
		2331 | SPEC_RULE_ISSET,
		2333 | SPEC_RULE_OP2,
		2338,
		2339 | SPEC_RULE_OP1,
		2344 | SPEC_RULE_OBSERVER,
		2346,
		2347 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2372 | SPEC_RULE_OP1 | SPEC_RULE_OBSERVER,
		2382,
		2383,
		2384,
		2385,
		2386 | SPEC_RULE_OP1,
		2391,
		2392,
		2393 | SPEC_RULE_OP1,
		2398 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2423,
		2424 | SPEC_RULE_OP1,
		2429,
		2430,
		2431,
		2432,
		2433,
		2434,
		2435,
		2436,
		2437 | SPEC_RULE_OP1,
		2442,
		2443,
		2444,
		2445 | SPEC_RULE_OP2,
		2450,
		2451 | SPEC_RULE_OP1,
		2456 | SPEC_RULE_OP1,
		2461 | SPEC_RULE_OP1,
		2466 | SPEC_RULE_OP1,
		2471 | SPEC_RULE_OP1,
		2476,
		2477 | SPEC_RULE_OP1,
		2482 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2507 | SPEC_RULE_OP1,
		2512 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2537 | SPEC_RULE_OP1,
		2542 | SPEC_RULE_OP1,
		2547,
		3451
	};
#if (ZEND_VM_KIND == ZEND_VM_KIND_HYBRID)
	zend_opcode_handler_funcs = labels;
	zend_spec_handlers = specs;
	execute_ex(NULL);
#else
	zend_opcode_handlers = labels;
	zend_handlers_count = sizeof(labels) / sizeof(void*);
	zend_spec_handlers = specs;
#endif
	VM_TRACE_START();
}

static HashTable *zend_handlers_table = NULL;

void zend_vm_dtor(void)
{
	VM_TRACE_END();
	if (zend_handlers_table) {
		zend_hash_destroy(zend_handlers_table);
		free(zend_handlers_table);
		zend_handlers_table = NULL;
	}
}

static void init_opcode_serialiser(void)
{
	int i;
	zval tmp;

	zend_handlers_table = malloc(sizeof(HashTable));
	zend_hash_init(zend_handlers_table, zend_handlers_count, NULL, NULL, 1);
	zend_hash_real_init(zend_handlers_table, 0);
	Z_TYPE_INFO(tmp) = IS_LONG;
	for (i = 0; i < zend_handlers_count; i++) {
		Z_LVAL(tmp) = i;
		zend_hash_index_add(zend_handlers_table, (zend_long)(zend_uintptr_t)zend_opcode_handlers[i], &tmp);
	}
}

ZEND_API void ZEND_FASTCALL zend_serialize_opcode_handler(zend_op *op)
{
	zval *zv;

	if (!zend_handlers_table) {
		init_opcode_serialiser();
	}
	zv = zend_hash_index_find(zend_handlers_table, (zend_long)(zend_uintptr_t)op->handler);
	ZEND_ASSERT(zv != NULL);
	op->handler = (const void *)(zend_uintptr_t)Z_LVAL_P(zv);
}

ZEND_API void ZEND_FASTCALL zend_deserialize_opcode_handler(zend_op *op)
{
	op->handler = zend_opcode_handlers[(zend_uintptr_t)op->handler];
}

ZEND_API const void* ZEND_FASTCALL zend_get_opcode_handler_func(const zend_op *op)
{
#if ZEND_VM_KIND == ZEND_VM_KIND_CALL
	return op->handler;
#elif ZEND_VM_KIND == ZEND_VM_KIND_HYBRID
	zval *zv;

	if (!zend_handlers_table) {
		init_opcode_serialiser();
	}
	zv = zend_hash_index_find(zend_handlers_table, (zend_long)(zend_uintptr_t)op->handler);
	ZEND_ASSERT(zv != NULL);
	return zend_opcode_handler_funcs[Z_LVAL_P(zv)];
#else
	return NULL;
#endif
}

ZEND_API const zend_op *zend_get_halt_op(void)
{
#if ZEND_VM_KIND == ZEND_VM_KIND_HYBRID
	return &hybrid_halt_op;
#else
	return NULL;
#endif
}

ZEND_API int zend_vm_kind(void)
{
	return ZEND_VM_KIND;
}

static uint32_t ZEND_FASTCALL zend_vm_get_opcode_handler_idx(uint32_t spec, const zend_op* op)
{
	static const int zend_vm_decode[] = {
		_UNUSED_CODE, /* 0 = IS_UNUSED  */
		_CONST_CODE,  /* 1 = IS_CONST   */
		_TMP_CODE,    /* 2 = IS_TMP_VAR */
		_UNUSED_CODE, /* 3              */
		_VAR_CODE,    /* 4 = IS_VAR     */
		_UNUSED_CODE, /* 5              */
		_UNUSED_CODE, /* 6              */
		_UNUSED_CODE, /* 7              */
		_CV_CODE      /* 8 = IS_CV      */
	};
	uint32_t offset = 0;
	if (spec & SPEC_RULE_OP1) offset = offset * 5 + zend_vm_decode[op->op1_type];
	if (spec & SPEC_RULE_OP2) offset = offset * 5 + zend_vm_decode[op->op2_type];
	if (spec & SPEC_EXTRA_MASK) {
		if (spec & SPEC_RULE_RETVAL) {
			offset = offset * 2 + (op->result_type != IS_UNUSED);
			if ((spec & SPEC_RULE_OBSERVER) && ZEND_OBSERVER_ENABLED) {
				offset += 2;
			}
		} else if (spec & SPEC_RULE_QUICK_ARG) {
			offset = offset * 2 + (op->op2.num <= MAX_ARG_FLAG_NUM);
		} else if (spec & SPEC_RULE_OP_DATA) {
			offset = offset * 5 + zend_vm_decode[(op + 1)->op1_type];
		} else if (spec & SPEC_RULE_ISSET) {
			offset = offset * 2 + (op->extended_value & ZEND_ISEMPTY);
		} else if (spec & SPEC_RULE_SMART_BRANCH) {
			offset = offset * 3;
			if (op->result_type == (IS_SMART_BRANCH_JMPZ|IS_TMP_VAR)) {
				offset += 1;
			} else if (op->result_type == (IS_SMART_BRANCH_JMPNZ|IS_TMP_VAR)) {
				offset += 2;
			}
		} else if (spec & SPEC_RULE_OBSERVER) {
			offset = offset * 2;
			if (ZEND_OBSERVER_ENABLED) {
				offset += 1;
			}
		}
	}
	return (spec & SPEC_START_MASK) + offset;
}

#if (ZEND_VM_KIND != ZEND_VM_KIND_HYBRID) || !ZEND_VM_SPEC
static const void *zend_vm_get_opcode_handler(zend_uchar opcode, const zend_op* op)
{
	return zend_opcode_handlers[zend_vm_get_opcode_handler_idx(zend_spec_handlers[opcode], op)];
}
#endif

#if ZEND_VM_KIND == ZEND_VM_KIND_HYBRID
static const void *zend_vm_get_opcode_handler_func(zend_uchar opcode, const zend_op* op)
{
	uint32_t spec = zend_spec_handlers[opcode];
	return zend_opcode_handler_funcs[zend_vm_get_opcode_handler_idx(spec, op)];
}

#endif

ZEND_API void ZEND_FASTCALL zend_vm_set_opcode_handler(zend_op* op)
{
	zend_uchar opcode = zend_user_opcodes[op->opcode];

	if (zend_spec_handlers[op->opcode] & SPEC_RULE_COMMUTATIVE) {
		if (op->op1_type < op->op2_type) {
			zend_swap_operands(op);
		}
	}
	op->handler = zend_opcode_handlers[zend_vm_get_opcode_handler_idx(zend_spec_handlers[opcode], op)];
}

ZEND_API void ZEND_FASTCALL zend_vm_set_opcode_handler_ex(zend_op* op, uint32_t op1_info, uint32_t op2_info, uint32_t res_info)
{
	zend_uchar opcode = zend_user_opcodes[op->opcode];
	uint32_t spec = zend_spec_handlers[opcode];
	switch (opcode) {
		case ZEND_ADD:
			if (res_info == MAY_BE_LONG && op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2550 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE;
				if (op->op1_type < op->op2_type) {
					zend_swap_operands(op);
				}
			} else if (op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2575 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE;
				if (op->op1_type < op->op2_type) {
					zend_swap_operands(op);
				}
			} else if (op1_info == MAY_BE_DOUBLE && op2_info == MAY_BE_DOUBLE) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2600 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE;
				if (op->op1_type < op->op2_type) {
					zend_swap_operands(op);
				}
			}
			break;
		case ZEND_SUB:
			if (res_info == MAY_BE_LONG && op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2625 | SPEC_RULE_OP1 | SPEC_RULE_OP2;
			} else if (op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2650 | SPEC_RULE_OP1 | SPEC_RULE_OP2;
			} else if (op1_info == MAY_BE_DOUBLE && op2_info == MAY_BE_DOUBLE) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2675 | SPEC_RULE_OP1 | SPEC_RULE_OP2;
			}
			break;
		case ZEND_MUL:
			if (op->op1_type < op->op2_type) {
				zend_swap_operands(op);
			}
			if (res_info == MAY_BE_LONG && op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2700 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE;
			} else if (op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2725 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE;
			} else if (op1_info == MAY_BE_DOUBLE && op2_info == MAY_BE_DOUBLE) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2750 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE;
			}
			break;
		case ZEND_IS_IDENTICAL:
			if (op->op1_type < op->op2_type) {
				zend_swap_operands(op);
			}
			if (op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2775 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH | SPEC_RULE_COMMUTATIVE;
			} else if (op1_info == MAY_BE_DOUBLE && op2_info == MAY_BE_DOUBLE) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2850 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH | SPEC_RULE_COMMUTATIVE;
			} else if (op->op1_type == IS_CV && (op->op2_type & (IS_CONST|IS_CV)) && !(op1_info & (MAY_BE_UNDEF|MAY_BE_REF)) && !(op2_info & (MAY_BE_UNDEF|MAY_BE_REF))) {
				spec = 3075 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE;
			}
			break;
		case ZEND_IS_NOT_IDENTICAL:
			if (op->op1_type < op->op2_type) {
				zend_swap_operands(op);
			}
			if (op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2925 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH | SPEC_RULE_COMMUTATIVE;
			} else if (op1_info == MAY_BE_DOUBLE && op2_info == MAY_BE_DOUBLE) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 3000 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH | SPEC_RULE_COMMUTATIVE;
			} else if (op->op1_type == IS_CV && (op->op2_type & (IS_CONST|IS_CV)) && !(op1_info & (MAY_BE_UNDEF|MAY_BE_REF)) && !(op2_info & (MAY_BE_UNDEF|MAY_BE_REF))) {
				spec = 3080 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE;
			}
			break;
		case ZEND_IS_EQUAL:
			if (op->op1_type < op->op2_type) {
				zend_swap_operands(op);
			}
			if (op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2775 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH | SPEC_RULE_COMMUTATIVE;
			} else if (op1_info == MAY_BE_DOUBLE && op2_info == MAY_BE_DOUBLE) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2850 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH | SPEC_RULE_COMMUTATIVE;
			}
			break;
		case ZEND_IS_NOT_EQUAL:
			if (op->op1_type < op->op2_type) {
				zend_swap_operands(op);
			}
			if (op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2925 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH | SPEC_RULE_COMMUTATIVE;
			} else if (op1_info == MAY_BE_DOUBLE && op2_info == MAY_BE_DOUBLE) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 3000 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH | SPEC_RULE_COMMUTATIVE;
			}
			break;
		case ZEND_IS_SMALLER:
			if (op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 3085 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH;
			} else if (op1_info == MAY_BE_DOUBLE && op2_info == MAY_BE_DOUBLE) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 3160 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH;
			}
			break;
		case ZEND_IS_SMALLER_OR_EQUAL:
			if (op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 3235 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH;
			} else if (op1_info == MAY_BE_DOUBLE && op2_info == MAY_BE_DOUBLE) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 3310 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH;
			}
			break;
		case ZEND_QM_ASSIGN:
			if (op1_info == MAY_BE_LONG) {
				spec = 3397 | SPEC_RULE_OP1;
			} else if (op1_info == MAY_BE_DOUBLE) {
				spec = 3402 | SPEC_RULE_OP1;
			} else if ((op->op1_type == IS_CONST) ? !Z_REFCOUNTED_P(RT_CONSTANT(op, op->op1)) : (!(op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG|MAY_BE_DOUBLE))))) {
				spec = 3407 | SPEC_RULE_OP1;
			}
			break;
		case ZEND_PRE_INC:
			if (res_info == MAY_BE_LONG && op1_info == MAY_BE_LONG) {
				spec = 3385 | SPEC_RULE_RETVAL;
			} else if (op1_info == MAY_BE_LONG) {
				spec = 3387 | SPEC_RULE_RETVAL;
			}
			break;
		case ZEND_PRE_DEC:
			if (res_info == MAY_BE_LONG && op1_info == MAY_BE_LONG) {
				spec = 3389 | SPEC_RULE_RETVAL;
			} else if (op1_info == MAY_BE_LONG) {
				spec = 3391 | SPEC_RULE_RETVAL;
			}
			break;
		case ZEND_POST_INC:
			if (res_info == MAY_BE_LONG && op1_info == MAY_BE_LONG) {
				spec = 3393;
			} else if (op1_info == MAY_BE_LONG) {
				spec = 3394;
			}
			break;
		case ZEND_POST_DEC:
			if (res_info == MAY_BE_LONG && op1_info == MAY_BE_LONG) {
				spec = 3395;
			} else if (op1_info == MAY_BE_LONG) {
				spec = 3396;
			}
			break;
		case ZEND_JMP:
			if (OP_JMP_ADDR(op, op->op1) > op) {
				spec = 2549;
			}
			break;
		case ZEND_RECV:
			if (op->op2.num == MAY_BE_ANY) {
				spec = 2548;
			}
			break;
		case ZEND_SEND_VAL:
			if (op->op1_type == IS_CONST && op->op2_type == IS_UNUSED && !Z_REFCOUNTED_P(RT_CONSTANT(op, op->op1))) {
				spec = 3447;
			}
			break;
		case ZEND_SEND_VAR_EX:
			if (op->op2_type == IS_UNUSED && op->op2.num <= MAX_ARG_FLAG_NUM && (op1_info & (MAY_BE_UNDEF|MAY_BE_REF)) == 0) {
				spec = 3442 | SPEC_RULE_OP1;
			}
			break;
		case ZEND_FE_FETCH_R:
			if (op->op2_type == IS_CV && (op1_info & (MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_ARRAY) {
				spec = 3449 | SPEC_RULE_RETVAL;
			}
			break;
		case ZEND_FETCH_DIM_R:
			if (!(op2_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF))) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 3412 | SPEC_RULE_OP1 | SPEC_RULE_OP2;
			}
			break;
		case ZEND_SEND_VAL_EX:
			if (op->op2_type == IS_UNUSED && op->op2.num <= MAX_ARG_FLAG_NUM && op->op1_type == IS_CONST && !Z_REFCOUNTED_P(RT_CONSTANT(op, op->op1))) {
				spec = 3448;
			}
			break;
		case ZEND_SEND_VAR:
			if (op->op2_type == IS_UNUSED && (op1_info & (MAY_BE_UNDEF|MAY_BE_REF)) == 0) {
				spec = 3437 | SPEC_RULE_OP1;
			}
			break;
		case ZEND_BW_OR:
		case ZEND_BW_AND:
		case ZEND_BW_XOR:
		case ZEND_BOOL_XOR:
			if (op->op1_type < op->op2_type) {
				zend_swap_operands(op);
			}
			break;
		case ZEND_USER_OPCODE:
			if (zend_spec_handlers[op->opcode] & SPEC_RULE_COMMUTATIVE) {
				if (op->op1_type < op->op2_type) {
					zend_swap_operands(op);
				}
			}
			break;
		default:
			break;
	}
	op->handler = zend_opcode_handlers[zend_vm_get_opcode_handler_idx(spec, op)];
}

ZEND_API int ZEND_FASTCALL zend_vm_call_opcode_handler(zend_execute_data* ex)
{
#if (ZEND_VM_KIND == ZEND_VM_KIND_HYBRID)
	opcode_handler_t handler;
#endif
	int ret;
#ifdef ZEND_VM_IP_GLOBAL_REG
	const zend_op *orig_opline = opline;
#endif
#ifdef ZEND_VM_FP_GLOBAL_REG
	zend_execute_data *orig_execute_data = execute_data;
	execute_data = ex;
#else
	zend_execute_data *execute_data = ex;
#endif

	LOAD_OPLINE();
#if defined(ZEND_VM_FP_GLOBAL_REG) && defined(ZEND_VM_IP_GLOBAL_REG)
#if (ZEND_VM_KIND == ZEND_VM_KIND_HYBRID)
	handler = (opcode_handler_t)zend_vm_get_opcode_handler_func(zend_user_opcodes[opline->opcode], opline);
	handler(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	if (EXPECTED(opline != &hybrid_halt_op)) {
#else
	((opcode_handler_t)OPLINE->handler)(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	if (EXPECTED(opline)) {
#endif
		ret = execute_data != ex ? (int)(execute_data->prev_execute_data != ex) + 1 : 0;
		SAVE_OPLINE();
	} else {
		ret = -1;
	}
#else
	ret = ((opcode_handler_t)OPLINE->handler)(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	SAVE_OPLINE();
#endif
#ifdef ZEND_VM_FP_GLOBAL_REG
	execute_data = orig_execute_data;
#endif
#ifdef ZEND_VM_IP_GLOBAL_REG
	opline = orig_opline;
#endif
	return ret;
}

