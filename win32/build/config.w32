// vim:ft=javascript
// $Id$
// "Master" config file; think of it as a configure.in
// equivalent.

ARG_WITH('cygwin', 'Path to cygwin utilities on your system', '\\cygwin');
CL = PATH_PROG('cl');
if (!CL) {
	ERROR("MS C++ compiler is required");
}

// 1200 is VC6
// 1300 is vs.net 2002
// 1310 is vs.net 2003
// 1400 is vs.net 2005
// 1500 is vs.net 2008
// Which version of the compiler do we have?
VCVERS = probe_binary(CL).substr(0, 5).replace('.', '');
STDOUT.WriteLine("  Detected compiler " + VC_VERSIONS[VCVERS]);
AC_DEFINE('COMPILER', VC_VERSIONS[VCVERS], "Detected compiler version");

// do we use x64 or 80x86 version of compiler?
X64 = probe_binary(CL, 64);
if (X64) {
	STDOUT.WriteLine("Detected 64-bit compiler");
} else {
	STDOUT.WriteLine("Detected 32-bit compiler");
}

// cygwin now ships with link.exe.  Avoid searching the cygwin path
// for this, as we want the MS linker, not the fileutil
PATH_PROG('link', WshShell.Environment("Process").Item("PATH"));
PATH_PROG('nmake');

// we don't want to define LIB, as that will override the default library path
// that is set in that env var
PATH_PROG('lib', null, 'MAKE_LIB');
if (!PATH_PROG('bison')) {
	ERROR('bison is required')
}

// There's a minimum requirement for re2c..
MINRE2C = "0.13.4";

function probe_re2c_version(RE2C)
{
	var command = "cmd /c " + RE2C + " -v";
	var version = execute(command + '" 2>&1"');

	if (version.match(/((\d+)\.(\d+)\.(\d+))/)) {
		return RegExp.$1;
	}
	return 0;
}

RE2C = PATH_PROG('re2c');
if (RE2C) {
	var intvers, intmin;
	var pattern = /\./g;

	RE2CVERS = probe_re2c_version(RE2C);
	intvers = RE2CVERS.replace(pattern, '') - 0;
	intmin = MINRE2C.replace(pattern, '') - 0;

	if (intvers < intmin) {
		STDOUT.WriteLine('WARNING: The minimum RE2C version requirement is ' + MINRE2C + ', ' + RE2CVERS + ' detected');
		STDOUT.WriteLine('Parsers will not be generated. Upgrade your copy at http://sf.net/projects/re2c');
		DEFINE('RE2C', '');
	} else {
		DEFINE('RE2C_FLAGS', '');
	}
} else {
	STDOUT.WriteLine('Parsers will not be regenerated');
}
PATH_PROG('zip');
PATH_PROG('lemon');

// avoid picking up midnight commander from cygwin
PATH_PROG('mc', WshShell.Environment("Process").Item("PATH"));

// Try locating manifest tool
PATH_PROG('mt', WshShell.Environment("Process").Item("PATH"));

// stick objects somewhere outside of the source tree
ARG_ENABLE('object-out-dir', 'Alternate location for binary objects during build', '');
if (PHP_OBJECT_OUT_DIR.length) {
	if (!FSO.FolderExists(PHP_OBJECT_OUT_DIR)) {
		ERROR('you chosen output directory ' + PHP_OBJECT_OUT_DIR + ' does not exist');
	}
	PHP_OBJECT_OUT_DIR += '\\';
} else if (X64) {
	if (!FSO.FolderExists("x64")) {
		FSO.CreateFolder("x64");
	}
	PHP_OBJECT_OUT_DIR = 'x64\\';
}

ARG_ENABLE('debug', 'Compile with debugging symbols', "no");
ARG_ENABLE('debug-pack', 'Release binaries with external debug symbols (--enable-debug must not be specified)', 'no');
if (PHP_DEBUG == "yes" && PHP_DEBUG_PACK == "yes") {
	ERROR("Use of both --enable-debug and --enable-debug-pack not allowed.");
}
ARG_ENABLE('zts', 'Thread safety', 'yes');
// Configures the hard-coded installation dir
ARG_ENABLE('prefix', 'where PHP will be installed', '');
if (PHP_PREFIX == '') {
	PHP_PREFIX = "C:\\php" + PHP_VERSION;
	if (PHP_DEBUG == "yes")
		PHP_PREFIX += "\\debug";
}
DEFINE('PHP_PREFIX', PHP_PREFIX);

DEFINE("BASE_INCLUDES", "/I . /I main /I Zend /I TSRM /I ext ");

// CFLAGS for building the PHP dll
DEFINE("CFLAGS_PHP", "/D _USRDLL /D PHP5DLLTS_EXPORTS /D PHP_EXPORTS \
/D LIBZEND_EXPORTS /D TSRM_EXPORTS /D SAPI_EXPORTS /D WINVER=0x400");

DEFINE('CFLAGS_PHP_OBJ', '$(CFLAGS_PHP) $(STATIC_EXT_CFLAGS)');

// General CFLAGS for building objects
DEFINE("CFLAGS", "/nologo /FD $(BASE_INCLUDES) /D _WINDOWS \
/D ZEND_WIN32=1 /D PHP_WIN32=1 /D WIN32 /D _MBCS");

if (VCVERS < 1400) {
	// Enable automatic precompiled headers
	ADD_FLAG('CFLAGS', ' /YX ');

	if (PHP_DEBUG == "yes") {
		// Set some debug/release specific options
		ADD_FLAG('CFLAGS', ' /GZ ');
	}
}

if (VCVERS >= 1400) {
	// fun stuff: MS deprecated ANSI stdio and similar functions
	// disable annoying warnings.  In addition, time_t defaults
	// to 64-bit.  Ask for 32-bit.
	if (X64) {
		ADD_FLAG('CFLAGS', ' /wd4996 /Wp64 ');
	} else {
		ADD_FLAG('CFLAGS', ' /wd4996 /D_USE_32BIT_TIME_T=1 ');
	}

	if (PHP_DEBUG == "yes") {
		// Set some debug/release specific options
		ADD_FLAG('CFLAGS', ' /RTC1 ');
	}
}

// General link flags
DEFINE("LDFLAGS", "/nologo /version:" +
	PHP_VERSION + "." + PHP_MINOR_VERSION + "." + PHP_RELEASE_VERSION);

// General DLL link flags
DEFINE("DLL_LDFLAGS", "/dll ");

// PHP DLL link flags
DEFINE("PHP_LDFLAGS", "$(DLL_LDFLAGS)");

// General libs
// urlmon.lib ole32.lib oleaut32.lib uuid.lib gdi32.lib winspool.lib comdlg32.lib
DEFINE("LIBS", "kernel32.lib ole32.lib user32.lib advapi32.lib shell32.lib ws2_32.lib");

// Set some debug/release specific options
if (PHP_DEBUG == "yes") {
	ADD_FLAG("CFLAGS", "/LDd /MDd /Gm /Od /D _DEBUG /D ZEND_DEBUG=1 " +
		(X64?"/Zi":"/ZI"));
	ADD_FLAG("LDFLAGS", "/debug");
	// Avoid problems when linking to release libraries that use the release
	// version of the libc
	ADD_FLAG("PHP_LDFLAGS", "/nodefaultlib:msvcrt");
} else {
	// Generate external debug files when --enable-debug-pack is specified
	if (PHP_DEBUG_PACK == "yes") {
		ADD_FLAG("CFLAGS", "/Zi");
		ADD_FLAG("LDFLAGS", "/incremental:no /debug /opt:ref,icf");
	}
	// Equivalent to Release_TSInline build -> best optimization
	ADD_FLAG("CFLAGS", "/LD /MD /W3 /Ox /D NDebug /D NDEBUG \
/D ZEND_WIN32_FORCE_INLINE /GF /D ZEND_DEBUG=0");
	// if you have VS.Net /GS hardens the binary against buffer overruns
	// ADD_FLAG("CFLAGS", "/GS");
}

if (PHP_ZTS == "yes") {
	ADD_FLAG("CFLAGS", "/D ZTS=1");
}

// we want msvcrt in the PHP DLL
ADD_FLAG("PHP_LDFLAGS", "/nodefaultlib:libcmt");

// set up the build dir and DLL name
if (PHP_DEBUG == "yes" && PHP_ZTS == "yes") {
	DEFINE("BUILD_DIR", PHP_OBJECT_OUT_DIR + "Debug_TS");
	DEFINE("PHPDLL", "php" + PHP_VERSION + "ts_debug.dll");
	DEFINE("PHPLIB", "php" + PHP_VERSION + "ts_debug.lib");
} else if (PHP_DEBUG == "yes" && PHP_ZTS == "no") {
	DEFINE("BUILD_DIR", PHP_OBJECT_OUT_DIR + "Debug");
	DEFINE("PHPDLL", "php" + PHP_VERSION + "_debug.dll");
	DEFINE("PHPLIB", "php" + PHP_VERSION + "_debug.lib");
} else if (PHP_DEBUG == "no" && PHP_ZTS == "yes") {
	DEFINE("BUILD_DIR", PHP_OBJECT_OUT_DIR + "Release_TS");
	DEFINE("PHPDLL", "php" + PHP_VERSION + "ts.dll");
	DEFINE("PHPLIB", "php" + PHP_VERSION + "ts.lib");
} else if (PHP_DEBUG == "no" && PHP_ZTS == "no") {
	DEFINE("BUILD_DIR", PHP_OBJECT_OUT_DIR + "Release");
	DEFINE("PHPDLL", "php" + PHP_VERSION + ".dll");
	DEFINE("PHPLIB", "php" + PHP_VERSION + ".lib");
}

// Find the php_build dir - it contains headers and libraries
// that we need
ARG_WITH('php-build', 'Path to where you extracted http://www.php.net/extra/win32build.zip. Assumes that it is a sibling of this source dir (..\\php_build) if not specified', 'no');

if (PHP_PHP_BUILD == 'no') {
	if (FSO.FolderExists("..\\php_build")) {
		PHP_PHP_BUILD = "..\\php_build";
	} else {
		if (X64) {
			if (FSO.FolderExists("..\\win64build")) {
				PHP_PHP_BUILD = "..\\win64build";
			} else if (FSO.FolderExists("..\\php-win64-dev\\php_build")) {
				PHP_PHP_BUILD = "..\\php-win64-dev\\php_build";
			}
		} else {
			if (FSO.FolderExists("..\\win32build")) {
				PHP_PHP_BUILD = "..\\win32build";
			} else if (FSO.FolderExists("..\\php-win32-dev\\php_build")) {
				PHP_PHP_BUILD = "..\\php-win32-dev\\php_build";
			}
		}
	}
}

ARG_WITH('extra-includes', 'Extra include path to use when building everything', '');
ARG_WITH('extra-libs', 'Extra library path to use when linking everything', '');

var php_usual_include_suspects = PHP_PHP_BUILD+"\\include;..\\bindlib_w32";
var php_usual_lib_suspects = PHP_PHP_BUILD+"\\lib;..\\bindlib_w32";

// Poke around for some headers
function probe_basic_headers()
{
	var p;

	if (PHP_PHP_BUILD != "no") {
		php_usual_include_suspects += ";" + PHP_PHP_BUILD + "\\include";
		php_usual_lib_suspects += ";" + PHP_PHP_BUILD + "\\lib";
	}

	p = CHECK_HEADER_ADD_INCLUDE("arpa\\nameser.h", "CFLAGS", php_usual_include_suspects);

	// hack to catch common location of libs
	if (typeof(p) == "string") {
		p = p.replace(new RegExp("include$"), "lib");
		ADD_FLAG("LDFLAGS", '/libpath:"' + p + '" ');
		php_usual_lib_suspects += ";" + p;
	} else if (!p) {
		ERROR("We really need that arpa\\nameser.h file - it is part of the bindlib package");
	}
}

function add_extra_dirs()
{
	var path, i, f;

	if (PHP_EXTRA_INCLUDES.length) {
		path = PHP_EXTRA_INCLUDES.split(';');
		for (i = 0; i < path.length; i++) {
			f = FSO.GetAbsolutePathName(path[i]);
			if (FSO.FolderExists(f)) {
				ADD_FLAG("CFLAGS", '/I "' + f + '" ');
			}
		}
	}
	if (PHP_EXTRA_LIBS.length) {
		path = PHP_EXTRA_LIBS.split(';');
		for (i = 0; i < path.length; i++) {
			f = FSO.GetAbsolutePathName(path[i]);
			if (FSO.FolderExists(f)) {
				if (VCVERS <= 1200 && f.indexOf(" ") >= 0) {
					ADD_FLAG("LDFLAGS", '/libpath:"\\"' + f + '\\"" ');
				} else {
					ADD_FLAG("LDFLAGS", '/libpath:"' + f + '" ');
				}
			}
		}
	}

}

probe_basic_headers();
add_extra_dirs();

// We can't probe for libs before this line

if (!(CHECK_LIB("resolv_a.lib") || CHECK_LIB("resolv.lib"))) {
	ERROR("We really need that arpa\\nameser.h file - it is part of the bindlib package");
}

// Do we want static ICU lib
ARG_WITH('static-icu', 'Link against the static version of the ICU library', 'no');
if (PHP_STATIC_ICU == "yes") {
	if (!CHECK_LIB('sicuuc.lib', null, PHP_STATIC_ICU)) {
		ERROR('static ICU library not found');
	}
	ADD_FLAG("LIBS", "sicuuc.lib sicuin.lib sicuio.lib sicule.lib siculx.lib sicudt.lib");
	ADD_FLAG("CFLAGS", "/D U_STATIC_IMPLEMENTATION=1")
} else {
	if (!CHECK_LIB('icuuc.lib', null)) {
		ERROR('ICU library not found');
	}
	ADD_FLAG("LIBS", "icuuc.lib icuin.lib icuio.lib icule.lib iculx.lib");
}

//DEFINE("PHP_BUILD", PHP_PHP_BUILD);

STDOUT.WriteBlankLines(1);
STDOUT.WriteLine("Build dir: " + get_define('BUILD_DIR'));
STDOUT.WriteLine("PHP Core:  " + get_define('PHPDLL') + " and " + get_define('PHPLIB'));

ADD_SOURCES("Zend", "zend_language_parser.c zend_language_scanner.c \
	zend_ini_parser.c zend_ini_scanner.c zend_alloc.c zend_compile.c \
	zend_constants.c zend_dynamic_array.c zend_exceptions.c \
	zend_execute_API.c zend_highlight.c \
	zend_llist.c zend_opcode.c zend_operators.c zend_ptr_stack.c \
	zend_stack.c zend_variables.c zend.c zend_API.c zend_extensions.c \
	zend_hash.c zend_list.c zend_indent.c zend_builtin_functions.c \
	zend_sprintf.c zend_ini.c zend_qsort.c zend_ts_hash.c \
	zend_stream.c zend_iterators.c zend_interfaces.c zend_objects.c \
	zend_object_handlers.c zend_objects_API.c  zend_unicode.c zend_strtol.c  \
	zend_default_classes.c zend_execute.c zend_strtod.c zend_gc.c zend_closures.c");

ADD_SOURCES("main", "main.c snprintf.c spprintf.c fopen_wrappers.c \
	php_scandir.c php_ini.c SAPI.c rfc1867.c php_content_types.c strlcpy.c \
	strlcat.c mergesort.c reentrancy.c php_variables.c php_ticks.c network.c \
	php_open_temporary_file.c php_logos.c output.c internal_functions.c php_sprintf.c \
	getopt.c");

ADD_SOURCES("main/streams", "streams.c cast.c memory.c filter.c plain_wrapper.c \
	userspace.c transports.c xp_socket.c mmap.c unicode_filter.c glob_wrapper.c");

ADD_SOURCES("win32", "crypt_win32.c glob.c md5crypt.c readdir.c \
	registry.c select.c sendmail.c time.c wfile.c winutil.c wsyslog.c globals.c");

STDOUT.WriteBlankLines(1);

/* Can we build with IPv6 support? */
ARG_ENABLE("ipv6", "Disable IPv6 support (default is turn it on if available)", "yes");

var main_network_has_ipv6 = 0;
if (PHP_IPV6 == "yes") {
	main_network_has_ipv6 = CHECK_HEADER_ADD_INCLUDE("wspiapi.h", "CFLAGS") ? 1 : 0;
}
if (main_network_has_ipv6) {
	STDOUT.WriteLine("Enabling IPv6 support");
}
AC_DEFINE('HAVE_GETADDRINFO', main_network_has_ipv6);
AC_DEFINE('HAVE_GAI_STRERROR', main_network_has_ipv6);
AC_DEFINE('HAVE_IPV6', main_network_has_ipv6);

/* this allows up to 256 sockets to be select()ed in a single
 * call to select(), instead of the usual 64 */
ARG_ENABLE('fd-setsize', "Set maximum number of sockets for select(2)", "256");
ADD_FLAG("CFLAGS", "/D FD_SETSIZE=" + parseInt(PHP_FD_SETSIZE));

AC_DEFINE('HAVE_USLEEP', 1);
AC_DEFINE('HAVE_STRCOLL', 1);

/* For snapshot builders, where can we find the additional
 * files that make up the snapshot template? */
ARG_WITH("snapshot-template", "Path to snapshot builder template dir", "no");

if (PHP_SNAPSHOT_TEMPLATE == "no") {
	/* default is as a sibling of the php_build dir */
	if (FSO.FolderExists(PHP_PHP_BUILD + "\\template")) {
		PHP_SNAPSHOT_TEMPLATE = FSO.GetAbsolutePathName(PHP_PHP_BUILD + "\\template");
	} else if (FSO.FolderExists(PHP_PHP_BUILD + "\\..\\template")) {
		PHP_SNAPSHOT_TEMPLATE = FSO.GetAbsolutePathName(PHP_PHP_BUILD + "\\..\\template");
	}
}

DEFINE('SNAPSHOT_TEMPLATE', PHP_SNAPSHOT_TEMPLATE);

ARG_ENABLE('summary', 'Enable configuration summary', 'yes');
