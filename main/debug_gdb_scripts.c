/*
 * Generated by debug_gdb_scripts_gen.php.
 *
 * This inlines .gdbinit and php_gdb.py into the .debug_gdb_scripts
 * section of the binary, so that they can be found by gdb.
 *
 * See https://sourceware.org/gdb/current/onlinedocs/gdb.html/dotdebug_005fgdb_005fscripts-section.html#dotdebug_005fgdb_005fscripts-section
 */
asm(
    ".pushsection \".debug_gdb_scripts\", \"MS\",%progbits,1\n"
    ".byte 4 /* Python Text */\n"
    ".ascii \"gdb.inlined-script\\n\"\n"
    ".ascii \"gdb.execute('''\\n\"\n"
    ".ascii \"define set_ts\\n\"\n"
    ".ascii \"	set $tsrm_ls = $arg0\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"document set_ts\\n\"\n"
    ".ascii \"	set the ts resource, it is impossible for gdb to\\n\"\n"
    ".ascii \"	call ts_resource_ex while no process is running,\\n\"\n"
    ".ascii \"	but we could get the resource from the argument\\n\"\n"
    ".ascii \"	of frame info.\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"define ____executor_globals\\n\"\n"
    ".ascii \"	if basic_functions_module.zts\\n\"\n"
    ".ascii \"		set $tsrm_ls = _tsrm_ls_cache\\n\"\n"
    ".ascii \"		set $eg = ((zend_executor_globals*) (*((void ***) $tsrm_ls))[executor_globals_id-1])\\n\"\n"
    ".ascii \"		set $cg = ((zend_compiler_globals*) (*((void ***) $tsrm_ls))[compiler_globals_id-1])\\n\"\n"
    ".ascii \"		set $eg_ptr = $eg\\n\"\n"
    ".ascii \"	else\\n\"\n"
    ".ascii \"		set $eg = executor_globals\\n\"\n"
    ".ascii \"		set $cg = compiler_globals\\n\"\n"
    ".ascii \"		set $eg_ptr = (zend_executor_globals*) &executor_globals\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"document ____executor_globals\\n\"\n"
    ".ascii \"	portable way of accessing executor_globals, set $eg\\n\"\n"
    ".ascii \"	this also sets compiler_globals to $cg\\n\"\n"
    ".ascii \"	ZTS detection is automatically based on ext/standard module struct\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"define print_cvs\\n\"\n"
    ".ascii \"	if $argc == 0\\n\"\n"
    ".ascii \"		____executor_globals\\n\"\n"
    ".ascii \"		set $cv_ex_ptr = $eg.current_execute_data\\n\"\n"
    ".ascii \"	else\\n\"\n"
    ".ascii \"		set $cv_ex_ptr = (zend_execute_data *)$arg0\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	set $cv_count = $cv_ex_ptr.func.op_array.last_var\\n\"\n"
    ".ascii \"	set $cv = $cv_ex_ptr.func.op_array.vars\\n\"\n"
    ".ascii \"	set $cv_idx = 0\\n\"\n"
    ".ascii \"	set $callFrameSize = (sizeof(zend_execute_data) + sizeof(zval) - 1) / sizeof(zval)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"	printf \\\"Compiled variables count: %d\\\\\\\\n\\\\\\\\n\\\", $cv_count\\n\"\n"
    ".ascii \"	while $cv_idx < $cv_count\\n\"\n"
    ".ascii \"		printf \\\"[%d] \\\\'%s\\\\'\\\\\\\\n\\\", $cv_idx, $cv[$cv_idx].val\\n\"\n"
    ".ascii \"		set $zvalue = ((zval *) $cv_ex_ptr) + $callFrameSize + $cv_idx\\n\"\n"
    ".ascii \"		printzv $zvalue\\n\"\n"
    ".ascii \"		set $cv_idx = $cv_idx + 1\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"document print_cvs\\n\"\n"
    ".ascii \"	Prints the compiled variables and their values.\\n\"\n"
    ".ascii \"	If a zend_execute_data pointer is set this will print the compiled\\n\"\n"
    ".ascii \"	variables of that scope. If no parameter is used it will use\\n\"\n"
    ".ascii \"	current_execute_data for scope.\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"	usage: print_cvs [zend_execute_data *]\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"define dump_bt\\n\"\n"
    ".ascii \"	set $ex = $arg0\\n\"\n"
    ".ascii \"	while $ex\\n\"\n"
    ".ascii \"		printf \\\"[%p] \\\", $ex\\n\"\n"
    ".ascii \"		set $func = $ex->func\\n\"\n"
    ".ascii \"		if $func\\n\"\n"
    ".ascii \"			if $ex->This->value.obj\\n\"\n"
    ".ascii \"				if $func->common.scope\\n\"\n"
    ".ascii \"					printf \\\"%s->\\\", (char*)$func->common.scope->name->val\\n\"\n"
    ".ascii \"				else\\n\"\n"
    ".ascii \"					printf \\\"%s->\\\", (char*)$ex->This->value.obj->ce.name->val\\n\"\n"
    ".ascii \"				end\\n\"\n"
    ".ascii \"			else\\n\"\n"
    ".ascii \"				if $func->common.scope\\n\"\n"
    ".ascii \"					printf \\\"%s::\\\", (char*)$func->common.scope->name->val\\n\"\n"
    ".ascii \"				end\\n\"\n"
    ".ascii \"			end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"			if $func->common.function_name\\n\"\n"
    ".ascii \"				printf \\\"%s(\\\", (char*)$func->common.function_name->val\\n\"\n"
    ".ascii \"			else\\n\"\n"
    ".ascii \"				printf \\\"(main\\\"\\n\"\n"
    ".ascii \"			end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"			set $callFrameSize = (sizeof(zend_execute_data) + sizeof(zval) - 1) / sizeof(zval)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"			set $count = $ex->This.u2.num_args\\n\"\n"
    ".ascii \"			set $arg = 0\\n\"\n"
    ".ascii \"			while $arg < $count\\n\"\n"
    ".ascii \"				if $arg > 0\\n\"\n"
    ".ascii \"					printf \\\", \\\"\\n\"\n"
    ".ascii \"				end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"				set $zvalue = (zval *) $ex + $callFrameSize + $arg\\n\"\n"
    ".ascii \"				set $type = $zvalue->u1.v.type\\n\"\n"
    ".ascii \"				if $type == 1\\n\"\n"
    ".ascii \"					printf \\\"NULL\\\"\\n\"\n"
    ".ascii \"				end\\n\"\n"
    ".ascii \"				if $type == 2\\n\"\n"
    ".ascii \"					printf \\\"false\\\"\\n\"\n"
    ".ascii \"				end\\n\"\n"
    ".ascii \"				if $type == 3\\n\"\n"
    ".ascii \"					printf \\\"true\\\"\\n\"\n"
    ".ascii \"				end\\n\"\n"
    ".ascii \"				if $type == 4\\n\"\n"
    ".ascii \"					printf \\\"%ld\\\", $zvalue->value.lval\\n\"\n"
    ".ascii \"				end\\n\"\n"
    ".ascii \"				if $type == 5\\n\"\n"
    ".ascii \"					printf \\\"%f\\\", $zvalue->value.dval\\n\"\n"
    ".ascii \"				end\\n\"\n"
    ".ascii \"				if $type == 6\\n\"\n"
    ".ascii \"					____print_str (char*)$zvalue->value.str->val $zvalue->value.str->len\\n\"\n"
    ".ascii \"				end\\n\"\n"
    ".ascii \"				if $type == 7\\n\"\n"
    ".ascii \"					printf \\\"array(%d)[%p]\\\", $zvalue->value.arr->nNumOfElements, $zvalue\\n\"\n"
    ".ascii \"				end\\n\"\n"
    ".ascii \"				if $type == 8\\n\"\n"
    ".ascii \"					printf \\\"object[%p]\\\", $zvalue\\n\"\n"
    ".ascii \"				end\\n\"\n"
    ".ascii \"				if $type == 9\\n\"\n"
    ".ascii \"					printf \\\"resource(#%d)\\\", $zvalue->value.lval\\n\"\n"
    ".ascii \"				end\\n\"\n"
    ".ascii \"				if $type == 10\\n\"\n"
    ".ascii \"					printf \\\"reference\\\"\\n\"\n"
    ".ascii \"				end\\n\"\n"
    ".ascii \"				if $type > 10\\n\"\n"
    ".ascii \"					printf \\\"unknown type %d\\\", $type\\n\"\n"
    ".ascii \"				end\\n\"\n"
    ".ascii \"				set $arg = $arg + 1\\n\"\n"
    ".ascii \"			end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"			printf \\\") \\\"\\n\"\n"
    ".ascii \"		else\\n\"\n"
    ".ascii \"			printf \\\"\?\?\? \\\"\\n\"\n"
    ".ascii \"		end\\n\"\n"
    ".ascii \"		if $func != 0\\n\"\n"
    ".ascii \"			if $func->type == 2\\n\"\n"
    ".ascii \"				printf \\\"%s:%d \\\", (char*)$func->op_array.filename->val, $ex->opline->lineno\\n\"\n"
    ".ascii \"			else\\n\"\n"
    ".ascii \"				printf \\\"[internal function]\\\"\\n\"\n"
    ".ascii \"			end\\n\"\n"
    ".ascii \"		end\\n\"\n"
    ".ascii \"		set $ex = $ex->prev_execute_data\\n\"\n"
    ".ascii \"		printf \\\"\\\\\\\\n\\\"\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"document dump_bt\\n\"\n"
    ".ascii \"	dumps the current execution stack. usage: dump_bt executor_globals.current_execute_data\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"define printzv\\n\"\n"
    ".ascii \"	set $ind = 1\\n\"\n"
    ".ascii \"	____printzv $arg0 0\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"document printzv\\n\"\n"
    ".ascii \"	prints zval contents\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"define ____printzv_contents\\n\"\n"
    ".ascii \"	set $zvalue = $arg0\\n\"\n"
    ".ascii \"	set $type = $zvalue->u1.v.type\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"	# 15 == IS_INDIRECT\\n\"\n"
    ".ascii \"	if $type > 5 && $type < 12\\n\"\n"
    ".ascii \"		printf \\\"(refcount=%d) \\\", $zvalue->value.counted->gc.refcount\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"	if $type == 0\\n\"\n"
    ".ascii \"		printf \\\"UNDEF\\\"\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $type == 1\\n\"\n"
    ".ascii \"		printf \\\"NULL\\\"\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $type == 2\\n\"\n"
    ".ascii \"		printf \\\"bool: false\\\"\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $type == 3\\n\"\n"
    ".ascii \"		printf \\\"bool: true\\\"\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $type == 4\\n\"\n"
    ".ascii \"		printf \\\"long: %ld\\\", $zvalue->value.lval\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $type == 5\\n\"\n"
    ".ascii \"		printf \\\"double: %f\\\", $zvalue->value.dval\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $type == 6\\n\"\n"
    ".ascii \"		printf \\\"string: %s\\\", (char*)$zvalue->value.str->val\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $type == 7\\n\"\n"
    ".ascii \"		printf \\\"array: \\\"\\n\"\n"
    ".ascii \"		if ! $arg1\\n\"\n"
    ".ascii \"			set $ind = $ind + 1\\n\"\n"
    ".ascii \"			____print_ht $zvalue->value.arr 1\\n\"\n"
    ".ascii \"			set $ind = $ind - 1\\n\"\n"
    ".ascii \"			set $i = $ind\\n\"\n"
    ".ascii \"			while $i > 0\\n\"\n"
    ".ascii \"				printf \\\"  \\\"\\n\"\n"
    ".ascii \"				set $i = $i - 1\\n\"\n"
    ".ascii \"			end\\n\"\n"
    ".ascii \"		end\\n\"\n"
    ".ascii \"		set $type = 0\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $type == 8\\n\"\n"
    ".ascii \"		printf \\\"object\\\"\\n\"\n"
    ".ascii \"		____executor_globals\\n\"\n"
    ".ascii \"		set $handle = $zvalue->value.obj.handle\\n\"\n"
    ".ascii \"		set $handlers = $zvalue->value.obj.handlers\\n\"\n"
    ".ascii \"		set $zobj = $zvalue->value.obj\\n\"\n"
    ".ascii \"		set $cname = (char*)$zobj->ce->name->val\\n\"\n"
    ".ascii \"		printf \\\"(%s) #%d\\\", $cname, $handle\\n\"\n"
    ".ascii \"		if ! $arg1\\n\"\n"
    ".ascii \"			if $handlers->get_properties == &zend_std_get_properties\\n\"\n"
    ".ascii \"				if $zobj->properties\\n\"\n"
    ".ascii \"					printf \\\"\\\\\\\\nProperties \\\"\\n\"\n"
    ".ascii \"					set $ht = $zobj->properties\\n\"\n"
    ".ascii \"					set $ind = $ind + 1\\n\"\n"
    ".ascii \"					____print_ht $ht 1\\n\"\n"
    ".ascii \"					set $ind = $ind - 1\\n\"\n"
    ".ascii \"					set $i = $ind\\n\"\n"
    ".ascii \"					while $i > 0\\n\"\n"
    ".ascii \"						printf \\\"  \\\"\\n\"\n"
    ".ascii \"						set $i = $i - 1\\n\"\n"
    ".ascii \"					end\\n\"\n"
    ".ascii \"				else\\n\"\n"
    ".ascii \"					printf \\\" {\\\\\\\\n\\\"\\n\"\n"
    ".ascii \"					set $ht = &$zobj->ce->properties_info\\n\"\n"
    ".ascii \"					set $k = 0\\n\"\n"
    ".ascii \"					set $num = $ht->nNumUsed\\n\"\n"
    ".ascii \"					while $k < $num\\n\"\n"
    ".ascii \"						set $p = (Bucket*)($ht->arData + $k)\\n\"\n"
    ".ascii \"						set $name = $p->key\\n\"\n"
    ".ascii \"						set $prop = (zend_property_info*)$p->val.value.ptr\\n\"\n"
    ".ascii \"						set $val = (zval*)((char*)$zobj + $prop->offset)\\n\"\n"
    ".ascii \"						printf \\\"%s => \\\", (char*)$name->val\\n\"\n"
    ".ascii \"						printzv $val\\n\"\n"
    ".ascii \"						set $k = $k + 1\\n\"\n"
    ".ascii \"					end\\n\"\n"
    ".ascii \"				end\\n\"\n"
    ".ascii \"			end\\n\"\n"
    ".ascii \"		end\\n\"\n"
    ".ascii \"		set $type = 0\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $type == 9\\n\"\n"
    ".ascii \"		printf \\\"resource: #%d\\\", $zvalue->value.res->handle\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $type == 10\\n\"\n"
    ".ascii \"		printf \\\"reference: \\\"\\n\"\n"
    ".ascii \"		____printzv &$zvalue->value.ref->val $arg1\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $type == 11\\n\"\n"
    ".ascii \"		printf \\\"CONSTANT_AST\\\"\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $type == 12\\n\"\n"
    ".ascii \"		printf \\\"indirect: \\\"\\n\"\n"
    ".ascii \"		____printzv $zvalue->value.zv $arg1\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $type == 13\\n\"\n"
    ".ascii \"		printf \\\"pointer: %p\\\", $zvalue->value.ptr\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $type == 15\\n\"\n"
    ".ascii \"		printf \\\"_ERROR\\\"\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $type == 16\\n\"\n"
    ".ascii \"		printf \\\"_BOOL\\\"\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $type == 17\\n\"\n"
    ".ascii \"		printf \\\"_NUMBER\\\"\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $type > 17\\n\"\n"
    ".ascii \"		printf \\\"unknown type %d\\\", $type\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	printf \\\"\\\\\\\\n\\\"\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"define ____printzv\\n\"\n"
    ".ascii \"	____executor_globals\\n\"\n"
    ".ascii \"	set $zvalue = $arg0\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"	printf \\\"[%p] \\\", $zvalue\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"	set $zcontents = (zval*) $zvalue\\n\"\n"
    ".ascii \"	if $arg1\\n\"\n"
    ".ascii \"		____printzv_contents $zcontents $arg1\\n\"\n"
    ".ascii \"	else\\n\"\n"
    ".ascii \"		____printzv_contents $zcontents 0\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"define print_global_vars\\n\"\n"
    ".ascii \"	____executor_globals\\n\"\n"
    ".ascii \"	set $symtable = ((HashTable *)&($eg_ptr->symbol_table))\\n\"\n"
    ".ascii \"	print_ht $symtable\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"document print_global_vars\\n\"\n"
    ".ascii \"	Prints the global variables\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"define print_const_table\\n\"\n"
    ".ascii \"	set $ind = 1\\n\"\n"
    ".ascii \"	printf \\\"[%p] {\\\\\\\\n\\\", $arg0\\n\"\n"
    ".ascii \"	____print_ht $arg0 4\\n\"\n"
    ".ascii \"	printf \\\"}\\\\\\\\n\\\"\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"document print_const_table\\n\"\n"
    ".ascii \"	Dumps elements of Constants HashTable\\n\"\n"
    ".ascii \"	Example: print_const_table executor_globals.zend_constants\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"define ____print_ht\\n\"\n"
    ".ascii \"	set $ht = (HashTable*)$arg0\\n\"\n"
    ".ascii \"	set $n = $ind\\n\"\n"
    ".ascii \"	while $n > 0\\n\"\n"
    ".ascii \"		printf \\\"  \\\"\\n\"\n"
    ".ascii \"		set $n = $n - 1\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"	set $packed = $ht->u.v.flags & 4\\n\"\n"
    ".ascii \"	if $packed\\n\"\n"
    ".ascii \"		printf \\\"Packed\\\"\\n\"\n"
    ".ascii \"	else\\n\"\n"
    ".ascii \"		printf \\\"Hash\\\"\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	printf \\\"(%d)[%p]: {\\\\\\\\n\\\", $ht->nNumOfElements, $ht\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"	set $num = $ht->nNumUsed\\n\"\n"
    ".ascii \"	set $i = 0\\n\"\n"
    ".ascii \"	set $ind = $ind + 1\\n\"\n"
    ".ascii \"	while $i < $num\\n\"\n"
    ".ascii \"		if $packed\\n\"\n"
    ".ascii \"			set $val = (zval*)($ht->arPacked + $i)\\n\"\n"
    ".ascii \"			set $key = (zend_string*)0\\n\"\n"
    ".ascii \"			set $h = $i\\n\"\n"
    ".ascii \"		else\\n\"\n"
    ".ascii \"			set $bucket = (Bucket*)($ht->arData + $i)\\n\"\n"
    ".ascii \"			set $val = &$bucket->val\\n\"\n"
    ".ascii \"			set $key = $bucket->key\\n\"\n"
    ".ascii \"			set $h = $bucket->h\\n\"\n"
    ".ascii \"		end\\n\"\n"
    ".ascii \"		set $n = $ind\\n\"\n"
    ".ascii \"		if $val->u1.v.type > 0\\n\"\n"
    ".ascii \"			while $n > 0\\n\"\n"
    ".ascii \"				printf \\\"  \\\"\\n\"\n"
    ".ascii \"				set $n = $n - 1\\n\"\n"
    ".ascii \"			end\\n\"\n"
    ".ascii \"			printf \\\"[%d] \\\", $i\\n\"\n"
    ".ascii \"			if $key\\n\"\n"
    ".ascii \"				____print_str (char*)$key->val $key->len\\n\"\n"
    ".ascii \"				printf \\\" => \\\"\\n\"\n"
    ".ascii \"			else\\n\"\n"
    ".ascii \"				printf \\\"%d => \\\", $h\\n\"\n"
    ".ascii \"			end\\n\"\n"
    ".ascii \"			if $arg1 == 0\\n\"\n"
    ".ascii \"				printf \\\"%p\\\\\\\\n\\\", $val\\n\"\n"
    ".ascii \"			end\\n\"\n"
    ".ascii \"			if $arg1 == 1\\n\"\n"
    ".ascii \"				set $zval = $val\\n\"\n"
    ".ascii \"				____printzv $zval 1\\n\"\n"
    ".ascii \"			end\\n\"\n"
    ".ascii \"			if $arg1 == 2\\n\"\n"
    ".ascii \"				printf \\\"%s\\\\\\\\n\\\", (char*)$val->value.ptr\\n\"\n"
    ".ascii \"			end\\n\"\n"
    ".ascii \"			if $arg1 == 3\\n\"\n"
    ".ascii \"				set $func = (zend_function*)$val->value.ptr\\n\"\n"
    ".ascii \"				printf \\\"\\\\\\\\\\\"%s\\\\\\\\\\\"\\\\\\\\n\\\", (char*)$func->common.function_name->val\\n\"\n"
    ".ascii \"			end\\n\"\n"
    ".ascii \"			if $arg1 == 4\\n\"\n"
    ".ascii \"				set $const = (zend_constant *)$val->value.ptr\\n\"\n"
    ".ascii \"				____printzv $const 1\\n\"\n"
    ".ascii \"			end\\n\"\n"
    ".ascii \"		end\\n\"\n"
    ".ascii \"		set $i = $i + 1\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	set $ind = $ind - 1\\n\"\n"
    ".ascii \"	printf \\\"}\\\\\\\\n\\\"\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"define print_ht\\n\"\n"
    ".ascii \"	set $ind = 0\\n\"\n"
    ".ascii \"	____print_ht $arg0 1\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"document print_ht\\n\"\n"
    ".ascii \"	dumps elements of HashTable made of zval\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"define print_htptr\\n\"\n"
    ".ascii \"	set $ind = 0\\n\"\n"
    ".ascii \"	____print_ht $arg0 0\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"document print_htptr\\n\"\n"
    ".ascii \"	dumps elements of HashTable made of pointers\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"define print_htstr\\n\"\n"
    ".ascii \"	set $ind = 0\\n\"\n"
    ".ascii \"	____print_ht $arg0 2\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"document print_htstr\\n\"\n"
    ".ascii \"	dumps elements of HashTable made of strings\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"define print_ft\\n\"\n"
    ".ascii \"	set $ind = 0\\n\"\n"
    ".ascii \"	____print_ht $arg0 3\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"document print_ft\\n\"\n"
    ".ascii \"	dumps a function table (HashTable)\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"define ____print_inh_class\\n\"\n"
    ".ascii \"	set $ce = $arg0\\n\"\n"
    ".ascii \"	if $ce->ce_flags & 0x10 || $ce->ce_flags & 0x20\\n\"\n"
    ".ascii \"		printf \\\"abstract \\\"\\n\"\n"
    ".ascii \"	else\\n\"\n"
    ".ascii \"		if $ce->ce_flags & 0x40\\n\"\n"
    ".ascii \"			printf \\\"final \\\"\\n\"\n"
    ".ascii \"		end\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	printf \\\"class %s\\\", (char*)$ce->name->val\\n\"\n"
    ".ascii \"	if $ce->parent != 0\\n\"\n"
    ".ascii \"		printf \\\" extends %s\\\", (char*)$ce->parent->name->val\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $ce->num_interfaces != 0\\n\"\n"
    ".ascii \"		printf \\\" implements\\\"\\n\"\n"
    ".ascii \"		set $tmp = 0\\n\"\n"
    ".ascii \"		while $tmp < $ce->num_interfaces\\n\"\n"
    ".ascii \"			printf \\\" %s\\\", (char*)$ce->interfaces[$tmp]->name->val\\n\"\n"
    ".ascii \"			set $tmp = $tmp + 1\\n\"\n"
    ".ascii \"			if $tmp < $ce->num_interfaces\\n\"\n"
    ".ascii \"				printf \\\",\\\"\\n\"\n"
    ".ascii \"			end\\n\"\n"
    ".ascii \"		end\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	set $ce = $ce->parent\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"define ____print_inh_iface\\n\"\n"
    ".ascii \"	set $ce = $arg0\\n\"\n"
    ".ascii \"	printf \\\"interface %s\\\", (char*)$ce->name->val\\n\"\n"
    ".ascii \"	if $ce->num_interfaces != 0\\n\"\n"
    ".ascii \"		set $ce = $ce->interfaces[0]\\n\"\n"
    ".ascii \"		printf \\\" extends %s\\\", (char*)$ce->name->val\\n\"\n"
    ".ascii \"	else\\n\"\n"
    ".ascii \"		set $ce = 0\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"define print_inh\\n\"\n"
    ".ascii \"	set $ce = $arg0\\n\"\n"
    ".ascii \"	set $depth = 0\\n\"\n"
    ".ascii \"	while $ce != 0\\n\"\n"
    ".ascii \"		set $tmp = $depth\\n\"\n"
    ".ascii \"		while $tmp != 0\\n\"\n"
    ".ascii \"			printf \\\" \\\"\\n\"\n"
    ".ascii \"			set $tmp = $tmp - 1\\n\"\n"
    ".ascii \"		end\\n\"\n"
    ".ascii \"		set $depth = $depth + 1\\n\"\n"
    ".ascii \"		if $ce->ce_flags & 0x80\\n\"\n"
    ".ascii \"			____print_inh_iface $ce\\n\"\n"
    ".ascii \"		else\\n\"\n"
    ".ascii \"			____print_inh_class $ce\\n\"\n"
    ".ascii \"		end\\n\"\n"
    ".ascii \"		printf \\\" {\\\\\\\\n\\\"\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	while $depth != 0\\n\"\n"
    ".ascii \"		set $tmp = $depth\\n\"\n"
    ".ascii \"		while $tmp != 1\\n\"\n"
    ".ascii \"			printf \\\" \\\"\\n\"\n"
    ".ascii \"			set $tmp = $tmp - 1\\n\"\n"
    ".ascii \"		end\\n\"\n"
    ".ascii \"		printf \\\"}\\\\\\\\n\\\"\\n\"\n"
    ".ascii \"		set $depth = $depth - 1\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"define print_pi\\n\"\n"
    ".ascii \"	set $pi = (zend_property_info *)$arg0\\n\"\n"
    ".ascii \"	set $initial_offset = ((uint32_t)(uintptr_t)(&((zend_object*)0)->properties_table[(0)]))\\n\"\n"
    ".ascii \"	set $ptr_to_val = (zval*)((char*)$pi->ce->default_properties_table + $pi->offset - $initial_offset)\\n\"\n"
    ".ascii \"	printf \\\"[%p] {\\\\\\\\n\\\", $pi\\n\"\n"
    ".ascii \"	printf \\\"    offset = %p\\\\\\\\n\\\", $pi->offset\\n\"\n"
    ".ascii \"	printf \\\"    ce = [%p] %s\\\\\\\\n\\\", $pi->ce, (char*)$pi->ce->name->val\\n\"\n"
    ".ascii \"	printf \\\"    flags = 0x%x (\\\", $pi->flags\\n\"\n"
    ".ascii \"	if $pi->flags & 0x100\\n\"\n"
    ".ascii \"		printf \\\"ZEND_ACC_PUBLIC\\\"\\n\"\n"
    ".ascii \"	else\\n\"\n"
    ".ascii \"		if $pi->flags & 0x200\\n\"\n"
    ".ascii \"			printf \\\"ZEND_ACC_PROTECTED\\\"\\n\"\n"
    ".ascii \"		else\\n\"\n"
    ".ascii \"			if $pi->flags & 0x400\\n\"\n"
    ".ascii \"				printf \\\"ZEND_ACC_PRIVATE\\\"\\n\"\n"
    ".ascii \"			else\\n\"\n"
    ".ascii \"				if $pi->flags & 0x800\\n\"\n"
    ".ascii \"					printf \\\"ZEND_ACC_EARLY_BINDING\\\"\\n\"\n"
    ".ascii \"				else\\n\"\n"
    ".ascii \"					if $pi->flags & 0x20000\\n\"\n"
    ".ascii \"						printf \\\"ZEND_ACC_SHADOW\\\"\\n\"\n"
    ".ascii \"					end\\n\"\n"
    ".ascii \"				end\\n\"\n"
    ".ascii \"			end\\n\"\n"
    ".ascii \"		end\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	printf \\\")\\\\\\\\n\\\"\\n\"\n"
    ".ascii \"	printf \\\"    name  = \\\"\\n\"\n"
    ".ascii \"	print_zstr $pi->name\\n\"\n"
    ".ascii \"	printf \\\"    default value: \\\"\\n\"\n"
    ".ascii \"	printzv $ptr_to_val\\n\"\n"
    ".ascii \"	printf \\\"}\\\\\\\\n\\\"\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"document print_pi\\n\"\n"
    ".ascii \"	Takes a pointer to an object\\\\'s property and prints the property information\\n\"\n"
    ".ascii \"	usage: print_pi <ptr>\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"define ____print_str\\n\"\n"
    ".ascii \"	set $tmp = 0\\n\"\n"
    ".ascii \"	set $str = $arg0\\n\"\n"
    ".ascii \"	if $argc > 2\\n\"\n"
    ".ascii \"		set $maxlen = $arg2\\n\"\n"
    ".ascii \"	else\\n\"\n"
    ".ascii \"		set $maxlen = 256\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"	printf \\\"\\\\\\\\\\\"\\\"\\n\"\n"
    ".ascii \"	while $tmp < $arg1 && $tmp < $maxlen\\n\"\n"
    ".ascii \"		if $str[$tmp] > 31 && $str[$tmp] < 127\\n\"\n"
    ".ascii \"			printf \\\"%c\\\", $str[$tmp]\\n\"\n"
    ".ascii \"		else\\n\"\n"
    ".ascii \"			printf \\\"\\\\\\\\\\\\\\\\%o\\\", $str[$tmp]\\n\"\n"
    ".ascii \"		end\\n\"\n"
    ".ascii \"		set $tmp = $tmp + 1\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $tmp != $arg1\\n\"\n"
    ".ascii \"		printf \\\"...\\\"\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	printf \\\"\\\\\\\\\\\"\\\"\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"define printzn\\n\"\n"
    ".ascii \"	____executor_globals\\n\"\n"
    ".ascii \"	set $ind = 0\\n\"\n"
    ".ascii \"	set $znode = $arg0\\n\"\n"
    ".ascii \"	if $znode->op_type == 1\\n\"\n"
    ".ascii \"		set $optype = \\\"IS_CONST\\\"\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $znode->op_type == 2\\n\"\n"
    ".ascii \"		set $optype = \\\"IS_TMP_VAR\\\"\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $znode->op_type == 4\\n\"\n"
    ".ascii \"		set $optype = \\\"IS_VAR\\\"\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $znode->op_type == 8\\n\"\n"
    ".ascii \"		set $optype = \\\"IS_UNUSED\\\"\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"	printf \\\"[%p] %s\\\", $znode, $optype\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"	if $znode->op_type == 1\\n\"\n"
    ".ascii \"		printf \\\": \\\"\\n\"\n"
    ".ascii \"		____printzv &$znode->u.constant 0\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $znode->op_type == 2\\n\"\n"
    ".ascii \"		printf \\\": \\\"\\n\"\n"
    ".ascii \"		set $tvar = (union _temp_variable *)((char *)$eg.current_execute_data->Ts + $znode->u.var)\\n\"\n"
    ".ascii \"		____printzv ((union _temp_variable *)$tvar)->tmp_var 0\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $znode->op_type == 4\\n\"\n"
    ".ascii \"		printf \\\": \\\"\\n\"\n"
    ".ascii \"		set $tvar = (union _temp_variable *)((char *)$eg.current_execute_data->Ts + $znode->u.var)\\n\"\n"
    ".ascii \"		____printzv *$tvar->var.ptr_ptr 0\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	if $znode->op_type == 8\\n\"\n"
    ".ascii \"		printf \\\"\\\\\\\\n\\\"\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"document printzn\\n\"\n"
    ".ascii \"	print type and content of znode.\\n\"\n"
    ".ascii \"	usage: printzn &opline->op1\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"define printzops\\n\"\n"
    ".ascii \"	printf \\\"op1 => \\\"\\n\"\n"
    ".ascii \"	printzn &execute_data->opline.op1\\n\"\n"
    ".ascii \"	printf \\\"op2 => \\\"\\n\"\n"
    ".ascii \"	printzn &execute_data->opline.op2\\n\"\n"
    ".ascii \"	printf \\\"result => \\\"\\n\"\n"
    ".ascii \"	printzn &execute_data->opline.result\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"document printzops\\n\"\n"
    ".ascii \"	dump operands of the current opline\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"define print_zstr\\n\"\n"
    ".ascii \"	set $zstr = (zend_string *)$arg0\\n\"\n"
    ".ascii \"	if $argc == 2\\n\"\n"
    ".ascii \"		set $maxlen = $arg1\\n\"\n"
    ".ascii \"	else\\n\"\n"
    ".ascii \"		set $maxlen = $zstr->len\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"	printf \\\"string(%d) \\\", $zstr->len\\n\"\n"
    ".ascii \"	____print_str (char*)$zstr->val $zstr->len $maxlen\\n\"\n"
    ".ascii \"	printf \\\"\\\\\\\\n\\\"\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"document print_zstr\\n\"\n"
    ".ascii \"	print the length and contents of a zend string\\n\"\n"
    ".ascii \"	usage: print_zstr <ptr> [max length]\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"define zbacktrace\\n\"\n"
    ".ascii \"	____executor_globals\\n\"\n"
    ".ascii \"	dump_bt $eg.current_execute_data\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"document zbacktrace\\n\"\n"
    ".ascii \"	prints backtrace.\\n\"\n"
    ".ascii \"	This command is almost a short cut for\\n\"\n"
    ".ascii \"	> (gdb) ____executor_globals\\n\"\n"
    ".ascii \"	> (gdb) dump_bt $eg.current_execute_data\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"define lookup_root\\n\"\n"
    ".ascii \"	set $found = 0\\n\"\n"
    ".ascii \"	if gc_globals->roots\\n\"\n"
    ".ascii \"		set $current = gc_globals->roots->next\\n\"\n"
    ".ascii \"		printf \\\"looking ref %p in roots\\\\\\\\n\\\", $arg0\\n\"\n"
    ".ascii \"		while $current != &gc_globals->roots\\n\"\n"
    ".ascii \"			if $current->ref == $arg0\\n\"\n"
    ".ascii \"				set $found = $current\\n\"\n"
    ".ascii \"				break\\n\"\n"
    ".ascii \"			end\\n\"\n"
    ".ascii \"			set $current = $current->next\\n\"\n"
    ".ascii \"		end\\n\"\n"
    ".ascii \"		if $found != 0\\n\"\n"
    ".ascii \"			printf \\\"found root %p\\\\\\\\n\\\", $found\\n\"\n"
    ".ascii \"		else\\n\"\n"
    ".ascii \"			printf \\\"not found\\\\\\\\n\\\"\\n\"\n"
    ".ascii \"		end\\n\"\n"
    ".ascii \"	end\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"document lookup_root\\n\"\n"
    ".ascii \"	lookup a refcounted in root\\n\"\n"
    ".ascii \"	usage: lookup_root [ptr].\\n\"\n"
    ".ascii \"end\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"''')\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"\\\"\\\"\\\"GDB support for PHP types\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"This is auto-loaded by GDB if Python Auto-loading is enabled (the default), and\\n\"\n"
    ".ascii \"the PHP binary is in the auto load safe path:\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    # ~/.config/gdb/gdbinit (not ~/.gdbinit)\\n\"\n"
    ".ascii \"    add-auto-load-safe-path /path/to/php-src\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"See https://sourceware.org/gdb/current/onlinedocs/gdb.html/Python-Auto_002dloading.html\\n\"\n"
    ".ascii \"See https://sourceware.org/gdb/current/onlinedocs/gdb.html/Auto_002dloading-safe-path.html#Auto_002dloading-safe-path\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"If needed, pretty printers can be by-passed by using the /r flag:\\n\"\n"
    ".ascii \"  (gdb) p /r any_variable\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"Use |set print pretty| to enable multi-line printing and indentation:\\n\"\n"
    ".ascii \"  (gdb) set print pretty on\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"Use |set print max-depth| to control the maximum print depth for nested\\n\"\n"
    ".ascii \"structures:\\n\"\n"
    ".ascii \"  (gdb) set print max-depth 5\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"To interactively type Python for development of the printers, use\\n\"\n"
    ".ascii \"  (gdb) python foo = gdb.parse_and_eval('bar')\\n\"\n"
    ".ascii \"to put the C value 'bar' in the current scope into a Python variable 'foo'.\\n\"\n"
    ".ascii \"Then you can interact with that variable:\\n\"\n"
    ".ascii \"  (gdb) python print foo['impl_']\\n\"\n"
    ".ascii \"\\\"\\\"\\\"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"import gdb\\n\"\n"
    ".ascii \"import gdb.printing\\n\"\n"
    ".ascii \"import gdb.types\\n\"\n"
    ".ascii \"import re\\n\"\n"
    ".ascii \"import traceback\\n\"\n"
    ".ascii \"import os\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"pp_set = gdb.printing.RegexpCollectionPrettyPrinter(\\\"php\\\")\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class ZendStringPrettyPrinter(gdb.printing.PrettyPrinter):\\n\"\n"
    ".ascii \"    \\\"Print a zend_string\\\"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def __init__(self, val):\\n\"\n"
    ".ascii \"        self.val = val\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def to_string(self):\\n\"\n"
    ".ascii \"        return '((zend_string*) 0x%x) %s' % (self.val.address, format_zstr(self.val))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def children(self):\\n\"\n"
    ".ascii \"        for field in self.val.type.fields():\\n\"\n"
    ".ascii \"            if field.name == 'val':\\n\"\n"
    ".ascii \"                yield ('val', format_zstr(self.val))\\n\"\n"
    ".ascii \"            else:\\n\"\n"
    ".ascii \"                yield (field.name, format_nested(self.val[field.name]))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"pp_set.add_printer('zend_string', '^_zend_string$', ZendStringPrettyPrinter)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class ZendObjectPrettyPrinter(gdb.printing.PrettyPrinter):\\n\"\n"
    ".ascii \"    \\\"Print a zend_object\\\"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def __init__(self, val):\\n\"\n"
    ".ascii \"        self.val = val\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def to_string(self):\\n\"\n"
    ".ascii \"        return 'object(%s)' % format_zstr(self.val['ce']['name'])\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def children(self):\\n\"\n"
    ".ascii \"        for field in self.val.type.fields():\\n\"\n"
    ".ascii \"            yield (field.name, format_nested(self.val[field.name]))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"pp_set.add_printer('zend_object', '^_zend_object$', ZendObjectPrettyPrinter)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class ZendArrayPrettyPrinter(gdb.printing.PrettyPrinter):\\n\"\n"
    ".ascii \"    \\\"Print a zend_array\\\"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def __init__(self, val):\\n\"\n"
    ".ascii \"        self.val = val\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def to_string(self):\\n\"\n"
    ".ascii \"        return 'array(%d)' % self.val['nNumOfElements']\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def children(self):\\n\"\n"
    ".ascii \"        for field in self.val.type.fields():\\n\"\n"
    ".ascii \"            if field.name is None:\\n\"\n"
    ".ascii \"                name = '<anonymous>'\\n\"\n"
    ".ascii \"                val = self.val[field]\\n\"\n"
    ".ascii \"            else:\\n\"\n"
    ".ascii \"                name = field.name\\n\"\n"
    ".ascii \"                val = self.val[field.name]\\n\"\n"
    ".ascii \"            yield (name, format_nested(val))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"pp_set.add_printer('zend_array', '^_zend_array$', ZendArrayPrettyPrinter)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class ZendTypePrettyPrinter(gdb.printing.PrettyPrinter):\\n\"\n"
    ".ascii \"    \\\"Print a zend_type\\\"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def __init__(self, val):\\n\"\n"
    ".ascii \"        self.val = val\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def to_string(self):\\n\"\n"
    ".ascii \"        return '((zend_type*) 0x%x) %s' % (self.val.address, self.format_type(self.val))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def children(self):\\n\"\n"
    ".ascii \"        for field in self.val.type.fields():\\n\"\n"
    ".ascii \"            yield (field.name, format_nested(self.val[field.name]))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def format_type(self, t):\\n\"\n"
    ".ascii \"        type_mask = int(t['type_mask'])\\n\"\n"
    ".ascii \"        type_mask_size = t['type_mask'].type.sizeof * 8\\n\"\n"
    ".ascii \"        separator = '|'\\n\"\n"
    ".ascii \"        parts = []\\n\"\n"
    ".ascii \"        meta = []\\n\"\n"
    ".ascii \"        for bit in range(0, type_mask_size):\\n\"\n"
    ".ascii \"            if type_mask & (1 << bit):\\n\"\n"
    ".ascii \"                type_name = ZendTypeBits.zendTypeName(bit)\\n\"\n"
    ".ascii \"                if type_name is None:\\n\"\n"
    ".ascii \"                    parts.append('(1<<%d)' % bit)\\n\"\n"
    ".ascii \"                elif type_name == 'list':\\n\"\n"
    ".ascii \"                    list_ptr = t['ptr'].cast(gdb.lookup_type('zend_type_list').pointer())\\n\"\n"
    ".ascii \"                    num_types = int(list_ptr['num_types'])\\n\"\n"
    ".ascii \"                    types = list_ptr['types'].dereference().cast(gdb.lookup_type('zend_type').array(num_types))\\n\"\n"
    ".ascii \"                    for i in range(0, num_types):\\n\"\n"
    ".ascii \"                        type_str = self.format_type(types[i])\\n\"\n"
    ".ascii \"                        if any((c in set('|&()')) for c in type_str):\\n\"\n"
    ".ascii \"                            type_str = '(%s)' % type_str\\n\"\n"
    ".ascii \"                        parts.append(type_str)\\n\"\n"
    ".ascii \"                elif type_name == 'union' or type_name == 'arena':\\n\"\n"
    ".ascii \"                    meta.append(type_name)\\n\"\n"
    ".ascii \"                elif type_name == 'intersection':\\n\"\n"
    ".ascii \"                    meta.append(type_name)\\n\"\n"
    ".ascii \"                    separator = '&'\\n\"\n"
    ".ascii \"                elif type_name == 'name':\\n\"\n"
    ".ascii \"                    name_str = t['ptr'].cast(gdb.lookup_type('zend_string').pointer())\\n\"\n"
    ".ascii \"                    parts.append(format_zstr(name_str))\\n\"\n"
    ".ascii \"                else:\\n\"\n"
    ".ascii \"                    parts.append(type_name)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        str = separator.join(parts)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        if len(meta) > 0:\\n\"\n"
    ".ascii \"            str = '[%s] %s' % (','.join(meta), str)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        return str\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"pp_set.add_printer('zend_type', '^zend_type$', ZendTypePrettyPrinter)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class ZendAstKindPrettyPrinter(gdb.printing.PrettyPrinter):\\n\"\n"
    ".ascii \"    \\\"Print a zend_ast_kind\\\"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def __init__(self, val):\\n\"\n"
    ".ascii \"        self.val = val\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def to_string(self):\\n\"\n"
    ".ascii \"        return self.val.cast(gdb.lookup_type('enum _zend_ast_kind'))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"pp_set.add_printer('zend_ast_kind', '^zend_ast_kind$', ZendAstKindPrettyPrinter)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class ZendAstPrettyPrinter(gdb.printing.PrettyPrinter):\\n\"\n"
    ".ascii \"    \\\"\\\"\\\"\\n\"\n"
    ".ascii \"        Print a zend_ast, or one of the specialized structures based on it:\\n\"\n"
    ".ascii \"        zend_ast_decl, zend_ast_list, zend_ast_op_array, zend_ast_zval, or\\n\"\n"
    ".ascii \"        zend_ast_znode\\n\"\n"
    ".ascii \"    \\\"\\\"\\\"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def __init__(self, val):\\n\"\n"
    ".ascii \"        self.val = val\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def to_string(self):\\n\"\n"
    ".ascii \"        return '((%s*)0x%x)' % (str(self.cast().type), self.val.address)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def children(self):\\n\"\n"
    ".ascii \"        val = self.cast()\\n\"\n"
    ".ascii \"        for field in val.type.fields():\\n\"\n"
    ".ascii \"            if field.name == 'child':\\n\"\n"
    ".ascii \"                children = val[field.name]\\n\"\n"
    ".ascii \"                num_children = self.num_children()\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"                ptr_type = gdb.lookup_type('zend_ast').pointer().pointer()\\n\"\n"
    ".ascii \"                children = children.cast(ptr_type)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"                for i in range(0, num_children):\\n\"\n"
    ".ascii \"                    c = children[i]\\n\"\n"
    ".ascii \"                    if int(c) != 0:\\n\"\n"
    ".ascii \"                        c = c.dereference()\\n\"\n"
    ".ascii \"                    yield ('child[%d]' % i, c)\\n\"\n"
    ".ascii \"            elif field.name == 'val':\\n\"\n"
    ".ascii \"                yield (field.name, ZvalPrettyPrinter(val[field.name]).to_string())\\n\"\n"
    ".ascii \"            else:\\n\"\n"
    ".ascii \"                yield (field.name, format_nested(val[field.name]))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def is_special(self):\\n\"\n"
    ".ascii \"        special_shift = 6 # ZEND_AST_SPECIAL_SHIFT\\n\"\n"
    ".ascii \"        kind = self.val['kind']\\n\"\n"
    ".ascii \"        return (kind >> special_shift) & 1\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def is_decl(self):\\n\"\n"
    ".ascii \"        return self.is_special() and int(self.val['kind']) >= enum_value('ZEND_AST_FUNC_DECL')\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def is_list(self):\\n\"\n"
    ".ascii \"        list_shift = 7 # ZEND_AST_IS_LIST_SHIFT\\n\"\n"
    ".ascii \"        kind = self.val['kind']\\n\"\n"
    ".ascii \"        return (kind >> list_shift) & 1\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def cast(self):\\n\"\n"
    ".ascii \"        kind = int(self.val['kind'])\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        if kind == enum_value('ZEND_AST_ZVAL') or kind == enum_value('ZEND_AST_CONSTANT'):\\n\"\n"
    ".ascii \"            return self.val.cast(gdb.lookup_type('zend_ast_zval'))\\n\"\n"
    ".ascii \"        if kind == enum_value('ZEND_AST_OP_ARRAY'):\\n\"\n"
    ".ascii \"            return self.val.cast(gdb.lookup_type('zend_ast_op_array'))\\n\"\n"
    ".ascii \"        if kind == enum_value('ZEND_AST_CALLABLE_CONVERT'):\\n\"\n"
    ".ascii \"            return self.val.cast(gdb.lookup_type('zend_ast_fcc'))\\n\"\n"
    ".ascii \"        if kind == enum_value('ZEND_AST_ZNODE'):\\n\"\n"
    ".ascii \"            return self.val.cast(gdb.lookup_type('zend_ast_znode'))\\n\"\n"
    ".ascii \"        if self.is_decl():\\n\"\n"
    ".ascii \"            return self.val.cast(gdb.lookup_type('zend_ast_decl'))\\n\"\n"
    ".ascii \"        if self.is_list():\\n\"\n"
    ".ascii \"            return self.val.cast(gdb.lookup_type('zend_ast_list'))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        return self.val\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def num_children(self):\\n\"\n"
    ".ascii \"        if self.is_decl():\\n\"\n"
    ".ascii \"            decl_type = gdb.lookup_type('zend_ast_decl')\\n\"\n"
    ".ascii \"            child_type = decl_type['child'].type\\n\"\n"
    ".ascii \"            return array_size(child_type)\\n\"\n"
    ".ascii \"        if self.is_special():\\n\"\n"
    ".ascii \"            return 0\\n\"\n"
    ".ascii \"        elif self.is_list():\\n\"\n"
    ".ascii \"            return int(self.cast()['children'])\\n\"\n"
    ".ascii \"        else:\\n\"\n"
    ".ascii \"            num_children_shift = 8 # ZEND_AST_NUM_CHILDREN_SHIFT\\n\"\n"
    ".ascii \"            kind = self.val['kind']\\n\"\n"
    ".ascii \"            return kind >> num_children_shift\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"pp_set.add_printer('zend_ast', '^_zend_ast$', ZendAstPrettyPrinter)\\n\"\n"
    ".ascii \"pp_set.add_printer('zend_ast_decl', '^_zend_ast_decl$', ZendAstPrettyPrinter)\\n\"\n"
    ".ascii \"pp_set.add_printer('zend_ast_list', '^_zend_ast_list$', ZendAstPrettyPrinter)\\n\"\n"
    ".ascii \"pp_set.add_printer('zend_ast_op_array', '^_zend_ast_op_array$', ZendAstPrettyPrinter)\\n\"\n"
    ".ascii \"pp_set.add_printer('zend_ast_fcc', '^_zend_ast_fcc$', ZendAstPrettyPrinter)\\n\"\n"
    ".ascii \"pp_set.add_printer('zend_ast_zval', '^_zend_ast_zval$', ZendAstPrettyPrinter)\\n\"\n"
    ".ascii \"pp_set.add_printer('zend_ast_znode', '^_zend_ast_znode$', ZendAstPrettyPrinter)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class ZvalPrettyPrinter(gdb.printing.PrettyPrinter):\\n\"\n"
    ".ascii \"    \\\"Print a zval\\\"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def __init__(self, val):\\n\"\n"
    ".ascii \"        self.val = val\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def to_string(self):\\n\"\n"
    ".ascii \"        return '((zval*) 0x%x) %s' % (self.val.address, self.value_to_string())\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def value_to_string(self):\\n\"\n"
    ".ascii \"        t = int(self.val['u1']['v']['type'])\\n\"\n"
    ".ascii \"        if t == ZendTypeBits.bit('undef'):\\n\"\n"
    ".ascii \"            return 'undef'\\n\"\n"
    ".ascii \"        elif t == ZendTypeBits.bit('null'):\\n\"\n"
    ".ascii \"            return 'null'\\n\"\n"
    ".ascii \"        elif t == ZendTypeBits.bit('false'):\\n\"\n"
    ".ascii \"            return 'false'\\n\"\n"
    ".ascii \"        elif t == ZendTypeBits.bit('true'):\\n\"\n"
    ".ascii \"            return 'true'\\n\"\n"
    ".ascii \"        elif t == ZendTypeBits.bit('long'):\\n\"\n"
    ".ascii \"            return str(self.val['value']['lval'])\\n\"\n"
    ".ascii \"        elif t == ZendTypeBits.bit('double'):\\n\"\n"
    ".ascii \"            return str(self.val['value']['dval'])\\n\"\n"
    ".ascii \"        elif t == ZendTypeBits.bit('string'):\\n\"\n"
    ".ascii \"            return format_zstr(self.val['value']['str'])\\n\"\n"
    ".ascii \"        elif t == ZendTypeBits.bit('array'):\\n\"\n"
    ".ascii \"            return 'array'\\n\"\n"
    ".ascii \"        elif t == ZendTypeBits.bit('object'):\\n\"\n"
    ".ascii \"            return 'object(%s)' % format_zstr(self.val['value']['obj']['ce']['name'])\\n\"\n"
    ".ascii \"        elif t == ZendTypeBits.bit('resource'):\\n\"\n"
    ".ascii \"            return 'resource'\\n\"\n"
    ".ascii \"        elif t == ZendTypeBits.bit('reference'):\\n\"\n"
    ".ascii \"            return 'reference'\\n\"\n"
    ".ascii \"        elif t == ZendTypeBits.bit('constant_ast'):\\n\"\n"
    ".ascii \"            return 'constant_ast'\\n\"\n"
    ".ascii \"        elif t == ZendTypeBits.bit('indirect'):\\n\"\n"
    ".ascii \"            value = self.val['value']['zv']\\n\"\n"
    ".ascii \"            valuestr = ZvalPrettyPrinter(value).to_string()\\n\"\n"
    ".ascii \"            return 'indirect: ((zval*) 0x%x) %s' % (int(value), valuestr)\\n\"\n"
    ".ascii \"        elif t == ZendTypeBits.bit('ptr'):\\n\"\n"
    ".ascii \"            value = int(self.val['value']['ptr'])\\n\"\n"
    ".ascii \"            return 'ptr: ((void*) 0x%x)' % (value)\\n\"\n"
    ".ascii \"        elif t == ZendTypeBits.bit('alias_ptr'):\\n\"\n"
    ".ascii \"            value = int(self.val['value']['ptr'])\\n\"\n"
    ".ascii \"            return 'alias_ptr: ((void*) 0x%x)' % (value)\\n\"\n"
    ".ascii \"        else:\\n\"\n"
    ".ascii \"            return 'zval of type %d' % int(self.val['u1']['v']['type'])\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def children(self):\\n\"\n"
    ".ascii \"        for field in self.val.type.fields():\\n\"\n"
    ".ascii \"            if field.name == 'value':\\n\"\n"
    ".ascii \"                value = self.val['value']\\n\"\n"
    ".ascii \"                sub_field = 'ptr'\\n\"\n"
    ".ascii \"                t = int(self.val['u1']['v']['type'])\\n\"\n"
    ".ascii \"                if t == ZendTypeBits.bit('undef'):\\n\"\n"
    ".ascii \"                    sub_field = 'lval'\\n\"\n"
    ".ascii \"                elif t == ZendTypeBits.bit('null'):\\n\"\n"
    ".ascii \"                    sub_field = 'lval'\\n\"\n"
    ".ascii \"                elif t == ZendTypeBits.bit('false'):\\n\"\n"
    ".ascii \"                    sub_field = 'lval'\\n\"\n"
    ".ascii \"                elif t == ZendTypeBits.bit('true'):\\n\"\n"
    ".ascii \"                    sub_field = 'lval'\\n\"\n"
    ".ascii \"                elif t == ZendTypeBits.bit('long'):\\n\"\n"
    ".ascii \"                    sub_field = 'lval'\\n\"\n"
    ".ascii \"                elif t == ZendTypeBits.bit('double'):\\n\"\n"
    ".ascii \"                    sub_field = 'dval'\\n\"\n"
    ".ascii \"                elif t == ZendTypeBits.bit('string'):\\n\"\n"
    ".ascii \"                    sub_field = 'str'\\n\"\n"
    ".ascii \"                elif t == ZendTypeBits.bit('array'):\\n\"\n"
    ".ascii \"                    sub_field = 'arr'\\n\"\n"
    ".ascii \"                elif t == ZendTypeBits.bit('object'):\\n\"\n"
    ".ascii \"                    sub_field = 'obj'\\n\"\n"
    ".ascii \"                elif t == ZendTypeBits.bit('resource'):\\n\"\n"
    ".ascii \"                    sub_field = 'res'\\n\"\n"
    ".ascii \"                elif t == ZendTypeBits.bit('reference'):\\n\"\n"
    ".ascii \"                    sub_field = 'ref'\\n\"\n"
    ".ascii \"                elif t == ZendTypeBits.bit('constant_ast'):\\n\"\n"
    ".ascii \"                    sub_field = 'ast'\\n\"\n"
    ".ascii \"                elif t == ZendTypeBits.bit('indirect'):\\n\"\n"
    ".ascii \"                    sub_field = 'zv'\\n\"\n"
    ".ascii \"                value = value[sub_field]\\n\"\n"
    ".ascii \"                if sub_field != 'ptr' and value.type.code == gdb.TYPE_CODE_PTR:\\n\"\n"
    ".ascii \"                    value = value.dereference()\\n\"\n"
    ".ascii \"                yield ('%s.%s' % (field.name, sub_field), value)\\n\"\n"
    ".ascii \"            elif field.name == 'u2':\\n\"\n"
    ".ascii \"                yield ('u2', self.val[field.name]['extra'])\\n\"\n"
    ".ascii \"            else:\\n\"\n"
    ".ascii \"                yield (field.name, format_nested(self.val[field.name]))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"pp_set.add_printer('zval', '^_zval_struct$', ZvalPrettyPrinter)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class ZendClassEntryPrettyPrinter(gdb.printing.PrettyPrinter):\\n\"\n"
    ".ascii \"    \\\"Print a zend_class_entry\\\"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def __init__(self, val):\\n\"\n"
    ".ascii \"        self.val = val\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def to_string(self):\\n\"\n"
    ".ascii \"        return '((zend_class_entry*) 0x%x) %s' % (self.val.address, format_zstr(self.val['name']))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def children(self):\\n\"\n"
    ".ascii \"        for field in self.val.type.fields():\\n\"\n"
    ".ascii \"            if field.name is not None:\\n\"\n"
    ".ascii \"                if field.name == 'ce_flags':\\n\"\n"
    ".ascii \"                    flags = self.val[field.name]\\n\"\n"
    ".ascii \"                    yield (field.name, '%d (%s)' % (flags, ZendAccFlags.format_ce_flags(flags)))\\n\"\n"
    ".ascii \"                else:\\n\"\n"
    ".ascii \"                    yield (field.name, format_nested(self.val[field.name]))\\n\"\n"
    ".ascii \"            else:\\n\"\n"
    ".ascii \"                # Don't break on the union fields. Unfortunately, pretty\\n\"\n"
    ".ascii \"                # printers done in python cannot match the default formatting of\\n\"\n"
    ".ascii \"                # C anonymous fields, which omit the name entirely, see\\n\"\n"
    ".ascii \"                # binutils-gdb/gdb/cp-valprint.c#248 (as of commit\\n\"\n"
    ".ascii \"                # b6532accdd8e24329cc69bb58bc2883796008776)\\n\"\n"
    ".ascii \"                yield ('<anonymous>', self.val[field])\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"pp_set.add_printer('zend_class_entry', '^_zend_class_entry$', ZendClassEntryPrettyPrinter)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class ZendClassConstantPrettyPrinter(gdb.printing.PrettyPrinter):\\n\"\n"
    ".ascii \"    \\\"Print a zend_class_constant\\\"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def __init__(self, val):\\n\"\n"
    ".ascii \"        self.val = val\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def children(self):\\n\"\n"
    ".ascii \"        for field in self.val.type.fields():\\n\"\n"
    ".ascii \"            if field.name == 'value':\\n\"\n"
    ".ascii \"                flags = self.val[field.name]['u2']['constant_flags']\\n\"\n"
    ".ascii \"                yield ('value.u2.constant_flags', '%d (%s)' % (flags, ZendAccFlags.format_const_flags(flags)))\\n\"\n"
    ".ascii \"                yield (field.name, self.val[field.name])\\n\"\n"
    ".ascii \"            else:\\n\"\n"
    ".ascii \"                yield (field.name, format_nested(self.val[field.name]))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"pp_set.add_printer('zend_class_constant', '^_zend_class_constant$', ZendClassConstantPrettyPrinter)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class ZendPropertyInfoPrettyPrinter(gdb.printing.PrettyPrinter):\\n\"\n"
    ".ascii \"    \\\"Print a zend_property_info\\\"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def __init__(self, val):\\n\"\n"
    ".ascii \"        self.val = val\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def children(self):\\n\"\n"
    ".ascii \"        for field in self.val.type.fields():\\n\"\n"
    ".ascii \"            if field.name == 'flags':\\n\"\n"
    ".ascii \"                flags = self.val[field.name]\\n\"\n"
    ".ascii \"                yield ('flags', '%d (%s)' % (flags, ZendAccFlags.format_prop_flags(flags)))\\n\"\n"
    ".ascii \"            else:\\n\"\n"
    ".ascii \"                yield (field.name, format_nested(self.val[field.name]))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"pp_set.add_printer('zend_property_info', '^_zend_property_info$', ZendPropertyInfoPrettyPrinter)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class ZendFunctionPrettyPrinter(gdb.printing.PrettyPrinter):\\n\"\n"
    ".ascii \"    \\\"Print a zend_function\\\"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def __init__(self, val):\\n\"\n"
    ".ascii \"        self.val = val\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def to_string(self):\\n\"\n"
    ".ascii \"        val_type = int(self.val['type'])\\n\"\n"
    ".ascii \"        if val_type == ZendFnTypes.ZEND_INTERNAL_FUNCTION:\\n\"\n"
    ".ascii \"            typestr = 'internal'\\n\"\n"
    ".ascii \"        elif val_type == ZendFnTypes.ZEND_USER_FUNCTION:\\n\"\n"
    ".ascii \"            typestr = 'user'\\n\"\n"
    ".ascii \"        elif val_type == ZendFnTypes.ZEND_EVAL_CODE:\\n\"\n"
    ".ascii \"            typestr = 'eval'\\n\"\n"
    ".ascii \"        else:\\n\"\n"
    ".ascii \"            typestr = '\?\?\?'\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        if self.val['common']['function_name']:\\n\"\n"
    ".ascii \"            namestr = format_zstr(self.val['common']['function_name'])\\n\"\n"
    ".ascii \"        else:\\n\"\n"
    ".ascii \"            namestr = '{main}'\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        if self.val['common']['scope']:\\n\"\n"
    ".ascii \"            str = '%s method %s::%s' % (typestr, format_zstr(self.val['common']['scope']['name']), namestr)\\n\"\n"
    ".ascii \"        else:\\n\"\n"
    ".ascii \"            str = '%s function %s' % (typestr, namestr)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        if int(self.val['type']) == ZendFnTypes.ZEND_USER_FUNCTION or int(self.val['type']) == ZendFnTypes.ZEND_EVAL_CODE:\\n\"\n"
    ".ascii \"            str = '%s %s:%d' % (str, format_zstr(self.val['op_array']['filename']), int(self.val['op_array']['line_start']))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        return '((zend_function*) 0x%x) %s' % (self.val.address, str)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def children(self):\\n\"\n"
    ".ascii \"        for field in self.val.type.fields():\\n\"\n"
    ".ascii \"            if field.name == 'common' or field.name == 'type' or field.name == 'quick_arg_flags':\\n\"\n"
    ".ascii \"                # Redundant with op_array / internal_function\\n\"\n"
    ".ascii \"                continue\\n\"\n"
    ".ascii \"            elif field.name == 'op_array':\\n\"\n"
    ".ascii \"                if int(self.val['type']) == ZendFnTypes.ZEND_USER_FUNCTION or int(self.val['type']) == ZendFnTypes.ZEND_EVAL_CODE:\\n\"\n"
    ".ascii \"                    yield (field.name, self.val[field.name])\\n\"\n"
    ".ascii \"            elif field.name == 'internal_function':\\n\"\n"
    ".ascii \"                if int(self.val['type']) == ZendFnTypes.ZEND_INTERNAL_FUNCTION:\\n\"\n"
    ".ascii \"                    yield (field.name, self.val[field.name])\\n\"\n"
    ".ascii \"            else:\\n\"\n"
    ".ascii \"                yield (field.name, format_nested(self.val[field.name]))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"pp_set.add_printer('zend_function', '^_zend_function$', ZendFunctionPrettyPrinter)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class ZendOpArrayPrettyPrinter(gdb.printing.PrettyPrinter):\\n\"\n"
    ".ascii \"    \\\"Print a zend_op_array\\\"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def __init__(self, val):\\n\"\n"
    ".ascii \"        self.val = val\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def to_string(self):\\n\"\n"
    ".ascii \"        if self.val['function_name']:\\n\"\n"
    ".ascii \"            namestr = format_zstr(self.val['function_name'])\\n\"\n"
    ".ascii \"        else:\\n\"\n"
    ".ascii \"            namestr = '{main}'\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        if self.val['scope']:\\n\"\n"
    ".ascii \"            str = 'method %s::%s' % (format_zstr(self.val['scope']['name']), namestr)\\n\"\n"
    ".ascii \"        else:\\n\"\n"
    ".ascii \"            str = 'function %s' % (namestr)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        str = '%s %s:%d' % (str, format_zstr(self.val['filename']), int(self.val['line_start']))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        return '((zend_op_array*) 0x%x) %s' % (self.val.address, str)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def children(self):\\n\"\n"
    ".ascii \"        for field in self.val.type.fields():\\n\"\n"
    ".ascii \"            if field.name == 'fn_flags':\\n\"\n"
    ".ascii \"                value = self.val[field.name]\\n\"\n"
    ".ascii \"                yield (field.name, '%d (%s)' % (value, ZendAccFlags.format_fn_flags(value)))\\n\"\n"
    ".ascii \"            else:\\n\"\n"
    ".ascii \"                yield (field.name, format_nested(self.val[field.name]))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"pp_set.add_printer('zend_op_array', '^_zend_op_array$', ZendOpArrayPrettyPrinter)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class ZendOpPrettyPrinter(gdb.printing.PrettyPrinter):\\n\"\n"
    ".ascii \"    \\\"Print a zend_op\\\"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def __init__(self, val):\\n\"\n"
    ".ascii \"        self.val = val\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def children(self):\\n\"\n"
    ".ascii \"        for field in self.val.type.fields():\\n\"\n"
    ".ascii \"            if field.name == 'opcode':\\n\"\n"
    ".ascii \"                opcode = int(self.val[field.name])\\n\"\n"
    ".ascii \"                yield (field.name, '%d (%s)' % (opcode, ZendOpcodes.name(opcode)))\\n\"\n"
    ".ascii \"            else:\\n\"\n"
    ".ascii \"                yield (field.name, format_nested(self.val[field.name]))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"pp_set.add_printer('zend_op', '^_zend_op$', ZendOpPrettyPrinter)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class ZendInternalFunctionPrettyPrinter(gdb.printing.PrettyPrinter):\\n\"\n"
    ".ascii \"    \\\"Print a zend_internal_function\\\"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def __init__(self, val):\\n\"\n"
    ".ascii \"        self.val = val\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def to_string(self):\\n\"\n"
    ".ascii \"        if self.val['function_name']:\\n\"\n"
    ".ascii \"            namestr = format_zstr(self.val['function_name'])\\n\"\n"
    ".ascii \"        else:\\n\"\n"
    ".ascii \"            namestr = '\?\?\?'\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        if self.val['scope']:\\n\"\n"
    ".ascii \"            str = 'method %s::%s' % (format_zstr(self.val['scope']['name']), namestr)\\n\"\n"
    ".ascii \"        else:\\n\"\n"
    ".ascii \"            str = 'function %s' % (namestr)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        return '((zend_internal_function*) 0x%x) %s' % (self.val.address, str)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def children(self):\\n\"\n"
    ".ascii \"        for field in self.val.type.fields():\\n\"\n"
    ".ascii \"            if field.name == 'fn_flags':\\n\"\n"
    ".ascii \"                yield ('fn_flags', ('%d (%s)' % (self.val[field.name], ZendAccFlags.format_fn_flags(self.val[field.name]))))\\n\"\n"
    ".ascii \"            else:\\n\"\n"
    ".ascii \"                yield (field.name, format_nested(self.val[field.name]))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"pp_set.add_printer('zend_internal_function', '^_zend_internal_function$', ZendInternalFunctionPrettyPrinter)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class ZendRefcountedHPrettyPrinter(gdb.printing.PrettyPrinter):\\n\"\n"
    ".ascii \"    \\\"Print a zend_refcounted_h\\\"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def __init__(self, val):\\n\"\n"
    ".ascii \"        self.val = val\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def children(self):\\n\"\n"
    ".ascii \"        for field in self.val.type.fields():\\n\"\n"
    ".ascii \"            if field.name == 'u':\\n\"\n"
    ".ascii \"                val = self.val[field.name]\\n\"\n"
    ".ascii \"                if val == None:\\n\"\n"
    ".ascii \"                    val = self.val\\n\"\n"
    ".ascii \"                for subfield in val.type.fields():\\n\"\n"
    ".ascii \"                    if subfield.name == 'type_info':\\n\"\n"
    ".ascii \"                        flags = int(val[subfield.name])\\n\"\n"
    ".ascii \"                        yield (('%s.%s' % (field.name, subfield.name)), '%d (%s)' % (flags, ZendRefTypeInfo.format(flags)))\\n\"\n"
    ".ascii \"                    else:\\n\"\n"
    ".ascii \"                        yield (('%s.%s' % (field.name, subfield.name)), format_nested(val[subfield.name]))\\n\"\n"
    ".ascii \"            else:\\n\"\n"
    ".ascii \"                yield (('%s' % field.name), format_nested(self.val[field.name]))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"pp_set.add_printer('zend_refcounted_h', '^_zend_refcounted_h$', ZendRefcountedHPrettyPrinter)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class PrintAccFlagsCommand(gdb.Command):\\n\"\n"
    ".ascii \"    \\\"Pretty print ACC flags\\\"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def __init__ (self, type):\\n\"\n"
    ".ascii \"        self.type = type\\n\"\n"
    ".ascii \"        name = 'print_%s_flags' % type\\n\"\n"
    ".ascii \"        super(PrintAccFlagsCommand, self).__init__(name, gdb.COMMAND_USER, gdb.COMPLETE_EXPRESSION)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def invoke (self, arg, from_tty):\\n\"\n"
    ".ascii \"        arg = int(gdb.parse_and_eval(arg))\\n\"\n"
    ".ascii \"        print(ZendAccFlags.format_flags(arg, self.type))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"PrintAccFlagsCommand('fn')\\n\"\n"
    ".ascii \"PrintAccFlagsCommand('ce')\\n\"\n"
    ".ascii \"PrintAccFlagsCommand('prop')\\n\"\n"
    ".ascii \"PrintAccFlagsCommand('const')\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class PrintOpcodeCommand(gdb.Command):\\n\"\n"
    ".ascii \"    \\\"Pretty print opcode\\\"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def __init__ (self):\\n\"\n"
    ".ascii \"        super(PrintOpcodeCommand, self).__init__(\\\"print_opcode\\\", gdb.COMMAND_USER, gdb.COMPLETE_EXPRESSION)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def invoke (self, arg, from_tty):\\n\"\n"
    ".ascii \"        arg = int(gdb.parse_and_eval(arg))\\n\"\n"
    ".ascii \"        print(ZendOpcodes.name(arg))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"PrintOpcodeCommand()\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class PrintRefTypeInfoCommand(gdb.Command):\\n\"\n"
    ".ascii \"    \\\"Pretty print zend_refcounted.gc.u.type_info\\\"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def __init__ (self):\\n\"\n"
    ".ascii \"        super(PrintRefTypeInfoCommand, self).__init__(\\\"print_ref_type_info\\\", gdb.COMMAND_USER, gdb.COMPLETE_EXPRESSION)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def invoke (self, arg, from_tty):\\n\"\n"
    ".ascii \"        arg = int(gdb.parse_and_eval(arg))\\n\"\n"
    ".ascii \"        print(ZendRefTypeInfo.format(arg))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"PrintRefTypeInfoCommand()\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class DumpOpArrayCommand(gdb.Command):\\n\"\n"
    ".ascii \"    \\\"Dump an op_array\\\"\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def __init__ (self):\\n\"\n"
    ".ascii \"        super(DumpOpArrayCommand, self).__init__(\\\"dump_op_array\\\", gdb.COMMAND_USER, gdb.COMPLETE_EXPRESSION)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def invoke (self, arg, from_tty):\\n\"\n"
    ".ascii \"        op_array = gdb.parse_and_eval(arg)\\n\"\n"
    ".ascii \"        if op_array.type.code != gdb.TYPE_CODE_PTR:\\n\"\n"
    ".ascii \"            print(\\\"Must pass a zend_op_array* (got a %s)\\\" % op_array.type)\\n\"\n"
    ".ascii \"            return\\n\"\n"
    ".ascii \"        if str(gdb.types.get_basic_type(op_array.type.target())) != 'struct _zend_op_array':\\n\"\n"
    ".ascii \"            print(\\\"Must pass a zend_op_array* (got a %s)\\\" % op_array.type)\\n\"\n"
    ".ascii \"            return\\n\"\n"
    ".ascii \"        if int(op_array) == 0:\\n\"\n"
    ".ascii \"            print(\\\"NULL\\\")\\n\"\n"
    ".ascii \"            return\\n\"\n"
    ".ascii \"        gdb.execute(\\\"call zend_dump_op_array((zend_op_array*)0x%x, 0, 0, 0)\\\" % (int(op_array)))\\n\"\n"
    ".ascii \"        return\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"DumpOpArrayCommand()\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class ZendTypeBits:\\n\"\n"
    ".ascii \"    _bits = None\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def zendTypeName(self, bit):\\n\"\n"
    ".ascii \"        self._load()\\n\"\n"
    ".ascii \"        for name in self._bits:\\n\"\n"
    ".ascii \"            if bit == self._bits[name]:\\n\"\n"
    ".ascii \"                return name\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def zvalTypeName(self, bit):\\n\"\n"
    ".ascii \"        # Same as zendTypeName, but return the last matching one\\n\"\n"
    ".ascii \"        # e.g. 13 is IS_PTR, not IS_ITERABLE\\n\"\n"
    ".ascii \"        self._load()\\n\"\n"
    ".ascii \"        ret = None\\n\"\n"
    ".ascii \"        for name in self._bits:\\n\"\n"
    ".ascii \"            if bit == self._bits[name]:\\n\"\n"
    ".ascii \"                ret = name\\n\"\n"
    ".ascii \"        return ret\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def bit(self, name):\\n\"\n"
    ".ascii \"        self._load()\\n\"\n"
    ".ascii \"        return self._bits.get(name)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def _load(self):\\n\"\n"
    ".ascii \"        if self._bits != None:\\n\"\n"
    ".ascii \"            return\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        dirname = detect_source_dir()\\n\"\n"
    ".ascii \"        filename = os.path.join(dirname, 'zend_types.h')\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        bits = {}\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        with open(filename, 'r') as file:\\n\"\n"
    ".ascii \"            content = file.read()\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"            pattern = re.compile(r'#define _ZEND_TYPE_([^\\\\s]+)_BIT\\\\s+\\\\(1u << (\\\\d+)\\\\)')\\n\"\n"
    ".ascii \"            matches = pattern.findall(content)\\n\"\n"
    ".ascii \"            for name, bit in matches:\\n\"\n"
    ".ascii \"                bits[name.lower()] = int(bit)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"            pattern = re.compile(r'#define IS_([^\\\\s]+)\\\\s+(\\\\d+)')\\n\"\n"
    ".ascii \"            matches = pattern.findall(content)\\n\"\n"
    ".ascii \"            for name, bit in matches:\\n\"\n"
    ".ascii \"                bits[name.lower()] = int(bit)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        self._bits = bits\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class ZendFnTypes:\\n\"\n"
    ".ascii \"    ZEND_INTERNAL_FUNCTION = 1\\n\"\n"
    ".ascii \"    ZEND_USER_FUNCTION = 2\\n\"\n"
    ".ascii \"    ZEND_EVAL_CODE = 4\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class ZendAccFlag:\\n\"\n"
    ".ascii \"    ce = False\\n\"\n"
    ".ascii \"    fn = False\\n\"\n"
    ".ascii \"    prop = False\\n\"\n"
    ".ascii \"    const = False\\n\"\n"
    ".ascii \"    bit = 0\\n\"\n"
    ".ascii \"    def __init__(self, ce, fn, prop, const, bit):\\n\"\n"
    ".ascii \"        self.ce = ce\\n\"\n"
    ".ascii \"        self.fn = fn\\n\"\n"
    ".ascii \"        self.prop = prop\\n\"\n"
    ".ascii \"        self.const = const\\n\"\n"
    ".ascii \"        self.bit = bit\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    def applies_to(self, type):\\n\"\n"
    ".ascii \"        return getattr(self, type)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class ZendAccFlags:\\n\"\n"
    ".ascii \"    _flags = None\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def fn_flag_name(self, bit):\\n\"\n"
    ".ascii \"        self.flag_name(bit, 'fn')\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def ce_flag_name(self, bit):\\n\"\n"
    ".ascii \"        self.flag_name(bit, 'ce')\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def prop_flag_name(self, bit):\\n\"\n"
    ".ascii \"        self.flag_name(bit, 'prop')\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def const_flag_name(self, bit):\\n\"\n"
    ".ascii \"        self.flag_name(bit, 'const')\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def flag_name(self, bit, type):\\n\"\n"
    ".ascii \"        self._load()\\n\"\n"
    ".ascii \"        for name in self._flags:\\n\"\n"
    ".ascii \"            flag = self._flags[name]\\n\"\n"
    ".ascii \"            if flag.applies_to(type) and bit == flag.bit:\\n\"\n"
    ".ascii \"                return name\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def flag_bit(self, name):\\n\"\n"
    ".ascii \"        self._load()\\n\"\n"
    ".ascii \"        return self._flags[name]\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def format_flags(self, flags, type):\\n\"\n"
    ".ascii \"        flags = int(flags)\\n\"\n"
    ".ascii \"        names = []\\n\"\n"
    ".ascii \"        for i in range(0, 31):\\n\"\n"
    ".ascii \"            if (flags & (1 << i)) != 0:\\n\"\n"
    ".ascii \"                name = self.flag_name(i, type)\\n\"\n"
    ".ascii \"                if name == None:\\n\"\n"
    ".ascii \"                    names.append('(1 << %d)' % (i))\\n\"\n"
    ".ascii \"                else:\\n\"\n"
    ".ascii \"                    names.append(name)\\n\"\n"
    ".ascii \"        return ' | '.join(names)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def format_fn_flags(self, flags):\\n\"\n"
    ".ascii \"        return self.format_flags(flags, 'fn')\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def format_ce_flags(self, flags):\\n\"\n"
    ".ascii \"        return self.format_flags(flags, 'ce')\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def format_prop_flags(self, flags):\\n\"\n"
    ".ascii \"        return self.format_flags(flags, 'prop')\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def format_const_flags(self, flags):\\n\"\n"
    ".ascii \"        return self.format_flags(flags, 'const')\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def _load(self):\\n\"\n"
    ".ascii \"        if self._flags != None:\\n\"\n"
    ".ascii \"            return\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        dirname = detect_source_dir()\\n\"\n"
    ".ascii \"        filename = os.path.join(dirname, 'zend_compile.h')\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        flags = {}\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        with open(filename, 'r') as file:\\n\"\n"
    ".ascii \"            content = file.read()\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"            pattern = re.compile(r'#define (ZEND_ACC_[^\\\\s]+)\\\\s+\\\\(1U\?\\\\s+<<\\\\s+(\\\\d+)\\\\)\\\\s+/\\\\*\\\\s+(X\?)\\\\s+\\\\|\\\\s+(X\?)\\\\s+\\\\|\\\\s+(X\?)\\\\s+\\\\|\\\\s+(X\?)\\\\s+\\\\*/')\\n\"\n"
    ".ascii \"            matches = pattern.findall(content)\\n\"\n"
    ".ascii \"            for name, bit, cls, func, prop, const in matches:\\n\"\n"
    ".ascii \"                flags[name] = ZendAccFlag(cls == 'X', func == 'X', prop == 'X', const == 'X', int(bit))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        self._flags = flags\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class ZendOpcodes:\\n\"\n"
    ".ascii \"    _opcodes = None\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def name(self, number):\\n\"\n"
    ".ascii \"        self._load()\\n\"\n"
    ".ascii \"        number = int(number)\\n\"\n"
    ".ascii \"        for name in self._opcodes:\\n\"\n"
    ".ascii \"            if number == self._opcodes[name]:\\n\"\n"
    ".ascii \"                return name\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def number(self, name):\\n\"\n"
    ".ascii \"        self._load()\\n\"\n"
    ".ascii \"        return self._opcodes[name]\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def _load(self):\\n\"\n"
    ".ascii \"        if self._opcodes != None:\\n\"\n"
    ".ascii \"            return\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        dirname = detect_source_dir()\\n\"\n"
    ".ascii \"        filename = os.path.join(dirname, 'zend_vm_opcodes.h')\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        opcodes = {}\\n\"\n"
    ".ascii \"        found_nop = False\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        with open(filename, 'r') as file:\\n\"\n"
    ".ascii \"            content = file.read()\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"            pattern = re.compile(r'#define (ZEND_[^\\\\s]+)\\\\s+([0-9]+)')\\n\"\n"
    ".ascii \"            matches = pattern.findall(content)\\n\"\n"
    ".ascii \"            for name, number in matches:\\n\"\n"
    ".ascii \"                if not found_nop:\\n\"\n"
    ".ascii \"                    if name == 'ZEND_NOP':\\n\"\n"
    ".ascii \"                        found_nop = True\\n\"\n"
    ".ascii \"                    else:\\n\"\n"
    ".ascii \"                        continue\\n\"\n"
    ".ascii \"                if name == 'ZEND_VM_LAST_OPCODE':\\n\"\n"
    ".ascii \"                    break\\n\"\n"
    ".ascii \"                opcodes[name] = int(number)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        self._opcodes = opcodes\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"class ZendRefTypeInfo:\\n\"\n"
    ".ascii \"    _bits = None\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def flag_name(self, bit):\\n\"\n"
    ".ascii \"        return self._flag_name_in(bit, self._bits)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def _flag_name_in(self, bit, bits):\\n\"\n"
    ".ascii \"        for name in bits:\\n\"\n"
    ".ascii \"            if bit == bits[name]:\\n\"\n"
    ".ascii \"                return name\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def bit(self, name):\\n\"\n"
    ".ascii \"        return self._bits.get(name)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def format(self, flags):\\n\"\n"
    ".ascii \"        self._load()\\n\"\n"
    ".ascii \"        names = []\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        type = flags & self._type_mask\\n\"\n"
    ".ascii \"        type_name = ZendTypeBits.zvalTypeName(type)\\n\"\n"
    ".ascii \"        if type_name is not None:\\n\"\n"
    ".ascii \"            names.append('IS_%s' % type_name.upper())\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        bits = self._bits\\n\"\n"
    ".ascii \"        type_bits = None\\n\"\n"
    ".ascii \"        if type_name == 'string':\\n\"\n"
    ".ascii \"            type_bits = self._str_bits\\n\"\n"
    ".ascii \"        elif type_name == 'array':\\n\"\n"
    ".ascii \"            type_bits = self._array_bits\\n\"\n"
    ".ascii \"        elif type_name == 'object':\\n\"\n"
    ".ascii \"            type_bits = self._obj_bits\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        type_flags = flags & self._flags_mask\\n\"\n"
    ".ascii \"        for i in range(0, 31):\\n\"\n"
    ".ascii \"            if (1<<i) > type_flags:\\n\"\n"
    ".ascii \"                break\\n\"\n"
    ".ascii \"            if (type_flags & (1<<i)) != 0:\\n\"\n"
    ".ascii \"                name = self.flag_name(i)\\n\"\n"
    ".ascii \"                if type_bits is not None:\\n\"\n"
    ".ascii \"                    name2 = self._flag_name_in(i, type_bits)\\n\"\n"
    ".ascii \"                    if name2 is not None:\\n\"\n"
    ".ascii \"                        if name is not None:\\n\"\n"
    ".ascii \"                            names.append('%s(%s)' % (name2, name))\\n\"\n"
    ".ascii \"                        else:\\n\"\n"
    ".ascii \"                            names.append(name2)\\n\"\n"
    ".ascii \"                        continue\\n\"\n"
    ".ascii \"                if name is not None:\\n\"\n"
    ".ascii \"                    names.append(name)\\n\"\n"
    ".ascii \"                else:\\n\"\n"
    ".ascii \"                    names.append('(1 << %d)' % (i))\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        if (flags & (1<<self.bit('GC_NOT_COLLECTABLE'))) == 0:\\n\"\n"
    ".ascii \"            gc_color = (flags >> self._info_shift) & self._gc_color\\n\"\n"
    ".ascii \"            if gc_color == self._gc_black:\\n\"\n"
    ".ascii \"                names.append('GC_BLACK')\\n\"\n"
    ".ascii \"            elif gc_color == self._gc_white:\\n\"\n"
    ".ascii \"                names.append('GC_WHITE')\\n\"\n"
    ".ascii \"            elif gc_color == self._gc_grey:\\n\"\n"
    ".ascii \"                names.append('GC_GREY')\\n\"\n"
    ".ascii \"            elif gc_color == self._gc_purple:\\n\"\n"
    ".ascii \"                names.append('GC_PURPLE')\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"            gc_address = (flags >> self._info_shift) & self._gc_address\\n\"\n"
    ".ascii \"            if gc_address != 0:\\n\"\n"
    ".ascii \"                names.append('GC_ADDRESS(%d)' % gc_address)\\n\"\n"
    ".ascii \"        else:\\n\"\n"
    ".ascii \"            info = flags & self._info_mask\\n\"\n"
    ".ascii \"            if info != 0:\\n\"\n"
    ".ascii \"                names.append('GC_INFO(%d)' % info)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        return ' | '.join(names)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    @classmethod\\n\"\n"
    ".ascii \"    def _load(self):\\n\"\n"
    ".ascii \"        if self._bits != None:\\n\"\n"
    ".ascii \"            return\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        dirname = detect_source_dir()\\n\"\n"
    ".ascii \"        filename = os.path.join(dirname, 'zend_types.h')\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        bits = {}\\n\"\n"
    ".ascii \"        str_bits = {}\\n\"\n"
    ".ascii \"        array_bits = {}\\n\"\n"
    ".ascii \"        obj_bits = {}\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        with open(filename, 'r') as file:\\n\"\n"
    ".ascii \"            content = file.read()\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"            # GC_NOT_COLLECTABLE          (1<<4)\\n\"\n"
    ".ascii \"            pattern = re.compile(r'#define (GC_[^\\\\s]+)\\\\s+\\\\(\\\\s*1\\\\s*<<\\\\s*([0-9]+)\\\\s*\\\\)')\\n\"\n"
    ".ascii \"            matches = pattern.findall(content)\\n\"\n"
    ".ascii \"            for name, bit in matches:\\n\"\n"
    ".ascii \"                bits[name] = int(bit)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"            # GC_TYPE_MASK                0x0000000f\\n\"\n"
    ".ascii \"            # GC_INFO_SHIFT               10\\n\"\n"
    ".ascii \"            pattern = re.compile(r'#define (GC_[^\\\\s]+)\\\\s+((0x)\?[0-9a-f]+)')\\n\"\n"
    ".ascii \"            matches = pattern.findall(content)\\n\"\n"
    ".ascii \"            for name, bit, _ in matches:\\n\"\n"
    ".ascii \"                if name == 'GC_TYPE_MASK':\\n\"\n"
    ".ascii \"                    self._type_mask = int(bit, 0)\\n\"\n"
    ".ascii \"                elif name == 'GC_FLAGS_MASK':\\n\"\n"
    ".ascii \"                    self._flags_mask = int(bit, 0)\\n\"\n"
    ".ascii \"                elif name == 'GC_INFO_MASK':\\n\"\n"
    ".ascii \"                    self._info_mask = int(bit, 0)\\n\"\n"
    ".ascii \"                elif name == 'GC_INFO_SHIFT':\\n\"\n"
    ".ascii \"                    self._info_shift = int(bit, 0)\\n\"\n"
    ".ascii \"                elif name == 'GC_FLAGS_SHIFT':\\n\"\n"
    ".ascii \"                    self._flags_shift = int(bit, 0)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"            # IS_STR_INTERNED             GC_IMMUTABLE\\n\"\n"
    ".ascii \"            # IS_STR_PERMANENT            (1<<8)\\n\"\n"
    ".ascii \"            pattern = re.compile(r'#define (IS_(STR|ARRAY|OBJ)_[^\\\\s]+)\\\\s+(\\\\(\\\\s*1\\\\s*<<\\\\s*([0-9]+)\\\\s*\\\\)|GC_[a-zA-Z_]+)')\\n\"\n"
    ".ascii \"            matches = pattern.findall(content)\\n\"\n"
    ".ascii \"            for name, type, val, bit in matches:\\n\"\n"
    ".ascii \"                if bit == '':\\n\"\n"
    ".ascii \"                    bit = bits.get(val)\\n\"\n"
    ".ascii \"                    if bit == None:\\n\"\n"
    ".ascii \"                        continue\\n\"\n"
    ".ascii \"                if type == 'STR':\\n\"\n"
    ".ascii \"                    target = str_bits\\n\"\n"
    ".ascii \"                elif type == 'ARRAY':\\n\"\n"
    ".ascii \"                    target = array_bits\\n\"\n"
    ".ascii \"                elif type == 'OBJ':\\n\"\n"
    ".ascii \"                    target = obj_bits\\n\"\n"
    ".ascii \"                target[name] = int(bit)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        # Hard coded because these are not exposed in header files\\n\"\n"
    ".ascii \"        self._gc_address = 0x0fffff\\n\"\n"
    ".ascii \"        self._gc_color   = 0x300000\\n\"\n"
    ".ascii \"        self._gc_black   = 0x000000\\n\"\n"
    ".ascii \"        self._gc_white   = 0x100000\\n\"\n"
    ".ascii \"        self._gc_grey    = 0x200000\\n\"\n"
    ".ascii \"        self._gc_purple  = 0x300000\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"        self._bits = bits\\n\"\n"
    ".ascii \"        self._str_bits = str_bits\\n\"\n"
    ".ascii \"        self._array_bits = array_bits\\n\"\n"
    ".ascii \"        self._obj_bits = obj_bits\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"def detect_source_dir():\\n\"\n"
    ".ascii \"    (symbol,_) = gdb.lookup_symbol(\\\"zend_visibility_to_set_visibility\\\")\\n\"\n"
    ".ascii \"    if symbol == None:\\n\"\n"
    ".ascii \"        raise Exception(\\\"Could not find zend_compile.h: symbol zend_visibility_to_set_visibility not found\\\")\\n\"\n"
    ".ascii \"    filename = symbol.symtab.fullname()\\n\"\n"
    ".ascii \"    dirname = os.path.dirname(filename)\\n\"\n"
    ".ascii \"    return dirname\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"def lookup_symbol(name):\\n\"\n"
    ".ascii \"    (symbol, _) = gdb.lookup_symbol(name)\\n\"\n"
    ".ascii \"    if symbol == None:\\n\"\n"
    ".ascii \"        raise Exception(\\\"Could not lookup symbol %s\\\" % name)\\n\"\n"
    ".ascii \"    return symbol\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"def enum_value(name):\\n\"\n"
    ".ascii \"    symbol = lookup_symbol(name)\\n\"\n"
    ".ascii \"    return int(symbol.value())\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"def array_size(ary_type):\\n\"\n"
    ".ascii \"    # array types have a single field whose type represents its range\\n\"\n"
    ".ascii \"    return ary_type.fields()[0].type.range()[1]+1\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"def format_zstr(zstr):\\n\"\n"
    ".ascii \"    len = int(zstr['len'])\\n\"\n"
    ".ascii \"    truncated = False\\n\"\n"
    ".ascii \"    if len > 200:\\n\"\n"
    ".ascii \"        len = 200\\n\"\n"
    ".ascii \"        truncated = True\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    ptr_type = gdb.lookup_type('char').pointer()\\n\"\n"
    ".ascii \"    ary_type = gdb.lookup_type('char').array(len)\\n\"\n"
    ".ascii \"    str = zstr['val'].cast(ptr_type).dereference().cast(ary_type)\\n\"\n"
    ".ascii \"    str = str.format_string()\\n\"\n"
    ".ascii \"    if truncated:\\n\"\n"
    ".ascii \"        str += ' (%d bytes total)' % int(zstr['len'])\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    return str\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"def format_nested(value):\\n\"\n"
    ".ascii \"    orig_value = value\\n\"\n"
    ".ascii \"    type = value.type\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    # Null pointers\\n\"\n"
    ".ascii \"    if type.code == gdb.TYPE_CODE_PTR and int(value) == 0:\\n\"\n"
    ".ascii \"        return orig_value\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    addr = orig_value.address\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    while type.code == gdb.TYPE_CODE_PTR:\\n\"\n"
    ".ascii \"        addr = int(value)\\n\"\n"
    ".ascii \"        type = type.target()\\n\"\n"
    ".ascii \"        try:\\n\"\n"
    ".ascii \"            value = value.dereference()\\n\"\n"
    ".ascii \"        except:\\n\"\n"
    ".ascii \"            pass\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    type = gdb.types.get_basic_type(type)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    if type.tag and re.match(r'^_zend_string$', type.tag):\\n\"\n"
    ".ascii \"        return format_zstr(value)\\n\"\n"
    ".ascii \"    elif type.tag and re.match(r'^_zend_class_entry$', type.tag):\\n\"\n"
    ".ascii \"        return '((zend_class_entry*)0x%x) %s' % (addr, format_zstr(value['name']))\\n\"\n"
    ".ascii \"    elif type.tag and re.match(r'^_zend_array$', type.tag):\\n\"\n"
    ".ascii \"        return '((zend_array*)0x%x) array(%d)' % (addr, value['nNumOfElements'])\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"    return orig_value\\n\"\n"
    ".ascii \"\\n\"\n"
    ".ascii \"gdb.printing.register_pretty_printer(gdb, pp_set, replace=True)\\n\"\n"
    ".ascii \"\\n\"\n"
    ".byte 0\n"
    ".popsection\n"
);
