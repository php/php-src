--TEST--
xxHash: serialize/unserialize backward compatibility after xxHash library upgrade
--DESCRIPTION--
Ensures that serialized xxh32/xxh64 HashContext objects remain deserializable
and produce correct results across xxHash library versions (0.8.2 -> 0.8.3).
The struct field renames (v->acc, mem32->buffer, memsize->bufferedSize) in 0.8.3
do not change the binary layout, so the SPEC-based serialization must remain
backward compatible.

The serialized strings below were generated by hashing "I can't remember anything"
with xxh32/xxh64 (with and without seed). They are hardcoded to ensure that
a future library upgrade does not break deserialization of previously-stored
HashContext objects.
--FILE--
<?php

// Hardcoded serialized HashContext blobs (base64-encoded).
// These represent a mid-stream xxh32/xxh64 context after hashing
// "I can't remember anything", and must remain deserializable
// across xxHash library upgrades that don't change the struct layout.

$tests = [
    // xxh32, no seed
    [
        'algo' => 'xxh32',
        'serialized' => 'TzoxMToiSGFzaENvbnRleHQiOjU6e2k6MDtzOjU6Inh4aDMyIjtpOjE7aTowO2k6MjthOjEyOntpOjA7aToyNTtpOjE7aToxO2k6MjtpOjUyODE4NjE2NjtpOjM7aTotNDc5MjcxNTg0O2k6NDtpOjIwMTQxODQ2NzM7aTo1O2k6LTQzMjc1MjM5NjtpOjY7aToyMDM3Mjc2OTYwO2k6NztpOjE4NTI0MDE3ODA7aTo4O2k6MTAzO2k6OTtpOjA7aToxMDtpOjk7aToxMTtpOjA7fWk6MztpOjI7aTo0O2E6MDp7fX0=',
        'expected_final' => 'eee74423',
        'continue_data' => "Can't tell if this is true or dream",
        'expected_continued' => '336076ba',
    ],
    // xxh32, seed=1234
    [
        'algo' => 'xxh32',
        'seed' => 1234,
        'serialized' => 'TzoxMToiSGFzaENvbnRleHQiOjU6e2k6MDtzOjU6Inh4aDMyIjtpOjE7aTowO2k6MjthOjEyOntpOjA7aToyNTtpOjE7aToxO2k6MjtpOjg0NTI2NTcxODtpOjM7aTotMTYyMTkyMDMyO2k6NDtpOi0xOTYzNzAzMDcxO2k6NTtpOi0xMTU2NzI4NDQ7aTo2O2k6MjAzNzI3Njk2MDtpOjc7aToxODUyNDAxNzgwO2k6ODtpOjEwMztpOjk7aTowO2k6MTA7aTo5O2k6MTE7aTowO31pOjM7aToyO2k6NDthOjA6e319',
        'expected_final' => 'db5f448b',
        'continue_data' => "Can't tell if this is true or dream",
        'expected_continued' => '7da6974b',
    ],
    // xxh64, no seed
    [
        'algo' => 'xxh64',
        'serialized' => 'TzoxMToiSGFzaENvbnRleHQiOjU6e2k6MDtzOjU6Inh4aDY0IjtpOjE7aTowO2k6MjthOjIyOntpOjA7aToyNTtpOjE7aTowO2k6MjtpOi0xMzc5ODc5NDY2O2k6MztpOjE2MjU5NTgzODI7aTo0O2k6NjY4MjY1Mjk1O2k6NTtpOi0xMDI4NDc3Mzc5O2k6NjtpOjA7aTo3O2k6MDtpOjg7aToyMDQ4MTQ0NzYxO2k6OTtpOjE2NDA1MzE1MzQ7aToxMDtpOjE2MzM4ODYyODE7aToxMTtpOjU0NDQ4MzE4MjtpOjEyO2k6MTcwMTY2ODIxMDtpOjEzO2k6MTkxOTI0Njk1NztpOjE0O2k6MjAzNzI3Njk2MDtpOjE1O2k6MTg1MjQwMTc4MDtpOjE2O2k6MTAzO2k6MTc7aTowO2k6MTg7aToyNTtpOjE5O2k6MDtpOjIwO2k6MDtpOjIxO2k6MDt9aTozO2k6MjtpOjQ7YTowOnt9fQ==',
        'expected_final' => '9d6ab4708056a619',
        'continue_data' => "Can't tell if this is true or dream",
        'expected_continued' => 'a0ede520213aaf63',
    ],
    // xxh64, seed=1234
    [
        'algo' => 'xxh64',
        'seed' => 1234,
        'serialized' => 'TzoxMToiSGFzaENvbnRleHQiOjU6e2k6MDtzOjU6Inh4aDY0IjtpOjE7aTowO2k6MjthOjIyOntpOjA7aToyNTtpOjE7aTowO2k6MjtpOi0xMzc5ODc4MjMyO2k6MztpOjE2MjU5NTgzODI7aTo0O2k6NjY4MjY2NTI5O2k6NTtpOi0xMDI4NDc3Mzc5O2k6NjtpOjEyMzQ7aTo3O2k6MDtpOjg7aToyMDQ4MTQ1OTk1O2k6OTtpOjE2NDA1MzE1MzQ7aToxMDtpOjE2MzM4ODYyODE7aToxMTtpOjU0NDQ4MzE4MjtpOjEyO2k6MTcwMTY2ODIxMDtpOjEzO2k6MTkxOTI0Njk1NztpOjE0O2k6MjAzNzI3Njk2MDtpOjE1O2k6MTg1MjQwMTc4MDtpOjE2O2k6MTAzO2k6MTc7aTowO2k6MTg7aToyNTtpOjE5O2k6MDtpOjIwO2k6MDtpOjIxO2k6MDt9aTozO2k6MjtpOjQ7YTowOnt9fQ==',
        'expected_final' => 'be97930f372bf6e7',
        'continue_data' => "Can't tell if this is true or dream",
        'expected_continued' => 'a0434a21f6820fe4',
    ],
];

foreach ($tests as $test) {
    $algo = $test['algo'];
    $ctx = unserialize(base64_decode($test['serialized']));

    // 1. Finalizing the deserialized context produces the expected hash
    $ctx_final = clone $ctx;
    $digest = hash_final($ctx_final);
    if ($digest !== $test['expected_final']) {
        echo "FAIL: {$algo} final expected {$test['expected_final']}, got {$digest}\n";
    } else {
        echo "OK: {$algo} unserialize+final\n";
    }

    // 2. Continuing to hash after unserialize produces the correct result
    hash_update($ctx, $test['continue_data']);
    $digest = hash_final($ctx);
    if ($digest !== $test['expected_continued']) {
        echo "FAIL: {$algo} continued expected {$test['expected_continued']}, got {$digest}\n";
    } else {
        echo "OK: {$algo} unserialize+continue+final\n";
    }

    // 3. Round-trip: serialize now, unserialize, and ensure same result
    $seed = $test['seed'] ?? null;
    $ctx2 = $seed !== null ? hash_init($algo, options: ["seed" => $seed]) : hash_init($algo);
    hash_update($ctx2, "I can't remember anything");
    $reserialized = serialize($ctx2);
    $ctx3 = unserialize($reserialized);
    hash_update($ctx3, $test['continue_data']);
    $digest = hash_final($ctx3);
    if ($digest !== $test['expected_continued']) {
        echo "FAIL: {$algo} round-trip expected {$test['expected_continued']}, got {$digest}\n";
    } else {
        echo "OK: {$algo} fresh serialize round-trip\n";
    }
}

echo "Done\n";
?>
--EXPECT--
OK: xxh32 unserialize+final
OK: xxh32 unserialize+continue+final
OK: xxh32 fresh serialize round-trip
OK: xxh32 unserialize+final
OK: xxh32 unserialize+continue+final
OK: xxh32 fresh serialize round-trip
OK: xxh64 unserialize+final
OK: xxh64 unserialize+continue+final
OK: xxh64 fresh serialize round-trip
OK: xxh64 unserialize+final
OK: xxh64 unserialize+continue+final
OK: xxh64 fresh serialize round-trip
Done
