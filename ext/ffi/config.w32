ARG_WITH('ffi', 'ffi support', 'no');

if (PHP_FFI != 'no') {
	if (PKG_CHECK_MODULES("LIBFFI", "libffi")) {
		PHP_EVAL_INCLINE(LIBFFI_CFLAGS, "ffi");
		PHP_EVAL_LIBLINE(LIBFFI_LIBS, "ffi");
		AC_DEFINE('HAVE_FFI', 1, "Define to 1 if the PHP extension 'ffi' is available.");

		if (!X64) {
			AC_DEFINE('HAVE_FFI_FASTCALL', 1, 'Define to 1 if libffi supports the fastcall calling convention.');
			AC_DEFINE('HAVE_FFI_THISCALL', 1, 'Define to 1 if libffi supports the thiscall calling convention.');
			AC_DEFINE('HAVE_FFI_STDCALL', 1, 'Define to 1 if libffi supports the stdcall calling convention.');
			AC_DEFINE('HAVE_FFI_MS_CDECL', 1, 'Define to 1 if libffi supports the ms_cdecl calling convention.');
			AC_DEFINE('HAVE_FFI_SYSV', 1, 'Define to 1 if libffi supports the sysv calling convention.');
		}
		// Available in https://github.com/winlibs/libffi.
		// FIXME: only define if actually supported
		AC_DEFINE('HAVE_FFI_VECTORCALL_PARTIAL', 1, 'Define to 1 if libffi partially supports the vectorcall calling convention.');

		EXTENSION('ffi', 'ffi.c ffi_parser.c', null, '/DZEND_ENABLE_STATIC_TSRMLS_CACHE=1');
	} else {
		WARNING('ffi not enabled; libffi package not found');
	}
}
