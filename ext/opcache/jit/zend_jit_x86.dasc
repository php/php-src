/*
 *  +----------------------------------------------------------------------+
 *  | Zend JIT                                                             |
 *  +----------------------------------------------------------------------+
 *  | Copyright (c) 1998-2016 The PHP Group                                |
 *  +----------------------------------------------------------------------+
 *  | This source file is subject to version 3.01 of the PHP license,      |
 *  | that is bundled with this package in the file LICENSE, and is        |
 *  | available through the world-wide-web at the following url:           |
 *  | http://www.php.net/license/3_01.txt                                  |
 *  | If you did not receive a copy of the PHP license and are unable to   |
 *  | obtain it through the world-wide-web, please send a note to          |
 *  | license@php.net so we can mail you a copy immediately.               |
 *  +----------------------------------------------------------------------+
 *  | Authors: Dmitry Stogov <dmitry@zend.com>                             |
 *  |          Xinchen Hui <xinchen.h@zend.com>                            |
 *  +----------------------------------------------------------------------+
 */

|.if X64
 |.arch x64
|.else
 |.arch x86
|.endif

|.if X64
 |.define FP,      r14
 |.define IP,      r15
 |.define IPl,     r15d
 |.define RX,      IP        // the same as VM IP reused as a general purpos reg
 |.define RXl,     IPl
 |.define CARG1,   rdi       // x64/POSIX C call arguments.
 |.define CARG2,   rsi
 |.define CARG3,   rdx
 |.define CARG4,   rcx
 |.define CARG5,   r8
 |.define CARG6,   r9
 |.define CARG1d,  edi
 |.define CARG2d,  esi
 |.define CARG3d,  edx
 |.define CARG4d,  ecx
 |.define CARG5d,  r8d
 |.define CARG6d,  r9d
 |.define FCARG1a, CARG1    // Simulate x86 fastcall.
 |.define FCARG2a, CARG2
 |.define FCARG1d, CARG1d
 |.define FCARG2d, CARG2d
 |.define SPAD,    8
 |.define SSE,     1
|.else
 |.define FP,      esi
 |.define IP,      edi
 |.define IPl,     edi
 |.define RX,      IP        // the same as VM IP reused as a general purpos reg
 |.define RXl,     IPl
 |.define FCARG1a, ecx       // x86 fastcall arguments.
 |.define FCARG2a, edx
 |.define FCARG1d, ecx
 |.define FCARG2d, edx
 |.define SPAD,    12
 |.define SSE,     1
|.endif

#include "jit/zend_jit_x86.h"

const char* zend_reg_name[] = {
#ifdef __x86_64__
	"rax", "rcx", "rdx", "rbx", "rsp", "rbp", "rsi", "rdi",
	"r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
	"xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5", "xmm6", "xmm7",
	"xmm8", "xmm9", "xmm10", "xmm11", "xmm12", "xmm13", "xmm14", "xm15"
#else
	"rax", "rcx", "rdx", "rbx", "rsp", "rbp", "rsi", "rdi",
	"xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5", "xmm6", "xmm7"
#endif
};

|.type EX, zend_execute_data, FP
|.type OP, zend_op, IP
|.type ZVAL, zval

|.actionlist dasm_actions

|.globals zend_lb
static void* dasm_labels[zend_lb_MAX];

|.section code, cold_code

#define IS_32BIT(addr) (((uintptr_t)(addr)) <= 0xffffffff)

#define IS_SIGNED_32BIT(val) ((((intptr_t)(val)) <= 0x7fffffff) && (((intptr_t)(val)) >= (-2147483647 - 1)))

#define BP_JIT_IS 6

|.macro LOAD_ADDR, reg, addr
|.if X64
||if (IS_32BIT(addr)) {
|	mov reg, ((ptrdiff_t)addr)    // 0x48 0xc7 0xc0 <imm-32-bit>
|| } else {
|	mov64 reg, ((ptrdiff_t)addr)  // 0x48 0xb8 <imm-64-bit>
||}
|.else
|	mov reg, ((ptrdiff_t)addr)
|.endif
|.endmacro

|.macro PUSH_ADDR, addr, tmp_reg
|.if X64
||if (IS_32BIT(addr)) {
|	push ((ptrdiff_t)addr)    // 0x48 0xc7 0xc0 <imm-32-bit>
|| } else {
|	mov64 tmp_reg, ((ptrdiff_t)addr)  // 0x48 0xb8 <imm-64-bit>
|	push tmp_reg
||}
|.else
|	push ((ptrdiff_t)addr)
|.endif
|.endmacro

|.macro EXT_CALL, func, tmp_reg
|.if X64
||if (IS_32BIT(dasm_end) && IS_32BIT(func)) {
|	call qword &func
||} else {
|	LOAD_ADDR tmp_reg, func
|	call tmp_reg
||}
|.else
|	call dword &func
|.endif
|.endmacro

|.macro EXT_JMP, func, tmp_reg
|.if X64
||if (IS_32BIT(dasm_end) && IS_32BIT(func)) {
|	jmp qword &func
||} else {
|	LOAD_ADDR tmp_reg, func
|	jmp tmp_reg
||}
|.else
|	jmp dword &func
|.endif
|.endmacro

|.macro LOAD_ZVAL_ADDR, reg, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
|   mov reg, aword EX->literals
|   add reg, op.constant
|   .else
|   mov reg, op.zv
|   .endif
||} else {
|   lea reg, qword [FP + op.var]
||}
|.endmacro

|.macro PUSH_ZVAL_ADDR, op_type, op, tmp_reg
||if (op_type == IS_CONST) {
|   .if X64
|   mov tmp_reg, aword EX->literals
|   add tmp_reg, op.constant
|	push tmp_reg
|   .else
|   push op.zv
|   .endif
||} else {
|   lea tmp_reg, qword [FP + op.var]
|	push tmp_reg
||}
|.endmacro

|.macro GET_Z_TYPE_INFO, reg, zv
|	mov reg, dword [zv + 8]
|.endmacro

|.macro SET_Z_TYPE_INFO, zv, type
|	mov dword [zv + 8], type
|.endmacro

|.macro GET_Z_LVAL, reg, zv
|	mov reg, aword [zv]
|.endmacro

|.macro SET_Z_LVAL, zv, val
|	mov aword [zv], val
|.endmacro

|.macro GET_Z_PTR, reg, zv
|	mov reg, aword [zv]
|.endmacro

|.macro SET_Z_PTR, zv, val
|	mov aword [zv], val
|.endmacro

|.macro GET_Z_W2, reg, zv
|	mov reg, dword [zv + 4]
|.endmacro

|.macro SET_Z_W2, zv, val
|	mov dword [zv + 4], val
|.endmacro

|.macro FPU_OP, fp_ins, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
|   mov r0, aword EX->literals
|   fp_ins qword [r0 + op.constant]
|   .else
|   fp_ins qword [op.zv]
|   .endif
||} else {
|   fp_ins qword [FP + op.var]
||}
|.endmacro

|.macro FPU_LOAD, op_type, op
|	FPU_OP fld, op_type, op
|.endmacro

|.macro FPU_MATH, opcode, op_type, op
||switch (opcode) {
||    case ZEND_ADD:
||    case ZEND_ASSIGN_ADD:
|         FPU_OP fadd, op_type, op
||        break;
||    case ZEND_SUB:
||    case ZEND_ASSIGN_SUB:
|         FPU_OP fsub, op_type, op
||        break;
||    case ZEND_MUL:
||    case ZEND_ASSIGN_MUL:
|         FPU_OP fmul, op_type, op
||        break;
||    case ZEND_DIV:
||    case ZEND_ASSIGN_DIV:
|         FPU_OP fdiv, op_type, op
||        break;
||}
|.endmacro

|.macro FPU_STORE, zv
|	fstp qword [zv]
|.endmacro

|.macro SSE_OP, sse_ins, reg, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
|   mov r0, aword EX->literals
|   sse_ins xmm(reg-ZREG_XMM0), qword [r0 + op.constant]
|   .else
|   sse_ins xmm(reg-ZREG_XMM0), qword [op.zv]
|   .endif
||} else {
|   sse_ins xmm(reg-ZREG_XMM0), qword [FP + op.var]
||}
|.endmacro

|.macro SSE_LOAD_LONG, reg, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
|   mov r0, aword EX->literals
|   cvtsi2sd xmm(reg-ZREG_XMM0), qword [r0 + op.constant]
|   .else
|   cvtsi2sd xmm(reg-ZREG_XMM0), dword [op.zv]
|   .endif
||} else {
|   cvtsi2sd xmm(reg-ZREG_XMM0), aword [FP + op.var]
||}
|.endmacro

|.macro SSE_GET_Z_LVAL, reg, zv
|   cvtsi2sd xmm(reg-ZREG_XMM0), aword [zv]
|.endmacro

|.macro SSE_LOAD, reg, op_type, op
|	SSE_OP movsd, reg, op_type, op
|.endmacro

|.macro SSE_GET_Z_DVAL, reg, zv
|   movsd xmm(reg-ZREG_XMM0), qword [zv]
|.endmacro

|.macro SSE_MATH, opcode, reg, op
||switch (opcode) {
||    case ZEND_ADD:
||    case ZEND_ASSIGN_ADD:
|         addsd xmm(reg-ZREG_XMM0), op
||        break;
||    case ZEND_SUB:
||    case ZEND_ASSIGN_SUB:
|         subsd xmm(reg-ZREG_XMM0), op
||        break;
||    case ZEND_MUL:
||    case ZEND_ASSIGN_MUL:
|         mulsd xmm(reg-ZREG_XMM0), op
||        break;
||    case ZEND_DIV:
||    case ZEND_ASSIGN_DIV:
|         divsd xmm(reg-ZREG_XMM0), op
||        break;
||}
|.endmacro

|.macro SSE_MATH_CONST, opcode, reg, op
|   .if X64
|   mov r0, aword EX->literals
|   SSE_MATH, opcode, reg, qword [r0 + op.constant]
|   .else
|   SSE_MATH, opcode, reg, qword [op.zv]
|   .endif
|.endmacro

|.macro SSE_MATH_REG, opcode, dst_reg, src_reg
|   SSE_MATH, opcode, dst_reg, xmm(src_reg-ZREG_XMM0)
|.endmacro

|.macro SSE_STORE, zv, reg
|	movsd qword [zv], xmm(reg-ZREG_XMM0)
|.endmacro

|.macro LONG_OP, long_ins, reg, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
||  if (!IS_SIGNED_32BIT(Z_LVAL_P(RT_CONSTANT(op_array, op)))) {
|   	mov64 r1, Z_LVAL_P(RT_CONSTANT(op_array, op))
|   	long_ins reg, r1
||  } else {
|   	long_ins reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
||  }
|   .else
|   	long_ins reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
|   .endif
||} else {
|   long_ins reg, aword [FP + op.var]
||}
|.endmacro

|.macro LONG_LOAD, reg, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
||  if (!IS_SIGNED_32BIT(Z_LVAL_P(RT_CONSTANT(op_array, op)))) {
|   	mov64 reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
||  } else {
|   	mov reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
||  }
|   .else
|   	mov reg, Z_LVAL_P(RT_CONSTANT(op_array, op))
|   .endif
||} else {
|   GET_Z_LVAL reg, FP + op.var
||}
|.endmacro

|.macro LONG_MATH, opcode, reg, op_type, op
||switch (opcode) {
||    case ZEND_ADD:
||    case ZEND_ASSIGN_ADD:
|         LONG_OP add, reg, op_type, op
||        break;
||    case ZEND_SUB:
||    case ZEND_ASSIGN_SUB:
|         LONG_OP sub, reg, op_type, op
||        break;
||    case ZEND_MUL:
||    case ZEND_ASSIGN_MUL:
|         LONG_OP imul, reg, op_type, op
||        break;
||    case ZEND_DIV:
||    case ZEND_ASSIGN_DIV:
|         idiv aword [FP + op.var] // (reg == r0)
||        break;
||}
|.endmacro

|.macro LONG_MATH2, opcode, dst_reg, src_reg
||switch (opcode) {
||    case ZEND_ADD:
||    case ZEND_ASSIGN_ADD:
|         add dst_reg, src_reg
||        break;
||    case ZEND_SUB:
||    case ZEND_ASSIGN_SUB:
|         sub dst_reg, src_reg
||        break;
||    case ZEND_MUL:
||    case ZEND_ASSIGN_MUL:
|         imul dst_reg, src_reg
||        break;
||    case ZEND_DIV:
||    case ZEND_ASSIGN_DIV:
|         idiv src_reg // (reg1 == r0)
||        break;
||}
|.endmacro

|.macro FPU_LONG_OP, fp_ins, op_type, op
||if (op_type == IS_CONST) {
|   .if X64
|   mov r0, aword EX->literals
|   fp_ins qword [r0 + op.constant]
|   .else
|   fp_ins dword [op.zv]
|   .endif
||} else {
|   fp_ins aword [FP + op.var]
||}
|.endmacro

|.macro FPU_LONG_LOAD, op_type, op
|	FPU_LONG_OP fild, op_type, op
|.endmacro

|.macro FPU_GET_Z_LVAL, zv
|	fild aword [zv]
|.endmacro

|.macro FPU_GET_Z_DVAL, zv
|   fld qword [zv]
|.endmacro

|.macro FPU_MATH2, opcode, reg
||switch (opcode) {
||    case ZEND_ADD:
||    case ZEND_ASSIGN_ADD:
|         fadd reg
||        break;
||    case ZEND_SUB:
||    case ZEND_ASSIGN_SUB:
|         fsub reg
||        break;
||    case ZEND_MUL:
||    case ZEND_ASSIGN_MUL:
|         fmul reg
||        break;
||    case ZEND_DIV:
||    case ZEND_ASSIGN_DIV:
|         fdiv reg
||        break;
||}
|.endmacro

|.macro ZVAL_COPY_CONST, dst, dst_info, zv, tmp_reg
||if (Z_TYPE_P(zv) > IS_TRUE) {
||	if (Z_TYPE_P(zv) == IS_DOUBLE) {
|.if X64 or SSE
||		if (Z_DVAL_P(zv) == 0.0 && !is_signed(Z_DVAL_P(zv))) {
|			xorps xmm0, xmm0
| .if X64
||		} else if (!IS_32BIT(zv)) {
|			mov64 tmp_reg, ((uintptr_t)zv)
|			movsd xmm0, qword [tmp_reg]
| .endif
||		} else {
|			movsd xmm0, qword [((uint32_t)(uintptr_t)zv)]
||		}
|		movsd qword [dst], xmm0
|.else
||		if (Z_DVAL_P(zv) == 0.0 && !is_signed(Z_DVAL_P(zv))) {
|			fldz
||		} else if (Z_DVAL_P(zv) == 1.0) {
|			fld1
||		} else  {
|			fld qword [zv]
||		}
|		fstp qword [dst]
|.endif
||	} else {
|.if X64
||		if (!IS_SIGNED_32BIT(Z_LVAL_P(zv))) {
|			mov64 tmp_reg, ((uintptr_t)Z_LVAL_P(zv))
|			SET_Z_LVAL dst, tmp_reg
||		} else {
|			SET_Z_LVAL dst, Z_LVAL_P(zv)
||		}
|.else
|		SET_Z_LVAL dst, Z_LVAL_P(zv)
|.endif
||	}
||}
||if (((dst_info & MAY_BE_ANY) != (1<<Z_TYPE_P(zv))) ||  (dst_info & (MAY_BE_STRING|MAY_BE_ARRAY))) {
|	SET_Z_TYPE_INFO dst, Z_TYPE_INFO_P(zv)
||}
|.endmacro

|.macro ZVAL_COPY_CONST_2, dst, dst2, dst_info, zv, tmp_reg
||if (Z_TYPE_P(zv) > IS_TRUE) {
||	if (Z_TYPE_P(zv) == IS_DOUBLE) {
|.if X64 or SSE
||		if (Z_DVAL_P(zv) == 0.0 && !is_signed(Z_DVAL_P(zv))) {
|			xorps xmm0, xmm0
| .if X64
||		} else if (!IS_32BIT(zv)) {
|			mov64 tmp_reg, ((uintptr_t)zv)
|			movsd xmm0, qword [tmp_reg]
| .endif
||		} else {
|			movsd xmm0, qword [((uint32_t)(uintptr_t)zv)]
||		}
|		movsd qword [dst], xmm0
|		movsd qword [dst2], xmm0
|.else
||		if (Z_DVAL_P(zv) == 0.0 && !is_signed(Z_DVAL_P(zv))) {
|			fldz
||		} else if (Z_DVAL_P(zv) == 1.0) {
|			fld1
||		} else  {
|			fld qword [zv]
||		}
|		fstp qword [dst]
||		if (Z_DVAL_P(zv) == 0.0 && !is_signed(Z_DVAL_P(zv))) {
|			fldz
||		} else if (Z_DVAL_P(zv) == 1.0) {
|			fld1
||		} else  {
|			fld qword [zv]
||		}
|		fstp qword [dst2]
|.endif
||	} else {
|.if X64
||		if (!IS_SIGNED_32BIT(Z_LVAL_P(zv))) {
|			mov64 tmp_reg, ((uintptr_t)Z_LVAL_P(zv))
|			SET_Z_LVAL dst, tmp_reg
|			SET_Z_LVAL dst2, tmp_reg
||		} else {
|			SET_Z_LVAL dst, Z_LVAL_P(zv)
|			SET_Z_LVAL dst2, Z_LVAL_P(zv)
||		}
|.else
|		SET_Z_LVAL dst, Z_LVAL_P(zv)
|		SET_Z_LVAL dst2, Z_LVAL_P(zv)
|.endif
||	}
||}
||if (((dst_info & MAY_BE_ANY) != (1<<Z_TYPE_P(zv))) ||  (dst_info & (MAY_BE_STRING|MAY_BE_ARRAY))) {
|	SET_Z_TYPE_INFO dst, Z_TYPE_INFO_P(zv)
||}
|	SET_Z_TYPE_INFO dst2, Z_TYPE_INFO_P(zv)
|.endmacro

|.macro ZVAL_COPY_VALUE, dst, src, src_info, tmp_reg1, tmp_reg1d, tmp_reg2
||if (src_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE))) {
||	if (!(src_info & MAY_BE_DOUBLE)) {
| 		GET_Z_PTR tmp_reg2, src
| 		SET_Z_PTR dst, tmp_reg2
||	} else if ((src_info & MAY_BE_ANY) == MAY_BE_DOUBLE) {
|.if X64 or SSE
|		movsd xmm0, qword [src]
|		movsd qword [dst], xmm0
|.else
|		fld qword [src]
|		fstp qword [dst]
|.endif
||	} else {
|.if X64
|		GET_Z_PTR tmp_reg2, src
|		SET_Z_PTR dst, tmp_reg2
|.else
|		GET_Z_PTR tmp_reg2, src
|		GET_Z_W2 tmp_reg1, src
|		SET_Z_PTR dst, tmp_reg2
|		SET_Z_W2 dst, tmp_reg1
|.endif
||	}
||}
||if ((src_info & (MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG|MAY_BE_DOUBLE)) &&
||    has_concrete_type(src_info & MAY_BE_ANY)) {
||	zend_uchar type = concrete_type(src_info);
|	SET_Z_TYPE_INFO dst, type
||} else {
|	GET_Z_TYPE_INFO tmp_reg1d, src
|	SET_Z_TYPE_INFO dst, tmp_reg1d
||}
|.endmacro

/* the same as above, but "src" may overlap with "tmp_reg1d" */
|.macro ZVAL_COPY_VALUE_clobber_src, dst, src, src_info, tmp_reg1, tmp_reg1d, tmp_reg2
||if (src_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE))) {
||	if (!(src_info & MAY_BE_DOUBLE)) {
| 		GET_Z_PTR tmp_reg2, src
| 		SET_Z_PTR dst, tmp_reg2
||	} else if ((src_info & MAY_BE_ANY) == MAY_BE_DOUBLE) {
|.if X64 or SSE
|		movsd xmm0, qword [src]
|		movsd qword [dst], xmm0
|.else
|		fld qword [src]
|		fstp qword [dst]
|.endif
||	} else {
|.if X64
|		GET_Z_PTR tmp_reg2, src
|		SET_Z_PTR dst, tmp_reg2
|.else
|		GET_Z_W2 tmp_reg2, src
|		SET_Z_W2 dst, tmp_reg2
|		GET_Z_PTR tmp_reg2, src
|		SET_Z_PTR dst, tmp_reg2
|.endif
||	}
||}
||if ((src_info & (MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG|MAY_BE_DOUBLE)) &&
||    has_concrete_type(src_info & MAY_BE_ANY)) {
||	zend_uchar type = concrete_type(src_info);
|	SET_Z_TYPE_INFO dst, type
||} else {
|	GET_Z_TYPE_INFO tmp_reg1d, src
|	SET_Z_TYPE_INFO dst, tmp_reg1d
||}
|.endmacro

|.macro ZVAL_COPY_VALUE_2, dst, dst2, src, src_info, tmp_reg1, tmp_reg1d, tmp_reg2
||if (src_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE))) {
||	if (!(src_info & MAY_BE_DOUBLE)) {
| 		GET_Z_PTR tmp_reg2, src
| 		SET_Z_PTR dst, tmp_reg2
| 		SET_Z_PTR dst2, tmp_reg2
||	} else if ((src_info & MAY_BE_ANY) == MAY_BE_DOUBLE) {
|.if X64 or SSE
|		movsd xmm0, qword [src]
|		movsd qword [dst], xmm0
|		movsd qword [dst2], xmm0
|.else
|		fld qword [src]
|		fstp qword [dst]
|		fld qword [src]
|		fstp qword [dst2]
|.endif
||	} else {
|.if X64
|		GET_Z_PTR tmp_reg2, src
|		SET_Z_PTR dst, tmp_reg2
|		SET_Z_PTR dst2, tmp_reg2
|.else
|		GET_Z_PTR tmp_reg2, src
|		GET_Z_W2 tmp_reg1, src
|		SET_Z_PTR dst, tmp_reg2
|		SET_Z_PTR dst2, tmp_reg2
|		SET_Z_W2 dst, tmp_reg1
|		SET_Z_W2 dst2, tmp_reg1
|.endif
||	}
||}
||if ((src_info & (MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG|MAY_BE_DOUBLE)) &&
||    has_concrete_type(src_info & MAY_BE_ANY)) {
||	zend_uchar type = concrete_type(src_info);
|	SET_Z_TYPE_INFO dst, type
|	SET_Z_TYPE_INFO dst2, type
||} else {
|	GET_Z_TYPE_INFO tmp_reg1d, src
|	SET_Z_TYPE_INFO dst, tmp_reg1d
|	SET_Z_TYPE_INFO dst2, tmp_reg1d
||}
|.endmacro

/* the same as above, but "src" may overlap with "tmp_reg1d" */
|.macro ZVAL_COPY_VALUE_clobber_src_2, dst, dst2, src, src_info, tmp_reg1, tmp_reg1d, tmp_reg2
||if (src_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE))) {
||	if (!(src_info & MAY_BE_DOUBLE)) {
| 		GET_Z_PTR tmp_reg2, src
| 		SET_Z_PTR dst, tmp_reg2
| 		SET_Z_PTR dst2, tmp_reg2
||	} else if ((src_info & MAY_BE_ANY) == MAY_BE_DOUBLE) {
|.if X64 or SSE
|		movsd xmm0, qword [src]
|		movsd qword [dst], xmm0
|		movsd qword [dst2], xmm0
|.else
|		fld qword [src]
|		fstp qword [dst]
|		fld qword [src]
|		fstp qword [dst2]
|.endif
||	} else {
|.if X64
|		GET_Z_PTR tmp_reg2, src
|		SET_Z_PTR dst, tmp_reg2
|		SET_Z_PTR dst2, tmp_reg2
|.else
|		GET_Z_W2 tmp_reg2, src
|		SET_Z_W2 dst, tmp_reg2
|		SET_Z_W2 dst2, tmp_reg2
|		GET_Z_PTR tmp_reg2, src
|		SET_Z_PTR dst, tmp_reg2
|		SET_Z_PTR dst2, tmp_reg2
|.endif
||	}
||}
||if ((src_info & (MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG|MAY_BE_DOUBLE)) &&
||    has_concrete_type(src_info & MAY_BE_ANY)) {
||	zend_uchar type = concrete_type(src_info);
|	SET_Z_TYPE_INFO dst, type
|	SET_Z_TYPE_INFO dst2, type
||} else {
|	GET_Z_TYPE_INFO tmp_reg1d, src
|	SET_Z_TYPE_INFO dst, tmp_reg1d
|	SET_Z_TYPE_INFO dst2, tmp_reg1d
||}
|.endmacro

|.macro IF_TYPE, type, val, label
|	cmp type, val
|	je label
|.endmacro

|.macro IF_NOT_TYPE, type, val, label
|	cmp type, val
|	jne label
|.endmacro

|.macro IF_Z_TYPE, zv, val, label
|	IF_TYPE byte [zv + 8], val, label
|.endmacro

|.macro IF_NOT_Z_TYPE, zv, val, label
|	IF_NOT_TYPE byte [zv + 8], val, label
|.endmacro

|.macro IF_FLAGS, type_flags, mask, label
|	test type_flags, mask
|	jnz label
|.endmacro

|.macro IF_NOT_FLAGS, type_flags, mask, label
|	test type_flags, mask
|	jz label
|.endmacro

|.macro IF_REFCOUNTED, type_flags, label
|	IF_FLAGS type_flags, IS_TYPE_REFCOUNTED, label
|.endmacro

|.macro IF_NOT_REFCOUNTED, type_flags, label
|	IF_NOT_FLAGS type_flags, IS_TYPE_REFCOUNTED, label
|.endmacro

|.macro IF_Z_FLAGS, zv, mask, label
|	IF_FLAGS byte [zv + 9], mask, label
|.endmacro

|.macro IF_NOT_Z_FLAGS, zv, mask, label
|	IF_NOT_FLAGS byte [zv + 9], mask, label
|.endmacro

|.macro IF_Z_REFCOUNTED, zv, label
|	IF_Z_FLAGS zv, IS_TYPE_REFCOUNTED, label
|.endmacro

|.macro IF_NOT_Z_REFCOUNTED, zv, label
|	IF_NOT_Z_FLAGS zv, IS_TYPE_REFCOUNTED, label
|.endmacro

|.macro GC_ADDREF, zv
|	add	dword [zv], 1
|.endmacro

|.macro GC_DELREF, zv
|	sub	dword [zv], 1
|.endmacro

|.macro IF_GC_MAY_NOT_LEAK, ptr, tmp_reg, label
|	mov tmp_reg, dword [ptr + 4]
|	and tmp_reg, (GC_INFO_MASK | (GC_COLLECTABLE << GC_FLAGS_SHIFT))
|	cmp tmp_reg, (GC_COLLECTABLE << GC_FLAGS_SHIFT)
|	jne label
|.endmacro

|.macro ADDREF_CONST, zv, tmp_reg
|.if X64
||		if (!IS_SIGNED_32BIT(Z_LVAL_P(zv))) {
|			mov64 tmp_reg, ((uintptr_t)Z_LVAL_P(zv))
|			add dword [tmp_reg], 1
||		} else {
|			add dword [Z_LVAL_P(zv)], 1
||		}
|.else
|		add dword [Z_LVAL_P(zv)], 1
|.endif
|.endmacro

|.macro ADDREF_CONST_2, zv, tmp_reg
|.if X64
||		if (!IS_SIGNED_32BIT(Z_LVAL_P(zv))) {
|			mov64 tmp_reg, ((uintptr_t)Z_LVAL_P(zv))
|			add dword [tmp_reg], 2
||		} else {
|			add dword [Z_LVAL_P(zv)], 2
||		}
|.else
|		add dword [Z_LVAL_P(zv)], 1
|.endif
|.endmacro

|.macro TRY_ADDREF, val_info, type_flags_reg, value_ptr_reg
||if (val_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE)) {
||	if (val_info & (MAY_BE_ANY-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
|		IF_NOT_REFCOUNTED type_flags_reg, >1
||	}
|	GC_ADDREF value_ptr_reg
|1:
||}
|.endmacro

|.macro TRY_ADDREF_2, val_info, type_flags_reg, value_ptr_reg
||if (val_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE)) {
||	if (val_info & (MAY_BE_ANY-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
|		IF_NOT_REFCOUNTED type_flags_reg, >1
||	}
|	add dword [value_ptr_reg], 2
|1:
||}
|.endmacro

// zval should be in FCARG1a
|.macro ZVAL_COPY_CTOR_FUNC, filename, lineno // arg1 must be in FCARG1a
||	if (ZEND_DEBUG) {
||		if (filename) {
|			LOAD_ADDR FCARG2a, ZSTR_VAL((zend_string*)filename)
||		} else {
|			mov FCARG2a, 0
||		}
|.if X64
|		mov CARG3d, lineno
|.else
|		push lineno
|.endif
||	}
|		EXT_CALL _zval_copy_ctor_func, r0
|.endmacro

// zval should be in FCARG1a
|.macro ZVAL_COPY_CTOR, val_info, type_flags_reg, value_ptr_reg, filename, lineno
||if (val_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE)) {
||	if (val_info & (MAY_BE_STRING|MAY_BE_ARRAY)) {
|		IF_NOT_FLAGS type_flags_reg, IS_TYPE_REFCOUNTED + IS_TYPE_COPYABLE, >2
|		IF_NOT_FLAGS type_flags_reg, IS_TYPE_COPYABLE, >1
|		GC_ADDREF value_ptr_reg
|		jmp >2
|1:
|		ZVAL_COPY_CTOR_FUNC filename, lineno
|2:
||	} else {
|		TRY_ADDREF val_info, type_flags_reg, value_ptr_reg
||	}
||}
|.endmacro

|.macro ZVAL_DEREF, reg, info
||	if (info & MAY_BE_REF) {
|		IF_NOT_Z_TYPE, reg, IS_REFERENCE, >1
|		GET_Z_PTR reg, reg
|		add reg, offsetof(zend_reference, val)
|1:
||	}
|.endmacro

|.macro SAVE_VALID_OPLINE, op
|| if (op == last_valid_opline) {
|		mov aword EX->opline, IP
|| } else {
|.if X64
||		if (IS_32BIT(op)) {
|			mov aword EX->opline, ((ptrdiff_t)op)
||		} else {
|			mov64 r0, ((ptrdiff_t)op)
|			mov aword EX->opline, r0
||		}
|.else
|		mov aword EX->opline, op
|.endif
||	}
|.endmacro

// zval should be in FCARG1a
|.macro ZVAL_DTOR_FUNC, var_info, filename, opline // arg1 must be in FCARG1a
||do {
||	if (opline) {
|		SAVE_VALID_OPLINE opline
||	}
||	if (has_concrete_type((var_info) & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
||		zend_uchar type = concrete_type((var_info) & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE));
||		if (type == IS_STRING && !ZEND_DEBUG) {
|			test byte [FCARG1a + 5], IS_STR_PERSISTENT
|			jnz >1
|			EXT_CALL _efree, r0
|			jmp >2
|1:
|			EXT_CALL free, r0
|2:
||			break;
||		} else if (type == IS_ARRAY) {
|			EXT_CALL zend_array_destroy, r0
||			break;
||		} else if (type == IS_OBJECT) {
|.if X64
|			EXT_CALL zend_objects_store_del, r0
|.else
|			sub r4, 12
|			push FCARG1a
|			EXT_CALL zend_objects_store_del, r0
|			add r4, 16
|.endif
||			break;
||		}
||	}
||	if (ZEND_DEBUG) {
||		uint32_t lineno = opline ? ((zend_op*)opline)->lineno : 0;
||		if (filename) {
|			LOAD_ADDR FCARG2a, ZSTR_VAL((zend_string*)filename)
||		} else {
|			mov FCARG2a, 0
||		}
|.if X64
|		mov CARG3d, lineno
|.else
|		push lineno
|.endif
||	}
|	EXT_CALL _zval_dtor_func, r0
||} while(0);
|.endmacro

|.macro ZVAL_PTR_DTOR, zv, op_info, gc, cold, safe, filename, opline
||	if ((op_info) & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF)) {
||		if ((op_info) & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
|			// if (Z_REFCOUNTED_P(cv)) {
||			if (cold) {
|				IF_Z_REFCOUNTED zv, >1
|.cold_code
|1:
||			} else {
|				IF_NOT_Z_REFCOUNTED zv, >4
||			}
||		}
|		// if (!Z_DELREF_P(cv)) {
|		GET_Z_PTR FCARG1a, zv
|		GC_DELREF FCARG1a
||		if (RC_MAY_BE_1(op_info)) {
||			if (RC_MAY_BE_N(op_info)) {
||				if (gc && RC_MAY_BE_N(op_info) && ((op_info) & (MAY_BE_REF|MAY_BE_ARRAY|MAY_BE_OBJECT))) {
|					jnz >3
||				} else {
|					jnz >4
||				}
||			}
||			if (safe) {
|				// ZVAL_NULL(cv);
|				SET_Z_TYPE_INFO zv, IS_NULL
||			}
|			// zval_dtor_func(r);
|			ZVAL_DTOR_FUNC op_info, filename, opline
||			if (gc && RC_MAY_BE_N(op_info) && ((op_info) & (MAY_BE_REF|MAY_BE_ARRAY|MAY_BE_OBJECT))) {
|				jmp >4
||			}
|3:
||		}
||		if (gc && RC_MAY_BE_N(op_info) && ((op_info) & (MAY_BE_REF|MAY_BE_ARRAY|MAY_BE_OBJECT))) {
||			if ((op_info) & MAY_BE_REF) {
|				GET_Z_PTR FCARG1a, zv
|				cmp byte [FCARG1a + 4], IS_REFERENCE
|				jnz >1
|				GET_Z_PTR FCARG1a, FCARG1a + offsetof(zend_reference, val)
|				IF_NOT_Z_REFCOUNTED zv, >4
|				GET_Z_PTR FCARG1a, zv
|1:
||			}
|			IF_GC_MAY_NOT_LEAK FCARG1a, eax, >4
|			// gc_possible_root(Z_COUNTED_P(z))
|			EXT_CALL gc_possible_root, r0
||			if (cold && ((op_info) & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_OBJECT|MAY_BE_RESOURCE)))) {
|				jmp >4
|.code
||			}
||		} else if (cold && ((op_info) & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_OBJECT|MAY_BE_RESOURCE)))) {
|			jmp >4
|.code
||		}
|4:
||	}
|.endmacro

|.macro FREE_OP, op_type, op, op_info, cold, op_array, opline
||if (op_type & (IS_VAR|IS_TMP_VAR)) {
|	ZVAL_PTR_DTOR FP + op.var, op_info, 0, cold, 0, op_array->filename, opline
||}
|.endmacro

|.macro SEPARATE_ZVAL_NOREF, zv, op_info, cold, filename, lineno
||	if ((op_info & (MAY_BE_STRING|MAY_BE_ARRAY)) && RC_MAY_BE_N(op_info)) {
||		if (cold) {
|			IF_Z_FLAGS zv, IS_TYPE_COPYABLE, >1
|.cold_code
|1:
||		} else {
|			IF_NOT_Z_FLAGS zv, IS_TYPE_COPYABLE, >2
||		}
|		GET_Z_PTR r0, zv
||		if (RC_MAY_BE_1(op_info)) {
|			cmp dword [r0], 1 // if (GC_REFCOUNTED() > 1)
|			jbe >2
||		}
|		IF_NOT_Z_FLAGS zv, IS_TYPE_REFCOUNTED, >1
|		GC_DELREF r0
|1:
|		lea FCARG1a, [zv]
|		ZVAL_COPY_CTOR_FUNC filename, lineno
||		if (cold) {
|			jmp >2
|.code
||		}
|2:
||	}
|.endmacro

|.macro SEPARATE_ZVAL_NOREF_REG, op_info, cold, filename, lineno
||	if ((op_info & (MAY_BE_STRING|MAY_BE_ARRAY)) && RC_MAY_BE_N(op_info)) {
||		if (cold) {
|			IF_Z_FLAGS FCARG1a, IS_TYPE_COPYABLE, >1
|.cold_code
|1:
||		} else {
|			IF_NOT_Z_FLAGS FCARG1a, IS_TYPE_COPYABLE, >2
||		}
|		GET_Z_PTR r0, FCARG1a
||		if (RC_MAY_BE_1(op_info)) {
|			cmp dword [r0], 1 // if (GC_REFCOUNTED() > 1)
|			jbe >2
||		}
|		IF_NOT_Z_FLAGS FCARG1a, IS_TYPE_REFCOUNTED, >1
|		GC_DELREF r0
|1:
|		mov aword [r4], FCARG1a // save
|		ZVAL_COPY_CTOR_FUNC filename, lineno
|		mov FCARG1a, aword [r4] // restore
||		if (cold) {
|			jmp >2
|.code
||		}
|2:
||	}
|.endmacro

|.macro SEPARATE_ARRAY, op_type, op, op_info, cold, filename, lineno
|	LONG_LOAD FCARG1a, op_type, op
||	if (RC_MAY_BE_N(op_info)) {
||		if (RC_MAY_BE_1(op_info)) {
|			cmp dword [FCARG1a], 1 // if (GC_REFCOUNTED() > 1)
||			if (cold) {
|				ja >1
|.cold_code
|1:
||			} else {
|				jbe >2
||			}
||		}
|		IF_NOT_Z_FLAGS FP + op.var, IS_TYPE_REFCOUNTED, >1
|		GC_DELREF FCARG1a
|1:
|		LOAD_ZVAL_ADDR FCARG1a, op_type, op
|		ZVAL_COPY_CTOR_FUNC filename, lineno
|		LONG_LOAD FCARG1a, op_type, op
||		if (RC_MAY_BE_1(op_info)) {
||			if (cold) {
|				jmp >2
|.code
||			}
||		}
|2:
||	}
|.endmacro

|.macro SEPARATE_ARRAY_REG, op_info, cold, filename, lineno
||	if (RC_MAY_BE_N(op_info)) {
|		GET_Z_PTR r0, FCARG1a
||		if (RC_MAY_BE_1(op_info)) {
|			cmp dword [r0], 1 // if (GC_REFCOUNTED() > 1)
||			if (cold) {
|				ja >1
|.cold_code
|1:
||			} else {
|				jbe >2
||			}
||		}
|		IF_NOT_Z_FLAGS FCARG1a, IS_TYPE_REFCOUNTED, >1
|		GC_DELREF r0
|1:
|		mov aword [r4], FCARG1a // save
|		ZVAL_COPY_CTOR_FUNC filename, lineno
|		mov FCARG1a, aword [r4] // restore
|		GET_Z_PTR FCARG1a, FCARG1a
||		if (RC_MAY_BE_1(op_info)) {
||			if (cold) {
|				jmp >2
|.code
||			}
||		}
|		mov FCARG1a, r0
|2:
||	} else {
|		GET_Z_PTR FCARG1a, FCARG1a
||	}
|.endmacro

|.macro EFREE_REG_24, op_array, opline
||#if ZEND_DEBUG
||		const char *filename = op_array->filename ? op_array->filename->val : NULL;
|		LOAD_ADDR FCARG2a, filename
|.if X64
|		mov CARG3d, opline->lineno
|		xor CARG4, CARG4
|		xor CARG5, CARG5
|.else
|		push 0
|		push 0
|		push opline->lineno
|.endif
|		EXT_CALL _efree, r0
||#else
|		EXT_CALL _efree_24, r0
||#endif
|.endmacro

|.macro EFREE_24, ptr, op_array, opline
|	mov FCARG1a, ptr
|	EFREE_REG_24 op_array, opline
|.endmacro

|.macro EMALLOC, size, op_array, opline
||#if ZEND_DEBUG
||		const char *filename = op_array->filename ? op_array->filename->val : NULL;
|		mov FCARG1a, size
|		LOAD_ADDR FCARG2a, filename
|.if X64
|		mov CARG3d, opline->lineno
|		xor CARG4, CARG4
|		xor CARG5, CARG5
|.else
|		push 0
|		push 0
|		push opline->lineno
|.endif
|		EXT_CALL _emalloc, r0
||#else
||	if (size == 24) {
|		EXT_CALL _emalloc_24, r0
||	} else {
|		mov FCARG1a, size
|		EXT_CALL _emalloc, r0
||	}
||#endif
|.endmacro

|.macro OBJ_RELEASE, reg, tmp_reg, exit_label
|	GC_DELREF reg
|	jne >1
|	// zend_objects_store_del(obj);
|.if X64
|	mov CARG1, reg
|	EXT_CALL zend_objects_store_del, r0
|.else
|	sub r4, 12
|	push reg
|	EXT_CALL zend_objects_store_del, r0
|	add r4, 16
|.endif
|	jmp exit_label
|1:
|	IF_GC_MAY_NOT_LEAK reg, tmp_reg, >1
|	// gc_possible_root(obj)
|	mov FCARG1a, reg
|	EXT_CALL gc_possible_root, r0
|1:
|.endmacro

|.macro UNDEFINED_OFFSET, opline
|| if (opline == last_valid_opline) {
|	call ->undefined_offset_ex
|| } else {
|	SAVE_VALID_OPLINE, opline
|	call ->undefined_offset
|| }
|.endmacro

|.macro UNDEFINED_INDEX, opline
|| if (opline == last_valid_opline) {
|	call ->undefined_index_ex
|| } else {
|	SAVE_VALID_OPLINE, opline
|	call ->undefined_index
|| }
|.endmacro

|.macro CANNOT_ADD_ELEMENT, opline
|| if (opline == last_valid_opline) {
|	call ->cannot_add_element_ex
|| } else {
|	SAVE_VALID_OPLINE, opline
|	call ->cannot_add_element
|| }
|.endmacro

static zend_bool reuse_ip;
static zend_bool delayed_call_chain;
static uint32_t  delayed_call_level;
static const zend_op *last_valid_opline;
static int jit_return_label;

/* bit helpers */

/* from http://aggregate.org/MAGIC/ */
static uint32_t ones32(uint32_t x)
{
	x -= ((x >> 1) & 0x55555555);
	x = (((x >> 2) & 0x33333333) + (x & 0x33333333));
	x = (((x >> 4) + x) & 0x0f0f0f0f);
	x += (x >> 8);
	x += (x >> 16);
	return x & 0x0000003f;
}

static uint32_t floor_log2(uint32_t x)
{
	x |= (x >> 1);
	x |= (x >> 2);
	x |= (x >> 4);
	x |= (x >> 8);
	x |= (x >> 16);
	return ones32(x) - 1;
}

static zend_bool is_power_of_two(uint32_t x)
{
	return !(x & (x - 1));
}

static zend_bool has_concrete_type(uint32_t value_type)
{
	if (value_type & MAY_BE_UNDEF) {
		value_type |= MAY_BE_NULL;
	}
	value_type &= MAY_BE_ANY;
	return is_power_of_two (value_type);
}

static uint32_t concrete_type(uint32_t value_type)
{
	return floor_log2(value_type & MAY_BE_ANY);
}

static inline zend_bool is_signed(double d)
{
    return (((unsigned char*)&d)[sizeof(double)-1] & 0x80) != 0;
}

static int zend_jit_interrupt_handler_stub(dasm_State **Dst)
{
	|->interrupt_handler:
	|	//EG(vm_interrupt) = 0;
	|	mov byte [&EG(vm_interrupt)], 0
	|	//if (EG(timed_out)) {
	|	cmp byte [&EG(timed_out)], 0
	|	je >1
	|	//zend_timeout(0);
	|.if X64
	|	xor CARG1d, CARG1d
	|.else
	|	push 0
	|.endif
	|	EXT_CALL zend_timeout, r0
	|1:
	|	//} else if (zend_interrupt_function) {
	if (zend_interrupt_function) {
		|	//SAVE_OPLINE();
		|	mov EX->opline, IP
		|	//zend_interrupt_function(execute_data);
		|.if X64
		|	mov CARG1, FP
		|	EXT_CALL zend_interrupt_function, r0
		|.else
		|	sub r4, 12
		|	push FP
		|	EXT_CALL zend_interrupt_function, r0
		|	add r4, 16
		|.endif
		|	//ZEND_VM_ENTER();
		|	//execute_data = EG(current_execute_data);
		|	mov FP, aword [&EG(current_execute_data)]
		|	// LOAD_OPLINE();
		|	mov IP, EX->opline
		|	//}
	}
	|	//ZEND_VM_CONTINUE()
	|	add r4, SPAD // stack alignment
	|	jmp aword [IP]

	return 1;
}

static int zend_jit_exception_handler_stub(dasm_State **Dst)
{
	|->exception_handler:
	|	add r4, SPAD // stack alignment
	|	EXT_JMP EG(exception_op)->handler, r0

	return 1;
}

static int zend_jit_exception_handler_undef_stub(dasm_State **Dst)
{
	|->exception_handler_undef:
	|	SET_Z_TYPE_INFO FP + r0, IS_UNDEF
	|	jmp ->exception_handler

	return 1;
}

static int zend_jit_leave_function_stub(dasm_State **Dst)
{
	|->leave_function_handler:
	|	add r4, SPAD
	|	test FCARG1d, ZEND_CALL_TOP
	|	jnz >1
	|	EXT_JMP zend_jit_leave_nested_func_helper, r0
	|1:
	|	EXT_JMP zend_jit_leave_top_func_helper, r0

	return 1;
}

static int zend_jit_leave_throw_stub(dasm_State **Dst)
{
	|->leave_throw_handler:
	|	// if (opline->opcode != ZEND_HANDLE_EXCEPTION) {
	|	cmp byte OP:IP->opcode, ZEND_HANDLE_EXCEPTION
	|	je >5
	|	// EG(opline_before_exception) = opline;
	|	mov aword [&EG(opline_before_exception)], IP
	|5:
	|	// opline = EG(exception_op);
	|	LOAD_ADDR IP, &EG(exception_op)
	|	//	HANDLE_EXCEPTION()
	|	jmp ->exception_handler

	return 1;
}

static int zend_jit_icall_throw_stub(dasm_State **Dst)
{
	|->icall_throw_handler:
	|	//	zend_throw_exception_internal(NULL);
	|.if X64
	|	xor CARG1, CARG1
	|	EXT_CALL zend_throw_exception_internal, r0
	|.else
	|	sub r4, 12
	|	push 0
	|	EXT_CALL zend_throw_exception_internal, r0
	|	add r4, 16
	|.endif
	|	//	HANDLE_EXCEPTION()
	|	jmp ->exception_handler

	return 1;
}

static int zend_jit_throw_cannot_pass_by_ref_stub(dasm_State **Dst)
{
	|->throw_cannot_pass_by_ref:
	|	mov r0, EX->opline
	|.if X64
	|	movsxd r1, dword OP:r0->result.var
	|.else
	|	mov r1, OP:r0->result.var
	|.endif
	|	SET_Z_TYPE_INFO RX+r1, IS_UNDEF
	|	mov RX, r0
	|.if X64
	|	xor CARG1, CARG1
	|	LOAD_ADDR CARG2, "Cannot pass parameter %d by reference"
	|	mov CARG3d, dword OP:r0->op2.num
	|	EXT_CALL zend_throw_error, r0
	|.else
	|	mov r1, dword OP:r0->op2.num
	|	sub r4, 4
	|	push r1
	|	push "Cannot pass parameter %d by reference"
	|	push 0
	|	EXT_CALL zend_throw_error, r0
	|	add r4, 16
	|.endif
	|	cmp byte OP:RX->op1_type, IS_TMP_VAR
	|	jne >9
	|.if X64
	|	movsxd r0, dword OP:RX->op1.var
	|.else
	|	mov r0, OP:RX->op1.var
	|.endif
	|	add r0, FP
	|	ZVAL_PTR_DTOR r0, MAY_BE_ANY|MAY_BE_RC1|MAY_BE_RCN|MAY_BE_REF, 0, 0, 0, NULL, NULL
	|9:
	|	jmp ->exception_handler

	return 1;
}

static int zend_jit_undefined_offset_ex_stub(dasm_State **Dst)
{
	|->undefined_offset_ex:
	|	mov aword EX->opline, IP
	|	jmp ->undefined_offset

	return 1;
}

static int zend_jit_undefined_offset_stub(dasm_State **Dst)
{
	|->undefined_offset:
	|.if X64
	|	sub r4, 8
	|.else
	|	sub r4, 12
	|.endif
	|	mov r0, EX->opline
	|.if X64
	|	movsxd r1, dword OP:r0->result.var
	|.else
	|	mov r1, OP:r0->result.var
	|.endif
	|	cmp byte OP:r0->op2_type, IS_CONST
	|	SET_Z_TYPE_INFO FP + r1, IS_NULL
	|	jne >2
	|.if X64
	|	movsxd r0, dword OP:r0->op2.constant
	|   add r0, aword EX->literals
	|.else
	|	mov r0, aword OP:r0->op2.zv
	|.endif
	|	jmp >3
	|2:
	|.if X64
	|	movsxd r0, dword OP:r0->op2.var
	|.else
	|	mov r0, OP:r0->op2.var
	|.endif
	|	add r0, FP
	|3:
	|.if X64
	|	mov CARG1, E_NOTICE
	|	LOAD_ADDR CARG2, "Undefined offset: " ZEND_LONG_FMT
	|	mov CARG3, aword [r0]
	|	EXT_CALL zend_error, r0
	|	add r4, 8 // stack alignment
	|.else
	|	sub r4, 4
	|	push aword [r0]
	|	push "Undefined offset: " ZEND_LONG_FMT
	|	push E_NOTICE
	|	EXT_CALL zend_error, r0
	|	add r4, 28
	|.endif
	|	ret

	return 1;
}

static int zend_jit_undefined_index_ex_stub(dasm_State **Dst)
{
	|->undefined_index_ex:
	|	mov aword EX->opline, IP
	|	jmp ->undefined_index

	return 1;
}

static int zend_jit_undefined_index_stub(dasm_State **Dst)
{
	|->undefined_index:
	|.if X64
	|	sub r4, 8
	|.else
	|	sub r4, 12
	|.endif
	|	mov r0, EX->opline
	|.if X64
	|	movsxd r1, dword OP:r0->result.var
	|.else
	|	mov r1, OP:r0->result.var
	|.endif
	|	cmp byte OP:r0->op2_type, IS_CONST
	|	SET_Z_TYPE_INFO FP + r1, IS_NULL
	|	jne >2
	|.if X64
	|	movsxd r0, dword OP:r0->op2.constant
	|   add r0, aword EX->literals
	|.else
	|	mov r0, aword OP:r0->op2.zv
	|.endif
	|	jmp >3
	|2:
	|.if X64
	|	movsxd r0, dword OP:r0->op2.var
	|.else
	|	mov r0, OP:r0->op2.var
	|.endif
	|	add r0, FP
	|3:
	|.if X64
	|	mov CARG1, E_NOTICE
	|	LOAD_ADDR CARG2, "Undefined index: %s"
	|	mov CARG3, aword [r0]
	|	add CARG3, offsetof(zend_string, val)
	|	EXT_CALL zend_error, r0
	|	add r4, 8
	|.else
	|	sub r4, 4
	|	mov r0, aword [r0]
	|	add r0, offsetof(zend_string, val)
	|	push r0
	|	push "Undefined index: %s"
	|	push E_NOTICE
	|	EXT_CALL zend_error, r0
	|	add r4, 28
	|.endif
	|	ret

	return 1;
}

static int zend_jit_cannot_add_element_ex_stub(dasm_State **Dst)
{
	|->cannot_add_element_ex:
	|	mov aword EX->opline, IP
	|	jmp ->cannot_add_element

	return 1;
}

static int zend_jit_cannot_add_element_stub(dasm_State **Dst)
{
	|->cannot_add_element:
	|.if X64
	|	sub r4, 8
	|.else
	|	sub r4, 12
	|.endif
	|	mov r0, EX->opline
	|	cmp byte OP:r0->result_type, IS_UNUSED
	|	jz >1
	|.if X64
	|	movsxd r0, dword OP:r0->result.var
	|.else
	|	mov r0, OP:r0->result.var
	|.endif
	|	SET_Z_TYPE_INFO FP + r0, IS_NULL
	|1:
	|.if X64
	|	mov CARG1, E_WARNING
	|	LOAD_ADDR CARG2, "Cannot add element to the array as the next element is already occupied"
	|	EXT_CALL zend_error, r0
	|	add r4, 8
	|.else
	|	sub r4, 8
	|	push "Cannot add element to the array as the next element is already occupied"
	|	push E_WARNING
	|	EXT_CALL zend_error, r0
	|	add r4, 28
	|.endif
	|	ret

	return 1;
}

static int zend_jit_not_obj_stub(dasm_State **Dst)
{
	|->not_obj:
	|8:
	|.if X64
	|	xor CARG1, CARG1
	|	LOAD_ADDR CARG2, "Using $this when not in object context"
	|	EXT_CALL zend_throw_error, r0
	|.else
	|	sub r4, 8
	|	push "Using $this when not in object context"
	|	push 0
	|	EXT_CALL zend_throw_error, r0
	|	add r4, 16
	|.endif
	|	jmp ->exception_handler
	return 1;
}

static const zend_jit_stub zend_jit_stubs[] = {
	JIT_STUB(interrupt_handler),
	JIT_STUB(exception_handler),
	JIT_STUB(exception_handler_undef),
	JIT_STUB(leave_function),
	JIT_STUB(leave_throw),
	JIT_STUB(icall_throw),
	JIT_STUB(throw_cannot_pass_by_ref),
	JIT_STUB(undefined_offset),
	JIT_STUB(undefined_index),
	JIT_STUB(cannot_add_element),
	JIT_STUB(undefined_offset_ex),
	JIT_STUB(undefined_index_ex),
	JIT_STUB(cannot_add_element_ex),
	JIT_STUB(not_obj),
};

static int zend_jit_align_func(dasm_State **Dst)
{
	reuse_ip = 0;
	delayed_call_chain = 0;
	last_valid_opline = NULL;
	jit_return_label = -1;
	|.align 16
	return 1;
}

static int zend_jit_prologue(dasm_State **Dst)
{
	|	sub r4, SPAD // stack alignment
	return 1;
}

static int zend_jit_label(dasm_State **Dst, unsigned int label)
{
	|=>label:
	return 1;
}

static int zend_jit_save_call_chain(dasm_State **Dst, uint32_t call_level)
{
	|	// call->prev_execute_data = EX(call);
	if (call_level == 1) {
		|	mov aword EX:RX->prev_execute_data, 0
	} else {
		|	mov r0, EX->call
		|	mov EX:RX->prev_execute_data, r0
	}
	|	// EX(call) = call;
	|	mov EX->call, RX

	delayed_call_chain = 0;

	return 1;
}

static int zend_jit_set_valid_ip(dasm_State **Dst, const zend_op *opline)
{
	if (delayed_call_chain) {
		if (!zend_jit_save_call_chain(Dst, delayed_call_level)) {
			return 0;
		}
	}
	if (!last_valid_opline) {
		|	LOAD_ADDR  IP, opline
	} else if (last_valid_opline != opline) {
		|	add IP, (opline - last_valid_opline) * sizeof(zend_op);
	}
	last_valid_opline = opline;
	reuse_ip = 0;
	return 1;
}

static int zend_jit_check_timeout(dasm_State **Dst, const zend_op *opline)
{
	if (zend_interrupt_function) {
		if (!zend_jit_set_valid_ip(Dst, opline)) {
			return 0;
		}
	}
	|	cmp byte [&EG(vm_interrupt)], 0
	|	jne ->interrupt_handler
	return 1;
}

static int zend_jit_check_exception(dasm_State **Dst)
{
	|	cmp aword [&EG(exception)], 0
	|	jne ->exception_handler
	return 1;
}

static int zend_jit_check_exception_undef_result(dasm_State **Dst, const zend_op *opline)
{
	if (opline->result_type & (IS_TMP_VAR|IS_VAR)) {
		|	cmp aword [&EG(exception)], 0
		|	mov r0, opline->result.var
		|	jne ->exception_handler_undef
		return 1;
	}
	return zend_jit_check_exception(Dst);
}

static int zend_jit_handler(dasm_State **Dst, const zend_op *opline, int may_throw)
{
	if (!zend_jit_set_valid_ip(Dst, opline)) {
		return 0;
	}
	|	EXT_CALL opline->handler, r0
	if (may_throw) {
		zend_jit_check_exception(Dst);
	}
	last_valid_opline++;

	/* Skip the following OP_DATA */
	switch (opline->opcode) {
		case ZEND_ASSIGN_DIM:
		case ZEND_ASSIGN_OBJ:
			last_valid_opline++;
			break;
		case ZEND_ASSIGN_ADD:
		case ZEND_ASSIGN_SUB:
		case ZEND_ASSIGN_MUL:
		case ZEND_ASSIGN_DIV:
		case ZEND_ASSIGN_MOD:
		case ZEND_ASSIGN_SL:
		case ZEND_ASSIGN_SR:
		case ZEND_ASSIGN_CONCAT:
		case ZEND_ASSIGN_BW_OR:
		case ZEND_ASSIGN_BW_AND:
		case ZEND_ASSIGN_BW_XOR:
		case ZEND_ASSIGN_POW:
			if (opline->extended_value) {
				last_valid_opline++;
			}
			break;
		default:
			break;
	}

	return 1;
}

static int zend_jit_tail_handler(dasm_State **Dst, const zend_op *opline)
{
	if (!zend_jit_set_valid_ip(Dst, opline)) {
		return 0;
	}
	|	add r4, SPAD // stack alignment
	|	EXT_JMP opline->handler, r0
	last_valid_opline = NULL;
	return 1;
}

static int zend_jit_set_opline(dasm_State **Dst, const zend_op *target_opline)
{
	if (!reuse_ip) {
		last_valid_opline = target_opline;
	}
	return 1;
}

static int zend_jit_reset_opline(dasm_State **Dst, const zend_op *target_opline)
{
	last_valid_opline = NULL;
	return 1;
}

static void zend_jit_start_reuse_ip(void) {
	last_valid_opline = NULL;
	reuse_ip = 1;
}

static void zend_jit_stop_reuse_ip(void) {
	reuse_ip = 0;
}

static int zend_jit_jmp(dasm_State **Dst, unsigned int target_label)
{
	|	jmp =>target_label
	return 1;
}

static int zend_jit_cond_jmp(dasm_State **Dst, const zend_op *next_opline, unsigned int target_label)
{
	|	cmp IPl, next_opline
	|	jne =>target_label

	last_valid_opline = next_opline;

	return 1;
}

static int zend_jit_smart_branch(dasm_State **Dst, const zend_op *opline, unsigned int next_label, unsigned int target_label)
{
	const zend_op *next_opline = opline + 1;
	const zend_op *target_opline = OP_JMP_ADDR(opline, opline->op2);

	|	cmp IPl, next_opline
	|	je =>next_label
	|	cmp IPl, target_opline
	|	je =>target_label

	return 1;
}

#ifdef CONTEXT_THREADED_JIT
static int zend_jit_context_threaded_call(dasm_State **Dst, const zend_op *opline)
{
	if (!zend_jit_handler(Dst, opline, 1)) return 0;
	if (opline->opcode == ZEND_DO_UCALL) {
		|	call aword [IP]
		zend_jit_check_exception(Dst);
	} else {
		const zend_op *next_opline = opline + 1;

		|	cmp IPl, next_opline
		|	je >1
		|	call aword [IP]
		zend_jit_check_exception(Dst);
		|1:
	}
	return 1;
}
#endif

static int zend_jit_call(dasm_State **Dst, const zend_op *opline)
{
#ifdef CONTEXT_THREADED_JIT
	return zend_jit_context_threaded_call(Dst, opline);
#else
	return zend_jit_tail_handler(Dst, opline);
#endif
}

static int zend_jit_new(dasm_State **Dst, const zend_op *opline, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	if (!zend_jit_handler(Dst, opline, 1)) {
		return 0;
	}
	if (opline->extended_value == 0 && (opline+1)->opcode == ZEND_DO_FCALL) {
		zend_class_entry *ce = NULL;

		if (zend_jit_level >= ZEND_JIT_LEVEL_OPT_FUNC) {
			if (ssa->ops && ssa->var_info) {
				zend_ssa_var_info *res_ssa = &ssa->var_info[ssa->ops[opline - op_array->opcodes].result_def];
				if (res_ssa->ce && !res_ssa->is_instanceof) {
					ce = res_ssa->ce;
				}
			}
		} else {
			if (opline->op1_type == IS_CONST) {
				zval *zv = RT_CONSTANT(op_array, opline->op1);
				if (Z_TYPE_P(zv) == IS_STRING) {
					zval *lc = zv + 1;
					ce = (zend_class_entry*)zend_hash_find_ptr(EG(class_table), Z_STR_P(lc));
				}
			}
		}

		(*opnum)++;
		if (!ce || ce->constructor) {
			const zend_op *next_opline = opline + 1;

			|	cmp IPl, next_opline
			|	jne >1
			zend_jit_call(Dst, next_opline);
			|1:
		}
	}
	return 1;
}

static int zend_jit_inc_dec(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op1_def_info;

	op1_info = OP1_INFO();
	if (opline->op1_type != IS_CV || !(op1_info & MAY_BE_LONG)) {
		goto fallback;
	}

	if (op1_info & ((MAY_BE_UNDEF|MAY_BE_ANY)-MAY_BE_LONG)) {
		|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_LONG, >2
	}
	||	if ((opline->opcode == ZEND_POST_INC || opline->opcode == ZEND_POST_DEC) &&
	||	    opline->result_type != IS_UNUSED) {
	|		ZVAL_COPY_VALUE FP + opline->result.var, FP + opline->op1.var, MAY_BE_LONG, r0, eax, r1
	||	}
	if (opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_POST_INC) {
		|	add aword [FP + opline->op1.var], 1
	} else {
		|	sub aword [FP + opline->op1.var], 1
	}
	op1_def_info = OP1_DEF_INFO();

	if ((op1_def_info & MAY_BE_DOUBLE) && zend_may_overflow(opline, op_array, ssa)) {
		|	jo >1
		||	if ((opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_PRE_DEC) &&
		||	    opline->result_type != IS_UNUSED) {
		|		ZVAL_COPY_VALUE FP + opline->result.var, FP + opline->op1.var, MAY_BE_LONG, r0, eax, r1
		||	}
		|.cold_code
		|1:
		if (opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_POST_INC) {
			|.if X64
			|	mov64 rax, 0x43e0000000000000
			|	SET_Z_LVAL FP + opline->op1.var, rax
			|.else
			|	SET_Z_LVAL FP + opline->op1.var, 0
			|	SET_Z_W2 FP + opline->op1.var, 0x41e00000
			|.endif
		} else {
			|.if X64
			|	mov64 rax, 0xc3e0000000000000
			|	SET_Z_LVAL FP + opline->op1.var, rax
			|.else
			|	SET_Z_LVAL FP + opline->op1.var, 0x00200000
			|	SET_Z_W2 FP + opline->op1.var, 0xc1e00000
			|.endif
		}
		|	SET_Z_TYPE_INFO FP + opline->op1.var, IS_DOUBLE
		||	if ((opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_PRE_DEC) &&
		||	    opline->result_type != IS_UNUSED) {
		|		ZVAL_COPY_VALUE FP + opline->result.var, FP + opline->op1.var, MAY_BE_DOUBLE, r0, eax, r1
		||	}
		|	jmp >3
		|.code
	} else {
		||	if ((opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_PRE_DEC) &&
		||	    opline->result_type != IS_UNUSED) {
		|		ZVAL_COPY_VALUE FP + opline->result.var, FP + opline->op1.var, MAY_BE_LONG, r0, eax, r1
		||	}
	}
	if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-MAY_BE_LONG)) {
		|.cold_code
		|2:
		|	SAVE_VALID_OPLINE opline
		||	if (op1_info & MAY_BE_UNDEF) {
		|		IF_NOT_Z_TYPE FP + opline->op1.var, IS_UNDEF, >2
		|		// zend_error(E_NOTICE, "Undefined variable: %s", ZSTR_VAL(CV_DEF_OF(EX_VAR_TO_NUM(opline->op1.var))));
		|		mov FCARG1d, opline->op1.var
		|		EXT_CALL zend_jit_undefined_op_helper, r0
		|		SET_Z_TYPE_INFO FP + opline->op1.var, IS_NULL
		||		op1_info |= MAY_BE_NULL;
		||	}
		|2:
		|	lea	FCARG1a, [FP + opline->op1.var]
		|	// ZVAL_DEREF(var_ptr);
		|	ZVAL_DEREF FCARG1a, op1_info
		||	if ((opline->opcode == ZEND_POST_INC || opline->opcode == ZEND_POST_DEC)) {
		||		if (opline->result_type != IS_UNUSED) {
		|			ZVAL_COPY_VALUE FP + opline->result.var, FCARG1a, op1_info, r0, eax, r2
		|			//ZVAL_COPY_CTOR op1_info, ah, r2, op_array->filename, opline->lineno
		||			if (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE)) {
		||				if (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY)) {
		|					IF_NOT_FLAGS ah, IS_TYPE_REFCOUNTED + IS_TYPE_COPYABLE, >2
		|					IF_FLAGS ah, IS_TYPE_COPYABLE, >1
		|					GC_ADDREF r2
		|					jmp >2
		|1:
		|					mov aword [r4], FCARG1a // save
		|					ZVAL_COPY_CTOR_FUNC op_array->filename, opline->lineno
		|					mov FCARG1a, aword [r4] // restore
		|2:
		||				} else {
		|					TRY_ADDREF op1_info, ah, r2
		||				}
		||			}
		||		}
		||	} else {
		|		SEPARATE_ZVAL_NOREF_REG op1_info, 0, op_array->filename, opline->lineno
		||	}
		||	if (opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_POST_INC) {
		|		EXT_CALL increment_function, r0
		||	} else {
		|		EXT_CALL decrement_function, r0
		||	}
		||	if ((opline->opcode == ZEND_PRE_INC || opline->opcode == ZEND_PRE_DEC) &&
		||	    opline->result_type != IS_UNUSED) {
		|		ZVAL_COPY_VALUE FP + opline->result.var, FP + opline->op1.var, op1_def_info, r0, eax, r1
		|		TRY_ADDREF op1_def_info, ah, r1
		||	}
		|	jmp >3
		|.code
	}
	|3:
	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_math_long_long(dasm_State    **Dst,
                                   const zend_op  *opline,
                                   zend_op_array  *op_array,
                                   zend_ssa       *ssa,
                                   zend_uchar      op1_type,
                                   znode_op        op1,
                                   uint32_t        op1_reg,
                                   uint32_t        op1_offset,
                                   zend_uchar      op2_type,
                                   znode_op        op2,
                                   uint32_t        op2_reg,
                                   uint32_t        op2_offset,
                                   uint32_t        res_reg,
                                   uint32_t        res_offset,
                                   uint32_t        res_info)
{
	zend_bool same_ops = (op1_type == op2_type) && (op1.var == op2.var);

	if (opline->opcode == ZEND_MUL &&
		((op2_type == IS_CONST &&
		IS_SIGNED_32BIT(Z_LVAL_P(RT_CONSTANT(op_array, op2))) &&
		is_power_of_two(Z_LVAL_P(RT_CONSTANT(op_array, op2)))) ||
		(op1_type == IS_CONST &&
		IS_SIGNED_32BIT(Z_LVAL_P(RT_CONSTANT(op_array, op1))) &&
		is_power_of_two(Z_LVAL_P(RT_CONSTANT(op_array, op1)))))) {
		if (op2_type == IS_CONST) {
			if (op1_type == IS_CONST) {
				|  	LONG_LOAD r0, op1_type, op1
			} else {
				|  	GET_Z_LVAL r0, Ra(op1_reg)+op1_offset
			}
			|	shl r0, floor_log2(Z_LVAL_P(RT_CONSTANT(op_array, op2)))
		} else {
			if (op2_type == IS_CONST) {
				|   LONG_LOAD r0, op2_type, op2
			} else {
				|  	GET_Z_LVAL r0, Ra(op2_reg)+op2_offset
			}
			|	shl r0, floor_log2(Z_LVAL_P(RT_CONSTANT(op_array, op1)))
		}
	} else if (opline->opcode == ZEND_DIV &&
			(op2_type == IS_CONST &&
            is_power_of_two(Z_LVAL_P(RT_CONSTANT(op_array, op2))))) {
		if (op1_type == IS_CONST) {
			|  	LONG_LOAD r0, op1_type, op1
		} else {
			|  	GET_Z_LVAL r0, Ra(op1_reg)+op1_offset
		}
		| 	shr r0, floor_log2(Z_LVAL_P(RT_CONSTANT(op_array, op2)))
	} else {
		if (op1_type == IS_CONST) {
			|  	LONG_LOAD r0, op1_type, op1
		} else {
			|  	GET_Z_LVAL r0, Ra(op1_reg)+op1_offset
		}
		if (same_ops && opline->opcode != ZEND_DIV) {
			|	LONG_MATH2 opline->opcode, r0, r0
		} else if (op2_type == IS_CONST) {
			|	LONG_MATH opline->opcode, r0, op2_type, op2
		} else {
			|	LONG_MATH2 opline->opcode, r0, aword [Ra(op2_reg)+op2_offset]
		}
	}
	if ((res_info & MAY_BE_DOUBLE) && zend_may_overflow(opline, op_array, ssa)) {
		|	jo >1
		|.cold_code
		|1:
		|.if X64 or SSE
		zend_reg tmp_reg1 = ZREG_XMM0;
		zend_reg tmp_reg2 = ZREG_XMM1;

		if (op1_type == IS_CONST) {
			|	SSE_LOAD_LONG tmp_reg1, op1_type, op1
		} else {
			|  	SSE_GET_Z_LVAL tmp_reg1, Ra(op1_reg)+op1_offset
		}
		if (op2_type == IS_CONST) {
			|	SSE_LOAD_LONG tmp_reg2, op2_type, op2
		} else {
			|  	SSE_GET_Z_LVAL tmp_reg2, Ra(op2_reg)+op2_offset
		}
		|	SSE_MATH_REG opline->opcode, tmp_reg1, tmp_reg2
		|	SSE_STORE Ra(res_reg)+res_offset, tmp_reg1
		|.else
		if (op2_type == IS_CONST) {
			|	FPU_LONG_LOAD op2_type, op2
		} else {
			|  	FPU_GET_Z_LVAL Ra(op2_reg)+op2_offset
		}
		if (op1_type == IS_CONST) {
			|	FPU_LONG_LOAD op1_type, op1
		} else {
			|  	FPU_GET_Z_LVAL Ra(op1_reg)+op1_offset
		}
		|	FPU_MATH2 opline->opcode, st1
		|	FPU_STORE Ra(res_reg)+res_offset
		|.endif
		|	SET_Z_TYPE_INFO Ra(res_reg)+res_offset, IS_DOUBLE
		|	jmp >2
		|.code
		|	SET_Z_LVAL Ra(res_reg)+res_offset, r0
		if (op1_type == IS_CONST || op1_reg != res_reg || op1_offset != res_offset) {
			|	SET_Z_TYPE_INFO Ra(res_reg)+res_offset, IS_LONG
		}
		|2:
	} else {
		|	SET_Z_LVAL Ra(res_reg)+res_offset, r0
		if (op1_type == IS_CONST || op1_reg != res_reg || op1_offset != res_offset) {
			|	SET_Z_TYPE_INFO Ra(res_reg)+res_offset, IS_LONG
		}
	}

	return 1;
}

static int zend_jit_math_long_double(dasm_State    **Dst,
                                     const zend_op  *opline,
                                     zend_uchar      op1_type,
                                     znode_op        op1,
                                     uint32_t        op1_reg,
                                     uint32_t        op1_offset,
                                     zend_uchar      op2_type,
                                     znode_op        op2,
                                     uint32_t        op2_reg,
                                     uint32_t        op2_offset,
                                     uint32_t        res_reg,
                                     uint32_t        res_offset)
{
	|.if X64 or SSE
		zend_reg result_reg = ZREG_XMM0;

		if (op1_type == IS_CONST) {
			|	SSE_LOAD_LONG result_reg, op1_type, op1
		} else {
			|	SSE_GET_Z_LVAL result_reg, Ra(op1_reg)+op1_offset
		}
		if (op2_type == IS_CONST) {
			|	SSE_MATH_CONST opline->opcode, result_reg, op2
		} else {
			|	SSE_MATH opline->opcode, result_reg, qword [Ra(op2_reg)+op2_offset]
		}
		|	SSE_STORE Ra(res_reg)+res_offset, result_reg
	|.else
		if (op1_type == IS_CONST) {
			|	FPU_LONG_LOAD op1_type, op1
		} else {
			|	FPU_GET_Z_LVAL Ra(op1_reg)+op1_offset
		}
		if (op2_type == IS_CONST) {
			|	FPU_MATH opline->opcode, op2_type, op2
		} else {
			|	FPU_MATH2 opline->opcode, qword [Ra(op2_reg)+op2_offset]
		}
		|	FPU_STORE Ra(res_reg)+res_offset
	|.endif
	|	SET_Z_TYPE_INFO Ra(res_reg)+res_offset, IS_DOUBLE

	return 1;
}

static int zend_jit_math_double_long(dasm_State    **Dst,
                                     const zend_op  *opline,
                                     zend_uchar      op1_type,
                                     znode_op        op1,
                                     uint32_t        op1_reg,
                                     uint32_t        op1_offset,
                                     zend_uchar      op2_type,
                                     znode_op        op2,
                                     uint32_t        op2_reg,
                                     uint32_t        op2_offset,
                                     uint32_t        res_reg,
                                     uint32_t        res_offset)
{
	|.if X64 or SSE
	||	zend_reg result_reg = ZREG_XMM0;
	||
	||	if (opline->opcode == ZEND_ADD || opline->opcode == ZEND_MUL || opline->opcode == ZEND_ASSIGN_ADD || opline->opcode == ZEND_ASSIGN_MUL) {
	||		if (op2_type == IS_CONST) {
	|			SSE_LOAD_LONG result_reg, op2_type, op2
	||		} else {
	|			SSE_GET_Z_LVAL result_reg, Ra(op2_reg)+op2_offset
	||		}
	||		if (op1_type == IS_CONST) {
	|			SSE_MATH_CONST opline->opcode, result_reg, op1
	||		} else {
	|			SSE_MATH opline->opcode, result_reg, qword [Ra(op1_reg)+op1_offset]
	||		}
	||	} else {
	||		int tmp_reg = 1;
	||
	||		if (op1_type == IS_CONST) {
	|			SSE_LOAD result_reg, op1_type, op1
	||		} else {
	|			SSE_GET_Z_DVAL result_reg, Ra(op1_reg)+op1_offset
	||		}
	||		if (op2_type == IS_CONST) {
	|			SSE_LOAD_LONG tmp_reg, op2_type, op2
	||		} else {
	|			SSE_GET_Z_LVAL tmp_reg, Ra(op2_reg)+op2_offset
	||		}
	|		SSE_MATH_REG opline->opcode, result_reg, tmp_reg
	||	}
	|	SSE_STORE Ra(res_reg)+res_offset, result_reg
	|.else
	||	if (op2_type == IS_CONST) {
	|		FPU_LONG_LOAD op2_type, op2
	||	} else {
	|		FPU_GET_Z_LVAL Ra(op2_reg)+op2_offset
	||	}
	||	if (opline->opcode == ZEND_ADD || opline->opcode == ZEND_MUL || opline->opcode == ZEND_ASSIGN_ADD || opline->opcode == ZEND_ASSIGN_MUL) {
	||		if (op1_type == IS_CONST) {
	|			FPU_MATH opline->opcode, op1_type, op1
	||		} else {
	|			FPU_MATH2 opline->opcode, qword [Ra(op1_reg)+op1_offset]
	||		}
	||	} else {
	||		if (op1_type == IS_CONST) {
	|			FPU_LOAD op1_type, op1
	||		} else {
	|			FPU_GET_Z_DVAL Ra(op1_reg)+op1_offset
	||		}
	|		FPU_MATH2 opline->opcode, st1
	||	}
	|	FPU_STORE Ra(res_reg)+res_offset
	|.endif
	if (op1_type == IS_CONST || op1_reg != res_reg || op1_offset != res_offset) {
		|	SET_Z_TYPE_INFO Ra(res_reg)+res_offset, IS_DOUBLE
	}
	return 1;
}

static int zend_jit_math_double_double(dasm_State    **Dst,
                                       const zend_op  *opline,
                                       zend_uchar      op1_type,
                                       znode_op        op1,
                                       uint32_t        op1_reg,
                                       uint32_t        op1_offset,
                                       zend_uchar      op2_type,
                                       znode_op        op2,
                                       uint32_t        op2_reg,
                                       uint32_t        op2_offset,
                                       uint32_t        res_reg,
                                       uint32_t        res_offset)
{
	zend_bool same_ops = (op1_type == op2_type) && (op1.var == op2.var);

	|.if X64 or SSE
	zend_reg result_reg = ZREG_XMM0;

	if (op1_type == IS_CONST) {
		|	SSE_LOAD result_reg, op1_type, op1
	} else {
		|	SSE_GET_Z_DVAL result_reg, Ra(op1_reg)+op1_offset
	}
	if (same_ops) {
		|	SSE_MATH_REG opline->opcode, result_reg, result_reg
	} else if (op2_type == IS_CONST) {
		|	SSE_MATH_CONST opline->opcode, result_reg, op2
	} else {
		|	SSE_MATH opline->opcode, result_reg, qword [Ra(op2_reg)+op2_offset]
	}
	|	SSE_STORE Ra(res_reg)+res_offset, result_reg
	|.else
	if (op1_type == IS_CONST) {
		|	FPU_LOAD op1_type, op1
	} else {
		|	FPU_GET_Z_DVAL Ra(op1_reg)+op1_offset
	}
	if (op2_type == IS_CONST) {
		|	FPU_MATH opline->opcode, op2_type, op2
	} else {
		|	FPU_MATH2 opline->opcode, qword [Ra(op2_reg)+op2_offset]
	}
	|	FPU_STORE Ra(res_reg)+res_offset
	|.endif
	if (op1_type == IS_CONST || op1_reg != res_reg || op1_offset != res_offset) {
		|	SET_Z_TYPE_INFO Ra(res_reg)+res_offset, IS_DOUBLE
	}

	return 1;
}


static int zend_jit_shift(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	zval *op2;
	uint32_t op1_info;
	zend_bool has_slow;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();

	if ((op1_info & MAY_BE_UNDEF) ||
		opline->op2_type != IS_CONST ||
		Z_TYPE_P(RT_CONSTANT(op_array, opline->op2)) != IS_LONG ||
		Z_LVAL_P(RT_CONSTANT(op_array, opline->op2)) >= SIZEOF_ZEND_LONG * 8) {
		goto fallback;
	}

	has_slow = (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - MAY_BE_LONG)) != 0;

	op2 = RT_CONSTANT(op_array, opline->op2);

	if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
	|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_LONG, >9
	}
	|	LONG_LOAD r0, opline->op1_type, opline->op1
	if (opline->opcode == ZEND_SR) {
	|	shr, r0, Z_LVAL_P(op2)
	} else {
	|	shl, r0, Z_LVAL_P(op2)
	}
	|	SET_Z_LVAL FP + opline->result.var, r0
	|	SET_Z_TYPE_INFO FP + opline->result.var, IS_LONG

	if (has_slow) {
		|.cold_code
		|9:
		|   lea FCARG1a, aword [FP + opline->result.var]
		|   lea FCARG2a, aword [FP + opline->op1.var]
		|.if X64
		|   LOAD_ADDR CARG3, op2
		|.else
		|   push dword op2
		|.endif
		if (opline->opcode == ZEND_SR) {
		|   EXT_CALL shift_right_function, r0
		} else {
		|   EXT_CALL shift_left_function, r0
		}
		|   jmp >1
		|.code
		|1:
	}

	|	FREE_OP opline->op1_type, opline->op1, op1_info, 1, op_array, opline

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_math_helper(dasm_State    **Dst,
                                const zend_op  *opline,
                                zend_op_array  *op_array,
                                zend_ssa       *ssa,
                                zend_uchar      op1_type,
                                znode_op        op1,
                                uint32_t        op1_reg,
                                uint32_t        op1_offset,
                                uint32_t        op1_info,
                                zend_uchar      op2_type,
                                znode_op        op2,
                                uint32_t        op2_reg,
                                uint32_t        op2_offset,
                                uint32_t        op2_info,
                                uint32_t        res_reg,
                                uint32_t        res_offset,
                                uint32_t        res_info,
                                zend_bool       separate_op1)
/* Labels: 1,2,3,4,5,6 */
{
	zend_bool same_ops = (op1_type == op2_type) && (op1.var == op2.var);

	if ((op1_info & MAY_BE_LONG) && (op2_info & MAY_BE_LONG)) {
		if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
			if (op1_info & MAY_BE_DOUBLE) {
				|	IF_NOT_Z_TYPE Ra(op1_reg)+op1_offset, IS_LONG, >3
			} else {
				|	IF_NOT_Z_TYPE Ra(op1_reg)+op1_offset, IS_LONG, >6
			}
		}
		if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_LONG))) {
			if (op2_info & MAY_BE_DOUBLE) {
				|	IF_NOT_Z_TYPE Ra(op2_reg)+op2_offset, IS_LONG, >1
				|.cold_code
				|1:
				if (op2_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
					|	IF_NOT_Z_TYPE Ra(op2_reg)+op2_offset, IS_DOUBLE, >6
				}
				if (!zend_jit_math_long_double(Dst, opline, op1_type, op1, op1_reg, op1_offset, op2_type, op2, op2_reg, op2_offset, res_reg, res_offset)) {
					return 0;
				}
				|	jmp >5
				|.code
			} else {
				|	IF_NOT_Z_TYPE Ra(op2_reg)+op2_offset, IS_LONG, >6
			}
		}
		if (!zend_jit_math_long_long(Dst, opline, op_array, ssa, op1_type, op1, op1_reg, op1_offset, op2_type, op2, op2_reg, op2_offset, res_reg, res_offset, res_info)) {
			return 0;
		}
		if (op1_info & MAY_BE_DOUBLE) {
			|.cold_code
			|3:
			if (op1_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
				|	IF_NOT_Z_TYPE Ra(op1_reg)+op1_offset, IS_DOUBLE, >6
			}
			if (op2_info & MAY_BE_DOUBLE) {
				if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
					if (!same_ops) {
						|	IF_NOT_Z_TYPE, Ra(op2_reg)+op2_offset, IS_DOUBLE, >1
					} else {
						|	IF_NOT_Z_TYPE, Ra(op2_reg)+op2_offset, IS_DOUBLE, >6
					}
				}
				if (!zend_jit_math_double_double(Dst, opline, op1_type, op1, op1_reg, op1_offset, op2_type, op2, op2_reg, op2_offset, res_reg, res_offset)) {
					return 0;
				}
				|	jmp >5
			}
			if (!same_ops) {
				|1:
				if (op2_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
					|	IF_NOT_Z_TYPE Ra(op2_reg)+op2_offset, IS_LONG, >6
				}
				if (!zend_jit_math_double_long(Dst, opline, op1_type, op1, op1_reg, op1_offset, op2_type, op2, op2_reg, op2_offset, res_reg, res_offset)) {
					return 0;
				}
				|	jmp >5
			}
			|.code
		}
	} else if ((op1_info & MAY_BE_DOUBLE) &&
	           !(op1_info & MAY_BE_LONG) &&
	           (op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		if (op1_info & (MAY_BE_ANY-MAY_BE_DOUBLE)) {
			|	IF_NOT_Z_TYPE Ra(op1_reg)+op1_offset, IS_DOUBLE, >6
		}
		if (op2_info & MAY_BE_DOUBLE) {
			if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
				if (!same_ops && (op2_info & MAY_BE_LONG)) {
					|	IF_NOT_Z_TYPE Ra(op2_reg)+op2_offset, IS_DOUBLE, >1
				} else {
					|	IF_NOT_Z_TYPE Ra(op2_reg)+op2_offset, IS_DOUBLE, >6
				}
			}
			if (!zend_jit_math_double_double(Dst, opline, op1_type, op1, op1_reg, op1_offset, op2_type, op2, op2_reg, op2_offset, res_reg, res_offset)) {
				return 0;
			}
		}
		if (!same_ops && (op2_info & MAY_BE_LONG)) {
			if (op2_info & MAY_BE_DOUBLE) {
				|.cold_code
			}
		    |1:
			if (op2_info & (MAY_BE_ANY-(MAY_BE_DOUBLE|MAY_BE_LONG))) {
				|	IF_NOT_Z_TYPE Ra(op2_reg)+op2_offset, IS_LONG, >5
			}
			if (!zend_jit_math_double_long(Dst, opline, op1_type, op1, op1_reg, op1_offset, op2_type, op2, op2_reg, op2_offset, res_reg, res_offset)) {
				return 0;
			}
			if (op2_info & MAY_BE_DOUBLE) {
				|	jmp >5
				|.code
			}
		}
	} else if ((op2_info & MAY_BE_DOUBLE) &&
	           !(op2_info & MAY_BE_LONG) &&
	           (op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		if (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE)) {
			|	IF_NOT_Z_TYPE Ra(op2_reg)+op2_offset, IS_DOUBLE, >6
		}
		if (op1_info & MAY_BE_DOUBLE) {
			if (!same_ops && (op1_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
				if (!same_ops && (op1_info & MAY_BE_LONG)) {
					|	IF_NOT_Z_TYPE Ra(op1_reg)+op1_offset, IS_DOUBLE, >1
				} else {
					|	IF_NOT_Z_TYPE Ra(op1_reg)+op1_offset, IS_DOUBLE, >6
				}
			}
			if (!zend_jit_math_double_double(Dst, opline, op1_type, op1, op1_reg, op1_offset, op2_type, op2, op2_reg, op2_offset, res_reg, res_offset)) {
				return 0;
			}
		}
		if (!same_ops && (op1_info & MAY_BE_LONG)) {
			if (op1_info & MAY_BE_DOUBLE) {
				|.cold_code
			}
			|1:
			if (op1_info & (MAY_BE_ANY-(MAY_BE_DOUBLE|MAY_BE_LONG))) {
				|	IF_NOT_Z_TYPE Ra(op1_reg)+op1_offset, IS_LONG, >6
			}
			if (!zend_jit_math_long_double(Dst, opline, op1_type, op1, op1_reg, op1_offset, op2_type, op2, op2_reg, op2_offset, res_reg, res_offset)) {
				return 0;
			}
			if (op1_info & MAY_BE_DOUBLE) {
				|	jmp >5
				|.code
			}
		}
	}

	|5:

	if ((op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_LONG|MAY_BE_DOUBLE))) ||
		(op2_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_LONG|MAY_BE_DOUBLE)))) {
		if ((op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE)) &&
		    (op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
			|.cold_code
		}
		|6:
		|	SAVE_VALID_OPLINE opline
		if (separate_op1) {
			if (op1_reg != ZREG_FCARG1a || op1_offset != 0) {
				|	SEPARATE_ZVAL_NOREF Ra(op1_reg)+op1_offset, op1_info, 0, op_array->filename, opline->lineno
			} else {
				|	SEPARATE_ZVAL_NOREF_REG op1_info, 0, op_array->filename, opline->lineno
			}
		}
		if (res_reg != ZREG_FCARG1a || res_offset != 0) {
			|	lea	FCARG1a, [Ra(res_reg)+res_offset]
		}
		if (op1_type == IS_CONST) {
			|	LOAD_ZVAL_ADDR FCARG2a, op1_type, op1
		} else {
			|	lea FCARG2a, [Ra(op1_reg)+op1_offset]
		}
		if (op2_type == IS_CONST) {
			|.if X64
			|	LOAD_ZVAL_ADDR CARG3, op2_type, op2
			|.else
			|	PUSH_ZVAL_ADDR op2_type, op2, r0
			|.endif
		} else {
			|.if X64
			|	lea CARG3, [Ra(op2_reg)+op2_offset]
			|.else
			|	lea r0, [Ra(op2_reg)+op2_offset]
			|	push r0
			|.endif
		}
		||	if (opline->opcode == ZEND_ADD || opline->opcode == ZEND_ASSIGN_ADD) {
		|		EXT_CALL add_function, r0
		||	} else if (opline->opcode == ZEND_SUB || opline->opcode == ZEND_ASSIGN_SUB) {
		|		EXT_CALL sub_function, r0
		||	} else if (opline->opcode == ZEND_MUL || opline->opcode == ZEND_ASSIGN_MUL) {
		|		EXT_CALL mul_function, r0
		||	} else if (opline->opcode == ZEND_DIV || opline->opcode == ZEND_ASSIGN_DIV) {
		|		EXT_CALL div_function, r0
		||	} else {
		||		ZEND_ASSERT(0);
		||	}
		|	FREE_OP op1_type, op1, op1_info, 0, op_array, opline
		|	FREE_OP op2_type, op2, op2_info, 0, op_array, opline
		||	if (zend_may_throw(opline, op_array, ssa)) {
		||		zend_jit_check_exception(Dst);
		||	}
		if ((op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE)) &&
		    (op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
			|	jmp <5
			|.code
		}
	}

	return 1;
}

static int zend_jit_math(dasm_State **Dst, const zend_op *opline, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if ((op1_info & MAY_BE_UNDEF) || (op2_info & MAY_BE_UNDEF)) {
		goto fallback;
	}

	if (!(op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE)) ||
	    !(op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		goto fallback;
	}

	if (opline->result_type == IS_TMP_VAR &&
	    (opline+1)->opcode == ZEND_SEND_VAL &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		/* Eliminate the following SEND_VAL */
		(*opnum)++;
		if (!reuse_ip) {
			zend_jit_start_reuse_ip();
			|	// call = EX(call);
			|	mov RX, EX->call
		}
		return zend_jit_math_helper(Dst, opline, op_array, ssa, opline->op1_type, opline->op1, ZREG_FP, opline->op1.var, op1_info, opline->op2_type, opline->op2, ZREG_FP, opline->op2.var, op2_info, ZREG_RX, (opline+1)->result.var, RES_INFO(), 0);
	} else {
		return zend_jit_math_helper(Dst, opline, op_array, ssa, opline->op1_type, opline->op1, ZREG_FP, opline->op1.var, op1_info, opline->op2_type, opline->op2, ZREG_FP, opline->op2.var, op2_info, ZREG_FP, opline->result.var, RES_INFO(), 0);
	}

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_concat_helper(dasm_State    **Dst,
                                  const zend_op  *opline,
                                  zend_op_array  *op_array,
                                  zend_ssa       *ssa,
                                  zend_uchar      op1_type,
                                  znode_op        op1,
                                  uint32_t        op1_reg,
                                  uint32_t        op1_offset,
                                  uint32_t        op1_info,
                                  zend_uchar      op2_type,
                                  znode_op        op2,
                                  uint32_t        op2_reg,
                                  uint32_t        op2_offset,
                                  uint32_t        op2_info,
                                  uint32_t        res_reg,
                                  uint32_t        res_offset,
                                  uint32_t        res_info)
{
#if 1
	if ((op1_info & MAY_BE_STRING) && (op2_info & MAY_BE_STRING)) {
		if (op1_info & ((MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF) - MAY_BE_STRING)) {
			|	IF_NOT_Z_TYPE Ra(op1_reg)+op1_offset, IS_STRING, >6
		}
		if (op2_info & ((MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF) - MAY_BE_STRING)) {
			|	IF_NOT_Z_TYPE Ra(op2_reg)+op2_offset, IS_STRING, >6
		}
		if (op1_type != IS_CONST && op1_reg == res_reg && op1_offset == res_offset) {
			if (res_reg != ZREG_FCARG1a || res_offset != 0) {
				|	lea	FCARG1a, [Ra(res_reg)+res_offset]
			}
			if (op2_type == IS_CONST) {
				|	LOAD_ZVAL_ADDR FCARG2a, op2_type, op2
			} else {
				|	lea FCARG2a, [Ra(op2_reg)+op2_offset]
			}
			|	EXT_CALL zend_jit_fast_assign_concat_helper, r0
		} else {
			if (res_reg != ZREG_FCARG1a || res_offset != 0) {
				|	lea	FCARG1a, [Ra(res_reg)+res_offset]
			}
			if (op1_type == IS_CONST) {
				|	LOAD_ZVAL_ADDR FCARG2a, op1_type, op1
			} else {
				|	lea FCARG2a, [Ra(op1_reg)+op1_offset]
			}
			if (op2_type == IS_CONST) {
				|.if X64
				|	LOAD_ZVAL_ADDR CARG3, op2_type, op2
				|.else
				|	PUSH_ZVAL_ADDR op2_type, op2, r0
				|.endif
			} else {
				|.if X64
				|	lea CARG3, [Ra(op2_reg)+op2_offset]
				|.else
				|	lea r0, [Ra(op2_reg)+op2_offset]
				|	push r0
				|.endif
			}
			|	EXT_CALL zend_jit_fast_concat_helper, r0
		}
		|	FREE_OP op1_type, op1, op1_info, 0, op_array, opline
		|	FREE_OP op2_type, op2, op2_info, 0, op_array, opline
		|5:
	}
	if ((op1_info & ((MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF) - MAY_BE_STRING)) ||
	    (op2_info & ((MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF) - MAY_BE_STRING))) {
		if ((op1_info & MAY_BE_STRING) && (op2_info & MAY_BE_STRING)) {
			|.cold_code
			|6:
		}
#endif
		|	SAVE_VALID_OPLINE opline
		if (res_reg != ZREG_FCARG1a || res_offset != 0) {
			|	lea	FCARG1a, [Ra(res_reg)+res_offset]
		}
		if (op1_type == IS_CONST) {
			|	LOAD_ZVAL_ADDR FCARG2a, op1_type, op1
		} else {
			|	lea FCARG2a, [Ra(op1_reg)+op1_offset]
		}
		if (op2_type == IS_CONST) {
			|.if X64
			|	LOAD_ZVAL_ADDR CARG3, op2_type, op2
			|.else
			|	PUSH_ZVAL_ADDR op2_type, op2, r0
			|.endif
		} else {
			|.if X64
			|	lea CARG3, [Ra(op2_reg)+op2_offset]
			|.else
			|	lea r0, [Ra(op2_reg)+op2_offset]
			|	push r0
			|.endif
		}
		|	EXT_CALL concat_function, r0
		|	FREE_OP op1_type, op1, op1_info, 0, op_array, opline
		|	FREE_OP op2_type, op2, op2_info, 0, op_array, opline
		||	if (zend_may_throw(opline, op_array, ssa)) {
		||		zend_jit_check_exception(Dst);
		||	}
#if 1
		if ((op1_info & MAY_BE_STRING) && (op2_info & MAY_BE_STRING)) {
			|	jmp <5
			|.code
		}
	}
#endif

	return 1;
}

static int zend_jit_concat(dasm_State **Dst, const zend_op *opline, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if ((op1_info & MAY_BE_UNDEF) || (op2_info & MAY_BE_UNDEF)) {
		goto fallback;
	}

	if (!(op1_info & MAY_BE_STRING) ||
	    !(op2_info & MAY_BE_STRING)) {
		goto fallback;
	}

	if (opline->result_type == IS_TMP_VAR &&
	    (opline+1)->opcode == ZEND_SEND_VAL &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		/* Eliminate the following SEND_VAL */
		(*opnum)++;
		if (!reuse_ip) {
			zend_jit_start_reuse_ip();
			|	// call = EX(call);
			|	mov RX, EX->call
		}
		return zend_jit_concat_helper(Dst, opline, op_array, ssa, opline->op1_type, opline->op1, ZREG_FP, opline->op1.var, op1_info, opline->op2_type, opline->op2, ZREG_FP, opline->op2.var, op2_info, ZREG_RX, (opline+1)->result.var, RES_INFO());
	} else {
		return zend_jit_concat_helper(Dst, opline, op_array, ssa, opline->op1_type, opline->op1, ZREG_FP, opline->op1.var, op1_info, opline->op2_type, opline->op2, ZREG_FP, opline->op2.var, op2_info, ZREG_FP, opline->result.var, RES_INFO());
	}

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_fetch_dimension_address_inner(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, uint32_t type, uint32_t op1_info, uint32_t op2_info, uint32_t found, uint32_t not_found)
/* Labels: 1,2,3,4,5 */
{
	if (op2_info & MAY_BE_LONG) {
		if (op2_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - MAY_BE_LONG)) {
			|	// if (EXPECTED(Z_TYPE_P(dim) == IS_LONG))
			|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_LONG, >3
		}
		|	// hval = Z_LVAL_P(dim);
		|	LONG_LOAD FCARG2a, opline->op2_type, opline->op2
		if (op1_info & MAY_BE_ARRAY_KEY_LONG) {
			if (opline->op2_type == IS_CONST) {
				zend_long val = Z_LVAL_P(RT_CONSTANT(op_array, opline->op2));
				if (val >= 0 && val < HT_MAX_SIZE) {
					|	// ZEND_HASH_INDEX_FIND(ht, hval, retval, num_undef);
					|	test dword [FCARG1a + offsetof(zend_array, u.flags)], HASH_FLAG_PACKED
					|	jz >4 // HASH_FIND
					|	// if (EXPECTED((zend_ulong)(_h) < (zend_ulong)(_ht)->nNumUsed))
					|.if X64
					|	movsxd r0, dword [FCARG1a + offsetof(zend_array, nNumUsed)]
					|	cmp r0, val
					|.else
					|	cmp dword [FCARG1a + offsetof(zend_array, nNumUsed)], val
					|.endif
					if (type == BP_JIT_IS) {
						|	jbe >9 // NOT_FOUND
					} else {
						|	jbe >2 // NOT_FOUND
					}
					|	// _ret = &_ht->arData[_h].val;
					|	mov r0, aword [FCARG1a + offsetof(zend_array, arData)]
					|	add r0, val * sizeof(Bucket)
					if (type == BP_JIT_IS) {
						|	jmp >5
					} else {
						|	IF_NOT_Z_TYPE r0, IS_UNDEF, >8
					}
				}
			} else {
				|	// ZEND_HASH_INDEX_FIND(ht, hval, retval, num_undef);
				|	test dword [FCARG1a + offsetof(zend_array, u.flags)], HASH_FLAG_PACKED
				|	jz >4 // HASH_FIND
				|	// if (EXPECTED((zend_ulong)(_h) < (zend_ulong)(_ht)->nNumUsed))
				|.if X64
				|	movsxd r0, dword [FCARG1a + offsetof(zend_array, nNumUsed)]
				|	cmp r0, FCARG2a
				|.else
				|	cmp dword [FCARG1a + offsetof(zend_array, nNumUsed)], FCARG2a
				|.endif
				if (type == BP_JIT_IS) {
					|	jbe >9 // NOT_FOUND
				} else {
					|	jbe >2 // NOT_FOUND
				}
				|	// _ret = &_ht->arData[_h].val;
				|.if X64
				|	mov r0, FCARG2a
				|	shl r0, 5
				|.else
				|	imul r0, FCARG2a, sizeof(Bucket)
				|.endif
				|	add r0, aword [FCARG1a + offsetof(zend_array, arData)]
				if (type == BP_JIT_IS) {
					|	jmp >5
				} else {
					|	IF_NOT_Z_TYPE r0, IS_UNDEF, >8
				}
			}
		}
		switch (type) {
			case BP_JIT_IS:
				if (op1_info & MAY_BE_ARRAY_KEY_LONG) {
					|4:
				}
				|	EXT_CALL zend_hash_index_find, r0
				|	test r0, r0
				|	jz >9 // NOT_FOUND
				if (op2_info & MAY_BE_STRING) {
					|	jmp >5
				}
				break;
			case BP_VAR_R:
			case BP_VAR_IS:
			case BP_VAR_UNSET:
				if (op1_info & MAY_BE_ARRAY_KEY_LONG) {
					if (opline->op2_type == IS_CONST) {
						zend_long val = Z_LVAL_P(RT_CONSTANT(op_array, opline->op2));
						if (val >= 0 && val < HT_MAX_SIZE) {
							|	jmp >2 // NOT_FOUND
						}
					} else {
						|	jmp >2 // NOT_FOUND
					}
					|4:
				}
				|	EXT_CALL zend_hash_index_find, r0
				|	test r0, r0
				|	jz >2 // NOT_FOUND
				|.cold_code
				|2:
				switch (type) {
					case BP_VAR_R:
						|	// zend_error(E_NOTICE,"Undefined offset: " ZEND_LONG_FMT, hval);
						|	// retval = &EG(uninitialized_zval);
						|	UNDEFINED_OFFSET opline
						|	jmp >9
						break;
					case BP_VAR_IS:
					case BP_VAR_UNSET:
						|	// retval = &EG(uninitialized_zval);
						|	SET_Z_TYPE_INFO FP + opline->result.var, IS_NULL
						|	jmp >9
						break;
					default:
						ZEND_ASSERT(0);
				}
				|.code
				break;
			case BP_VAR_RW:
				|2:
				|	SAVE_VALID_OPLINE opline
				|	// zend_error(E_NOTICE,"Undefined offset: " ZEND_LONG_FMT, hval);
				|	//retval = zend_hash_index_update(ht, hval, &EG(uninitialized_zval));
				|	EXT_CALL zend_jit_fetch_dimension_rw_long_helper, r0
				if (op1_info & MAY_BE_ARRAY_KEY_LONG) {
					|	jmp >8
					|4:
					|	SAVE_VALID_OPLINE opline
					|	EXT_CALL zend_jit_hash_index_lookup_rw, r0
				}
				break;
			case BP_VAR_W:
				|2:
				|	//retval = zend_hash_index_add_new(ht, hval, &EG(uninitialized_zval));
				||	if (ZEND_DEBUG) {
				||		const char *filename = op_array->filename ? op_array->filename->val : NULL;
				|.if X64
				|		LOAD_ADDR CARG4, filename
				|		mov CARG5d, opline->lineno
				|.else
				|		push opline->lineno
				|		push filename
				|.endif
				||	}
				|.if X64
				|		LOAD_ADDR CARG3, &EG(uninitialized_zval)
				|.else
				|		PUSH_ADDR &EG(uninitialized_zval), r0
				|.endif
				|	EXT_CALL _zend_hash_index_add_new, r0
				if (op1_info & MAY_BE_ARRAY_KEY_LONG) {
					|	jmp >8
					|4:
					|	EXT_CALL zend_jit_hash_index_lookup_w, r0
				}
				break;
			default:
				ZEND_ASSERT(0);
		}

		if (type != BP_JIT_IS && (op2_info & MAY_BE_STRING)) {
			|	jmp >8
		}
	}

	if (op2_info & MAY_BE_STRING) {
		|3:
		if (op2_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - (MAY_BE_LONG|MAY_BE_STRING))) {
			|	// if (EXPECTED(Z_TYPE_P(dim) == IS_STRING))
			|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_STRING, >3
		}
		|	// offset_key = Z_STR_P(dim);
		|	LONG_LOAD FCARG2a, opline->op2_type, opline->op2
		|	// retval = zend_hash_find(ht, offset_key);
		switch (type) {
			case BP_JIT_IS:
				if (opline->op2_type != IS_CONST) {
					|	cmp byte [FCARG2a + offsetof(zend_string, val)], '9'
					|	jle >1
					|.cold_code
					|1:
					|	EXT_CALL zend_jit_symtable_find, r0
					|	jmp >1
					|.code
					|	EXT_CALL zend_hash_find, r0
					|1:
				} else {
					|	EXT_CALL zend_hash_find, r0
				}
				|	test r0, r0
				|	jz >9 // NOT_FOUND
				|	// if (UNEXPECTED(Z_TYPE_P(retval) == IS_INDIRECT))
				|	IF_NOT_Z_TYPE r0, IS_INDIRECT, >1
				|	GET_Z_PTR r0, r0
				|1:
				break;
			case BP_VAR_R:
			case BP_VAR_IS:
			case BP_VAR_UNSET:
				if (opline->op2_type != IS_CONST) {
					|	cmp byte [FCARG2a + offsetof(zend_string, val)], '9'
					|	jle >1
					|.cold_code
					|1:
					|	EXT_CALL zend_jit_symtable_find, r0
					|	jmp >1
					|.code
					|	EXT_CALL zend_hash_find, r0
					|1:
				} else {
					|	EXT_CALL zend_hash_find, r0
				}
				|	test r0, r0
				|	jz >2 // NOT_FOUND
				|	// if (UNEXPECTED(Z_TYPE_P(retval) == IS_INDIRECT))
				|	IF_Z_TYPE r0, IS_INDIRECT, >1 // SLOW
				|.cold_code
				|1:
				|	//	retval = Z_INDIRECT_P(retval);
				|	GET_Z_PTR r0, r0
				|	IF_NOT_Z_TYPE r0, IS_UNDEF, >8
				|2:
				switch (type) {
					case BP_VAR_R:
						//	zend_error(E_NOTICE, "Undefined index: %s", ZSTR_VAL(offset_key));
						|	UNDEFINED_INDEX opline
						|	jmp >9
						break;
					case BP_VAR_IS:
					case BP_VAR_UNSET:
						|	// retval = &EG(uninitialized_zval);
						|	SET_Z_TYPE_INFO FP + opline->result.var, IS_NULL
						|	jmp >9
						break;
					default:
						ZEND_ASSERT(0);
				}
				|.code
				break;
			case BP_VAR_RW:
				|	SAVE_VALID_OPLINE opline
				if (opline->op2_type != IS_CONST) {
					|	EXT_CALL zend_jit_symtable_lookup_rw, r0
				} else {
					|	EXT_CALL zend_jit_hash_lookup_rw, r0
				}
				break;
			case BP_VAR_W:
				if (opline->op2_type != IS_CONST) {
					|	EXT_CALL zend_jit_symtable_lookup_w, r0
				} else {
					|	EXT_CALL zend_jit_hash_lookup_w, r0
				}
				break;
			default:
				ZEND_ASSERT(0);
		}
	}

	if (type == BP_JIT_IS && (op2_info & (MAY_BE_LONG|MAY_BE_STRING))) {
	    |5:
		if (op1_info & MAY_BE_ARRAY_OF_REF) {
			|	ZVAL_DEREF r0, MAY_BE_REF
		}
		|	cmp byte [r0 + 8], IS_NULL
		|	jle >9 // NOT FOUND
	}

	if (op2_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - (MAY_BE_LONG|MAY_BE_STRING))) {
		if (op2_info & (MAY_BE_LONG|MAY_BE_STRING)) {
			|.cold_code
			|3:
		}
		|	SAVE_VALID_OPLINE opline
		|	LOAD_ZVAL_ADDR FCARG2a, opline->op2_type, opline->op2
		switch (type) {
			case BP_VAR_R:
				|.if X64
				|   lea CARG3, [FP + opline->result.var]
				|.else
				|   lea r0, [FP + opline->result.var]
				|	push r0
				|.endif
				|	EXT_CALL zend_jit_fetch_dim_r_helper, r0
				|	jmp >9
				break;
			case BP_JIT_IS:
				|	EXT_CALL zend_jit_fetch_dim_isset_helper, r0
				|	test r0, r0
				|	jne >8
				|	jmp >9
				break;
			case BP_VAR_IS:
			case BP_VAR_UNSET:
				|.if X64
				|   lea CARG3, [FP + opline->result.var]
				|.else
				|   lea r0, [FP + opline->result.var]
				|	push r0
				|.endif
				|	EXT_CALL zend_jit_fetch_dim_is_helper, r0
				|	jmp >9
				break;
			case BP_VAR_RW:
				|	EXT_CALL zend_jit_fetch_dim_rw_helper, r0
				|	test r0, r0
				|	jne >8
				|	jmp >9
				break;
			case BP_VAR_W:
				|	EXT_CALL zend_jit_fetch_dim_w_helper, r0
				|	test r0, r0
				|	jne >8
				|	jmp >9
				break;
			default:
				ZEND_ASSERT(0);
		}
		if (op2_info & (MAY_BE_LONG|MAY_BE_STRING)) {
			|.code
		}
	}

	return 1;
}

static int zend_jit_simple_assign(dasm_State    **Dst,
                                  const zend_op  *opline,
                                  zend_op_array  *op_array,
                                  zend_ssa       *ssa,
                                  uint32_t        var_reg,
                                  uint32_t        var_offset,
                                  uint32_t        var_info,
                                  zend_uchar      val_type,
                                  znode_op        val,
                                  uint32_t        val_info,
                                  uint32_t        var2,
                                  int             in_cold)
/* Labels: 1,2,3 */
{
	ZEND_ASSERT(var_reg != ZREG_R0);
	if (val_type == IS_CONST) {
		zval *zv = RT_CONSTANT(op_array, val);
		if (var2 == (uint32_t)-1) {
			|	ZVAL_COPY_CONST Ra(var_reg)+var_offset, var_info, zv, r0
		} else {
			|	ZVAL_COPY_CONST_2 Ra(var_reg)+var_offset, FP + var2, var_info, zv, r0
		}
		if (Z_REFCOUNTED_P(zv)) {
			if (var2 == (uint32_t)-1) {
				|	ADDREF_CONST zv, r0
			} else {
				|	ADDREF_CONST_2 zv, r0
			}
		}
	} else {
		if (val_info & MAY_BE_UNDEF) {
			if (in_cold) {
				|	IF_NOT_Z_TYPE FP + val.var, IS_UNDEF, >2
			} else {
				|	IF_Z_TYPE FP + val.var, IS_UNDEF, >1
				|.cold_code
				|1:
			}
			|	// zend_error(E_NOTICE, "Undefined variable: %s", ZSTR_VAL(CV_DEF_OF(EX_VAR_TO_NUM(opline->op1.var))));
			if (var_reg != ZREG_FP) {
				|	mov aword [r4], Ra(var_reg) // save
			}
			|	SAVE_VALID_OPLINE opline
			|	mov FCARG1d, val.var
			|	EXT_CALL zend_jit_undefined_op_helper, r0
			if (var_reg != ZREG_FP) {
				|	mov Ra(var_reg), aword [r4] // restore
			}
			|	SET_Z_TYPE_INFO Ra(var_reg)+var_offset, IS_NULL
			if (var2 != (uint32_t)-1) {
				|	SET_Z_TYPE_INFO FP + var2, IS_NULL
			}
			|	jmp	>3
			if (in_cold) {
				|2:
			} else {
				|.code
			}
		}
		if (val_info & MAY_BE_REF) {
			if (val_type == IS_CV) {
				ZEND_ASSERT(var_reg != ZREG_R2);
				|	lea r2, [FP + val.var]
				|	ZVAL_DEREF r2, val_info
				if (var2 == (uint32_t)-1) {
					|	ZVAL_COPY_VALUE_clobber_src Ra(var_reg)+var_offset, r2, val_info, r2, edx, r0
				} else {
					|	ZVAL_COPY_VALUE_clobber_src_2 Ra(var_reg)+var_offset, FP + var2, r2, val_info, r2, edx, r0
				}
			} else {
				if (in_cold) {
					|	IF_NOT_Z_TYPE FP + val.var, IS_REFERENCE, >1
				} else {
					|	IF_Z_TYPE FP + val.var, IS_REFERENCE, >1
					|.cold_code
					|1:
				}
				|	// zend_refcounted *ref = Z_COUNTED_P(retval_ptr);
				|	GET_Z_PTR r2, FP + val.var
				|	GC_DELREF r2
				|	// ZVAL_COPY_VALUE(return_value, &ref->value);
				if (var2 == (uint32_t)-1) {
					|	ZVAL_COPY_VALUE_clobber_src Ra(var_reg)+var_offset, r2 + 8, val_info, r2, edx, r0
				} else {
					|	ZVAL_COPY_VALUE_clobber_src_2 Ra(var_reg)+var_offset, FP + var2, r2 + 8, val_info, r2, edx, r0
				}
				|	je >2
				|	IF_NOT_REFCOUNTED dh, >3
				if (var2 == (uint32_t)-1) {
					|	GC_ADDREF r0
				} else {
					|	add dword [r0], 2
				}
				|	jmp >3
				|2:
				if (var2 != (uint32_t)-1) {
					|	IF_NOT_REFCOUNTED dh, >2
					|	GC_ADDREF r0
					|2:
				}
				|	EFREE_24 aword [FP + val.var], op_array, opline
				|	jmp >3
				if (in_cold) {
					|1:
				} else {
					|.code
				}
				if (var2 == (uint32_t)-1) {
					|	ZVAL_COPY_VALUE Ra(var_reg)+var_offset, FP + val.var, val_info, r2, edx, r0
				} else {
					|	ZVAL_COPY_VALUE_2 Ra(var_reg)+var_offset, FP + var2, FP + val.var, val_info, r2, edx, r0
				}
			}
		} else {
			if (var2 == (uint32_t)-1) {
				|	ZVAL_COPY_VALUE Ra(var_reg)+var_offset, FP + val.var, val_info, r2, edx, r0
			} else {
				|	ZVAL_COPY_VALUE_2 Ra(var_reg)+var_offset, FP + var2, FP + val.var, val_info, r2, edx, r0
			}
		}
		if (val_type == IS_CV) {
			if (var2 == (uint32_t)-1) {
				|	TRY_ADDREF val_info, dh, r0
			} else {
				|	TRY_ADDREF_2 val_info, dh, r0
			}
		} else {
			if (var2 != (uint32_t)-1) {
				|	TRY_ADDREF val_info, dh, r0
			}
		}
		|3:
	}
	return 1;
}

static int zend_jit_assign_to_variable(dasm_State    **Dst,
                                       const zend_op  *opline,
                                       zend_op_array  *op_array,
                                       zend_ssa       *ssa,
                                       uint32_t        var_reg,
                                       uint32_t        var_offset,
                                       uint32_t        var_info,
                                       zend_uchar      val_type,
                                       znode_op        val,
                                       uint32_t        val_info,
                                       uint32_t        var2)
/* Labels: 1,2,3,4,5 */
{
	if (var_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE)) {
		int in_cold = 0;

		ZEND_ASSERT(var_reg != ZREG_R0);
		if (var_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
			|	IF_Z_REFCOUNTED Ra(var_reg)+var_offset, >1
			|.cold_code
			|1:
			in_cold = 1;
		}
		|	// TODO: support for object->set
		|	// TODO: support for assignment to itself
		|	GET_Z_PTR r0, Ra(var_reg)+var_offset
		|	GC_DELREF r0
		if (RC_MAY_BE_1(var_info)) {
			if (RC_MAY_BE_N(var_info)) {
				|	jnz >4
			}
			|	mov aword [r4], r0 // save
			if (!zend_jit_simple_assign(Dst, opline, op_array, ssa, var_reg, var_offset, var_info, val_type, val, val_info, var2, in_cold)) {
				return 0;
			}
			|	mov FCARG1a, aword [r4] // restore
			|	ZVAL_DTOR_FUNC var_info, op_array->filename, opline
			|	jmp >3
			|4:
		}
		if (RC_MAY_BE_N(var_info)) {
			if (var_reg == ZREG_FP) {
				|	GET_Z_PTR FCARG1a, Ra(var_reg)+var_offset
				|	IF_GC_MAY_NOT_LEAK FCARG1a, eax, >5
			} else if (var_reg != ZREG_FCARG1a) {
				|	GET_Z_PTR FCARG1a, Ra(var_reg)+var_offset
				|	IF_GC_MAY_NOT_LEAK FCARG1a, eax, >5
				|	mov [r4], Ra(var_reg) // save
			} else {
				|	GET_Z_PTR r0, Ra(var_reg)+var_offset
				|	IF_GC_MAY_NOT_LEAK r0, eax, >5
				|	mov [r4], Ra(var_reg) // save
				|	GET_Z_PTR FCARG1a, Ra(var_reg)+var_offset
			}
			|	EXT_CALL gc_possible_root, r0
			if (var_reg != ZREG_FP) {
				|	mov Ra(var_reg), [r4] // restore
			}
			if (in_cold) {
				|	jmp >5
				|.code
			}
	    } else if (in_cold) {
			|.code
	    }
		|5:
	}

	if (!zend_jit_simple_assign(Dst, opline, op_array, ssa, var_reg, var_offset, var_info, val_type, val, val_info, var2, 0)) {
		return 0;
	}
	|3:

	return 1;
}

static int zend_jit_assign_dim(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info, val_info;

	if (opline->op1_type != IS_CV) {
		goto fallback;
	}

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();
	val_info = OP1_DATA_INFO();

	if (op1_info & MAY_BE_REF) {
		|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		|	ZVAL_DEREF FCARG1a, op1_info
	}

	if (op1_info & MAY_BE_ARRAY) {
		if (op1_info & MAY_BE_REF) {
			|	IF_NOT_Z_TYPE FCARG1a, IS_ARRAY, >7
			|	SEPARATE_ARRAY_REG op1_info, 1, op_array->filename, opline->lineno
		} else {
			if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - MAY_BE_ARRAY)) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_ARRAY, >7
			}
			|	SEPARATE_ARRAY opline->op1_type, opline->op1, op1_info, 1, op_array->filename, opline->lineno
		}
	} else if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE)) {
		if (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY))) {
		    if (op1_info & MAY_BE_REF) {
				|	cmp byte [FCARG1a + 8], IS_FALSE
			} else {
				|	cmp byte [FP + opline->op1.var + 8], IS_FALSE
			}
			|	jg >7
		}
		|	// ZVAL_NEW_ARR(container);
		|	// zend_hash_init(Z_ARRVAL_P(container), 8, NULL, ZVAL_PTR_DTOR, 0);
		if (op1_info & MAY_BE_REF) {
			|	mov [r4], FCARG1a // save
		}
		||	if (ZEND_DEBUG) {
		||		const char *filename = op_array->filename ? op_array->filename->val : NULL;
		|.if X64
		|		LOAD_ADDR CARG3, filename
		|		xor CARG4d, opline->lineno
		|.else
		|		push opline->lineno
		|		push filename
		|.endif
		||	} else {
		|.if not X64
		|		sub r4, 8
		|.endif
		||	}
		|.if X64
		|	LOAD_ADDR CARG2, 8
		||	if (!(op1_info & MAY_BE_REF)) {
		|		LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		||	}
		|.else
		|	push 8
		||	if (!(op1_info & MAY_BE_REF)) {
		|		LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		||	}
		|	push FCARG1a
		|.endif
		|	EXT_CALL _array_init, r0
		|.if not X64
		|	add r4, 16
		|.endif
		if (op1_info & MAY_BE_REF) {
			|	mov FCARG1a, [r4] // restore
			|	GET_Z_PTR FCARG1a, FCARG1a
		} else {
			|	LONG_LOAD FCARG1a, opline->op1_type, opline->op1
		}
	}

	if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY)) {
		|6:
		if (opline->op2_type == IS_UNUSED) {
			|	// var_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(container), &EG(uninitialized_zval));
			|	LOAD_ADDR FCARG2a, &EG(uninitialized_zval)
			||	if (ZEND_DEBUG) {
			||		const char *filename = op_array->filename ? op_array->filename->val : NULL;
			|.if X64
			|		LOAD_ADDR CARG3, filename
			|		mov CARG4d, opline->lineno
			|.else
			|		push opline->lineno
			|		push filename
			|.endif
			||	}
			|	EXT_CALL _zend_hash_next_index_insert, r0
			|	// if (UNEXPECTED(!var_ptr)) {
			|	test r0, r0
			|	jz >1
			|.cold_code
			|1:
			|	// zend_error(E_WARNING, "Cannot add element to the array as the next element is already occupied");
			|	CANNOT_ADD_ELEMENT opline
			|	//ZEND_VM_C_GOTO(assign_dim_op_ret_null);
			|	jmp >9
			|.code
			|	mov FCARG1a, r0
		} else {
			if (!zend_jit_fetch_dimension_address_inner(Dst, opline, op_array, BP_VAR_W, op1_info, op2_info, 8, 8)) {
				return 0;
			}

			|8:
			|	mov FCARG1a, r0
		}

		if (opline->op2_type == IS_UNUSED) {
			uint32_t var_info = zend_array_element_type(op1_info, 0, 0);

			if (!zend_jit_simple_assign(Dst, opline, op_array, ssa, ZREG_FCARG1a, 0, var_info, (opline+1)->op1_type, (opline+1)->op1, val_info,
				opline->result_type == IS_UNUSED ? -1 : opline->result.var, 0)) {
				return 0;
			}
		} else {
			uint32_t var_info = zend_array_element_type(op1_info, 0, 0);

			|	// value = zend_assign_to_variable(variable_ptr, value, OP_DATA_TYPE);
			|	ZVAL_DEREF FCARG1a, var_info
			if (!zend_jit_assign_to_variable(Dst, opline, op_array, ssa, ZREG_FCARG1a, 0, var_info, (opline+1)->op1_type, (opline+1)->op1, val_info,
					opline->result_type == IS_UNUSED ? -1 : opline->result.var)) {
				return 0;
			}
		}
	}

	if (((op1_info & MAY_BE_ARRAY) &&
	     (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE))) ||
	    (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY)))) {
		if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY)) {
			|.cold_code
			|7:
		}

		if ((op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE)) &&
		    (op1_info & MAY_BE_ARRAY)) {
			if (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY))) {
			    if (op1_info & MAY_BE_REF) {
					|	cmp byte [FCARG1a + 8], IS_FALSE
				} else {
					|	cmp byte [FP + opline->op1.var + 8], IS_FALSE
				}
				|	jg >2
			}
			|	// ZVAL_NEW_ARR(container);
			|	// zend_hash_init(Z_ARRVAL_P(container), 8, NULL, ZVAL_PTR_DTOR, 0);
			if (op1_info & MAY_BE_REF) {
				|	mov [r4], FCARG1a // save
			}
			||	if (ZEND_DEBUG) {
			||		const char *filename = op_array->filename ? op_array->filename->val : NULL;
			|.if X64
			|		LOAD_ADDR CARG3, filename
			|		xor CARG4d, opline->lineno
			|.else
			|		push opline->lineno
			|		push filename
			|.endif
			||	} else {
			|.if not X64
			|		sub r4, 8
			|.endif
			||	}
			|.if X64
			|	LOAD_ADDR CARG2, 8
			||	if (!(op1_info & MAY_BE_REF)) {
			|		LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
			||	}
			|.else
			|	push 8
			||	if (!(op1_info & MAY_BE_REF)) {
			|		LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
			||	}
			|	push FCARG1a
			|.endif
			|	EXT_CALL _array_init, r0
			|.if not X64
			|	add r4, 16
			|.endif
			if (op1_info & MAY_BE_REF) {
				|	mov FCARG1a, [r4] // restore
				|	GET_Z_PTR FCARG1a, FCARG1a
			} else {
				|	LONG_LOAD FCARG1a, opline->op1_type, opline->op1
			}
			|	// ZEND_VM_C_GOTO(assign_dim_op_new_array);
			|	jmp <6
			|2:
		}

		if (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY))) {
			|	SAVE_VALID_OPLINE opline
		    if (!(op1_info & MAY_BE_REF)) {
				|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
			}
		    if (opline->op2_type == IS_UNUSED) {
				|	xor FCARG2a, FCARG2a
			} else {
				|	LOAD_ZVAL_ADDR FCARG2a, opline->op2_type, opline->op2
			}
			if (opline->result_type == IS_UNUSED) {
				|.if X64
				|	xor CARG4, CARG4
				|.else
				|	push 0
				|.endif
			} else {
				|.if X64
				|	LOAD_ZVAL_ADDR CARG4, opline->result_type, opline->result
				|.else
				|	PUSH_ZVAL_ADDR opline->result_type, opline->result, r0
				|.endif
			}
			|.if X64
			|	LOAD_ZVAL_ADDR CARG3, (opline+1)->op1_type, (opline+1)->op1
			|.else
			|	PUSH_ZVAL_ADDR (opline+1)->op1_type, (opline+1)->op1, r0
			|.endif
			|	EXT_CALL zend_jit_assign_dim_helper, r0

#ifdef ZEND_JIT_USE_RC_INFERENCE
			if (((opline+1)->op1_type & (IS_TMP_VAR|IS_VAR)) && (val_info & MAY_BE_RC1)) {
				/* ASSIGN_DIM may increase refcount of the value */
				val_info |= MAY_BE_RCN;
			}
#endif

			|	FREE_OP (opline+1)->op1_type, (opline+1)->op1, val_info, 0, op_array, opline
		}

		if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY)) {
			if (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY))) {
				|	jmp >9 // END
			}
			|.code
		}
	}

#ifdef ZEND_JIT_USE_RC_INFERENCE
	if ((opline->op2_type & (IS_TMP_VAR|IS_VAR)) && (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY|MAY_BE_OBJECT))) {
		/* ASSIGN_DIM may increase refcount of the key */
		op2_info |= MAY_BE_RCN;
	}
#endif

	|9:
	|	FREE_OP opline->op2_type, opline->op2, op2_info, 0, op_array, opline

	if (zend_may_throw(opline, op_array, ssa)) {
		zend_jit_check_exception(Dst);
	}

	return 1;

fallback:
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_assign_dim_op(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;

	if (opline->op1_type != IS_CV || opline->result_type != IS_UNUSED) {
		goto fallback;
	}

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if (op1_info & MAY_BE_REF) {
		|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		|	ZVAL_DEREF FCARG1a, op1_info
	}

	if (op1_info & MAY_BE_ARRAY) {
		if (op1_info & MAY_BE_REF) {
			|	IF_NOT_Z_TYPE FCARG1a, IS_ARRAY, >7
			|	SEPARATE_ARRAY_REG op1_info, 1, op_array->filename, opline->lineno
		} else {
			if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - MAY_BE_ARRAY)) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_ARRAY, >7
			}
			|	SEPARATE_ARRAY opline->op1_type, opline->op1, op1_info, 1, op_array->filename, opline->lineno
		}
	} else if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE)) {
		if (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY))) {
		    if (op1_info & MAY_BE_REF) {
				|	cmp byte [FCARG1a + 8], IS_FALSE
			} else {
				|	cmp byte [FP + opline->op1.var + 8], IS_FALSE
			}
			|	jg >7
		}
		if (op1_info & MAY_BE_UNDEF) {
			if (op1_info & (MAY_BE_NULL|MAY_BE_FALSE)) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_UNDEF, >1
			}
			|	SAVE_VALID_OPLINE opline
			|	mov FCARG1a, opline->op1.var
			|	EXT_CALL zend_jit_undefined_op_helper, r0
			|1:
		}
		|	// ZVAL_NEW_ARR(container);
		|	// zend_hash_init(Z_ARRVAL_P(container), 8, NULL, ZVAL_PTR_DTOR, 0);
		if (op1_info & MAY_BE_REF) {
			|	mov [r4], FCARG1a // save
		}
		||	if (ZEND_DEBUG) {
		||		const char *filename = op_array->filename ? op_array->filename->val : NULL;
		|.if X64
		|		LOAD_ADDR CARG3, filename
		|		xor CARG4d, opline->lineno
		|.else
		|		push opline->lineno
		|		push filename
		|.endif
		||	} else {
		|.if not X64
		|		sub r4, 8
		|.endif
		||	}
		|.if X64
		|	LOAD_ADDR CARG2, 8
		||	if (!(op1_info & MAY_BE_REF)) {
		|		LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		||	}
		|.else
		|	push 8
		||	if (!(op1_info & MAY_BE_REF)) {
		|		LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		||	}
		|	push FCARG1a
		|.endif
		|	EXT_CALL _array_init, r0
		|.if not X64
		|	add r4, 16
		|.endif
		if (op1_info & MAY_BE_REF) {
			|	mov FCARG1a, [r4] // restore
			|	GET_Z_PTR FCARG1a, FCARG1a
		} else {
			|	LONG_LOAD FCARG1a, opline->op1_type, opline->op1
		}
	}

	if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY)) {
		uint32_t var_info = zend_array_element_type(op1_info, 0, 0);

		|6:
		if (opline->op2_type == IS_UNUSED) {
			|	// var_ptr = zend_hash_next_index_insert(Z_ARRVAL_P(container), &EG(uninitialized_zval));
			|	LOAD_ADDR FCARG2a, &EG(uninitialized_zval)
			||	if (ZEND_DEBUG) {
			||		const char *filename = op_array->filename ? op_array->filename->val : NULL;
			|.if X64
			|		LOAD_ADDR CARG3, filename
			|		mov CARG4d, opline->lineno
			|.else
			|		push opline->lineno
			|		push filename
			|.endif
			||	}
			|	EXT_CALL _zend_hash_next_index_insert, r0
			|	// if (UNEXPECTED(!var_ptr)) {
			|	test r0, r0
			|	jz >1
			|.cold_code
			|1:
			|	// zend_error(E_WARNING, "Cannot add element to the array as the next element is already occupied");
			|	CANNOT_ADD_ELEMENT opline
			|	//ZEND_VM_C_GOTO(assign_dim_op_ret_null);
			|	jmp >9
			|.code
			|	mov FCARG1a, r0
		} else {
			if (!zend_jit_fetch_dimension_address_inner(Dst, opline, op_array, BP_VAR_RW, op1_info, op2_info, 8, 8)) {
				return 0;
			}

			|8:
			|	mov FCARG1a, r0
			if (op1_info & (MAY_BE_ARRAY_OF_REF)) {
				|	ZVAL_DEREF FCARG1a, MAY_BE_REF
			}
		}

		switch (opline->opcode) {
			case ZEND_ASSIGN_ADD:
			case ZEND_ASSIGN_SUB:
			case ZEND_ASSIGN_MUL:
			case ZEND_ASSIGN_DIV:
				if (!zend_jit_math_helper(Dst, opline, op_array, ssa, IS_CV, opline->op1, ZREG_FCARG1a, 0, var_info, (opline+1)->op1_type, (opline+1)->op1, ZREG_FP, (opline+1)->op1.var, OP1_DATA_INFO(), ZREG_FCARG1a, 0, OP1_DEF_INFO(), 1)) {
					return 0;
				}
				break;
			case ZEND_ASSIGN_CONCAT:
				if (!zend_jit_concat_helper(Dst, opline, op_array, ssa, IS_CV, opline->op1, ZREG_FCARG1a, 0, var_info, (opline+1)->op1_type, (opline+1)->op1, ZREG_FP, (opline+1)->op1.var, OP1_DATA_INFO(), ZREG_FCARG1a, 0, OP1_DEF_INFO())) {
					return 0;
				}
				break;
			default:
				ZEND_ASSERT(0);
		}
	}

	if (((op1_info & MAY_BE_ARRAY) &&
	     (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE))) ||
	    (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY)))) {
		if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY)) {
			|.cold_code
			|7:
		}

		if ((op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE)) &&
		    (op1_info & MAY_BE_ARRAY)) {
			if (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY))) {
				if (op1_info & (MAY_BE_NULL|MAY_BE_FALSE)) {
				    if (op1_info & MAY_BE_REF) {
						|	cmp byte [FCARG1a + 8], IS_FALSE
					} else {
						|	cmp byte [FP + opline->op1.var + 8], IS_FALSE
					}
					|	jg >2
				}
			}
			if (op1_info & MAY_BE_UNDEF) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_UNDEF, >1
				|	SAVE_VALID_OPLINE opline
				|	mov FCARG1a, opline->op1.var
				|	EXT_CALL zend_jit_undefined_op_helper, r0
				|1:
			}
			|	// ZVAL_NEW_ARR(container);
			|	// zend_hash_init(Z_ARRVAL_P(container), 8, NULL, ZVAL_PTR_DTOR, 0);
			if (op1_info & MAY_BE_REF) {
				|	mov [r4], FCARG1a // save
			}
			||	if (ZEND_DEBUG) {
			||		const char *filename = op_array->filename ? op_array->filename->val : NULL;
			|.if X64
			|		LOAD_ADDR CARG3, filename
			|		xor CARG4d, opline->lineno
			|.else
			|		push opline->lineno
			|		push filename
			|.endif
			||	} else {
			|.if not X64
			|		sub r4, 8
			|.endif
			||	}
			|.if X64
			|	LOAD_ADDR CARG2, 8
			||	if (!(op1_info & MAY_BE_REF)) {
			|		LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
			||	}
			|.else
			|	push 8
			||	if (!(op1_info & MAY_BE_REF)) {
			|		LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
			||	}
			|	push FCARG1a
			|.endif
			|	EXT_CALL _array_init, r0
			|.if not X64
			|	add r4, 16
			|.endif
			if (op1_info & MAY_BE_REF) {
				|	mov FCARG1a, [r4] // restore
				|	GET_Z_PTR FCARG1a, FCARG1a
			} else {
				|	LONG_LOAD FCARG1a, opline->op1_type, opline->op1
			}
			|	// ZEND_VM_C_GOTO(assign_dim_op_new_array);
			|	jmp <6
			|2:
		}

		if (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY))) {
			|	SAVE_VALID_OPLINE opline
		    if (!(op1_info & MAY_BE_REF)) {
				|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
			}
		    if (opline->op2_type == IS_UNUSED) {
				|	xor FCARG2a, FCARG2a
			} else {
				|	LOAD_ZVAL_ADDR FCARG2a, opline->op2_type, opline->op2
			}
			|.if X64
			|	LOAD_ZVAL_ADDR CARG3, (opline+1)->op1_type, (opline+1)->op1
			|.else
			|	PUSH_ZVAL_ADDR (opline+1)->op1_type, (opline+1)->op1, r0
			|.endif
			switch (opline->opcode) {
				case ZEND_ASSIGN_ADD:
					|	EXT_CALL zend_jit_assign_dim_add_helper, r0
					break;
				case ZEND_ASSIGN_SUB:
					|	EXT_CALL zend_jit_assign_dim_sub_helper, r0
					break;
				case ZEND_ASSIGN_MUL:
					|	EXT_CALL zend_jit_assign_dim_mul_helper, r0
					break;
				case ZEND_ASSIGN_DIV:
					|	EXT_CALL zend_jit_assign_dim_div_helper, r0
					break;
				case ZEND_ASSIGN_CONCAT:
					|	EXT_CALL zend_jit_assign_dim_concat_helper, r0
					break;
				default:
					ZEND_ASSERT(0);
			}
		}

		if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY)) {
			if (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_ARRAY))) {
				|	jmp >9 // END
			}
			|.code
		}
	}

	|9:

	return 1;

fallback:
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_assign_op(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;

	if (opline->extended_value == ZEND_ASSIGN_DIM) {
		return zend_jit_assign_dim_op(Dst, opline, op_array, ssa);
	} else if (opline->extended_value == ZEND_ASSIGN_OBJ) {
		goto fallback;
	}

	if (opline->op1_type != IS_CV || opline->result_type != IS_UNUSED) {
		goto fallback;
	}

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if ((op1_info & MAY_BE_UNDEF) || (op2_info & MAY_BE_UNDEF)) {
		goto fallback;
	}

	switch (opline->opcode) {
		case ZEND_ASSIGN_ADD:
		case ZEND_ASSIGN_SUB:
		case ZEND_ASSIGN_MUL:
		case ZEND_ASSIGN_DIV:
			if (!(op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE)) ||
			    !(op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
				goto fallback;
			}
			break;
		case ZEND_ASSIGN_CONCAT:
			if (!(op1_info & MAY_BE_STRING) ||
			    !(op2_info & MAY_BE_STRING)) {
				goto fallback;
			}
			break;
		default:
			ZEND_ASSERT(0);
	}

	if (op1_info & MAY_BE_REF) {
		|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		|	ZVAL_DEREF FCARG1a, op1_info
		switch (opline->opcode) {
			case ZEND_ASSIGN_ADD:
			case ZEND_ASSIGN_SUB:
			case ZEND_ASSIGN_MUL:
			case ZEND_ASSIGN_DIV:
				return zend_jit_math_helper(Dst, opline, op_array, ssa, opline->op1_type, opline->op1, ZREG_FCARG1a, 0, op1_info, opline->op2_type, opline->op2, ZREG_FP, opline->op2.var, op2_info, ZREG_FCARG1a, 0, OP1_DEF_INFO(), 1);
			case ZEND_ASSIGN_CONCAT:
				return zend_jit_concat_helper(Dst, opline, op_array, ssa, opline->op1_type, opline->op1, ZREG_FCARG1a, 0, op1_info, opline->op2_type, opline->op2, ZREG_FP, opline->op2.var, op2_info, ZREG_FCARG1a, 0, OP1_DEF_INFO());
			default:
				ZEND_ASSERT(0);
		}
	} else {
		switch (opline->opcode) {
			case ZEND_ASSIGN_ADD:
			case ZEND_ASSIGN_SUB:
			case ZEND_ASSIGN_MUL:
			case ZEND_ASSIGN_DIV:
				return zend_jit_math_helper(Dst, opline, op_array, ssa, opline->op1_type, opline->op1, ZREG_FP, opline->op1.var, op1_info, opline->op2_type, opline->op2, ZREG_FP, opline->op2.var, op2_info, ZREG_FP, opline->op1.var, OP1_DEF_INFO(), 1);
			case ZEND_ASSIGN_CONCAT:
				return zend_jit_concat_helper(Dst, opline, op_array, ssa, opline->op1_type, opline->op1, ZREG_FP, opline->op1.var, op1_info, opline->op2_type, opline->op2, ZREG_FP, opline->op2.var, op2_info, ZREG_FP, opline->op1.var, OP1_DEF_INFO());
			default:
				ZEND_ASSERT(0);
		}
	}

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_cmp_long_long(dasm_State **Dst, const zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	unsigned int target_label;
	int swap = 0;

	if (opline->op1_type == IS_CONST && opline->op2_type != IS_CONST) {
		zend_long val = Z_LVAL_P(RT_CONSTANT(op_array, opline->op1));

		|   .if X64
		||  if (!IS_SIGNED_32BIT(val)) {
		|   	mov64 r0, val
		|   	cmp aword [FP + opline->op2.var], r0
		||  } else {
		|   	cmp aword [FP + opline->op2.var], val
		||  }
		|   .else
		|   	cmp aword [FP + opline->op2.var], val
		|   .endif
		swap = 1;
	} else if (opline->op2_type == IS_CONST && opline->op1_type != IS_CONST) {
		zend_long val = Z_LVAL_P(RT_CONSTANT(op_array, opline->op2));

		|   .if X64
		||  if (!IS_SIGNED_32BIT(val)) {
		|   	mov64 r0, val
		|   	cmp aword [FP + opline->op1.var], r0
		||  } else {
		|   	cmp aword [FP + opline->op1.var], val
		||  }
		|   .else
		|   	cmp aword [FP + opline->op1.var], val
		|   .endif
	} else {
		|	LONG_LOAD r0, opline->op1_type, opline->op1
		|	LONG_OP cmp, r0, opline->op2_type, opline->op2
	}
	if (((opline+1)->opcode == ZEND_JMPZ_EX ||
	     (opline+1)->opcode == ZEND_JMPNZ_EX) &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				|	sete al
				break;
			case ZEND_IS_NOT_EQUAL:
				|	setne al
				break;
			case ZEND_IS_SMALLER:
				if (swap) {
					|	setg al
				} else {
					|	setl al
				}
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				if (swap) {
					|	setge al
				} else {
					|	setle al
				}
				break;
			default:
				ZEND_ASSERT(0);
		}
		|	movzx eax, al
		|	lea eax, [eax + 2]
		|	SET_Z_TYPE_INFO FP + opline->result.var, eax
	}
	if (((opline+1)->opcode == ZEND_JMPZ ||
	     (opline+1)->opcode == ZEND_JMPZ_EX) &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| jne => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| je => target_label
				break;
			case ZEND_IS_SMALLER:
				if (swap) {
					| jle => target_label
				} else {
					| jge => target_label
				}
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				if (swap) {
					| jl => target_label
				} else {
					| jg => target_label
				}
				break;
			default:
				ZEND_ASSERT(0);
		}
	} else if (((opline+1)->opcode == ZEND_JMPNZ ||
	            (opline+1)->opcode == ZEND_JMPNZ_EX) &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| je => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| jne => target_label
				break;
			case ZEND_IS_SMALLER:
				if (swap) {
					| jg => target_label
				} else {
					| jl => target_label
				}
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				if (swap) {
					| jge => target_label
				} else {
					| jle => target_label
				}
				break;
			default:
				ZEND_ASSERT(0);
		}
	} else if ((opline+1)->opcode == ZEND_JMPZNZ &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| jne => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| je => target_label
				break;
			case ZEND_IS_SMALLER:
			    if (swap) {
					| jle => target_label
			    } else {
					| jge => target_label
				}
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				if (swap) {
					| jl => target_label
				} else {
					| jg => target_label
				}
				break;
			default:
				ZEND_ASSERT(0);
		}
		target_label = ssa->cfg.blocks[b].successors[1];
		| jmp => target_label
	} else {
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				|	sete al
				break;
			case ZEND_IS_NOT_EQUAL:
				|	setne al
				break;
			case ZEND_IS_SMALLER:
				if (swap) {
					|	setg al
				} else {
					|	setl al
				}
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				if (swap) {
					|	setge al
				} else {
					|	setle al
				}
				break;
			default:
				ZEND_ASSERT(0);
		}
		|	movzx eax, al
		|	add eax, 2
		|	SET_Z_TYPE_INFO FP + opline->result.var, eax
	}

	return 1;
}

static int zend_jit_cmp_double_common(dasm_State **Dst, const zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	unsigned int target_label;

	if ((opline+1)->opcode == ZEND_JMPZ &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| jp >1
				| jne => target_label
				|1:
				break;
			case ZEND_IS_NOT_EQUAL:
				| jp >1
				| je => target_label
				|1:
				break;
			case ZEND_IS_SMALLER:
				| jae => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| ja => target_label
				break;
			default:
				ZEND_ASSERT(0);
		}
	} else if ((opline+1)->opcode == ZEND_JMPNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| jp >1
				| je => target_label
				|1:
				break;
			case ZEND_IS_NOT_EQUAL:
				| jp >1
				| jne => target_label
				|1:
				break;
			case ZEND_IS_SMALLER:
				| jnae => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| jna => target_label
				break;
			default:
				ZEND_ASSERT(0);
		}
	} else if ((opline+1)->opcode == ZEND_JMPZNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| jp >1
				| jne => target_label
				|1:
				break;
			case ZEND_IS_NOT_EQUAL:
				| jp >1
				| je => target_label
				|1:
				break;
			case ZEND_IS_SMALLER:
				| jae => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| ja => target_label
				break;
			default:
				ZEND_ASSERT(0);
		}
		target_label = ssa->cfg.blocks[b].successors[1];
		| jmp => target_label
	} else if ((opline+1)->opcode == ZEND_JMPZ_EX &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				|	SET_Z_TYPE_INFO FP + opline->result.var, IS_FALSE
				|	jp >1
				|	jne => target_label
				|	SET_Z_TYPE_INFO FP + opline->result.var, IS_TRUE
				|1:
				break;
			case ZEND_IS_NOT_EQUAL:
				|	jp >1
				|	SET_Z_TYPE_INFO FP + opline->result.var, IS_TRUE
				|	je => target_label
				|1:
				|	SET_Z_TYPE_INFO FP + opline->result.var, IS_FALSE
				break;
			case ZEND_IS_SMALLER:
				|	setnae al
				|	movzx eax, al
				|	lea eax, [eax + 2]
				|	SET_Z_TYPE_INFO FP + opline->result.var, eax
				|	jae => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				|	setna al
				|	movzx eax, al
				|	lea eax, [eax + 2]
				|	SET_Z_TYPE_INFO FP + opline->result.var, eax
				|	ja => target_label
				break;
			default:
				ZEND_ASSERT(0);
		}
	} else if ((opline+1)->opcode == ZEND_JMPNZ_EX &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				|	jp >1
				|	SET_Z_TYPE_INFO FP + opline->result.var, IS_TRUE
				|	je => target_label
				|1:
				|	SET_Z_TYPE_INFO FP + opline->result.var, IS_FALSE
				break;
			case ZEND_IS_NOT_EQUAL:
				|	SET_Z_TYPE_INFO FP + opline->result.var, IS_TRUE
				|	jp >1
				|	jne => target_label
				|	SET_Z_TYPE_INFO FP + opline->result.var, IS_FALSE
				|1:
				break;
			case ZEND_IS_SMALLER:
				|	setnae al
				|	movzx eax, al
				|	lea eax, [eax + 2]
				|	SET_Z_TYPE_INFO FP + opline->result.var, eax
				|	jnae => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				|	setna al
				|	movzx eax, al
				|	lea eax, [eax + 2]
				|	SET_Z_TYPE_INFO FP + opline->result.var, eax
				|	jna => target_label
				break;
			default:
				ZEND_ASSERT(0);
		}
	} else {
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				|	jp >1
				|	mov eax, IS_TRUE
				|	je >2
				|1:
				|	mov eax, IS_FALSE
				|2:
				break;
			case ZEND_IS_NOT_EQUAL:
				|	jp >1
				|	mov eax, IS_FALSE
				|	je >2
				|1:
				|	mov eax, IS_TRUE
				|2:
				break;
			case ZEND_IS_SMALLER:
				|	setnae al
				|	movzx eax, al
				|	add eax, 2
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				|	setna al
				|	movzx eax, al
				|	add eax, 2
				break;
			default:
				ZEND_ASSERT(0);
		}
		|	SET_Z_TYPE_INFO FP + opline->result.var, eax
	}

	return 1;
}

static int zend_jit_cmp_long_double(dasm_State **Dst, const zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	|.if X64 or SSE
	||	zend_reg tmp_reg = ZREG_XMM1;
	||
	|	SSE_LOAD_LONG tmp_reg, opline->op1_type, opline->op1
	|	SSE_OP ucomisd, tmp_reg, opline->op2_type, opline->op2
	|.else
	|	FPU_LOAD opline->op2_type, opline->op2
	|	FPU_LONG_LOAD opline->op1_type, opline->op1
	|	fucomip st1
	|	fstp st0
	|.endif

	return zend_jit_cmp_double_common(Dst, opline, b, op_array, ssa);
}

static int zend_jit_cmp_double_long(dasm_State **Dst, const zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	|.if X64 or SSE
		zend_reg tmp_reg1 = ZREG_XMM0;
		zend_reg tmp_reg2 = ZREG_XMM1;

	|	SSE_LOAD tmp_reg1, opline->op1_type, opline->op1
	|	SSE_LOAD_LONG tmp_reg2, opline->op2_type, opline->op2
	|	ucomisd xmm(tmp_reg1-ZREG_XMM0), xmm(tmp_reg2-ZREG_XMM0)
	|.else
	|	FPU_LONG_LOAD opline->op2_type, opline->op2
	|	FPU_LOAD opline->op1_type, opline->op1
	|	fucomip st1
	|	fstp st0
	|.endif

	return zend_jit_cmp_double_common(Dst, opline, b, op_array, ssa);
}

static int zend_jit_cmp_double_double(dasm_State **Dst, const zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	|.if X64 or SSE
		zend_reg tmp_reg = ZREG_XMM0;

	|	SSE_LOAD tmp_reg, opline->op1_type, opline->op1
	|	SSE_OP ucomisd, tmp_reg, opline->op2_type, opline->op2
	|.else
	|	FPU_LOAD opline->op2_type, opline->op2
	|	FPU_LOAD opline->op1_type, opline->op1
	|	fucomip st1
	|	fstp st0
	|.endif

	return zend_jit_cmp_double_common(Dst, opline, b, op_array, ssa);
}

static int zend_jit_cmp_slow(dasm_State **Dst, const zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	unsigned int target_label;

	|	cmp aword [FP + opline->result.var], 0
	if (((opline+1)->opcode == ZEND_JMPZ_EX ||
	     (opline+1)->opcode == ZEND_JMPNZ_EX) &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				|	sete al
				break;
			case ZEND_IS_NOT_EQUAL:
				|	setne al
				break;
			case ZEND_IS_SMALLER:
				|	setl al
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				|	setle al
				break;
			default:
				ZEND_ASSERT(0);
		}
		|	movzx eax, al
		|	lea eax, [eax + 2]
		|	SET_Z_TYPE_INFO FP + opline->result.var, eax
	}
	if (((opline+1)->opcode == ZEND_JMPZ ||
	     (opline+1)->opcode == ZEND_JMPZ_EX) &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| jne => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| je => target_label
				break;
			case ZEND_IS_SMALLER:
				| jge => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| jg => target_label
				break;
			default:
				ZEND_ASSERT(0);
		}
	} else if (((opline+1)->opcode == ZEND_JMPNZ ||
	            (opline+1)->opcode == ZEND_JMPNZ_EX) &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| je => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| jne => target_label
				break;
			case ZEND_IS_SMALLER:
				| jl => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| jle => target_label
				break;
			default:
				ZEND_ASSERT(0);
		}
	} else if ((opline+1)->opcode == ZEND_JMPZNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				| jne => target_label
				break;
			case ZEND_IS_NOT_EQUAL:
				| je => target_label
				break;
			case ZEND_IS_SMALLER:
				| jge => target_label
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				| jg => target_label
				break;
			default:
				ZEND_ASSERT(0);
		}
		target_label = ssa->cfg.blocks[b].successors[1];
		| jmp => target_label
	} else {
		switch (opline->opcode) {
			case ZEND_IS_EQUAL:
			case ZEND_CASE:
				|	sete al
				break;
			case ZEND_IS_NOT_EQUAL:
				|	setne al
				break;
			case ZEND_IS_SMALLER:
				|	setl al
				break;
			case ZEND_IS_SMALLER_OR_EQUAL:
				|	setle al
				break;
			default:
				ZEND_ASSERT(0);
		}
		|	movzx eax, al
		|	add eax, 2
		|	SET_Z_TYPE_INFO FP + opline->result.var, eax
	}

	return 1;
}

static int zend_jit_cmp(dasm_State **Dst, const zend_op *opline, int b, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;
	zend_bool same_ops = (opline->op1_type == opline->op2_type) && (opline->op1.var == opline->op2.var);
	zend_bool has_slow;

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	has_slow =
		(op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE)) &&
		(op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE)) &&
		((op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_LONG|MAY_BE_DOUBLE))) ||
		 (op2_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_LONG|MAY_BE_DOUBLE))));

	if ((op1_info & MAY_BE_LONG) && (op2_info & MAY_BE_LONG)) {
		if (op1_info & (MAY_BE_ANY-MAY_BE_LONG)) {
			if (op1_info & MAY_BE_DOUBLE) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_LONG, >4
			} else {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_LONG, >9
			}
		}
		if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_LONG))) {
			if (op2_info & MAY_BE_DOUBLE) {
				|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_LONG, >3
				|.cold_code
				|3:
				if (op2_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
					|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_DOUBLE, >9
				}
				if (!zend_jit_cmp_long_double(Dst, opline, b, op_array, ssa)) {
					return 0;
				}
				|	jmp >6
				|.code
			} else {
				|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_LONG, >9
			}
		}
		if (!zend_jit_cmp_long_long(Dst, opline, b, op_array, ssa)) {
			return 0;
		}
		if (op1_info & MAY_BE_DOUBLE) {
			|.cold_code
			|4:
			if (op1_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_DOUBLE, >9
			}
			if (op2_info & MAY_BE_DOUBLE) {
				if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
					if (!same_ops) {
						|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_DOUBLE, >5
					} else {
						|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_DOUBLE, >9
					}
				}
				if (!zend_jit_cmp_double_double(Dst, opline, b, op_array, ssa)) {
					return 0;
				}
				|	jmp >6
			}
			if (!same_ops) {
				|5:
				if (op2_info & (MAY_BE_ANY-(MAY_BE_LONG|MAY_BE_DOUBLE))) {
					|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_LONG, >9
				}
				if (!zend_jit_cmp_double_long(Dst, opline, b, op_array, ssa)) {
					return 0;
				}
				|	jmp >6
			}
			|.code
		}
	} else if ((op1_info & MAY_BE_DOUBLE) &&
	           !(op1_info & MAY_BE_LONG) &&
	           (op2_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		if (op1_info & (MAY_BE_ANY-MAY_BE_DOUBLE)) {
			|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_DOUBLE, >9
		}
		if (op2_info & MAY_BE_DOUBLE) {
			if (!same_ops && (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
				if (!same_ops && (op2_info & MAY_BE_LONG)) {
					|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_DOUBLE, >3
				} else {
					|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_DOUBLE, >9
				}
			}
			if (!zend_jit_cmp_double_double(Dst, opline, b, op_array, ssa)) {
				return 0;
			}
		}
		if (!same_ops && (op2_info & MAY_BE_LONG)) {
			if (op2_info & MAY_BE_DOUBLE) {
				|.cold_code
			}
		    |3:
			if (op2_info & (MAY_BE_ANY-(MAY_BE_DOUBLE|MAY_BE_LONG))) {
				|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_LONG, >9
			}
			if (!zend_jit_cmp_double_long(Dst, opline, b, op_array, ssa)) {
				return 0;
			}
			if (op2_info & MAY_BE_DOUBLE) {
				|	jmp >6
				|.code
			}
		}
	} else if ((op2_info & MAY_BE_DOUBLE) &&
	           !(op2_info & MAY_BE_LONG) &&
	           (op1_info & (MAY_BE_LONG|MAY_BE_DOUBLE))) {
		if (op2_info & (MAY_BE_ANY-MAY_BE_DOUBLE)) {
			|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_DOUBLE, >9
		}
		if (op1_info & MAY_BE_DOUBLE) {
			if (!same_ops && (op1_info & (MAY_BE_ANY-MAY_BE_DOUBLE))) {
				if (!same_ops && (op1_info & MAY_BE_LONG)) {
					|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_DOUBLE, >3
				} else {
					|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_DOUBLE, >9
				}
			}
			if (!zend_jit_cmp_double_double(Dst, opline, b, op_array, ssa)) {
				return 0;
			}
		}
		if (!same_ops && (op1_info & MAY_BE_LONG)) {
			if (op1_info & MAY_BE_DOUBLE) {
				|.cold_code
			}
			|3:
			if (op1_info & (MAY_BE_ANY-(MAY_BE_DOUBLE|MAY_BE_LONG))) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_LONG, >9
			}
			if (!zend_jit_cmp_long_double(Dst, opline, b, op_array, ssa)) {
				return 0;
			}
			if (op1_info & MAY_BE_DOUBLE) {
				|	jmp >6
				|.code
			}
		}
	}

	if (has_slow ||
	    (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_LONG|MAY_BE_DOUBLE))) ||
	    (op2_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_LONG|MAY_BE_DOUBLE)))) {
		if (has_slow) {
			|.cold_code
			|9:
		}
		|	SAVE_VALID_OPLINE opline
		|	lea	FCARG1a, [FP + opline->result.var]
		|	LOAD_ZVAL_ADDR FCARG2a, opline->op1_type, opline->op1
		if (opline->op1_type == IS_CV && (op1_info & MAY_BE_UNDEF)) {
			|	IF_NOT_Z_TYPE FCARG2a, IS_UNDEF, >1
			|	mov FCARG1a, opline->op1.var
			|	EXT_CALL zend_jit_undefined_op_helper, r0
			|	LOAD_ADDR FCARG2a, &EG(uninitialized_zval)
			|1:
		}
		if (opline->op2_type == IS_CV && (op2_info & MAY_BE_UNDEF)) {
			|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_UNDEF, >1
			|	mov [r4], FCARG2a // save
			|	mov FCARG1a, opline->op2.var
			|	EXT_CALL zend_jit_undefined_op_helper, r0
			|	mov FCARG2a, [r4] // restore
			|.if X64
			|	LOAD_ADDR CARG3, &EG(uninitialized_zval)
			|.else
			|	PUSH_ADDR &EG(uninitialized_zval), r0
			|.endif
			|	jmp >2
			|1:
			|.if X64
			|	LOAD_ZVAL_ADDR CARG3, opline->op2_type, opline->op2
			|.else
			|	PUSH_ZVAL_ADDR opline->op2_type, opline->op2, r0
			|.endif
			|2:
		} else {
			|.if X64
			|	LOAD_ZVAL_ADDR CARG3, opline->op2_type, opline->op2
			|.else
			|	PUSH_ZVAL_ADDR opline->op2_type, opline->op2, r0
			|.endif
		}
		|	EXT_CALL compare_function, r0
		||	if (opline->opcode != ZEND_CASE) {
		|		FREE_OP opline->op1_type, opline->op1, op1_info, 0, op_array, opline
		||	}
		|	FREE_OP opline->op2_type, opline->op2, op2_info, 0, op_array, opline
		||	if (zend_may_throw(opline, op_array, ssa)) {
		||		zend_jit_check_exception_undef_result(Dst, opline);
		||	}
		if (!zend_jit_cmp_slow(Dst, opline, b, op_array, ssa)) {
			return 0;
		}
		if (has_slow) {
			|	jmp >6
			|.code
		}
	}

	|6:
	if (((opline+1)->opcode == ZEND_JMPZ ||
	     (opline+1)->opcode == ZEND_JMPNZ ||
	     (opline+1)->opcode == ZEND_JMPZ_EX ||
	     (opline+1)->opcode == ZEND_JMPNZ_EX ||
	     (opline+1)->opcode == ZEND_JMPZNZ) &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		(*opnum)++;
	}

	return 1;
}

static int zend_jit_identical(dasm_State **Dst, const zend_op *opline, int b, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	zend_bool smart_branch = 0;
	uint32_t identical_label = (uint32_t)-1;
	uint32_t not_identical_label = (uint32_t)-1;
	uint32_t op1_info, op2_info;

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();
	if (((opline+1)->opcode == ZEND_JMPZ ||
	     (opline+1)->opcode == ZEND_JMPNZ ||
	     (opline+1)->opcode == ZEND_JMPZNZ) &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		(*opnum)++;
		smart_branch = 1;
	}

	if (smart_branch) {
		if (opline->opcode == ZEND_IS_IDENTICAL) {
			if ((opline+1)->opcode == ZEND_JMPZ) {
				not_identical_label = ssa->cfg.blocks[b].successors[0];
			} else if ((opline+1)->opcode == ZEND_JMPNZ) {
				identical_label = ssa->cfg.blocks[b].successors[0];
			} else if ((opline+1)->opcode == ZEND_JMPZNZ) {
				not_identical_label = ssa->cfg.blocks[b].successors[0];
				identical_label = ssa->cfg.blocks[b].successors[1];
			} else {
				ZEND_ASSERT(0);
			}
		} else if (opline->opcode == ZEND_IS_NOT_IDENTICAL) {
			if ((opline+1)->opcode == ZEND_JMPZ) {
				identical_label = ssa->cfg.blocks[b].successors[0];
			} else if ((opline+1)->opcode == ZEND_JMPNZ) {
				not_identical_label = ssa->cfg.blocks[b].successors[0];
			} else if ((opline+1)->opcode == ZEND_JMPZNZ) {
				identical_label = ssa->cfg.blocks[b].successors[0];
				not_identical_label = ssa->cfg.blocks[b].successors[1];
			} else {
				ZEND_ASSERT(0);
			}
		} else {
			ZEND_ASSERT(0);
		}
	}

	if ((op1_info & MAY_BE_UNDEF) && (op2_info & MAY_BE_UNDEF)) {
		op1_info |= MAY_BE_NULL;
		op2_info |= MAY_BE_NULL;
		|	LOAD_ZVAL_ADDR FCARG1a, IS_CV, opline->op1
		|	IF_Z_TYPE FCARG1a, IS_UNDEF, >1
		|.cold_code
		|1:
		|	// zend_error(E_NOTICE, "Undefined variable: %s", ZSTR_VAL(CV_DEF_OF(EX_VAR_TO_NUM(opline->op1.var))));
		|	SAVE_VALID_OPLINE opline
		|	mov FCARG1d, opline->op1.var
		|	EXT_CALL zend_jit_undefined_op_helper, r0
		||	if (zend_may_throw(opline, op_array, ssa)) {
		||		zend_jit_check_exception_undef_result(Dst, opline);
		||	}
		|	LOAD_ADDR FCARG1a, &EG(uninitialized_zval)
		|	jmp >1
		|.code
		|1:
		|	LOAD_ZVAL_ADDR FCARG2a, IS_CV, opline->op2
		|	IF_Z_TYPE FCARG2a, IS_UNDEF, >1
		|.cold_code
		|1:
		|	// zend_error(E_NOTICE, "Undefined variable: %s", ZSTR_VAL(CV_DEF_OF(EX_VAR_TO_NUM(opline->op1.var))));
		|	SAVE_VALID_OPLINE opline
		|	mov aword [r4], FCARG1a // save
		|	mov FCARG1d, opline->op2.var
		|	EXT_CALL zend_jit_undefined_op_helper, r0
		||	if (zend_may_throw(opline, op_array, ssa)) {
		||		zend_jit_check_exception_undef_result(Dst, opline);
		||	}
		|	mov FCARG1a, aword [r4] // restore
		|	LOAD_ADDR FCARG2a, &EG(uninitialized_zval)
		|	jmp >1
		|.code
		|1:
	} else if (op1_info & MAY_BE_UNDEF) {
		op1_info |= MAY_BE_NULL;
		|	LOAD_ZVAL_ADDR FCARG1a, IS_CV, opline->op1
		|	IF_Z_TYPE FCARG1a, IS_UNDEF, >1
		|.cold_code
		|1:
		|	// zend_error(E_NOTICE, "Undefined variable: %s", ZSTR_VAL(CV_DEF_OF(EX_VAR_TO_NUM(opline->op1.var))));
		|	SAVE_VALID_OPLINE opline
		|	mov FCARG1d, opline->op1.var
		|	EXT_CALL zend_jit_undefined_op_helper, r0
		||	if (zend_may_throw(opline, op_array, ssa)) {
		||		zend_jit_check_exception_undef_result(Dst, opline);
		||	}
		|	LOAD_ADDR FCARG1a, &EG(uninitialized_zval)
		|	jmp >1
		|.code
		|1:
		if (opline->op2_type != IS_CONST) {
			|	LOAD_ZVAL_ADDR FCARG2a, opline->op2_type, opline->op2
		}
	} else if (op2_info & MAY_BE_UNDEF) {
		op2_info |= MAY_BE_NULL;
		|	LOAD_ZVAL_ADDR FCARG2a, IS_CV, opline->op2
		|	IF_Z_TYPE FCARG2a, IS_UNDEF, >1
		|.cold_code
		|1:
		|	// zend_error(E_NOTICE, "Undefined variable: %s", ZSTR_VAL(CV_DEF_OF(EX_VAR_TO_NUM(opline->op1.var))));
		|	SAVE_VALID_OPLINE opline
		|	mov FCARG1d, opline->op2.var
		|	EXT_CALL zend_jit_undefined_op_helper, r0
		||	if (zend_may_throw(opline, op_array, ssa)) {
		||		zend_jit_check_exception_undef_result(Dst, opline);
		||	}
		|	LOAD_ADDR FCARG2a, &EG(uninitialized_zval)
		|	jmp >1
		|.code
		|1:
		if (opline->op1_type != IS_CONST) {
			|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		}
	} else {
		if (opline->op1_type != IS_CONST) {
			|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		}
		if (opline->op2_type != IS_CONST) {
			|	LOAD_ZVAL_ADDR FCARG2a, opline->op2_type, opline->op2
		}
	}
	if (opline->op1_type & (IS_CV|IS_VAR)) {
		|	ZVAL_DEREF FCARG1a, op1_info
	}
	if (opline->op2_type & (IS_CV|IS_VAR)) {
		|	ZVAL_DEREF FCARG2a, op2_info
	}

	if ((op1_info & op2_info & MAY_BE_ANY) == 0) {
		if (((opline->op1_type & (IS_VAR|IS_TMP_VAR)) &&
		     (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF))) ||
		    ((opline->op2_type & (IS_VAR|IS_TMP_VAR)) &&
		     (op2_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF)))) {
			|	SAVE_VALID_OPLINE opline
			|	FREE_OP opline->op1_type, opline->op1, op1_info, 1, op_array, opline
			|	FREE_OP opline->op2_type, opline->op2, op2_info, 1, op_array, opline
		}
		if (smart_branch) {
			zend_jit_check_exception_undef_result(Dst, opline);
			if (not_identical_label != (uint32_t)-1) {
				|	jmp =>not_identical_label
			}
		} else {
			|	SET_Z_TYPE_INFO FP + opline->result.var, (opline->opcode == ZEND_IS_IDENTICAL ? IS_FALSE : IS_TRUE)
			zend_jit_check_exception(Dst);
		}
	} else if (has_concrete_type(op1_info) &&
	           has_concrete_type(op2_info) &&
	           concrete_type(op1_info) == concrete_type(op2_info) &&
	           concrete_type(op1_info) <= IS_TRUE) {
		if (smart_branch) {
			if (identical_label != (uint32_t)-1) {
				|	jmp =>identical_label
			}
		} else {
			|	SET_Z_TYPE_INFO FP + opline->result.var, (opline->opcode == ZEND_IS_IDENTICAL ? IS_TRUE : IS_FALSE)
		}
	} else if (opline->op1_type == IS_CONST && opline->op2_type == IS_CONST) {
		if (zend_is_identical(RT_CONSTANT(op_array, opline->op1), RT_CONSTANT(op_array, opline->op2))) {
			if (smart_branch) {
				if (identical_label != (uint32_t)-1) {
					|	jmp =>identical_label
				}
			} else {
				|	SET_Z_TYPE_INFO FP + opline->result.var, (opline->opcode == ZEND_IS_IDENTICAL ? IS_TRUE : IS_FALSE)
			}
		} else {
			if (smart_branch) {
				if (not_identical_label != (uint32_t)-1) {
					|	jmp =>not_identical_label
				}
			} else {
				|	SET_Z_TYPE_INFO FP + opline->result.var, (opline->opcode == ZEND_IS_IDENTICAL ? IS_FALSE : IS_TRUE)
			}
		}
	} else if (opline->op1_type == IS_CONST && Z_TYPE_P(RT_CONSTANT(op_array, opline->op1)) <= IS_TRUE) {
		zval *val = RT_CONSTANT(op_array, opline->op1);

		|	cmp byte [FCARG2a + offsetof(zval, u1.v.type)], Z_TYPE_P(val)
		if (smart_branch) {
			if (opline->op2_type == IS_VAR && (op2_info & MAY_BE_REF)) {
				|	jne >8
				|	SAVE_VALID_OPLINE opline
				|	FREE_OP opline->op2_type, opline->op2, op2_info, 1, op_array, opline
				zend_jit_check_exception_undef_result(Dst, opline);
				if (identical_label != (uint32_t)-1) {
					|	jmp =>identical_label
				} else {
					|	jmp >9
				}
				|8:
			} else if (identical_label != (uint32_t)-1) {
				|	je =>identical_label
			} else {
				|	je >9
			}
		} else {
			if (opline->opcode == ZEND_IS_IDENTICAL) {
				|	sete al
			} else {
				|	setne al
			}
			|	movzx eax, al
			|	lea eax, [eax + 2]
			|	SET_Z_TYPE_INFO FP + opline->result.var, eax
		}
		if ((opline->op2_type & (IS_VAR|IS_TMP_VAR)) &&
		    (op2_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF))) {
			|	SAVE_VALID_OPLINE opline
			|	FREE_OP opline->op2_type, opline->op2, op2_info, 1, op_array, opline
			zend_jit_check_exception_undef_result(Dst, opline);
		}
		if (smart_branch && not_identical_label != (uint32_t)-1) {
			|	jmp =>not_identical_label
		}
	} else if (opline->op2_type == IS_CONST && Z_TYPE_P(RT_CONSTANT(op_array, opline->op2)) <= IS_TRUE) {
		zval *val = RT_CONSTANT(op_array, opline->op2);

		|	cmp byte [FCARG1a + offsetof(zval, u1.v.type)], Z_TYPE_P(val)
		if (smart_branch) {
			if (opline->op1_type == IS_VAR && (op1_info & MAY_BE_REF)) {
				|	jne >8
				|	SAVE_VALID_OPLINE opline
				|	FREE_OP opline->op1_type, opline->op1, op1_info, 1, op_array, opline
				zend_jit_check_exception_undef_result(Dst, opline);
				if (identical_label != (uint32_t)-1) {
					|	jmp =>identical_label
				} else {
					|	jmp >9
				}
				|8:
			} else if (identical_label != (uint32_t)-1) {
				|	je =>identical_label
			} else {
				|	je >9
			}
		} else {
			if (opline->opcode == ZEND_IS_IDENTICAL) {
				|	sete al
			} else {
				|	setne al
			}
			|	movzx eax, al
			|	lea eax, [eax + 2]
			|	SET_Z_TYPE_INFO FP + opline->result.var, eax
		}
		if ((opline->op1_type & (IS_VAR|IS_TMP_VAR)) &&
		    (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF))) {
			|	SAVE_VALID_OPLINE opline
			|	FREE_OP opline->op1_type, opline->op1, op1_info, 1, op_array, opline
			zend_jit_check_exception_undef_result(Dst, opline);
		}
		if (smart_branch && not_identical_label != (uint32_t)-1) {
			|	jmp =>not_identical_label
		}
	} else {
		if (opline->op1_type == IS_CONST) {
			|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		}
		if (opline->op2_type == IS_CONST) {
			|	LOAD_ZVAL_ADDR FCARG2a, opline->op2_type, opline->op2
		}
		|	EXT_CALL zend_is_identical, r0
			if (((opline->op1_type & (IS_VAR|IS_TMP_VAR)) &&
			     (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF))) ||
			    ((opline->op2_type & (IS_VAR|IS_TMP_VAR)) &&
			     (op2_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF)))) {
				|	mov aword [r4], r0 // save
				|	SAVE_VALID_OPLINE opline
				|	FREE_OP opline->op1_type, opline->op1, op1_info, 1, op_array, opline
				|	FREE_OP opline->op2_type, opline->op2, op2_info, 1, op_array, opline
				zend_jit_check_exception_undef_result(Dst, opline);
				|	mov r0, aword [r4] // restore
			}
		|	test r0, r0
		if (smart_branch) {
			if (not_identical_label != (uint32_t)-1) {
				|	jz =>not_identical_label
				if (identical_label != (uint32_t)-1) {
					|	jmp =>identical_label
				}
			} else if (identical_label != (uint32_t)-1) {
				|	jnz =>identical_label
			}
		} else {
			if (opline->opcode == ZEND_IS_IDENTICAL) {
				|	setnz al
			} else {
				|	setz al
			}
			|	movzx eax, al
			|	lea eax, [eax + 2]
			|	SET_Z_TYPE_INFO FP + opline->result.var, eax
		}
	}

	|9:

	return 1;
}

static int zend_jit_bool_jmpznz(dasm_State **Dst, const zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info = OP1_INFO();
	uint32_t true_label = -1;
	uint32_t false_label = -1;
	zend_bool set_bool = 0;
	zend_bool set_bool_not = 0;
	zend_bool jmp_done = 0;

	if (opline->opcode == ZEND_JMPZ) {
		false_label = ssa->cfg.blocks[b].successors[0];
	} else if (opline->opcode == ZEND_JMPNZ) {
		true_label = ssa->cfg.blocks[b].successors[0];
	} else if (opline->opcode == ZEND_JMPZNZ) {
		true_label = ssa->cfg.blocks[b].successors[1];
		false_label = ssa->cfg.blocks[b].successors[0];
	} else if (opline->opcode == ZEND_BOOL) {
		set_bool = 1;
	} else if (opline->opcode == ZEND_BOOL_NOT) {
		set_bool = 1;
		set_bool_not = 1;
	} else if (opline->opcode == ZEND_JMPZ_EX) {
		set_bool = 1;
		false_label = ssa->cfg.blocks[b].successors[0];
	} else if (opline->opcode == ZEND_JMPNZ_EX) {
		set_bool = 1;
		true_label = ssa->cfg.blocks[b].successors[0];
	} else {
		ZEND_ASSERT(0);
	}

	if (op1_info & MAY_BE_REF) {
		|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		|	ZVAL_DEREF FCARG1a, op1_info
	}

	if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE)) {
		if (!(op1_info & ((MAY_BE_UNDEF|MAY_BE_ANY)-MAY_BE_TRUE))) {
			/* Always TRUE */
			if (set_bool) {
				if (set_bool_not) {
					|	SET_Z_TYPE_INFO FP + opline->result.var, IS_FALSE
				} else {
					|	SET_Z_TYPE_INFO FP + opline->result.var, IS_TRUE
				}
			}
			if (true_label != (uint32_t)-1) {
				|	jmp =>true_label;
			}
		} else {
			if (!(op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE)))) {
				/* Always FASLE */
				if (set_bool) {
					if (set_bool_not) {
						|	SET_Z_TYPE_INFO FP + opline->result.var, IS_TRUE
					} else {
						|	SET_Z_TYPE_INFO FP + opline->result.var, IS_FALSE
					}
				}
			} else {
			    if (op1_info & MAY_BE_REF) {
					|	cmp byte [FCARG1a + 8], IS_TRUE
				} else {
					|	cmp byte [FP + opline->op1.var + 8], IS_TRUE
				}
				if (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE))) {
				    if ((op1_info & MAY_BE_LONG) &&
				        !(op1_info & MAY_BE_UNDEF) &&
				        !set_bool) {
						if (false_label != (uint32_t)-1) {
							|	jl =>false_label
						} else {
							|	jl >9
						}
						jmp_done = 1;
					} else {
						|	jg >2
					}
				}
				if (!(op1_info & MAY_BE_TRUE)) {
					/* It's FALSE */
					if (set_bool) {
						if (set_bool_not) {
							|	SET_Z_TYPE_INFO FP + opline->result.var, IS_TRUE
						} else {
							|	SET_Z_TYPE_INFO FP + opline->result.var, IS_FALSE
						}
					}
				} else {
					if (true_label != (uint32_t)-1 || false_label != (uint32_t)-1) {
						if (set_bool) {
							|	jne >1
							|	SET_Z_TYPE_INFO FP + opline->result.var, IS_TRUE
							if (true_label != (uint32_t)-1) {
								|	jmp =>true_label
							} else {
								|	jmp >9
							}
							|1:
							|	SET_Z_TYPE_INFO FP + opline->result.var, IS_FALSE
						} else {
							if (true_label != (uint32_t)-1) {
								|	je =>true_label
							} else if (!(op1_info & (MAY_BE_UNDEF|MAY_BE_LONG))) {
								|	jne =>false_label
								jmp_done = 1;
							} else {
								|	je >9
							}
						}
					} else if (set_bool) {
						|	sete al
						|	movzx eax, al
						if (set_bool_not) {
							|	neg eax
							|	add eax, 3
						} else {
							|	add eax, 2
						}
						|	SET_Z_TYPE_INFO FP + opline->result.var, eax
					}
				}
			}

			/* It's FALSE, but may be UNDEF */
			if (op1_info & MAY_BE_UNDEF) {
				if (op1_info & MAY_BE_ANY) {
					if (op1_info & MAY_BE_REF) {
						|	IF_Z_TYPE FCARG1a, IS_UNDEF, >1
					} else {
						|	IF_Z_TYPE FP + opline->op1.var, IS_UNDEF, >1
					}
					|.cold_code
					|1:
				}
				|	mov FCARG1d, opline->op1.var
				|	SAVE_VALID_OPLINE opline
				|	EXT_CALL zend_jit_undefined_op_helper, r0

				if (zend_may_throw(opline, op_array, ssa)) {
					if (!zend_jit_check_exception_undef_result(Dst, opline)) {
						return 0;
					}
				}

				if (false_label != (uint32_t)-1) {
					|	jmp =>false_label
				}
				if (op1_info & MAY_BE_ANY) {
					if (false_label == (uint32_t)-1) {
						|	jmp >9
					}
					|.code
				}
			}

			if (!jmp_done) {
				if (false_label != (uint32_t)-1) {
					|	jmp =>false_label
				} else if (op1_info & MAY_BE_LONG) {
					|	jmp >9
				}
			}
		}
	}

	if (op1_info & MAY_BE_LONG) {
		|2:
		if (op1_info & (MAY_BE_ANY-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG))) {
			if (op1_info & MAY_BE_REF) {
				|	IF_NOT_Z_TYPE FCARG1a, IS_LONG, >2
			} else {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_LONG, >2
			}
		}
		if (op1_info & MAY_BE_REF) {
			|	cmp	aword [FCARG1a], 0
		} else {
			|	cmp	aword [FP + opline->op1.var], 0
		}
		if (set_bool) {
			|	setne al
			|	movzx eax, al
			if (set_bool_not) {
				|	neg eax
				|	add eax, 3
			} else {
				|	lea eax, [eax + 2]
			}
			|	SET_Z_TYPE_INFO FP + opline->result.var, eax
		}
		if (true_label != (uint32_t)-1 || false_label != (uint32_t)-1) {
			if (true_label != (uint32_t)-1) {
				|	jne =>true_label
				if (false_label != (uint32_t)-1) {
					|	jmp =>false_label
				}
			} else {
				|	je =>false_label
			}
		}
	}

	if (op1_info & (MAY_BE_ANY - (MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG))) {
		if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG)) {
			|.cold_code
			|2:
		}
		if (!(op1_info & MAY_BE_REF)) {
			|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		}
		|	SAVE_VALID_OPLINE opline
		|	EXT_CALL zend_is_true, r0

		if (set_bool) {
			if (set_bool_not) {
				|	neg eax
				|	add eax, 3
			} else {
				|	add eax, 2
			}
			|	SET_Z_TYPE_INFO FP + opline->result.var, eax
			|	FREE_OP opline->op1_type, opline->op1, op1_info, !(op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG)), op_array, opline
			if (zend_may_throw(opline, op_array, ssa)) {
				if (!zend_jit_check_exception_undef_result(Dst, opline)) {
					return 0;
				}
			}
			if (true_label != (uint32_t)-1 || false_label != (uint32_t)-1) {
				|	cmp dword [FP + opline->result.var + 8], IS_FALSE
				if (true_label != (uint32_t)-1) {
					|	jne =>true_label
					if (false_label != (uint32_t)-1) {
						|	jmp =>false_label
					} else if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG)) {
						|	jmp >9
					}
				} else {
					|	je =>false_label
				}
			}
			if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG)) {
				|	jmp >9
				|.code
			}
		} else {

			if ((opline->op1_type & (IS_VAR|IS_TMP_VAR)) &&
			    (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
				|	test byte [FP + opline->op1.var + 9], IS_TYPE_REFCOUNTED
				|	jz >3
				|	mov FCARG1a, aword [FP + opline->op1.var]
				|	sub dword [FCARG1a], 1
				|	jnz >3
				|	mov aword [r4], r0 // save
				|	ZVAL_DTOR_FUNC op1_info, op_array->filename, opline
				|	mov r0, aword [r4] // restore
				|3:
			}
			if (zend_may_throw(opline, op_array, ssa)) {
				if (!zend_jit_check_exception_undef_result(Dst, opline)) {
					return 0;
				}
			}

			|	test r0, r0
			if (true_label != (uint32_t)-1) {
				|	jne =>true_label
				if (false_label != (uint32_t)-1) {
					|	jmp =>false_label
				} else if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG)) {
					|	jmp >9
				}
			} else {
				|	je =>false_label
				if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG)) {
					|	jmp >9
				}
			}

			if (op1_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG)) {
				|.code
			}
		}
	}

	|9:

	return 1;
}

static int zend_jit_qm_assign(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info = OP1_INFO();

	return zend_jit_simple_assign(Dst, opline, op_array, ssa, ZREG_FP, opline->result.var, -1, opline->op1_type, opline->op1, op1_info, -1, 0);
}

static int zend_jit_assign(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;

	if (opline->op1_type != IS_CV || !ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if (op1_info & MAY_BE_REF) {
		|	lea	FCARG1a, [FP + opline->op1.var]
		|	ZVAL_DEREF FCARG1a, op1_info
		if (!zend_jit_assign_to_variable(Dst, opline, op_array, ssa, ZREG_FCARG1a, 0, op1_info, opline->op2_type, opline->op2, op2_info,
				opline->result_type == IS_UNUSED ? -1 : opline->result.var)) {
			return 0;
		}
	} else {
		if (!zend_jit_assign_to_variable(Dst, opline, op_array, ssa, ZREG_FP, opline->op1.var, op1_info, opline->op2_type, opline->op2, op2_info,
				opline->result_type == IS_UNUSED ? -1 : opline->result.var)) {
			return 0;
		}
	}

	if (zend_may_throw(opline, op_array, ssa)) {
		zend_jit_check_exception(Dst);
	}

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_push_call_frame(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_function *func)
{
	uint32_t used_stack;

	if (func) {
		used_stack = zend_vm_calc_used_stack(opline->extended_value, func);
	} else {
		used_stack = (ZEND_CALL_FRAME_SLOT + opline->extended_value) * sizeof(zval);

		|	// if (EXPECTED(ZEND_USER_CODE(func->type))) {
		|	test byte [r0 + offsetof(zend_function, type)], 1
		|	mov FCARG1a, used_stack
		|	jnz >1
		|	// used_stack += (func->op_array.last_var + func->op_array.T - MIN(func->op_array.num_args, num_args)) * sizeof(zval);
		|	mov	edx, opline->extended_value
		|	cmp edx, dword [r0 + offsetof(zend_function, op_array.num_args)]
		|	cmova edx, dword [r0 + offsetof(zend_function, op_array.num_args)]
		|	sub edx, dword [r0 + offsetof(zend_function, op_array.last_var)]
		|	sub edx, dword [r0 + offsetof(zend_function, op_array.T)]
		|	shl edx, 5
		|.if X64
		|	movsxd r2, edx
		|.endif
		|	sub FCARG1a, r2
		|1:
	}

	zend_jit_start_reuse_ip();

	|	// if (UNEXPECTED(used_stack > (size_t)(((char*)EG(vm_stack_end)) - (char*)call))) {
	|	mov RX, aword [&EG(vm_stack_top)]
	|	// Check Stack Overflow
	|	mov r2, aword [&EG(vm_stack_end)]
	|	sub r2, RX
	if (func) {
		|	cmp r2, used_stack
	} else {
		|	cmp r2, FCARG1a
	}
	|	jb >1
	|	// EG(vm_stack_top) = (zval*)((char*)call + used_stack);
	|.cold_code
	|1:
	if (func) {
		|	mov FCARG1d, used_stack
	}
	if (func && func->type == ZEND_INTERNAL_FUNCTION) {
		|	EXT_CALL zend_jit_int_extend_stack_helper, r0
	} else {
		|	mov FCARG2a, r0
		|	EXT_CALL zend_jit_extend_stack_helper, r0
	}
	|	mov RX, r0
	|	jmp >1
	|.code

	if (func) {
		|	add aword [&EG(vm_stack_top)], used_stack
	} else {
		|	add aword [&EG(vm_stack_top)], FCARG1a
	}
	|	// zend_vm_init_call_frame(call, call_info, func, num_args, called_scope, object);
	|	// ZEND_SET_CALL_INFO(call, 0, call_info);
	|	mov dword EX:RX->This.u1.type_info, (IS_UNDEF | (ZEND_CALL_NESTED_FUNCTION << ZEND_CALL_INFO_SHIFT))
	|	// call->func = func;
	if (func && func->type == ZEND_INTERNAL_FUNCTION) {
		|1:
		|.if X64
		||	if (!IS_32BIT(func)) {
		|		mov aword EX:RX->func, func
		||	} else {
		|		LOAD_ADDR r0, func
		|		mov aword EX:RX->func, r0
		||	}
		|.else
		|	mov aword EX:RX->func, func
		|.endif
	} else {
		|	mov aword EX:RX->func, r0
		|1:
	}
	|	// Z_CE(call->This) = called_scope;
	|	mov aword EX:RX->This.value.ptr, 0
	|	// ZEND_CALL_NUM_ARGS(call) = num_args;
	|	mov dword EX:RX->This.u2.num_args, opline->extended_value
	return 1;
}

static int zend_jit_needs_call_chain(zend_call_info *call_info, uint32_t b, zend_op_array *op_array, zend_ssa *ssa, const zend_op *opline)
{
	int skip;

	if (!call_info) {
		const zend_op *end = op_array->opcodes + op_array->last;

		opline++;
		skip = 1;
		while (opline != end) {
			if (!skip) {
				if (zend_may_throw(opline, op_array, ssa)) {
					return 1;
				}
			}
			switch (opline->opcode) {
				case ZEND_SEND_VAL:
				case ZEND_SEND_VAR:
				case ZEND_SEND_VAL_EX:
				case ZEND_SEND_VAR_EX:
				case ZEND_SEND_REF:
				case ZEND_SEND_VAR_NO_REF:
				case ZEND_SEND_VAR_NO_REF_EX:
					skip = 0;
					break;
				case ZEND_SEND_ARRAY:
				case ZEND_SEND_USER:
				case ZEND_SEND_UNPACK:
				case ZEND_INIT_FCALL:
				case ZEND_INIT_METHOD_CALL:
				case ZEND_INIT_STATIC_METHOD_CALL:
				case ZEND_INIT_FCALL_BY_NAME:
				case ZEND_INIT_NS_FCALL_BY_NAME:
				case ZEND_INIT_DYNAMIC_CALL:
				case ZEND_NEW:
				case ZEND_INIT_USER_CALL:
				case ZEND_FAST_CALL:
				case ZEND_JMP:
				case ZEND_JMPZNZ:
				case ZEND_JMPZ:
				case ZEND_JMPNZ:
				case ZEND_JMPZ_EX:
				case ZEND_JMPNZ_EX:
				case ZEND_FE_RESET_R:
				case ZEND_FE_RESET_RW:
				case ZEND_JMP_SET:
				case ZEND_COALESCE:
				case ZEND_ASSERT_CHECK:
				case ZEND_CATCH:
				case ZEND_DECLARE_ANON_CLASS:
				case ZEND_DECLARE_ANON_INHERITED_CLASS:
				case ZEND_FE_FETCH_R:
				case ZEND_FE_FETCH_RW:
					return 1;
				case ZEND_DO_ICALL:
				case ZEND_DO_UCALL:
				case ZEND_DO_FCALL_BY_NAME:
				case ZEND_DO_FCALL:
					end = opline;
					if (end - op_array->opcodes >= ssa->cfg.blocks[b].start + ssa->cfg.blocks[b].len) {
						/* INIT_FCALL and DO_FCALL in different BasicBlocks */
						return 1;
					}
					return 0;
			}
			opline++;
		}

		return 1;
	} else {
		const zend_op *end = call_info->caller_call_opline;

		if (end - op_array->opcodes >= ssa->cfg.blocks[b].start + ssa->cfg.blocks[b].len) {
			/* INIT_FCALL and DO_FCALL in different BasicBlocks */
			return 1;
		}

		opline++;
		skip = 1;
		while (opline != end) {
			if (skip) {
				switch (opline->opcode) {
					case ZEND_SEND_VAL:
					case ZEND_SEND_VAR:
					case ZEND_SEND_VAL_EX:
					case ZEND_SEND_VAR_EX:
					case ZEND_SEND_REF:
					case ZEND_SEND_VAR_NO_REF:
					case ZEND_SEND_VAR_NO_REF_EX:
						skip = 0;
						break;
					case ZEND_SEND_ARRAY:
					case ZEND_SEND_USER:
					case ZEND_SEND_UNPACK:
						return 1;
				}
			} else {
				if (zend_may_throw(opline, op_array, ssa)) {
					return 1;
				}
			}
			opline++;
		}

		return 0;
	}
}

static int zend_jit_init_fcall(dasm_State **Dst, const zend_op *opline, uint32_t b, zend_op_array *op_array, zend_ssa *ssa, int call_level)
{
	zend_func_info *info = ZEND_FUNC_INFO(op_array);
	zend_call_info *call_info = NULL;
	zend_function *func = NULL;

	if (delayed_call_chain) {
		if (!zend_jit_save_call_chain(Dst, delayed_call_level)) {
			return 0;
		}
	}

	if (info) {
		call_info = info->callee_info;
		while (call_info && call_info->caller_init_opline != opline) {
			call_info = call_info->next_callee;
		}
		if (call_info && call_info->callee_func) {
			func = call_info->callee_func;
		}
	}

	if (func && func->type == ZEND_INTERNAL_FUNCTION) {
		/* load constant address later */
	} else if (func && op_array == &func->op_array) {
		/* recursive call */
		|	mov r0,	EX->func
	} else {
		zval *zv = RT_CONSTANT(op_array, opline->op2);

		|	// if (CACHED_PTR(Z_CACHE_SLOT_P(fname)))
		|	mov r0,	EX->run_time_cache
		|	mov r0, aword [r0 + Z_CACHE_SLOT_P(zv)]
		|	test r0, r0
		|	jz >1
		|.cold_code
		|1:
		|	// SAVE_OPLINE();
		|	SAVE_VALID_OPLINE opline
		if (opline->opcode == ZEND_INIT_FCALL) {
			|	LOAD_ADDR FCARG1a, Z_STR_P(zv);
			|	EXT_CALL zend_jit_find_func_helper, r0
		} else if (opline->opcode == ZEND_INIT_FCALL_BY_NAME) {
			|	LOAD_ADDR FCARG1a, Z_STR_P(zv);
			|	LOAD_ADDR FCARG2a, Z_STR_P(zv + 1);
			|	EXT_CALL zend_jit_find_func_by_name_helper, r0
		} else {
			ZEND_ASSERT(0);
		}
		if (opline->opcode != ZEND_INIT_FCALL) {
			// TODO: INIT_FCALL may fail in some cases ???
			|	test r0, r0
			|	jz ->exception_handler
		}
		|	// CACHE_PTR(Z_CACHE_SLOT_P(fname), fbc);
		|	mov r1,	EX->run_time_cache
		|	mov aword [r1 + Z_CACHE_SLOT_P(zv)], r0
		|	jmp >3
		|.code
		|3:
	}

	if (!zend_jit_push_call_frame(Dst, opline, op_array, func)) {
		return 0;
	}

	if (zend_jit_needs_call_chain(call_info, b, op_array, ssa, opline)) {
		if (!zend_jit_save_call_chain(Dst, call_level)) {
			return 0;
		}
	} else {
		delayed_call_chain = 1;
		delayed_call_level = call_level;
	}

	return 1;
}

static int zend_jit_do_fcall(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa, int call_level)
{
	zend_func_info *info = ZEND_FUNC_INFO(op_array);
	zend_call_info *call_info = NULL;
	zend_function *func = NULL;
	uint32_t i;

	if (info) {
		call_info = info->callee_info;
		while (call_info && call_info->caller_call_opline != opline) {
			call_info = call_info->next_callee;
		}
		if (call_info && call_info->callee_func) {
			func = call_info->callee_func;
		}
	}
	if (!func) {
		/* resolve function ar run time */
	} else if (func->type == ZEND_USER_FUNCTION) {
		if (call_info->num_args > func->op_array.num_args ||
		    (opline-1)->opcode == ZEND_SEND_UNPACK ||
		    (opline-1)->opcode == ZEND_SEND_ARRAY ||
		    (func->op_array.fn_flags & ZEND_ACC_HAS_TYPE_HINTS) != 0) {
			goto fallback;
		}
	} else if (func->type == ZEND_INTERNAL_FUNCTION) {
#if ZEND_DEBUG
		if (func->common.fn_flags & ZEND_ACC_HAS_RETURN_TYPE) {
			goto fallback;
		}
#endif
		if ((opline-1)->opcode == ZEND_SEND_UNPACK || (opline-1)->opcode == ZEND_SEND_ARRAY) {
			goto fallback;
		}
	} else {
		ZEND_ASSERT(0);
	}

	if (!reuse_ip) {
		zend_jit_start_reuse_ip();
		|	// call = EX(call);
		|	mov RX, EX->call
	}
	zend_jit_stop_reuse_ip();

	|	// fbc = call->func;
	|	// mov r2, EX:RX->func ???
	|	// SAVE_OPLINE();
	|	SAVE_VALID_OPLINE opline

	if (!delayed_call_chain) {
		if (call_level == 1) {
			|	mov aword EX->call, 0
		} else {
			|	//EX(call) = call->prev_execute_data;
			|	mov r0, EX:RX->prev_execute_data
			|	mov EX->call, r0
		}
	}
	delayed_call_chain = 0;

	|	//call->prev_execute_data = execute_data;
	|	mov EX:RX->prev_execute_data, EX

	if (!func) {
		|	mov r0, EX:RX->func
	}

	if (opline->opcode == ZEND_DO_FCALL) {
		if (!func) {
			|	test dword [r0 + offsetof(zend_op_array, fn_flags)], (ZEND_ACC_DEPRECATED|ZEND_ACC_ABSTRACT)
			|	jnz >1
			|.cold_code
			|1:
			|	EXT_CALL zend_jit_deprecated_or_abstract_helper, r0
			|	cmp aword [&EG(exception)], 0
			|	jne ->exception_handler
			|	mov r0, EX:RX->func // reload
			|	jmp >1
			|.code
			|1:
		} else if (func->common.fn_flags & ZEND_ACC_ABSTRACT) {
			|	EXT_CALL zend_jit_deprecated_or_abstract_helper, r0
			|	jmp ->exception_handler
		} else if (func->common.fn_flags & ZEND_ACC_DEPRECATED) {
			|	EXT_CALL zend_jit_deprecated_or_abstract_helper, r0
			|	cmp aword [&EG(exception)], 0
			|	jne ->exception_handler
			|	mov r0, EX:RX->func // reload
		}
	}

	if (!func) {
		|	cmp byte [r0 + offsetof(zend_function, type)], ZEND_USER_FUNCTION
		|	jne >8
	}

	if (!func || func->type == ZEND_USER_FUNCTION) {
		|	// EX(call) = NULL;
		|	mov aword EX:RX->call, 0

		if (RETURN_VALUE_USED(opline)) {
			|	// ZVAL_NULL(EX_VAR(opline->result.var));
			|	SET_Z_TYPE_INFO FP + opline->result.var, IS_NULL
			|	// EX(return_value) = EX_VAR(opline->result.var);
			|	lea r2, aword [FP + opline->result.var]
			|	mov aword EX:RX->return_value, r2
		} else {
			|	// EX(return_value) = 0;
			|	mov aword EX:RX->return_value, 0
		}

		if (func) {
			for (i = call_info->num_args; i < func->op_array.last_var; i++) {
				uint32_t n = (uint32_t)(uintptr_t)ZEND_CALL_VAR_NUM(NULL, i);
				|	SET_Z_TYPE_INFO RX + n, IS_UNDEF
			}
		}

		//EX_LOAD_RUN_TIME_CACHE(op_array);
		if (!func || func->op_array.cache_size) {
			if (func && op_array == &func->op_array) {
				/* recursive call */
				if (func->op_array.cache_size > sizeof(void*)) {
					|	mov r2, EX->run_time_cache
					|	mov EX:RX->run_time_cache, r2
				}
			} else {
				if (func) {
					|	mov r0, EX:RX->func
				}
				|	mov r2, aword [r0 + offsetof(zend_op_array, run_time_cache)]
				|	mov EX:RX->run_time_cache, r2
			}
		}

		|	//EX_LOAD_LITERALS(op_array);
		|.if X64
		||	if (func && zend_accel_in_shm(func->op_array.literals)) {
		|		LOAD_ADDR r2, func->op_array.literals
		|		mov EX:RX->literals, r2
		||	} else {
		||		if (func) {
		|			mov r0, EX:RX->func
		||		}
		|		mov	r2, aword [r0 + offsetof(zend_op_array, literals)]
		|		mov EX:RX->literals, r2
		||	}
		|.endif

		|	// EG(current_execute_data) = execute_data;
		|	mov aword [&EG(current_execute_data)], RX
		|	mov FP, RX

		|	// opline = op_array->opcodes;
		if (func) {
			if (func && zend_accel_in_shm(func->op_array.opcodes)) {
				|	LOAD_ADDR IP, (func->op_array.opcodes + call_info->num_args)
			} else {
				if (func) {
					|	mov r0, EX->func
				}
				|	mov	IP, aword [r0 + offsetof(zend_op_array, opcodes)]
				if (call_info->num_args) {
					|	add IP, (call_info->num_args * sizeof(zend_op))
				}
			}
		} else {
			|	// opline = op_array->opcodes
			|	mov	IP, aword [r0 + offsetof(zend_op_array, opcodes)]
			|	// first_extra_arg = op_array->num_args;
			|	mov edx, dword [r0 + offsetof(zend_op_array, num_args)]
			|	// num_args = EX_NUM_ARGS();
			|	mov ecx, dword [FP + offsetof(zend_execute_data, This.u2.num_args)]
			|	// 	if (UNEXPECTED(num_args > first_extra_arg))
			|	cmp edx, ecx
			|	jl >1
			|.cold_code
			|1:
			|	EXT_CALL zend_jit_copy_extra_args_helper, r0
			|	mov r0, EX->func // reload
			|	mov ecx, dword [FP + offsetof(zend_execute_data, This.u2.num_args)] // reload
			|	jmp >1
			|.code
			|	// if (EXPECTED((op_array->fn_flags & ZEND_ACC_HAS_TYPE_HINTS) == 0))
			|	test dword [r0 + offsetof(zend_op_array, fn_flags)], ZEND_ACC_HAS_TYPE_HINTS
			|	jnz >1
			|	// opline += num_args;
			|.if X64
			|	movsxd r2, ecx
			|	imul r2, r2, sizeof(zend_op)
			|.else
			|	imul r2, ecx, sizeof(zend_op)
			|.endif
			|	add IP, r2
			|1:
			|	// if (EXPECTED((int)num_args < op_array->last_var)) {
			|	mov edx, dword [r0 + offsetof(zend_op_array, last_var)]
			|	sub edx, ecx
			|	jle >3 //???
			|	// zval *var = EX_VAR_NUM(num_args);
			|.if X64
			|	movsxd r1, ecx
			|.endif
			|	shl r1, 4
			|	lea r1, [FP + r1 + (ZEND_CALL_FRAME_SLOT * sizeof(zval))]
			|2:
			|	SET_Z_TYPE_INFO r1, IS_UNDEF
			|	sub edx, 1
			|	lea r1, [r1 + 16]
			|	jne <2
			|3:
		}

		if (func && op_array == &func->op_array) {
			/* recursive call */
#ifdef CONTEXT_THREADED_JIT
			|	call =>(call_info->num_args+ssa->cfg.blocks_count)
			|	cmp aword [&EG(exception)], 0
			|	jne ->exception_handler
			if (!func) {
				|	jmp >9
			}
#else
			|	jmp =>call_info->num_args
#endif
		} else {
#ifdef CONTEXT_THREADED_JIT
			|	call aword [IP]
			|	cmp aword [&EG(exception)], 0
			|	jne ->exception_handler
			if (!func) {
				|	jmp >9
			}
#else
			|	add r4, SPAD // stack alignment
			|	jmp aword [IP]
#endif
		}
	}

	if (!func || func->type == ZEND_INTERNAL_FUNCTION) {
		if (!func) {
			|8:
			if (opline->opcode == ZEND_DO_FCALL) {
				|	jg >8
				|.cold_code
				|8:
				if (RETURN_VALUE_USED(opline)) {
					|	// ZVAL_NULL(EX_VAR(opline->result.var));
					|	lea FCARG2a, aword [FP + opline->result.var]
					|	SET_Z_TYPE_INFO FCARG2a, IS_NULL
				} else {
					|	sub r4, 16 /* alloca() */
					|	lea FCARG2a, aword [r4 + 8]
					|	SET_Z_TYPE_INFO FCARG2a, IS_NULL
				}
				|	mov FCARG1a, RX
				|	EXT_CALL zend_do_fcall_overloaded, r0
				|	test r0, r0
				|	jne >8
				if (!RETURN_VALUE_USED(opline)) {
					|	add r4, 16 /* revert alloca() */
				}
				|	jmp ->exception_handler
				|.code
			}
		}
		if (opline->opcode == ZEND_DO_FCALL_BY_NAME) {
			if (!func) {
				|	test dword [r0 + offsetof(zend_op_array, fn_flags)], (ZEND_ACC_DEPRECATED|ZEND_ACC_ABSTRACT)
				|	jnz >1
				|.cold_code
				|1:
				|	EXT_CALL zend_jit_deprecated_or_abstract_helper, r0
				|	cmp aword [&EG(exception)], 0
				|	jne ->exception_handler
				|	mov r0, EX:RX->func // reload
				|	jmp >1
				|.code
				|1:
			} else if (func->common.fn_flags & ZEND_ACC_ABSTRACT) {
				|	EXT_CALL zend_jit_deprecated_or_abstract_helper, r0
				|	jmp ->exception_handler
			} else if (func->common.fn_flags & ZEND_ACC_DEPRECATED) {
				|	EXT_CALL zend_jit_deprecated_or_abstract_helper, r0
				|	cmp aword [&EG(exception)], 0
				|	jne ->exception_handler
				|	mov r0, EX:RX->func // reload
			}
		}

		if (RETURN_VALUE_USED(opline)) {
			|	// ZVAL_NULL(EX_VAR(opline->result.var));
			|	lea FCARG2a, aword [FP + opline->result.var]
			|	SET_Z_TYPE_INFO FCARG2a, IS_NULL
		} else {
			|	sub r4, 16 /* alloca() */
			|	lea FCARG2a, aword [r4 + 8]
			|	SET_Z_TYPE_INFO FCARG2a, IS_NULL
		}

		|	// EG(current_execute_data) = execute_data;
		|	mov aword [&EG(current_execute_data)], RX

		if (!func || (func->common.fn_flags & ZEND_ACC_HAS_TYPE_HINTS)) {
			if (!func) {
				|	test dword [r0 + offsetof(zend_op_array, fn_flags)], ZEND_ACC_HAS_TYPE_HINTS
				|	jnz >1
				|.cold_code
			}
			|1:
			|	mov FCARG1a, RX
			|	EXT_CALL zend_jit_verify_internal_arg_types_helper, r0
			|	test r0, r0
			|	je >8
			|	// reload
			if (RETURN_VALUE_USED(opline)) {
				|	lea FCARG2a, aword [FP + opline->result.var]
			} else {
				|	lea FCARG2a, aword [r4 + 8]
			}
			if (!func) {
				|	mov r0, EX:RX->func // reload
				|	jmp >1
				|.code
			}
			|1:
		}

		zend_jit_reset_opline(Dst, NULL);

		|	// fbc->internal_function.handler(call, ret);
		|.if X64
		|	mov FCARG1a, RX
		if (func) {
			|	EXT_CALL func->internal_function.handler, r0
		} else {
			|	call aword [r0 + offsetof(zend_internal_function, handler)]
		}
		|.else
		|	sub r4, 8
		|	push FCARG2a
		|	push RX
		if (func) {
			|	EXT_CALL func->internal_function.handler, r0
		} else {
			|	call aword [r0 + offsetof(zend_internal_function, handler)]
		}
		|	add r4, 16
		|.endif

		|	// EG(current_execute_data) = execute_data;
		|	mov aword [&EG(current_execute_data)], FP

		|	// zend_vm_stack_free_args(call);
		if (func) {
			for (i = 0; i < call_info->num_args; i++ ) {
				uint32_t offset = (uint32_t)(uintptr_t)ZEND_CALL_VAR_NUM(NULL, i);
				|	ZVAL_PTR_DTOR RX + offset, MAY_BE_ANY|MAY_BE_RC1|MAY_BE_RCN, 0, 1, 1, op_array->filename, opline
			}
		} else {
			|	mov FCARG1a, RX
			|	EXT_CALL zend_jit_vm_stack_free_args_helper, r0
		}

		|8:
		if (opline->opcode == ZEND_DO_FCALL) {
			// TODO: optimize ???
			|	// if (UNEXPECTED(ZEND_CALL_INFO(call) & ZEND_CALL_RELEASE_THIS))
			|	test byte [RX + offsetof(zend_execute_data, This.u1.type_info) + 2], ZEND_CALL_RELEASE_THIS
			|	jnz >1
			|.cold_code
			|1:
			|	GET_Z_PTR r0, RX + offsetof(zend_execute_data, This)
			if (opline->op1.num & ZEND_CALL_CTOR) {
				|	// if (UNEXPECTED(EG(exception)
				|	cmp aword [&EG(exception)], 0
				|	je >1
				|	// GC_REFCOUNT(object)--;
				|	GC_DELREF r0
				|	// zend_object_store_ctor_failed(object);
				|	// GC_FLAGS(obj) |= IS_OBJ_DESTRUCTOR_CALLED;
				|	or byte [r0 + offsetof(zend_object, gc.u.v.flags)], IS_OBJ_DESTRUCTOR_CALLED
				|1:
			}
			|	// OBJ_RELEASE(object);
			|	OBJ_RELEASE r0, ecx, >2
			|	jmp >2
			|.code
			|2:
		}

		|	// zend_vm_stack_free_call_frame(call);
		|	test byte [RX + offsetof(zend_execute_data, This.u1.type_info) + 2], ZEND_CALL_ALLOCATED
		|	jnz >1
		|.cold_code
		|1:
		|	mov FCARG1a, RX
		|	EXT_CALL zend_jit_free_call_frame, r0
		|	jmp >1
		|.code
		|	mov aword [&EG(vm_stack_top)], RX
		|1:

		if (opline->result_type == IS_UNUSED) {
			uint32_t func_info = call_info ?
				zend_get_func_info(call_info, ssa) :
				(MAY_BE_ANY|MAY_BE_REF|MAY_BE_RC1|MAY_BE_RCN);

			if (func_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF)) {
				|	ZVAL_PTR_DTOR r4 + 8, func_info, 1, 1, 0, op_array->filename, opline
			}
			|	add r4, 16 /* revert alloca() */
		}

		|	// if (UNEXPECTED(EG(exception) != NULL)) {
		|	cmp aword [&EG(exception)], 0
		|	jne >1
		|.cold_code
		|1:
		|	LOAD_ADDR IP, opline
		|	jmp ->icall_throw_handler
		|.code

		// TODO: Can we avoid checking for interrupts after each call ???
		if (!zend_jit_check_timeout(Dst, opline + 1)) {
			return 0;
		}
		if (opline->opcode != ZEND_DO_ICALL) {
			uint32_t target_label = ssa->cfg.map[opline - op_array->opcodes] + 1;

			|	LOAD_ADDR IP, (opline + 1)
			|	jmp =>target_label
		}
	}

	if (!func) {
		|9:
	}

	return 1;

fallback:
	/* fallback to subroutine threading */
	if (opline->opcode == ZEND_DO_FCALL ||
	    opline->opcode == ZEND_DO_UCALL ||
	    opline->opcode == ZEND_DO_FCALL_BY_NAME ){
		return zend_jit_call(Dst, opline);
	} else {
		return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
	}
}

static int zend_jit_send_val(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;
	uint32_t arg_num = opline->op2.num;

	if (opline->opcode == ZEND_SEND_VAL_EX && arg_num > MAX_ARG_FLAG_NUM) {
		goto fallback;
	}

	op1_info = OP1_INFO();

	if (!reuse_ip) {
		zend_jit_start_reuse_ip();
		|	// call = EX(call);
		|	mov RX, EX->call
	}

	if (opline->opcode == ZEND_SEND_VAL_EX) {
		uint32_t mask = ZEND_SEND_BY_REF << ((arg_num + 3) * 2);

		|	mov r0, EX:RX->func
		if (arg_num <= MAX_ARG_FLAG_NUM) {
			|	test dword [r0 + offsetof(zend_function, quick_arg_flags)], mask
			|	jnz	>1
		} else {
			ZEND_ASSERT(0);
		}
		|.cold_code
		|1:
		|	SAVE_VALID_OPLINE opline
		|	jmp ->throw_cannot_pass_by_ref
		|.code
	}

	if (opline->op1_type == IS_CONST) {
		zval *zv = RT_CONSTANT(op_array, opline->op1);

		|	ZVAL_COPY_CONST RX + opline->result.var, -1, zv, r0
		||	if (Z_REFCOUNTED_P(zv)) {
		|		ADDREF_CONST zv, r0
		||	}
	} else {
		|	ZVAL_COPY_VALUE RX + opline->result.var, FP + opline->op1.var, op1_info, r0, eax, r2
	}

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_send_ref(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa, int cold)
{
	uint32_t op1_info;

	op1_info = OP1_INFO();

	if (!reuse_ip) {
		zend_jit_start_reuse_ip();
		|	// call = EX(call);
		|	mov RX, EX->call
	}

	if (opline->op1_type == IS_VAR) {
		|	lea r0, [FP + opline->op1.var]
		|	// if (EXPECTED(Z_TYPE_P(ret) == IS_INDIRECT)) {
		|	IF_NOT_Z_TYPE r0, IS_INDIRECT, >1
		|	// ret = Z_INDIRECT_P(ret);
		|	GET_Z_PTR r0, r0
		|1:
		if (op1_info & MAY_BE_ERROR) {
			if (op1_info & (MAY_BE_ANY|MAY_BE_REF)) {
				if (cold) {
					|	IF_NOT_Z_TYPE r0, _IS_ERROR, >1
				} else {
					|	IF_Z_TYPE r0, _IS_ERROR, >1
					|.cold_code
					|1:
				}
			}

			|	// ZVAL_NEW_EMPTY_REF(arg);
			|	EMALLOC sizeof(zend_reference), op_array, opline
			|	SET_Z_PTR RX + opline->result.var, r0
			|	SET_Z_TYPE_INFO RX + opline->result.var, IS_REFERENCE_EX
			|	mov dword [r0], 1
			|	mov dword [r0 + 4], IS_REFERENCE;
			|	// ZVAL_NULL(Z_REFVAL_P(arg));
			|	SET_Z_TYPE_INFO r0 + 8, IS_NULL

			if (op1_info & (MAY_BE_ANY|MAY_BE_REF)) {
				|	jmp >7
				if (cold) {
					|1:
				} else {
					|.code
				}
			}
		}
	} else if (opline->op1_type == IS_CV) {
		if (op1_info & MAY_BE_UNDEF) {
			if (op1_info & (MAY_BE_ANY|MAY_BE_REF)) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_UNDEF, >1
				|	SET_Z_TYPE_INFO FP + opline->op1.var, IS_NULL
				|	jmp >2
				|1:
			}
			op1_info &= ~MAY_BE_UNDEF;
			op1_info |= MAY_BE_NULL;
		}
	} else {
		ZEND_ASSERT(0);
	}

	if (op1_info & (MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)) {
		if (op1_info & MAY_BE_REF) {
			if (opline->op1_type == IS_VAR) {
				|	IF_NOT_Z_TYPE r0, IS_REFERENCE, >2
				|	GET_Z_PTR r1, r0
			} else {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_REFERENCE, >2
				|	GET_Z_PTR r1, FP + opline->op1.var
			}
			|	GC_ADDREF r1
			|	SET_Z_PTR RX + opline->result.var, r1
			|	SET_Z_TYPE_INFO RX + opline->result.var, IS_REFERENCE_EX
			|	jmp	>6
		}
		|2:
		|	// ZVAL_NEW_REF(arg, varptr);
		if (opline->op1_type == IS_VAR) {
			|	mov aword [r4], r0 // save
		}
		|	EMALLOC sizeof(zend_reference), op_array, opline
		|	mov dword [r0], 2
		|	mov dword [r0 + 4], IS_REFERENCE;
		if (opline->op1_type == IS_VAR) {
			|	mov r1, aword [r4] // restore
			|	ZVAL_COPY_VALUE_clobber_src r0 + 8, r1, op1_info, r1, ecx, r2
			|	mov r1, aword [r4] // restore
			|	SET_Z_PTR r1, r0
			|	SET_Z_TYPE_INFO r1, IS_REFERENCE_EX
		} else {
			|	ZVAL_COPY_VALUE r0 + 8, FP + opline->op1.var, op1_info, r1, ecx, r2
			|	SET_Z_PTR FP + opline->op1.var, r0
			|	SET_Z_TYPE_INFO FP + opline->op1.var, IS_REFERENCE_EX
		}
		|	SET_Z_PTR RX + opline->result.var, r0
		|	SET_Z_TYPE_INFO RX + opline->result.var, IS_REFERENCE_EX
	}

	|6:
	|	FREE_OP opline->op1_type, opline->op1, op1_info, !cold, op_array, opline
	|7:

	return 1;
}

static int zend_jit_send_var(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;
	uint32_t arg_num = opline->op2.num;

	if ((opline->opcode == ZEND_SEND_VAR_EX ||
	     opline->opcode == ZEND_SEND_VAR_NO_REF_EX) &&
	    arg_num > MAX_ARG_FLAG_NUM) {
		goto fallback;
	}

	op1_info = OP1_INFO();

	if (!reuse_ip) {
		zend_jit_start_reuse_ip();
		|	// call = EX(call);
		|	mov RX, EX->call
	}

	if (opline->opcode == ZEND_SEND_VAR_EX || opline->opcode == ZEND_SEND_VAR_NO_REF_EX) {
		uint32_t mask;

		if (opline->opcode == ZEND_SEND_VAR_EX) {
			mask = ZEND_SEND_BY_REF << ((arg_num + 3) * 2);
		} else {
			mask = (ZEND_SEND_BY_REF|ZEND_SEND_PREFER_REF) << ((arg_num + 3) * 2);
		}

		|	mov r0, EX:RX->func
		if (arg_num <= MAX_ARG_FLAG_NUM) {
			|	test dword [r0 + offsetof(zend_function, quick_arg_flags)], mask
			|	jnz	>1
		} else {
			ZEND_ASSERT(0);
		}

		|.cold_code
		|1:

		if (opline->opcode == ZEND_SEND_VAR_EX) {
			if (!zend_jit_send_ref(Dst, opline, op_array, ssa, 1)) {
				return 0;
			}
		} else if (opline->opcode == ZEND_SEND_VAR_NO_REF_EX) {
			mask = ZEND_SEND_PREFER_REF << ((arg_num + 3) * 2);

			|	ZVAL_COPY_VALUE RX + opline->result.var, FP + opline->op1.var, op1_info, r1, ecx, r2
			if (op1_info & MAY_BE_REF) {
				|	cmp cl, IS_REFERENCE
				|	je >7
			}
			|	test dword [r0 + offsetof(zend_function, quick_arg_flags)], mask
			|	jnz >7
			|	SAVE_VALID_OPLINE opline
			|.if X64
			|	mov CARG1, E_NOTICE
			|	LOAD_ADDR CARG2, "Only variables should be passed by reference"
			|	EXT_CALL zend_error, r0
			|.else
			|	sub r4, 8
			|	push "Only variables should be passed by reference"
			|	push E_NOTICE
			|	EXT_CALL zend_error, r0
			|	add r4, 16
			|.endif
			if (!zend_jit_check_exception(Dst)) {
				return 0;
			}
		} else {
			ZEND_ASSERT(0);
		}

		|	jmp >7
		|.code
	}

	if (op1_info & MAY_BE_UNDEF) {
		if (op1_info & (MAY_BE_ANY|MAY_BE_REF)) {
			|	IF_Z_TYPE FP + opline->op1.var, IS_UNDEF, >1
			|.cold_code
			|1:
		}

		|	SAVE_VALID_OPLINE opline
		|	mov FCARG1d, opline->op1.var
		|	EXT_CALL zend_jit_undefined_op_helper, r0
		|	SET_Z_TYPE_INFO RX + opline->result.var, IS_NULL

		if (op1_info & (MAY_BE_ANY|MAY_BE_REF)) {
			|	jmp >7
			|.code
		}
	}

	if (opline->opcode == ZEND_SEND_VAR_NO_REF) {
		|	ZVAL_COPY_VALUE RX + opline->result.var, FP + opline->op1.var, op1_info, r1, ecx, r2
		if (op1_info & MAY_BE_REF) {
			|	cmp cl, IS_REFERENCE
			|	je >7
		}
		|	SAVE_VALID_OPLINE opline
		|.if X64
		|	mov CARG1, E_NOTICE
		|	LOAD_ADDR CARG2, "Only variables should be passed by reference"
		|	EXT_CALL zend_error, r0
		|.else
		|	sub r4, 8
		|	push "Only variables should be passed by reference"
		|	push E_NOTICE
		|	EXT_CALL zend_error, r0
		|	add r4, 16
		|.endif
		if (!zend_jit_check_exception(Dst)) {
			return 0;
		}
	} else if (op1_info & (MAY_BE_ANY|MAY_BE_REF)) {
		if (op1_info & MAY_BE_REF) {
			if (opline->op1_type == IS_CV) {
				|	lea FCARG1a, [FP + opline->op1.var]
				|	ZVAL_DEREF FCARG1a, op1_info
				|	ZVAL_COPY_VALUE RX + opline->result.var, FCARG1a, op1_info, r0, eax, r2
				|	TRY_ADDREF op1_info, ah, r2
			} else {
				|	IF_Z_TYPE FP + opline->op1.var, IS_REFERENCE, >1
				|.cold_code
				|1:
				|	// zend_refcounted *ref = Z_COUNTED_P(retval_ptr);
				|	GET_Z_PTR FCARG1a, FP + opline->op1.var
				|	// ZVAL_COPY_VALUE(return_value, &ref->value);
				|	ZVAL_COPY_VALUE RX + opline->result.var, FCARG1a + 8, op1_info, r0, eax, r2
				|	GC_DELREF FCARG1a
				|	je >1
				|	IF_NOT_REFCOUNTED ah, >2
				|	GC_ADDREF r2
				|	jmp >2
				|1:
				|	EFREE_REG_24 op_array, opline
				|	jmp >2
				|.code
				|	ZVAL_COPY_VALUE RX + opline->result.var, FP + opline->op1.var, op1_info, r0, eax, r2
				|2:
			}
		} else {
			|	ZVAL_COPY_VALUE RX + opline->result.var, FP + opline->op1.var, op1_info, r0, eax, r2
			||	if (opline->op1_type == IS_CV) {
			|		TRY_ADDREF op1_info, ah, r2
			||	}
		}
	}
	|7:

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_smart_true(dasm_State **Dst, const zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa, int jmp)
{
	uint32_t target_label;

	if ((opline+1)->opcode == ZEND_JMPZ &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		if (jmp) {
			|	jmp >7
		}
	} else if ((opline+1)->opcode == ZEND_JMPNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		| 	jmp =>target_label
	} else if ((opline+1)->opcode == ZEND_JMPZNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[1];
		| 	jmp =>target_label
	} else {
		|	SET_Z_TYPE_INFO FP + opline->result.var, IS_TRUE
		if (jmp) {
			|	jmp >7
		}
	}

	return 1;
}

static int zend_jit_smart_false(dasm_State **Dst, const zend_op *opline, int b, zend_op_array *op_array, zend_ssa *ssa, int jmp)
{
	uint32_t target_label;

	if ((opline+1)->opcode == ZEND_JMPZ &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		| 	jmp =>target_label
	} else if ((opline+1)->opcode == ZEND_JMPNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		if (jmp) {
			|	jmp >7
		}
	} else if ((opline+1)->opcode == ZEND_JMPZNZ &&
	           (opline+1)->op1_type == IS_TMP_VAR &&
	           (opline+1)->op1.var == opline->result.var) {
		target_label = ssa->cfg.blocks[b].successors[0];
		| 	jmp =>target_label
	} else {
		|	SET_Z_TYPE_INFO FP + opline->result.var, IS_FALSE
		if (jmp) {
			|	jmp >7
		}
	}

	return 1;
}

static int zend_jit_defined(dasm_State **Dst, const zend_op *opline, int b, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	zend_bool smart_branch = 0;
	uint32_t defined_label = (uint32_t)-1;
	uint32_t undefined_label = (uint32_t)-1;
	zval *zv = RT_CONSTANT(op_array, opline->op1);

	if (((opline+1)->opcode == ZEND_JMPZ ||
	     (opline+1)->opcode == ZEND_JMPNZ ||
	     (opline+1)->opcode == ZEND_JMPZNZ) &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		(*opnum)++;
		smart_branch = 1;
	}

	if (smart_branch) {
		if ((opline+1)->opcode == ZEND_JMPZ) {
			undefined_label = ssa->cfg.blocks[b].successors[0];
		} else if ((opline+1)->opcode == ZEND_JMPNZ) {
			defined_label = ssa->cfg.blocks[b].successors[0];
		} else if ((opline+1)->opcode == ZEND_JMPZNZ) {
			undefined_label = ssa->cfg.blocks[b].successors[0];
			defined_label = ssa->cfg.blocks[b].successors[1];
		} else {
			ZEND_ASSERT(0);
		}
	}

	|	// if (CACHED_PTR(Z_CACHE_SLOT_P(EX_CONSTANT(opline->op1)))) {
	|	mov r0,	EX->run_time_cache
	|	mov r0, aword [r0 + Z_CACHE_SLOT_P(zv)]
	|	test r0, r0
	|	jz >1
	|.cold_code
	|1:
	|	LOAD_ADDR FCARG1a, zv
	|	xor FCARG2d, FCARG2d
	|	EXT_CALL zend_quick_get_constant, r0
	|	test r0, r0
	if (smart_branch) {
		if (undefined_label != (uint32_t)-1) {
			|	jz =>undefined_label
		} else {
			|	jz >3
		}
	}
	|	mov r0,	EX->run_time_cache
	|	mov r0, aword [r0 + Z_CACHE_SLOT_P(zv)]
	if (smart_branch) {
		if (defined_label != (uint32_t)-1) {
			|	jmp =>defined_label
		} else {
			|	jmp >3
		}
	} else {
		|	add eax, IS_FALSE
		|	SET_Z_TYPE_INFO FP + opline->result.var, eax
		|	jmp >3
	}
	|.code
	if (smart_branch) {
		if (defined_label != (uint32_t)-1) {
			|	jmp =>defined_label
		}
	} else {
		|	SET_Z_TYPE_INFO FP + opline->result.var, IS_TRUE
	}
	|3:

	return 1;
}

static int zend_jit_type_check(dasm_State **Dst, const zend_op *opline, int b, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, mask;
	uint32_t target_label;
	zend_uchar type;
	zend_bool smart_branch = 0;

	if (opline->extended_value == IS_RESOURCE) {
		// TODO: support for is_resource() ???
		goto fallback;
	}

	if (((opline+1)->opcode == ZEND_JMPZ ||
	     (opline+1)->opcode == ZEND_JMPNZ ||
	     (opline+1)->opcode == ZEND_JMPZNZ) &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		(*opnum)++;
		smart_branch = 1;
	}

	op1_info = OP1_INFO();
	if (op1_info & MAY_BE_UNDEF) {
		if (op1_info & (MAY_BE_ANY|MAY_BE_REF)) {
			|	IF_Z_TYPE FP + opline->op1.var, IS_UNDEF, >1
			|.cold_code
			|1:
		}
		|	SAVE_VALID_OPLINE opline
		|	mov FCARG1d, opline->op1.var
		|	EXT_CALL zend_jit_undefined_op_helper, r0
		if (opline->extended_value == IS_NULL) {
			if (!zend_jit_smart_true(Dst, opline, b, op_array, ssa, (op1_info & (MAY_BE_ANY|MAY_BE_REF)) != 0)) {
				return 0;
			}
		} else {
			if (!zend_jit_smart_false(Dst, opline, b, op_array, ssa, (op1_info & (MAY_BE_ANY|MAY_BE_REF)) != 0)) {
				return 0;
			}
		}
		if (op1_info & (MAY_BE_ANY|MAY_BE_REF)) {
			|.code
		}
	}

	if (op1_info & (MAY_BE_ANY|MAY_BE_REF)) {
		type = opline->extended_value;
		if (type == _IS_BOOL) {
			mask = MAY_BE_FALSE | MAY_BE_TRUE;
		} else {
			mask = (1 << type);
		}

		if (!(op1_info & (MAY_BE_ANY - mask))) {
			|	FREE_OP opline->op1_type, opline->op1, op1_info, 1, op_array, opline
			if (!zend_jit_smart_true(Dst, opline, b, op_array, ssa, 0)) {
				return 0;
			}
	    } else if (!(op1_info & mask)) {
			|	FREE_OP opline->op1_type, opline->op1, op1_info, 1, op_array, opline
			if (!zend_jit_smart_false(Dst, opline, b, op_array, ssa, 0)) {
				return 0;
			}
		} else {
			if (op1_info & MAY_BE_REF) {
				|	LOAD_ZVAL_ADDR r0, opline->op1_type, opline->op1
				|	ZVAL_DEREF r0, op1_info
			}
			if (opline->extended_value == _IS_BOOL) {
				if (smart_branch &&
				    (opline->op1_type & (IS_VAR|IS_TMP_VAR)) &&
				    (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
					if ((op1_info) & (MAY_BE_ANY-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
						|	// if (Z_REFCOUNTED_P(cv)) {
						|	IF_Z_REFCOUNTED FP + opline->op1.var, >1
						|.cold_code
						|1:
					}
					|	// if (!Z_DELREF_P(cv)) {
					|	GET_Z_PTR FCARG1a, FP + opline->op1.var
					|	GC_DELREF FCARG1a
					if (RC_MAY_BE_1(op1_info)) {
						if (RC_MAY_BE_N(op1_info)) {
							|	jnz >3
						}
						if (op1_info & MAY_BE_REF) {
							|	mov al, byte [r0 + 8]
						} else {
							|	mov al, byte [FP + opline->op1.var + 8]
						}
						|	mov byte [r4], al // save
						|	// zval_dtor_func(r);
						|	ZVAL_DTOR_FUNC op1_info, op_array->filename, opline
						|	mov cl, byte [r4] // restore
						|jmp >2
					}
					if ((op1_info) & (MAY_BE_ANY-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
						if (!RC_MAY_BE_1(op1_info)) {
							|	jmp >3
						}
						|.code
					}
					|3:
					if (op1_info & MAY_BE_REF) {
						|	mov cl, byte [r0 + 8]
					} else {
						|	mov cl, byte [FP + opline->op1.var + 8]
					}
					|2:
                } else {
					if (op1_info & MAY_BE_REF) {
						|	mov cl, byte [r0 + 8]
					} else {
						|	mov cl, byte [FP + opline->op1.var + 8]
					}
				}
				|	mov al, 1
				|	shl al, cl
				|	test al, 0xc
				if ((opline+1)->opcode == ZEND_JMPZ &&
				    (opline+1)->op1_type == IS_TMP_VAR &&
				    (opline+1)->op1.var == opline->result.var) {
					target_label = ssa->cfg.blocks[b].successors[0];
					| 	je =>target_label
				} else if ((opline+1)->opcode == ZEND_JMPNZ &&
				           (opline+1)->op1_type == IS_TMP_VAR &&
				           (opline+1)->op1.var == opline->result.var) {
					target_label = ssa->cfg.blocks[b].successors[0];
					| 	jne =>target_label
				} else if ((opline+1)->opcode == ZEND_JMPZNZ &&
				           (opline+1)->op1_type == IS_TMP_VAR &&
				           (opline+1)->op1.var == opline->result.var) {
					target_label = ssa->cfg.blocks[b].successors[0];
					| 	je =>target_label
					target_label = ssa->cfg.blocks[b].successors[1];
					| 	jmp =>target_label
				} else {
					|	setne al
					|	movzx eax, al
					|	add eax, 2
					|	SET_Z_TYPE_INFO FP + opline->result.var, eax
					|	FREE_OP opline->op1_type, opline->op1, op1_info, 1, op_array, opline
				}
			} else if (opline->extended_value == IS_RESOURCE) {
				ZEND_ASSERT(0);
			} else {
				if (smart_branch &&
				    (opline->op1_type & (IS_VAR|IS_TMP_VAR)) &&
				    (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
					if ((op1_info) & (MAY_BE_ANY-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
						|	// if (Z_REFCOUNTED_P(cv)) {
						|	IF_Z_REFCOUNTED FP + opline->op1.var, >1
						|.cold_code
						|1:
					}
					|	// if (!Z_DELREF_P(cv)) {
					|	GET_Z_PTR FCARG1a, FP + opline->op1.var
					|	GC_DELREF FCARG1a
					if (RC_MAY_BE_1(op1_info)) {
						if (RC_MAY_BE_N(op1_info)) {
							|	jnz >3
						}
						if (op1_info & MAY_BE_REF) {
							|	mov al, byte [r0 + 8]
						} else {
							|	mov al, byte [FP + opline->op1.var + 8]
						}
						|	mov byte [r4], al // save
						|	// zval_dtor_func(r);
						|	ZVAL_DTOR_FUNC op1_info, op_array->filename, opline
						|	mov cl, byte [r4] // restore
						|jmp >2
					}
					if ((op1_info) & (MAY_BE_ANY-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
						if (!RC_MAY_BE_1(op1_info)) {
							|	jmp >3
						}
						|.code
					}
					|3:
					if (op1_info & MAY_BE_REF) {
						|	mov cl, byte [r0 + 8]
					} else {
						|	mov cl, byte [FP + opline->op1.var + 8]
					}
					|2:
					|	cmp cl, opline->extended_value
				} else {
					if (op1_info & MAY_BE_REF) {
						|	cmp byte [r0 + 8], opline->extended_value
					} else {
						|	cmp byte [FP + opline->op1.var + 8], opline->extended_value
					}
				}
				if ((opline+1)->opcode == ZEND_JMPZ &&
				    (opline+1)->op1_type == IS_TMP_VAR &&
				    (opline+1)->op1.var == opline->result.var) {
					target_label = ssa->cfg.blocks[b].successors[0];
					| 	jne =>target_label
				} else if ((opline+1)->opcode == ZEND_JMPNZ &&
				           (opline+1)->op1_type == IS_TMP_VAR &&
				           (opline+1)->op1.var == opline->result.var) {
					target_label = ssa->cfg.blocks[b].successors[0];
					| 	je =>target_label
				} else if ((opline+1)->opcode == ZEND_JMPZNZ &&
				           (opline+1)->op1_type == IS_TMP_VAR &&
				           (opline+1)->op1.var == opline->result.var) {
					target_label = ssa->cfg.blocks[b].successors[0];
					| 	jne =>target_label
					target_label = ssa->cfg.blocks[b].successors[1];
					| 	jmp =>target_label
				} else {
					|	sete al
					|	movzx eax, al
					|	add eax, 2
					|	SET_Z_TYPE_INFO FP + opline->result.var, eax
					|	FREE_OP opline->op1_type, opline->op1, op1_info, 1, op_array, opline
				}
			}
	    }
	}

	|7:

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_free_compiled_variables(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
    uint32_t i, j, info;

	// Use type inference to avoid useless zval_ptr_dtor()
	for (i = 0 ; i < op_array->last_var; i++) {
		if (ssa->vars && ssa->var_info) {
			info = ssa->var_info[i].type;
			for (j = op_array->last_var; j < ssa->vars_count; j++) {
				if (ssa->vars[j].var == i) {
					info |= ssa->var_info[j].type;
				}
			}
		} else {
			info = MAY_BE_RC1 | MAY_BE_RCN | MAY_BE_REF | MAY_BE_ANY | MAY_BE_UNDEF;
		}

#ifdef ZEND_JIT_USE_RC_INFERENCE
		/* Refcount may be increased by RETRUN opcode */
		if ((info & MAY_BE_RC1) && !(info & MAY_BE_RCN)) {
			for (j = 0; j < ssa->cfg.blocks_count; j++) {
				if ((ssa->cfg.blocks[j].flags & ZEND_BB_REACHABLE) &&
				    ssa->cfg.blocks[j].len > 0) {
					const zend_op *opline = op_array->opcodes + ssa->cfg.blocks[j].start + ssa->cfg.blocks[j].len - 1;

					if (opline->opcode == ZEND_RETURN) {
						if (opline->op1_type == IS_CV &&
						    opline->op1.var == (uint32_t)(uintptr_t)(ZEND_CALL_VAR_NUM(NULL, i))) {
							info |= MAY_BE_RCN;
							break;
						}
					}
				}
			}
		}
#endif

		if (info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF)) {
			uint32_t offset = (uint32_t)(uintptr_t)ZEND_CALL_VAR_NUM(NULL, i);
			| ZVAL_PTR_DTOR FP + offset, info, 1, 1, 1, op_array->filename, opline
		}
	}
	return 1;
}

static int zend_jit_leave_func(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	// Avoid multiple leave sequnces
	if (jit_return_label >= 0) {
		| jmp =>jit_return_label
		return 1;
	}

	jit_return_label = ssa->cfg.blocks_count * 2;

	|=>jit_return_label:

	// i_free_compiled_variables(execute_data);
	if (!zend_jit_free_compiled_variables(Dst, opline, op_array, ssa)) {
		return 0;
	}

	|	movzx FCARG1d, word [FP + offsetof(zend_execute_data, This.u1.type_info) + 2]
	|	test FCARG1d, (ZEND_CALL_TOP|ZEND_CALL_HAS_SYMBOL_TABLE|ZEND_CALL_FREE_EXTRA_ARGS|ZEND_CALL_ALLOCATED|ZEND_CALL_FAKE_CLOSURE)
	|	jnz ->leave_function_handler

	if (op_array->scope || (op_array->fn_flags & ZEND_ACC_CLOSURE)) {
		|	// EG(current_execute_data) = EX(prev_execute_data);
		|	mov r0, EX->prev_execute_data
		|	mov aword [&EG(current_execute_data)], r0
		if (op_array->scope) {
			|	// if (call_info & ZEND_CALL_RELEASE_THIS)
			|	test FCARG1d, ZEND_CALL_RELEASE_THIS
			if (op_array->fn_flags & ZEND_ACC_STATIC) {
				|	jnz >1
				|.cold_code
				|1:
			} else {
				|	je >2
			}
			|	// zend_object *object = Z_OBJ(execute_data->This);
			|	mov r0, EX->This.value.obj
			if (op_array->scope && op_array->scope->constructor == (zend_function*)op_array) {
				|	// if (UNEXPECTED(EG(exception) != NULL)
				|	cmp aword [&EG(exception)], 0
				|	jne >6
				|.cold_code
				|6:
				|	// if (call_info & ZEND_CALL_CTOR)
				|	test FCARG1d, ZEND_CALL_CTOR
				|	jz >5
				|	// GC_REFCOUNT(object)--;
				|	GC_DELREF r0
				|	// zend_object_store_ctor_failed(object);
				|	// GC_FLAGS(obj) |= IS_OBJ_DESTRUCTOR_CALLED;
				|	or byte [r0 + offsetof(zend_object, gc.u.v.flags)], IS_OBJ_DESTRUCTOR_CALLED
				|	jmp >5
				|.code
				|5:
			}
			|	// OBJ_RELEASE(object);
			|	OBJ_RELEASE r0, ecx, >4
			if (op_array->fn_flags & (ZEND_ACC_CLOSURE|ZEND_ACC_STATIC)) {
				|	jmp >4
			}
			if (op_array->fn_flags & ZEND_ACC_STATIC) {
				|.code
			} else {
				|2:
			}
		}
		if (op_array->fn_flags & ZEND_ACC_CLOSURE) {
			|	test FCARG1d, ZEND_CALL_CLOSURE
			|	jnz >3
			|.cold_code
			|3:
			|	// OBJ_RELEASE((zend_object*)execute_data->func->op_array.prototype);
			|	mov r0, EX->func
			|	mov r0, aword [r0 + offsetof(zend_op_array, prototype)]
			|	OBJ_RELEASE r0, ecx, >4
			|	jmp >4
			|.code
		}
		|4:
		|	// EG(vm_stack_top) = (zval*)execute_data;
		|	mov aword [&EG(vm_stack_top)], FP
		|	// execute_data = EX(prev_execute_data);
		|	mov FP, EX->prev_execute_data
	} else {
		|	// EG(vm_stack_top) = (zval*)execute_data;
		|	mov aword [&EG(vm_stack_top)], FP
		|	// execute_data = EX(prev_execute_data);
		|	mov FP, EX->prev_execute_data
		|	// EG(current_execute_data) = execute_data
		|	mov aword [&EG(current_execute_data)], FP
	}
	|	// if (EG(exception))
	|	cmp aword [&EG(exception)], 0
	|	mov IP, EX->opline
	|	jne ->leave_throw_handler
	|	// opline = EX(opline) + 1
	|	add IP, sizeof(zend_op)
	|	add r4, SPAD // stack alignment
#ifdef CONTEXT_THREADED_JIT
	|	ret
#else
	|	jmp aword [IP]
#endif

	return 1;
}

static int zend_jit_return(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;

	if (op_array->type == ZEND_EVAL_CODE || !op_array->function_name || !ssa->ops || !ssa->var_info) {
		// TODO: support for top-level code
		return zend_jit_tail_handler(Dst, opline);
	}

	op1_info = OP1_INFO();
	if (opline->op1_type == IS_CV && (op1_info & MAY_BE_UNDEF)) {
		// TODO: support for IS_UNDEF ???
		return zend_jit_tail_handler(Dst, opline);
	}

	// if (!EX(return_value))
	|	mov r1, EX->return_value
	|	test r1, r1
	if ((opline->op1_type & (IS_VAR|IS_TMP_VAR)) &&
	    (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
		|	jz >1
		|.cold_code
		|1:
		||	if (op1_info & ((MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
		||		if (jit_return_label >= 0) {
		|			IF_NOT_Z_REFCOUNTED FP + opline->op1.var, =>jit_return_label
		||		} else {
		|			IF_NOT_Z_REFCOUNTED FP + opline->op1.var, >9
		||		}
		||	}
		|	GET_Z_PTR FCARG1a, FP + opline->op1.var
		|	GC_DELREF FCARG1a
		||	if (RC_MAY_BE_1(op1_info)) {
		||		if (RC_MAY_BE_N(op1_info)) {
		||			if (jit_return_label >= 0) {
		|				jnz =>jit_return_label
		||			} else {
		|				jnz >9
		||			}
		||		}
		|		//SAVE_OPLINE()
		|		SAVE_VALID_OPLINE opline
		|		ZVAL_DTOR_FUNC op1_info, op_array->filename, opline
		|		//????mov r1, EX->return_value // reload ???
		||	}
		||	if (jit_return_label >= 0) {
		|		jmp =>jit_return_label
		||	} else {
		|		jmp >9
		||	}
		|.code
	} else {
		||	if (jit_return_label >= 0) {
		|		jz =>jit_return_label
		||	} else {
		|		jz >9
		||	}
	}

	if (opline->op1_type == IS_CONST) {
		zval *zv = RT_CONSTANT(op_array, opline->op1);
		|	ZVAL_COPY_CONST r1, -1, zv, r0
		if (Z_REFCOUNTED_P(zv)) {
		|	ADDREF_CONST zv, r0
		}
	} else if (opline->op1_type == IS_TMP_VAR) {
		|	ZVAL_COPY_VALUE r1, FP + opline->op1.var, op1_info, r0, eax, r2
	} else if (opline->op1_type == IS_CV) {
		if (op1_info & MAY_BE_REF) {
			|	lea r0, [FP + opline->op1.var]
			|	ZVAL_DEREF r0, op1_info
			|	ZVAL_COPY_VALUE_clobber_src r1, r0, op1_info, r0, eax, r2
			|	TRY_ADDREF op1_info, ah, r2
		} else {
			|	ZVAL_COPY_VALUE r1, FP + opline->op1.var, op1_info, r0, eax, r2
			|	// TODO: JIT: if (EXPECTED(!(EX_CALL_INFO() & ZEND_CALL_CODE))) ZVAL_NULL(retval_ptr); ???
			|	TRY_ADDREF op1_info, ah, r2
		}
	} else {
		if (op1_info & MAY_BE_REF) {
			|	IF_Z_TYPE FP + opline->op1.var, IS_REFERENCE, >1
			|.cold_code
			|1:
			|	// zend_refcounted *ref = Z_COUNTED_P(retval_ptr);
			|	GET_Z_PTR r0, FP + opline->op1.var
			|	// ZVAL_COPY_VALUE(return_value, &ref->value);
			|.if X64
			|	GET_Z_PTR r2, r0 + offsetof(zend_reference, val)
			|	SET_Z_PTR r1, r2
			|.else
			|	GET_Z_PTR r2, r0 + offsetof(zend_reference, val)
			|	SET_Z_PTR r1, r2
			|	GET_Z_W2 r2, r0 + offsetof(zend_reference, val)
			|	SET_Z_W2 r1 + 4, r2
			|.endif
			|	GET_Z_TYPE_INFO edx, r0 + offsetof(zend_reference, val)
			|	SET_Z_TYPE_INFO r1, edx
			|	GC_DELREF r0
			|	je >2
			|	// if (IS_REFCOUNTED())
			||	if (jit_return_label >= 0) {
			|		IF_NOT_REFCOUNTED dh, =>jit_return_label
			||	} else {
			|		IF_NOT_REFCOUNTED dh, >9
			||	}
			|	// ADDREF
			|	GET_Z_PTR r2, r1
			|	GC_ADDREF r2
			||	if (jit_return_label >= 0) {
			|		jmp =>jit_return_label
			||	} else {
			|		jmp >9
			||	}
			|2:
			|	EFREE_24 r0, op_array, opline
			||	if (jit_return_label >= 0) {
			|		jmp =>jit_return_label
			||	} else {
			|		jmp >9
			||	}
			|.code
		}
		|	ZVAL_COPY_VALUE r1, FP + opline->op1.var, op1_info, r0, eax, r2
	}

	|9:
	//JIT: ZEND_VM_DISPATCH_TO_HELPER(zend_leave_helper);
	return zend_jit_leave_func(Dst, opline, op_array, ssa);
}

static int zend_jit_fetch_dim_read(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info, res_info;

	if (!ssa->ops || !ssa->var_info) {
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();
	res_info = RES_INFO();

	if (op1_info & MAY_BE_REF) {
		|	lea FCARG1a, [FP + opline->op1.var]
		|	ZVAL_DEREF FCARG1a, op1_info
	}

	if (op1_info & MAY_BE_ARRAY) {
		if (op1_info & MAY_BE_REF) {
			|	IF_NOT_Z_TYPE FCARG1a, IS_ARRAY, >7
			|	GET_Z_PTR FCARG1a, FCARG1a
		} else {
			if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - MAY_BE_ARRAY)) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_ARRAY, >7
			}
			|	LONG_LOAD FCARG1a, opline->op1_type, opline->op1
		}
		if (!zend_jit_fetch_dimension_address_inner(Dst, opline, op_array, (opline->opcode == ZEND_FETCH_DIM_R) ? BP_VAR_R : BP_VAR_IS, op1_info, op2_info, 8, 9)) {
			return 0;
		}
	}

	if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-MAY_BE_ARRAY)) {
		if (op1_info & MAY_BE_ARRAY) {
			|.cold_code
			|7:
		}

		if (op1_info & MAY_BE_STRING) {
			if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_ARRAY|MAY_BE_STRING))) {
			    if (op1_info & MAY_BE_REF) {
					|	IF_NOT_Z_TYPE FCARG1a, IS_STRING, >6
				} else {
					|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_STRING, >6
			    }
			}
			|	SAVE_VALID_OPLINE opline
		    if (!(op1_info & MAY_BE_REF)) {
				|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		    }
			|	LOAD_ZVAL_ADDR FCARG2a, opline->op2_type, opline->op2
			|.if X64
			|   lea CARG3, [FP + opline->result.var]
			|.else
			|   lea r0, [FP + opline->result.var]
			|	push r0
			|.endif
			if (opline->opcode == ZEND_FETCH_DIM_R) {
				|	EXT_CALL zend_jit_fetch_dim_str_r_helper, r0
			} else if (opline->opcode == ZEND_FETCH_DIM_IS) {
				|	EXT_CALL zend_jit_fetch_dim_str_is_helper, r0
			} else {
				ZEND_ASSERT(0);
			}
			if ((op1_info & MAY_BE_ARRAY) ||
				(op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_ARRAY|MAY_BE_STRING)))) {
			|	jmp >9 // END
			}
			|6:
		}

		if (op1_info & MAY_BE_OBJECT) {
			if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_ARRAY|MAY_BE_STRING|MAY_BE_OBJECT))) {
			    if (op1_info & MAY_BE_REF) {
					|	IF_NOT_Z_TYPE FCARG1a, IS_OBJECT, >6
				} else {
					|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_OBJECT, >6
			    }
			}
			|	SAVE_VALID_OPLINE opline
		    if (!(op1_info & MAY_BE_REF)) {
				|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		    }
			|	LOAD_ZVAL_ADDR FCARG2a, opline->op2_type, opline->op2
			|.if X64
			|   lea CARG3, [FP + opline->result.var]
			|.else
			|   lea r0, [FP + opline->result.var]
			|	push r0
			|.endif
			if (opline->opcode == ZEND_FETCH_DIM_R) {
				|	EXT_CALL zend_jit_fetch_dim_obj_r_helper, r0
			} else if (opline->opcode == ZEND_FETCH_DIM_IS) {
				|	EXT_CALL zend_jit_fetch_dim_obj_is_helper, r0
			} else {
				ZEND_ASSERT(0);
			}
			if ((op1_info & MAY_BE_ARRAY) ||
				(op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_ARRAY|MAY_BE_STRING|MAY_BE_OBJECT)))) {
			|	jmp >9 // END
			}
			|6:
		}

		if ((opline->opcode != ZEND_FETCH_DIM_IS && (op1_info & MAY_BE_UNDEF)) || (op2_info & MAY_BE_UNDEF)) {
			|	SAVE_VALID_OPLINE opline
			if (opline->opcode != ZEND_FETCH_DIM_IS && (op1_info & MAY_BE_UNDEF)) {
				if (op1_info & MAY_BE_REF) {
					|	IF_NOT_Z_TYPE FCARG1a, IS_UNDEF, >1
				} else {
					|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_UNDEF, >1
				}
				|	// zend_error(E_NOTICE, "Undefined variable: %s", ZSTR_VAL(CV_DEF_OF(EX_VAR_TO_NUM(opline->op1.var))));
				|	mov FCARG1d, opline->op1.var
				|	EXT_CALL zend_jit_undefined_op_helper, r0
				|1:
			}

			if (op2_info & MAY_BE_UNDEF) {
				|	IF_NOT_Z_TYPE FP + opline->op2.var, IS_UNDEF, >1
				|	mov FCARG1d, opline->op2.var
				|	EXT_CALL zend_jit_undefined_op_helper, r0
				|1:
			}
		}

		if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_ARRAY|MAY_BE_STRING|MAY_BE_OBJECT))) {
			|	SET_Z_TYPE_INFO FP + opline->result.var, IS_NULL
			if (op1_info & MAY_BE_ARRAY) {
			|	jmp >9 // END
			}
		}

		if (op1_info & MAY_BE_ARRAY) {
			|.code
		}
	}

	if (op1_info & MAY_BE_ARRAY) {
		|8:
		if (res_info & MAY_BE_REF) {
		|	// ZVAL_COPY_UNREF
			if (res_info & ((MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)-(MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
			|	IF_NOT_Z_REFCOUNTED r0, >2
			}
		|	GET_Z_PTR r1, r0
		|	IF_NOT_Z_TYPE r0, IS_REFERENCE, >1
		|	cmp dword [r1], 1
		|	jne >1
		|	lea FCARG1a, [FP + opline->result.var]
		|	mov FCARG2a, r0
		|	EXT_CALL zend_jit_zval_copy_unref_helper, r0
		|	jmp >9
		|1:
		|	GC_ADDREF r1
		|2:
		|	ZVAL_COPY_VALUE FP + opline->result.var, r0, MAY_BE_ANY, r1, ecx, r2
		} else  {
		|	// ZVAL_COPY
		|	ZVAL_COPY_VALUE FP + opline->result.var, r0, MAY_BE_ANY, r1, ecx, r2
		|	TRY_ADDREF res_info, ch, r2
		}
	}
	|9: // END

#ifdef ZEND_JIT_USE_RC_INFERENCE
	if ((opline->op2_type & (IS_TMP_VAR|IS_VAR)) && (op1_info & MAY_BE_OBJECT)) {
		/* Magic offsetGet() may increase refcount of the key */
		op2_info |= MAY_BE_RCN;
	}
#endif

	|	FREE_OP opline->op2_type, opline->op2, op2_info, 0, op_array, opline
	|	FREE_OP opline->op1_type, opline->op1, op1_info, 0, op_array, opline

	if (zend_may_throw(opline, op_array, ssa)) {
		if (!zend_jit_check_exception(Dst)) {
			return 0;
		}
	}

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_isset_isempty_dim(dasm_State **Dst, const zend_op *opline, int b, int *opnum, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info, op2_info;

	if (!ssa->ops || !ssa->var_info || !(opline->extended_value & ZEND_ISSET)) {
		// TODO: support for empty() ???
		goto fallback;
	}

	op1_info = OP1_INFO();
	op2_info = OP2_INFO();

	if (op1_info & MAY_BE_REF) {
		|	lea FCARG1a, [FP + opline->op1.var]
		|	ZVAL_DEREF FCARG1a, op1_info
	}

	if (op1_info & MAY_BE_ARRAY) {
		if (op1_info & MAY_BE_REF) {
			|	IF_NOT_Z_TYPE FCARG1a, IS_ARRAY, >7
			|	GET_Z_PTR FCARG1a, FCARG1a
		} else {
			if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF) - MAY_BE_ARRAY)) {
				|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_ARRAY, >7
			}
			|	LONG_LOAD FCARG1a, opline->op1_type, opline->op1
		}
		if (!zend_jit_fetch_dimension_address_inner(Dst, opline, op_array, BP_JIT_IS, op1_info, op2_info, 8, 9)) {
			return 0;
		}
	}

	if (op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-MAY_BE_ARRAY)) {
		if (op1_info & MAY_BE_ARRAY) {
			|.cold_code
			|7:
		}

		|	SAVE_VALID_OPLINE opline
	    if (!(op1_info & MAY_BE_REF)) {
			|	LOAD_ZVAL_ADDR FCARG1a, opline->op1_type, opline->op1
		}
		|	LOAD_ZVAL_ADDR FCARG2a, opline->op2_type, opline->op2
		|	EXT_CALL zend_jit_isset_dim_helper, r0
		|	test r0, r0
		|	jz >9
		|	jmp >8

		if (op1_info & MAY_BE_ARRAY) {
			|.code
		}
	}

#ifdef ZEND_JIT_USE_RC_INFERENCE
	if ((opline->op2_type & (IS_TMP_VAR|IS_VAR)) && (op1_info & MAY_BE_OBJECT)) {
		/* Magic offsetExists() may increase refcount of the key */
		op2_info |= MAY_BE_RCN;
	}
#endif

	|8:
	|	FREE_OP opline->op2_type, opline->op2, op2_info, 0, op_array, opline
	|	FREE_OP opline->op1_type, opline->op1, op1_info, 0, op_array, opline
	if (zend_may_throw(opline, op_array, ssa)) {
		if (!zend_jit_check_exception_undef_result(Dst, opline)) {
			return 0;
		}
	}
	if (opline->extended_value & ZEND_ISSET) {
		if ((opline+1)->opcode == ZEND_JMPZ) {
			unsigned int target_label = ssa->cfg.blocks[b].successors[1];
			|	jmp =>target_label
		} else if ((opline+1)->opcode == ZEND_JMPNZ) {
			unsigned int target_label = ssa->cfg.blocks[b].successors[0];
			|	jmp =>target_label
		} else if ((opline+1)->opcode == ZEND_JMPZNZ) {
			unsigned int target_label = ssa->cfg.blocks[b].successors[1];
			|	jmp =>target_label
		} else {
			|	SET_Z_TYPE_INFO FP + opline->result.var, IS_TRUE
			|	jmp >8
		}
	} else {
		|	//????
		|	int3
	}

	|9: // not found
	|	FREE_OP opline->op2_type, opline->op2, op2_info, 0, op_array, opline
	|	FREE_OP opline->op1_type, opline->op1, op1_info, 0, op_array, opline
	if (zend_may_throw(opline, op_array, ssa)) {
		if (!zend_jit_check_exception_undef_result(Dst, opline)) {
			return 0;
		}
	}
	if (opline->extended_value & ZEND_ISSET) {
		if ((opline+1)->opcode == ZEND_JMPZ) {
			unsigned int target_label = ssa->cfg.blocks[b].successors[0];
			|	jmp =>target_label
		} else if ((opline+1)->opcode == ZEND_JMPNZ) {
		} else if ((opline+1)->opcode == ZEND_JMPZNZ) {
			unsigned int target_label = ssa->cfg.blocks[b].successors[0];
			|	jmp =>target_label
		} else {
			|	SET_Z_TYPE_INFO FP + opline->result.var, IS_FALSE
		}
	} else {
		|	//????
		|	int3
	}

	|8:

	if (((opline+1)->opcode == ZEND_JMPZ ||
	     (opline+1)->opcode == ZEND_JMPNZ ||
	     (opline+1)->opcode == ZEND_JMPZNZ) &&
	    (opline+1)->op1_type == IS_TMP_VAR &&
	    (opline+1)->op1.var == opline->result.var) {
		(*opnum)++;
	}

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_bind_global(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;
	zval *varname = RT_CONSTANT(op_array, opline->op2);

	if (!ssa->ops || !ssa->var_info) {
		op1_info = MAY_BE_ANY|MAY_BE_REF;
	} else {
		op1_info = OP1_INFO();
	}

	//idx = (uint32_t)(uintptr_t)CACHED_PTR(Z_CACHE_SLOT_P(varname)) - 1;
	|	mov	r0, EX->run_time_cache
	|	mov r0, aword [r0 + Z_CACHE_SLOT_P(varname)]
	|	sub r0, 1
	//if (EXPECTED(idx < EG(symbol_table).nNumUsed))
	|	cmp r0, [&EG(symbol_table).nNumUsed]
	|	jae >9
	//Bucket *p = EG(symbol_table).arData + idx;
	|.if X64
	|	shl r0, 5
	|.else
	|	imul r0, sizeof(Bucket)
	|.endif
	|.if X64
	|	LOAD_ADDR r1, &EG(symbol_table.arData)
	|	add r0, [r1]
	|.else
	|	add r0, [&EG(symbol_table).arData]
	|.endif
	|	IF_Z_TYPE r0, IS_UNDEF, >9
	//	(EXPECTED(p->key == Z_STR_P(varname))
	|.if X64
	|	LOAD_ADDR r1, Z_PTR_P(varname)
	|	cmp [r0 + offsetof(Bucket, key)], r1
	|.else
	|	cmp aword [r0 + offsetof(Bucket, key)], Z_PTR_P(varname)
	|.endif
	|	jne >1
	|.cold_code
	|1:
	//(EXPECTED(p->h == ZSTR_H(Z_STR_P(varname)))
	|.if X64
	|	mov64 r1, ZSTR_H(Z_STR_P(varname))
	|	cmp qword [r0 + offsetof(Bucket, h)], r1
	|.else
	|	cmp dword [r0 + offsetof(Bucket, h)], ZSTR_H(Z_STR_P(varname))
	|.endif
	|	jne >9
	//EXPECTED(p->key != NULL)
	|	mov r1, [r0 + offsetof(Bucket, key)]
	|	test r1, r1
	|	jz >9
	//EXPECTED(ZSTR_LEN(p->key) == Z_STRLEN_P(varname))
	|	cmp dword [r1 + offsetof(zend_string, len)], Z_STRLEN_P(varname)
	|	jne >9
	//EXPECTED(memcmp(ZSTR_VAL(p->key), Z_STRVAL_P(varname), Z_STRLEN_P(varname)) == 0)
	|	add r1, offsetof(zend_string, val)
	|	mov [r4], r0
	|.if X64
	|	mov CARG1, r1
	|	LOAD_ADDR CARG2, Z_STRVAL_P(varname)
	|	mov CARG3, Z_STRLEN_P(varname)
	|	call &memcmp
	|.else
	|	sub r4, 4
	|	push Z_STRLEN_P(varname)
	|	push Z_STRVAL_P(varname)
	|	push r1
	|	call &memcmp
	|	add r4, 16
	|.endif
	|	test al, al
	|	mov r0, aword [r4]
	|	jnz >9
	|	jmp >2
	|.code
	|2:
	// if (UNEXPECTED(Z_TYPE_P(value) == IS_INDIRECT))
	|	mov cl, byte [r0 + 8]
	|	cmp cl, IS_INDIRECT
	|	je >1
	|.cold_code
	|1:
	//value = Z_INDIRECT_P(value)
	|	mov r0, [r0]
	|	mov cl, byte [r0 + 8]
	|	cmp cl, IS_UNDEF
	|	jne >2
	|	SET_Z_TYPE_INFO r0, IS_NULL
	|	jmp >8
	|.code
	|2:
	|	cmp cl, IS_REFERENCE
	|	jne >8
	|1:
	if (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF)) {
		//stash this for later use
	|	mov r2, r0
	}
	|	GET_Z_PTR r0, r0
	|	GC_ADDREF r0
	//if (UNEXPECTED(Z_REFCOUNTED_P(variable_ptr)))
	if (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF)) {
		if (op1_info & (MAY_BE_ANY - (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE))) {
		|	IF_Z_REFCOUNTED FP + opline->op1.var, >2
		}
		|.cold_code
		//zval_dtor_func(Z_COUNTED_P(variable_ptr))
		|2:
		//if (EXPECTED(variable_ptr != value))
		|	lea FCARG1a, aword [FP + opline->op1.var]
		|	cmp FCARG1a, r2
		|	je >4
		|	GET_Z_PTR FCARG1a, FCARG1a
		|	GC_DELREF FCARG1a
		if (op1_info & (MAY_BE_ARRAY|MAY_BE_OBJECT)) {
		|	jnz >3
		}
		|	mov aword [r4], r0 // save
		|	ZVAL_DTOR_FUNC op1_info, op_array->filename, opline
		|	mov r0, aword [r4] // restore
		|	jmp >5
		if (op1_info & (MAY_BE_ARRAY|MAY_BE_OBJECT)) {
		|3:
		// GC_ZVAL_CHECK_POSSIBLE_ROOT(variable_ptr)
		|	IF_GC_MAY_NOT_LEAK FCARG1a, edx, >5
		|	mov aword [r4], r0 //save
		|	EXT_CALL gc_possible_root, r1
		|	mov r0, aword [r4] // restore
		|	jmp >5
		}
		|4:
		|	GET_Z_PTR FCARG1a, FCARG1a
		|	GC_DELREF FCARG1a
		|	jmp >5
		|.code
	}
	|5:
	//ZVAL_REF(variable_ptr, ref)
	|	SET_Z_PTR FP + opline->op1.var, r0
	|	SET_Z_TYPE_INFO FP + opline->op1.var, IS_REFERENCE_EX
	//END of handler

	|.cold_code
	|8:
	|	mov FCARG1a, r0
	|	EXT_CALL zend_jit_new_ref_helper, r0
	|	jmp <1
	|9:
	|	mov FCARG1a, FP
	|	LOAD_ADDR FCARG2a, (ptrdiff_t)varname
	|	EXT_CALL zend_jit_fetch_global_helper, r0
	|	jmp <1
	|.code

	return 1;
}

static int zend_jit_recv_init(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_bool is_last, zend_ssa *ssa)
{
	zend_arg_info *arg_info;
	zend_bool has_slow = 0;
	uint32_t arg_num = opline->op1.num;
	zval *zv = RT_CONSTANT(op_array, opline->op2);

	|	cmp dword EX->This.u2.num_args, arg_num
	|	jae >5
	|	ZVAL_COPY_CONST FP + opline->result.var, -1, zv, r0
	if (Z_REFCOUNTED_P(zv)) {
	|	ADDREF_CONST zv, r0
	}
	if (Z_CONSTANT_P(zv)) {
		has_slow = 1;
	|	SAVE_VALID_OPLINE opline
	|.if X64
	|	lea CARG1, [FP + opline->result.var]
	|	mov r0, EX->func
	|	mov CARG2, [r0 + offsetof(zend_op_array, scope)]
	|	EXT_CALL zval_update_constant_ex, r0
	|.else
	|	sub r4, 8
	|	mov r0, EX->func
	|	push dword [r0 + offsetof(zend_op_array, scope)]
	|	lea r0, [FP + opline->result.var]
	|	push r0
	|	EXT_CALL zval_update_constant_ex, r0
	|	add r4, 16
	|.endif
	|	test al, al
	|	jnz >7
	}
	|5:
	if (op_array->fn_flags & ZEND_ACC_HAS_TYPE_HINTS) {
		do {
			if (arg_num <= op_array->num_args) {
				arg_info = &op_array->arg_info[arg_num-1];
			} else if (op_array->fn_flags & ZEND_ACC_VARIADIC) {
				arg_info = &op_array->arg_info[op_array->num_args];
			} else {
				break;
			}
			if (!ZEND_TYPE_IS_SET(arg_info->type)) {
				break;
			}
			has_slow += 2;
			|	lea r0, aword [FP + opline->result.var]
			|	ZVAL_DEREF r0, MAY_BE_REF
			if (!ZEND_TYPE_IS_CLASS(arg_info->type)) {
			|	cmp byte [r0 + 8], ZEND_TYPE_CODE(arg_info->type)
			|	jne >8
			} else {
			|	cmp byte [r0 + 8], IS_OBJECT
			|	jne >8
			|	mov FCARG1a, r0
			|	mov r0,	EX->run_time_cache
			|	lea r0, [r0 + Z_CACHE_SLOT_P(zv)]
			|	LOAD_ADDR FCARG2a, (ptrdiff_t)op_array
			|.if X64
			|	mov CARG3, arg_num
			|	LOAD_ADDR CARG4, (ptrdiff_t)arg_info
			|	mov CARG5, r0
			|.else
			|	push r0
			|	push (ptrdiff_t)arg_info
			|	push arg_num
			|.endif
			|	EXT_CALL zend_jit_verify_arg_object, r0
			}
		} while (0);
	}
	|9:
	if (zend_may_throw(opline, op_array, ssa)) {
		if (!zend_jit_check_exception(Dst)) {
			return 0;
		}
	}
	if (is_last) {
	|	LOAD_ADDR IP, (opline + 1)
		last_valid_opline = (opline + 1);
	}

	if (has_slow) {
	|.cold_code
	if (has_slow & 1) {
	|7:
	|	ZVAL_PTR_DTOR  FP + opline->result.var, MAY_BE_ANY|MAY_BE_RC1|MAY_BE_RCN, 1, 0, 0, op_array->filename, opline
	|	SET_Z_TYPE_INFO FP + opline->result.var, IS_UNDEF
	|	jmp <5
	}
	if (has_slow & 2) {
	|8:
	|	mov FCARG1a, r0
	|	mov r0,	EX->run_time_cache
	|	lea r0, [r0 + Z_CACHE_SLOT_P(zv)]
	|	LOAD_ADDR FCARG2a, (ptrdiff_t)op_array
	|.if X64
	|	mov CARG3, arg_num
	|	LOAD_ADDR CARG4, (ptrdiff_t)arg_info
	|	mov CARG5, r0
	|	LOAD_ADDR CARG6, zv
	|.else
	|	push zv
	|	push r0
	|	push (ptrdiff_t)arg_info
	|	push arg_num
	|.endif
	|	EXT_CALL zend_jit_verify_arg_slow, r0
	|	jmp <9
	}
	|.code
	}

	return 1;
}

static uint32_t zend_get_known_property_offset(zend_class_entry *ce, zend_string *member, zend_bool on_this, zend_string *filename)
{
	zend_property_info *info;

	if (!ce || (ce->ce_flags & ZEND_ACC_TRAIT)) {
		return ZEND_WRONG_PROPERTY_OFFSET;
	}

	if (ce->info.user.filename != filename) {
		/* class declaration might be changed infdependently */
		return ZEND_WRONG_PROPERTY_OFFSET;
	}

	if (ce->ce_flags & ZEND_ACC_INHERITED) {
		if (!ce->parent) {
			/* propery offests may be changed by inheritance */
			return ZEND_WRONG_PROPERTY_OFFSET;
		} else {
			zend_class_entry *parent = ce->parent;

			do {
				if (parent->type == ZEND_INTERNAL_CLASS) {
					break;
				} else if (parent->info.user.filename != filename) {
					/* some of parents class declarations might be changed infdependently */
					/* TODO: this check may be not enough, because even
					 * in the same it's possible to conditionnaly define
					 * few classes with the same name, and "parent" may
					 * change from request to request.
					 */
					return ZEND_WRONG_PROPERTY_OFFSET;
				}
				parent = parent->parent;
			} while (parent);
		}
	}

	info = (zend_property_info*)zend_hash_find_ptr(&ce->properties_info, member);
	if (info == NULL ||
	    info->offset == ZEND_WRONG_PROPERTY_OFFSET ||
	    (info->flags & ZEND_ACC_STATIC)) {
		return ZEND_WRONG_PROPERTY_OFFSET;
	}

	if (!(info->flags & ZEND_ACC_PUBLIC) &&
	    (!on_this || info->ce != ce)) {
		return ZEND_WRONG_PROPERTY_OFFSET;
	}

	return info->offset;
}

static int zend_jit_fetch_obj_read(dasm_State **Dst, zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info;
	zend_class_entry *ce = NULL;
	zval *member;
	uint32_t offset;

	if (opline->op2_type != IS_CONST) {
		goto fallback;
	}

	member = RT_CONSTANT(op_array, opline->op2);
	if (Z_TYPE_P(member) != IS_STRING || Z_STRVAL_P(member)[0] == '\0') {
		goto fallback;
	}

	if (opline->op1_type == IS_UNUSED) {
		op1_info = MAY_BE_OBJECT|MAY_BE_RC1|MAY_BE_RCN;
		ce = op_array->scope;
	} else {
		op1_info = OP1_INFO();
		if (ssa->var_info && ssa->ops) {
			zend_ssa_var_info *op1_ssa =
				ssa->var_info + ssa->ops[opline - op_array->opcodes].op1_use;

			if (op1_ssa->ce && !op1_ssa->is_instanceof && !op1_ssa->ce->create_object) {
				ce = op1_ssa->ce;
			}
		}
	}

	if (!(op1_info & MAY_BE_OBJECT)) {
		goto fallback;
	}

	offset = zend_get_known_property_offset(ce, Z_STR_P(member), opline->op1_type == IS_UNUSED, op_array->filename);

	if (opline->op1_type == IS_UNUSED) {
		|	IF_Z_TYPE FP + offsetof(zend_execute_data, This), IS_UNDEF, >1
		|.cold_code
		|1:
		|	SAVE_VALID_OPLINE opline
		|	jmp ->not_obj
		|.code
		|	GET_Z_PTR FCARG1a, FP + offsetof(zend_execute_data, This)
	} else if (op1_info & MAY_BE_REF) {
		|	lea r0, [FP + opline->op1.var]
		|	ZVAL_DEREF r0, op1_info
		|	IF_NOT_Z_TYPE r0, IS_OBJECT, >7
		|	GET_Z_PTR FCARG1a, r0
	} else {
		if (op1_info & ((MAY_BE_UNDEF|MAY_BE_ANY)- MAY_BE_OBJECT)) {
			|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_OBJECT, >7
		}
		|	GET_Z_PTR FCARG1a, FP + opline->op1.var
	}

	if (offset == ZEND_WRONG_PROPERTY_OFFSET) {
		|	mov r0,	EX->run_time_cache
		|	mov r2, aword [r0 + Z_CACHE_SLOT_P(member)]
		|	cmp r2, aword [FCARG1a + offsetof(zend_object, ce)]
		|	jne >5
		|	mov r0, aword [r0 + Z_CACHE_SLOT_P(member) + sizeof(void*)]
		|	cmp eax, (uint32_t)ZEND_DYNAMIC_PROPERTY_OFFSET
		|	je >8 // dynamic property
		|	mov edx, dword [FCARG1a + r0 + 8]
		|	IF_TYPE dl, IS_UNDEF, >5
		|	add FCARG1a, r0
		|	GET_Z_PTR r0, FCARG1a
	} else {
		|	mov edx, dword [FCARG1a + offset + 8]
		|	IF_TYPE dl, IS_UNDEF, >5
		|	GET_Z_PTR r0, FCARG1a + offset
	}
	|	IF_NOT_REFCOUNTED dh, >2
	if (opline->opcode == ZEND_FETCH_OBJ_R) {
		|	IF_TYPE dl, IS_REFERENCE, >6
	}
	|1:
	|	GC_ADDREF r0
	|2:
	|.if X64
	|	SET_Z_PTR FP + opline->result.var, r0
	|.else
	|	SET_Z_PTR FP + opline->result.var, r0
	if (offset == ZEND_WRONG_PROPERTY_OFFSET) {
		|	GET_Z_W2 r0, FCARG1a
	} else {
		|	GET_Z_W2 r0, FCARG1a + offset
	}
	|	SET_Z_W2 FP + opline->result.var, r0
	|.endif
	|	SET_Z_TYPE_INFO FP + opline->result.var, edx

	|.cold_code
	|5:
	|	LOAD_ADDR FCARG2a, member
	|.if X64
	|	lea CARG3, [FP + opline->result.var]
	|.else
	|	lea r0, [FP + opline->result.var]
	|	push r0
	|.endif
	|	SAVE_VALID_OPLINE opline
	if (opline->opcode == ZEND_FETCH_OBJ_R) {
		|	EXT_CALL zend_jit_fetch_obj_r_slow, r0
	} else if (opline->opcode == ZEND_FETCH_OBJ_IS) {
		|	EXT_CALL zend_jit_fetch_obj_is_slow, r0
	} else {
		ZEND_ASSERT(0);
	}
	|	jmp >9

	if (opline->opcode == ZEND_FETCH_OBJ_R) {
		|6:
		|	cmp dword [r0], 1
		|	jne <1
		if (offset == ZEND_WRONG_PROPERTY_OFFSET) {
			|	mov FCARG2a, FCARG1a
		} else {
			|	lea FCARG2a, [FCARG1a + offset]
		}
		|	lea FCARG1a, [FP + opline->result.var]
		|	EXT_CALL zend_jit_zval_copy_unref_helper, r0
		|	jmp >9
	}

	if (op1_info & ((MAY_BE_UNDEF|MAY_BE_ANY|MAY_BE_REF)- MAY_BE_OBJECT)) {
		|7:
		if (opline->opcode == ZEND_FETCH_OBJ_R) {
			|	SAVE_VALID_OPLINE opline
			if (op1_info & MAY_BE_UNDEF) {
				if (op1_info & MAY_BE_ANY) {
					if (op1_info & MAY_BE_REF) {
						|	IF_NOT_Z_TYPE r0, IS_UNDEF, >1
					} else {
						|	IF_NOT_Z_TYPE FP + opline->op1.var, IS_UNDEF, >1
					}
				}
				|	mov FCARG1d, opline->op1.var
				|	EXT_CALL zend_jit_undefined_op_helper, r0
				|1:
			}
			|.if X64
			|	mov CARG1, E_NOTICE
			|	LOAD_ADDR CARG2, "Trying to get property of non-object"
			|	EXT_CALL zend_error, r0
			|.else
			|	sub r4, 8
			|	push "Trying to get property of non-object"
			|	push E_NOTICE
			|	EXT_CALL zend_error, r0
			|	add r4, 16
			|.endif
		}
		|	SET_Z_TYPE_INFO FP + opline->result.var, IS_NULL
		|	jmp >9
	}

	if (offset == ZEND_WRONG_PROPERTY_OFFSET) {
		|8:
		|	LOAD_ADDR FCARG2a, member
		|.if X64
		|	lea CARG3, [FP + opline->result.var]
		|.else
		|	lea r0, [FP + opline->result.var]
		|	push r0
		|.endif
		|	SAVE_VALID_OPLINE opline
		if (opline->opcode == ZEND_FETCH_OBJ_R) {
			|	EXT_CALL zend_jit_fetch_obj_r_dynamic, r0
		} else if (opline->opcode == ZEND_FETCH_OBJ_IS) {
			|	EXT_CALL zend_jit_fetch_obj_is_dynamic, r0
		}
		|	jmp >9
	}

	|.code;
	|9: // END
	|	FREE_OP opline->op1_type, opline->op1, op1_info, 1, op_array, opline

	if (zend_may_throw(opline, op_array, ssa)) {
		if (!zend_jit_check_exception(Dst)) {
			return 0;
		}
	}

	return 1;

fallback:
	/* fallback to subroutine threading */
	return zend_jit_handler(Dst, opline, zend_may_throw(opline, op_array, ssa));
}

static int zend_jit_free(dasm_State **Dst, const zend_op *opline, zend_op_array *op_array, zend_ssa *ssa)
{
	uint32_t op1_info = OP1_INFO();

	if (op1_info & (MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF)) {
		if (zend_may_throw(opline, op_array, ssa)) {
			|	SAVE_VALID_OPLINE, opline
		}
		if (opline->opcode == ZEND_FE_FREE && (op1_info & (MAY_BE_OBJECT|MAY_BE_REF))) {
			if (op1_info & MAY_BE_ARRAY) {
				|	IF_Z_TYPE FP + opline->op1.var, IS_ARRAY, >7
			}
			|	mov FCARG1d, dword [FP + opline->op1.var + offsetof(zval, u2.fe_iter_idx)]
			|	cmp FCARG1d, -1
			|	je >7
			|	EXT_CALL zend_hash_iterator_del, r0
			|7:
		}
		|	ZVAL_PTR_DTOR FP + opline->op1.var, op1_info, 0, 0, 0, op_array->filename, opline
		if (zend_may_throw(opline, op_array, ssa)) {
			if (!zend_jit_check_exception(Dst)) {
				return 0;
			}
		}
	}

	return 1;
}

#ifdef ZEND_JIT_RECORD
static int zend_jit_func_header(dasm_State **Dst, zend_op_array *op_array)
{
	|	EXT_CALL zend_jit_func_header_helper, r0
	return 1;
}

static int zend_jit_loop_header(dasm_State **Dst, zend_op_array *op_array, zend_op *opline)
{
	if (!zend_jit_set_valid_ip(Dst, opline)) {
		return 0;
	}
	|	EXT_CALL zend_jit_loop_header_helper, r0
	return 1;
}
#endif

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 */
