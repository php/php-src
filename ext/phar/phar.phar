#!/usr/bin/php
<?php if (!class_exists('PHP_Archive')) {
?><?php
/**
 * PHP_Archive Class (implements .phar)
 *
 * @package PHP_Archive
 * @category PHP
 */
/**
 * PHP_Archive Class (implements .phar)
 *
 * PHAR files a singular archive from which an entire application can run.
 * To use it, simply package it using {@see PHP_Archive_Creator} and use phar://
 * URIs to your includes. i.e. require_once 'phar://config.php' will include config.php
 * from the root of the PHAR file.
 *
 * Gz code borrowed from the excellent File_Archive package by Vincent Lascaux.
 *
 * @copyright Copyright David Shafik and Synaptic Media 2004. All rights reserved.
 * @author Davey Shafik <davey@synapticmedia.net>
 * @author Greg Beaver <cellog@php.net>
 * @link http://www.synapticmedia.net Synaptic Media
 * @version $Id: Archive.php,v 1.43 2007/05/28 18:20:40 helly Exp $
 * @package PHP_Archive
 * @category PHP
 */
 
class PHP_Archive
{
    const GZ = 0x00001000;
    const BZ2 = 0x00002000;
    const SIG = 0x00010000;
    const SHA1 = 0x0002;
    const MD5 = 0x0001;
    /**
     * Whether this archive is compressed with zlib
     *
     * @var bool
     */
    private $_compressed;
    /**
     * @var string Real path to the .phar archive
     */
    private $_archiveName = null;
    /**
     * Current file name in the phar
     * @var string
     */
    protected $currentFilename = null;
    /**
     * Length of current file in the phar
     * @var string
     */
    protected $internalFileLength = null;
    /**
     * Current file statistics (size, creation date, etc.)
     * @var string
     */
    protected $currentStat = null;
    /**
     * @var resource|null Pointer to open .phar
     */
    protected $fp = null;
    /**
     * @var int Current Position of the pointer
     */
    protected $position = 0;

    /**
     * Map actual realpath of phars to meta-data about the phar
     *
     * Data is indexed by the alias that is used by internal files.  In other
     * words, if a file is included via:
     * <code>
     * require_once 'phar://PEAR.phar/PEAR/Installer.php';
     * </code>
     * then the alias is "PEAR.phar"
     * 
     * Information stored is a boolean indicating whether this .phar is compressed
     * with zlib, another for bzip2, phar-specific meta-data, and
     * the precise offset of internal files
     * within the .phar, used with the {@link $_manifest} to load actual file contents
     * @var array
     */
    private static $_pharMapping = array();
    /**
     * Map real file paths to alias used
     *
     * @var array
     */
    private static $_pharFiles = array();
    /**
     * File listing for the .phar
     * 
     * The manifest is indexed per phar.
     * 
     * Files within the .phar are indexed by their relative path within the
     * .phar.  Each file has this information in its internal array
     *
     * - 0 = uncompressed file size
     * - 1 = timestamp of when file was added to phar
     * - 2 = offset of file within phar relative to internal file's start
     * - 3 = compressed file size (actual size in the phar)
     * @var array
     */
    private static $_manifest = array();
    /**
     * Absolute offset of internal files within the .phar, indexed by absolute
     * path to the .phar
     *
     * @var array
     */
    private static $_fileStart = array();
    /**
     * file name of the phar
     *
     * @var string
     */
    private $_basename;


    /**
     * Default MIME types used for the web front controller
     *
     * @var array
     */
    public static $defaultmimes = array(
            'aif' => 'audio/x-aiff',
            'aiff' => 'audio/x-aiff',
            'arc' => 'application/octet-stream',
            'arj' => 'application/octet-stream',
            'art' => 'image/x-jg',
            'asf' => 'video/x-ms-asf',
            'asx' => 'video/x-ms-asf',
            'avi' => 'video/avi',
            'bin' => 'application/octet-stream',
            'bm' => 'image/bmp',
            'bmp' => 'image/bmp',
            'bz2' => 'application/x-bzip2',
            'css' => 'text/css',
            'doc' => 'application/msword',
            'dot' => 'application/msword',
            'dv' => 'video/x-dv',
            'dvi' => 'application/x-dvi',
            'eps' => 'application/postscript',
            'exe' => 'application/octet-stream',
            'gif' => 'image/gif',
            'gz' => 'application/x-gzip',
            'gzip' => 'application/x-gzip',
            'htm' => 'text/html',
            'html' => 'text/html',
            'ico' => 'image/x-icon',
            'jpe' => 'image/jpeg',
            'jpg' => 'image/jpeg',
            'jpeg' => 'image/jpeg',
            'js' => 'application/x-javascript',
            'log' => 'text/plain',
            'mid' => 'audio/x-midi',
            'mov' => 'video/quicktime',
            'mp2' => 'audio/mpeg',
            'mp3' => 'audio/mpeg3',
            'mpg' => 'audio/mpeg',
            'pdf' => 'aplication/pdf',
            'png' => 'image/png',
            'rtf' => 'application/rtf',
            'tif' => 'image/tiff',
            'tiff' => 'image/tiff',
            'txt' => 'text/plain',
            'xml' => 'text/xml',
        );

    public static $defaultphp = array(
        'php' => true
        );

    public static $defaultphps = array(
        'phps' => true
        );

    public static $deny = array('/.+\.inc$/');

    public static function viewSource($archive, $file)
    {
        // security, idea borrowed from PHK
        if (!file_exists($archive . '.introspect')) {
            header("HTTP/1.0 404 Not Found");
            exit;
        }
        if (self::_fileExists($archive, $_GET['viewsource'])) {
            $source = highlight_file('phar://@ALIAS@/' .
                $_GET['viewsource'], true);
            header('Content-Type: text/html');
            header('Content-Length: ' . strlen($source));
            echo '<html><head><title>Source of ',
                htmlspecialchars($_GET['viewsource']), '</title></head>';
            echo '<body><h1>Source of ',
                htmlspecialchars($_GET['viewsource']), '</h1>';
            if (isset($_GET['introspect'])) {
                echo '<a href="', htmlspecialchars($_SERVER['PHP_SELF']),
                    '?introspect=', urlencode(htmlspecialchars($_GET['introspect'])),
                    '">Return to ', htmlspecialchars($_GET['introspect']), '</a><br />';
            }
            echo $source;
            exit;
        } else {
            header("HTTP/1.0 404 Not Found");
            exit;
        }
        
    }

    public static function introspect($archive, $dir)
    {
        // security, idea borrowed from PHK
        if (!file_exists($archive . '.introspect')) {
            header("HTTP/1.0 404 Not Found");
            exit;
        }
        if (!$dir) {
            $dir = '/';
        }
        $dir = self::processFile($dir);
        if ($dir[0] != '/') {
            $dir = '/' . $dir;
        }
        try {
            $self = htmlspecialchars($_SERVER['PHP_SELF']);
            $iterate = new DirectoryIterator('phar://@ALIAS@' . $dir);
            echo '<html><head><title>Introspect ', htmlspecialchars($dir),
                '</title></head><body><h1>Introspect ', htmlspecialchars($dir),
                '</h1><ul>';
            if ($dir != '/') {
                echo '<li><a href="', $self, '?introspect=',
                    htmlspecialchars(dirname($dir)), '">..</a></li>';
            }
            foreach ($iterate as $entry) {
                if ($entry->isDot()) continue;
                $name = self::processFile($entry->getPathname());
                $name = str_replace('phar://@ALIAS@/', '', $name);
                if ($entry->isDir()) {
                    echo '<li><a href="', $self, '?introspect=',
                        urlencode(htmlspecialchars($name)),
                        '">',
                        htmlspecialchars($entry->getFilename()), '/</a> [directory]</li>';
                } else {
                    echo '<li><a href="', $self, '?introspect=',
                        urlencode(htmlspecialchars($dir)), '&viewsource=',
                        urlencode(htmlspecialchars($name)),
                        '">',
                        htmlspecialchars($entry->getFilename()), '</a></li>';
                }
            }
            exit;
        } catch (Exception $e) {
            echo '<html><head><title>Directory not found: ',
                htmlspecialchars($dir), '</title></head>',
                '<body><h1>Directory not found: ', htmlspecialchars($dir), '</h1>',
                '<p>Try <a href="', htmlspecialchars($_SERVER['PHP_SELF']), '?introspect=/">',
                'This link</a></p></body></html>';
            exit;
        }
    }

    public static function webFrontController($initfile)
    {
        if (isset($_SERVER) && isset($_SERVER['REQUEST_URI'])) {
            $uri = parse_url($_SERVER['REQUEST_URI']);
            $archive = realpath($_SERVER['SCRIPT_FILENAME']);
            $subpath = str_replace('/' . basename($archive), '', $uri['path']);
            if (!$subpath || $subpath == '/') {
                if (isset($_GET['viewsource'])) {
                    self::viewSource($archive, $_GET['viewsource']);
                }
                if (isset($_GET['introspect'])) {
                    self::introspect($archive, $_GET['introspect']);
                }
                $subpath = '/' . $initfile;
            }
            if (!self::_fileExists($archive, substr($subpath, 1))) {
                header("HTTP/1.0 404 Not Found");
                exit;
            }
            foreach (self::$deny as $pattern) {
                if (preg_match($pattern, $subpath)) {
                    header("HTTP/1.0 404 Not Found");
                    exit;
                }
            }
            $inf = pathinfo(basename($subpath));
            if (!isset($inf['extension'])) {
                header('Content-Type: text/plain');
                header('Content-Length: ' .
                    self::_filesize($archive, substr($subpath, 1)));
                readfile('phar://@ALIAS@' . $subpath);
                exit;
            }
            if (isset(self::$defaultphp[$inf['extension']])) {
                include 'phar://@ALIAS@' . $subpath;
                exit;
            }
            if (isset(self::$defaultmimes[$inf['extension']])) {
                header('Content-Type: ' . self::$defaultmimes[$inf['extension']]);
                header('Content-Length: ' .
                    self::_filesize($archive, substr($subpath, 1)));
                readfile('phar://@ALIAS@' . $subpath);
                exit;
            }
            if (isset(self::$defaultphps[$inf['extension']])) {
                header('Content-Type: text/html');
                $c = highlight_file('phar://@ALIAS@' . $subpath, true);
                header('Content-Length: ' . strlen($c));
                echo $c;
                exit;
            }
            header('Content-Type: text/plain');
            header('Content-Length: ' .
                    self::_filesize($archive, substr($subpath, 1)));
            readfile('phar://@ALIAS@' . $subpath);
            exit;
        }
    }

    /**
     * Detect end of stub
     *
     * @param string $buffer stub past '__HALT_'.'COMPILER();'
     * @return end of stub, prior to length of manifest.
     */
    private static final function _endOfStubLength($buffer)
    {
        $pos = 0;
        if (($buffer[0] == ' ' || $buffer[0] == "\n") && substr($buffer, 1, 2) == '?>')
        {
            $pos += 3;
            if ($buffer[$pos] == "\r" && $buffer[$pos+1] == "\n") {
                $pos += 2;
            }
            else if ($buffer[$pos] == "\n") {
                $pos += 1;
            }
        }
        return $pos;
    }

    /**
     * Allows loading an external Phar archive without include()ing it
     *
     * @param string $file  phar package to load
     * @param string $alias alias to use
     * @throws Exception
     */
    public static final function loadPhar($file, $alias = NULL)
    {
        $file = realpath($file);
        if ($file) {
            $fp = fopen($file, 'rb');
            $buffer = '';
            while (!$found && !feof($fp)) {
                $buffer .= fread($fp, 8192);
                // don't break phars
                if ($pos = strpos($buffer, '__HALT_COMPI' . 'LER();')) {
                    $buffer .= fread($fp, 5);
                    fclose($fp);
                    $pos += 18;
                    $pos += self::_endOfStubLength(substr($buffer, $pos));
                    return self::_mapPhar($file, $pos, $alias);
                }
            }
            fclose($fp);
        }
    }

    /**
     * Map a full real file path to an alias used to refer to the .phar
     *
     * This function can only be called from the initialization of the .phar itself.
     * Any attempt to call from outside the .phar or to re-alias the .phar will fail
     * as a security measure.
     * @param string $alias
     * @param int $dataoffset the value of __COMPILER_HALT_OFFSET__
     */
    public static final function mapPhar($alias = NULL, $dataoffset = NULL)
    {
        try {
            $file = __FILE__;
            // this ensures that this is safe
            if (!in_array($file, get_included_files())) {
                die('SECURITY ERROR: PHP_Archive::mapPhar can only be called from within ' .
                    'the phar that initiates it');
            }
            if (!isset($dataoffset)) {
                $dataoffset = constant('__COMPILER_HALT_OFFSET'.'__');
            }
            $file = realpath($file);

            $fp = fopen($file, 'rb');
            fseek($fp, $dataoffset, SEEK_SET);
            $pos = $dataoffset + self::_endOfStubLength(fread($fp, 5));
            fclose($fp);
            self::_mapPhar($file, $pos);
        } catch (Exception $e) {
            die($e->getMessage());
        }
    }

    /**
     * Sub-function, allows recovery from errors
     *
     * @param unknown_type $file
     * @param unknown_type $dataoffset
     */
    private static function _mapPhar($file, $dataoffset, $alias = NULL)
    {
        $file = realpath($file);
        if (isset(self::$_manifest[$file])) {
            return;
        }
        if (!is_array(self::$_pharMapping)) {
            self::$_pharMapping = array();
        }
        $fp = fopen($file, 'rb');
        // seek to __HALT_COMPILER_OFFSET__
        fseek($fp, $dataoffset);
        $manifest_length = unpack('Vlen', fread($fp, 4));
        $manifest = '';
        $last = '1';
        while (strlen($last) && strlen($manifest) < $manifest_length['len']) {
            $read = 8192;
            if ($manifest_length['len'] - strlen($manifest) < 8192) {
                $read = $manifest_length['len'] - strlen($manifest);
            }
            $last = fread($fp, $read);
            $manifest .= $last;
        }
        if (strlen($manifest) < $manifest_length['len']) {
            throw new Exception('ERROR: manifest length read was "' . 
                strlen($manifest) .'" should be "' .
                $manifest_length['len'] . '"');
        }
        $info = self::_unserializeManifest($manifest);
        if ($info['alias']) {
            $alias = $info['alias'];
            $explicit = true;
        } else {
            if (!isset($alias)) {
                $alias = $file;
            }
            $explicit = false;
        }
        self::$_manifest[$file] = $info['manifest'];
        $compressed = $info['compressed'];
        self::$_fileStart[$file] = ftell($fp);
        fclose($fp);
        if ($compressed & 0x00001000) {
            if (!function_exists('gzinflate')) {
                throw new Exception('Error: zlib extension is not enabled - gzinflate() function needed' .
                    ' for compressed .phars');
            }
        }
        if ($compressed & 0x00002000) {
            if (!function_exists('bzdecompress')) {
                throw new Exception('Error: bzip2 extension is not enabled - bzdecompress() function needed' .
                    ' for compressed .phars');
            }
        }
        if (isset(self::$_pharMapping[$alias])) {
            throw new Exception('ERROR: PHP_Archive::mapPhar has already been called for alias "' .
                $alias . '" cannot re-alias to "' . $file . '"');
        }
        self::$_pharMapping[$alias] = array($file, $compressed, $dataoffset, $explicit,
            $info['metadata']);
        self::$_pharFiles[$file] = $alias;
    }

    /**
     * extract the manifest into an internal array
     *
     * @param string $manifest
     * @return false|array
     */
    private static function _unserializeManifest($manifest)
    {
        // retrieve the number of files in the manifest
        $info = unpack('V', substr($manifest, 0, 4));
        $apiver = substr($manifest, 4, 2);
        $apiver = bin2hex($apiver);
        $apiver_dots = hexdec($apiver[0]) . '.' . hexdec($apiver[1]) . '.' . hexdec($apiver[2]);
        $majorcompat = hexdec($apiver[0]);
        $calcapi = explode('.', self::APIVersion());
        if ($calcapi[0] != $majorcompat) {
            throw new Exception('Phar is incompatible API version ' . $apiver_dots . ', but ' .
                'PHP_Archive is API version '.self::APIVersion());
        }
        if ($calcapi[0] === '0') {
            if (self::APIVersion() != $apiver_dots) {
                throw new Exception('Phar is API version ' . $apiver_dots .
                    ', but PHP_Archive is API version '.self::APIVersion(), E_USER_ERROR);
            }
        }
        $flags = unpack('V', substr($manifest, 6, 4));
        $ret = array('compressed' => $flags & 0x00003000);
        // signature is not verified by default in PHP_Archive, phar is better
        $ret['hassignature'] = $flags & 0x00010000;
        $aliaslen = unpack('V', substr($manifest, 10, 4));
        if ($aliaslen) {
            $ret['alias'] = substr($manifest, 14, $aliaslen[1]);
        } else {
            $ret['alias'] = false;
        }
        $manifest = substr($manifest, 14 + $aliaslen[1]);
        $metadatalen = unpack('V', substr($manifest, 0, 4));
        if ($metadatalen[1]) {
            $ret['metadata'] = unserialize(substr($manifest, 4, $metadatalen[1]));
            $manifest = substr($manifest, 4 + $metadatalen[1]);
        } else {
            $ret['metadata'] = null;
            $manifest = substr($manifest, 4);
        }
        $offset = 0;
        $start = 0;
        for ($i = 0; $i < $info[1]; $i++) {
            // length of the file name
            $len = unpack('V', substr($manifest, $start, 4));
            $start += 4;
            // file name
            $savepath = substr($manifest, $start, $len[1]);
            $start += $len[1];
            // retrieve manifest data:
            // 0 = uncompressed file size
            // 1 = timestamp of when file was added to phar
            // 2 = compressed filesize
            // 3 = crc32
            // 4 = flags
            // 5 = metadata length
            $ret['manifest'][$savepath] = array_values(unpack('Va/Vb/Vc/Vd/Ve/Vf', substr($manifest, $start, 24)));
            $ret['manifest'][$savepath][3] = sprintf('%u', $ret['manifest'][$savepath][3]);
            if ($ret['manifest'][$savepath][5]) {
                $ret['manifest'][$savepath][6] = unserialize(substr($manifest, $start + 24,
                    $ret['manifest'][$savepath][5]));
            } else {
                $ret['manifest'][$savepath][6] = null;
            }
            $ret['manifest'][$savepath][7] = $offset;
            $offset += $ret['manifest'][$savepath][2];
            $start += 24 + $ret['manifest'][$savepath][5];
        }
        return $ret;
    }

    /**
     * @param string
     */
    private static function processFile($path)
    {
        if ($path == '.') {
            return '';
        }
        $std = str_replace("\\", "/", $path);
        while ($std != ($std = ereg_replace("[^\/:?]+/\.\./", "", $std))) ;
        $std = str_replace("/./", "", $std);
        if (strlen($std) > 1 && $std[0] == '/') {
            $std = substr($std, 1);
        }
        if (strncmp($std, "./", 2) == 0) {
            return substr($std, 2);
        } else {
            return $std;
        }
    }

    /**
     * Seek in the master archive to a matching file or directory
     * @param string
     */
    protected function selectFile($path, $allowdirs = true)
    {
        $std = self::processFile($path);
        if (isset(self::$_manifest[$this->_archiveName][$path])) {
            $this->_setCurrentFile($path);
            return true;
        }
        if (!$allowdirs) {
            return 'Error: "' . $path . '" is not a file in phar "' . $this->_basename . '"';
        }
        foreach (self::$_manifest[$this->_archiveName] as $file => $info) {
            if (empty($std) ||
                  //$std is a directory
                  strncmp($std.'/', $path, strlen($std)+1) == 0) {
                $this->currentFilename = $this->internalFileLength = $this->currentStat = null;
                return true;
            }
        }
        return 'Error: "' . $path . '" not found in phar "' . $this->_basename . '"';
    }

    private function _setCurrentFile($path)
    {
        $this->currentStat = array(
            2 => 0100444, // file mode, readable by all, writeable by none
            4 => 0, // uid
            5 => 0, // gid
            7 => self::$_manifest[$this->_archiveName][$path][0], // size
            9 => self::$_manifest[$this->_archiveName][$path][1], // creation time
            );
        $this->currentFilename = $path;
        $this->internalFileLength = self::$_manifest[$this->_archiveName][$path][2];
        // seek to offset of file header within the .phar
        if (is_resource(@$this->fp)) {
            fseek($this->fp, self::$_fileStart[$this->_archiveName] + self::$_manifest[$this->_archiveName][$path][7]);
        }
    }

    private static function _fileExists($archive, $path)
    {
        return isset(self::$_manifest[$archive]) &&
            isset(self::$_manifest[$archive][$path]);
    }

    private static function _filesize($archive, $path)
    {
        return self::$_manifest[$archive][$path][0];
    }

    /**
     * Seek to a file within the master archive, and extract its contents
     * @param string
     * @return array|string an array containing an error message string is returned
     *                      upon error, otherwise the file contents are returned
     */
    public function extractFile($path)
    {
        $this->fp = @fopen($this->_archiveName, "rb");
        if (!$this->fp) {
            return array('Error: cannot open phar "' . $this->_archiveName . '"');
        }
        if (($e = $this->selectFile($path, false)) === true) {
            $data = '';
            $count = $this->internalFileLength;
            while ($count) {
                if ($count < 8192) {
                    $data .= @fread($this->fp, $count);
                    $count = 0;
                } else {
                    $count -= 8192;
                    $data .= @fread($this->fp, 8192);
                }
            }
            @fclose($this->fp);
            if (self::$_manifest[$this->_archiveName][$path][4] & self::GZ) {
                $data = gzinflate($data);
            } elseif (self::$_manifest[$this->_archiveName][$path][4] & self::BZ2) {
                $data = bzdecompress($data);
            }
            if (!isset(self::$_manifest[$this->_archiveName][$path]['ok'])) {
                if (strlen($data) != $this->currentStat[7]) {
                    return array("Not valid internal .phar file (size error {$size} != " .
                        $this->currentStat[7] . ")");
                }
                if (self::$_manifest[$this->_archiveName][$path][3] != sprintf("%u", crc32($data))) {
                    return array("Not valid internal .phar file (checksum error)");
                }
                self::$_manifest[$this->_archiveName][$path]['ok'] = true;
            }
            return $data;
        } else {
            @fclose($this->fp);
            return array($e);
        }
    }

    /**
     * Parse urls like phar:///fullpath/to/my.phar/file.txt
     *
     * @param string $file
     * @return false|array
     */
    static protected function parseUrl($file)
    {
        if (substr($file, 0, 7) != 'phar://') {
            return false;
        }
        $file = substr($file, 7);
    
        $ret = array('scheme' => 'phar');
        $pos_p = strpos($file, '.phar.php');
        $pos_z = strpos($file, '.phar.gz');
        $pos_b = strpos($file, '.phar.bz2');
        if ($pos_p) {
            if ($pos_z) {
                return false;
            }
            $ret['host'] = substr($file, 0, $pos_p + strlen('.phar.php'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif ($pos_z) {
            $ret['host'] = substr($file, 0, $pos_z + strlen('.phar.gz'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif ($pos_b) {
            $ret['host'] = substr($file, 0, $pos_z + strlen('.phar.bz2'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif (($pos_p = strpos($file, ".phar")) !== false) {
            $ret['host'] = substr($file, 0, $pos_p + strlen('.phar'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } else {
            return false;
        }
        if (!$ret['path']) {
            $ret['path'] = '/';
        }
        return $ret;
    }
    
    /**
     * Locate the .phar archive in the include_path and detect the file to open within
     * the archive.
     *
     * Possible parameters are phar://pharname.phar/filename_within_phar.ext
     * @param string a file within the archive
     * @return string the filename within the .phar to retrieve
     */
    public function initializeStream($file)
    {
        $file = self::processFile($file);
        $info = @parse_url($file);
        if (!$info) {
            $info = self::parseUrl($file);
        }
        if (!$info) {
            return false;
        }
        if (!isset($info['host'])) {
            // malformed internal file
            return false;
        }
        if (!isset(self::$_pharFiles[$info['host']]) &&
              !isset(self::$_pharMapping[$info['host']])) {
            try {
                self::loadPhar($info['host']);
                // use alias from here out
                $info['host'] = self::$_pharFiles[$info['host']];
            } catch (Exception $e) {
                return false;
            }
        }
        if (!isset($info['path'])) {
            return false;
        } elseif (strlen($info['path']) > 1) {
            $info['path'] = substr($info['path'], 1);
        }
        if (isset(self::$_pharMapping[$info['host']])) {
            $this->_basename = $info['host'];
            $this->_archiveName = self::$_pharMapping[$info['host']][0];
            $this->_compressed = self::$_pharMapping[$info['host']][1];
        } elseif (isset(self::$_pharFiles[$info['host']])) {
            $this->_archiveName = $info['host'];
            $this->_basename = self::$_pharFiles[$info['host']];
            $this->_compressed = self::$_pharMapping[$this->_basename][1];
        }
        $file = $info['path'];
        return $file;
    }

    /**
     * Open the requested file - PHP streams API
     *
     * @param string $file String provided by the Stream wrapper
     * @access private
     */
    public function stream_open($file)
    {
        return $this->_streamOpen($file);
    }

    /**
     * @param string filename to opne, or directory name
     * @param bool if true, a directory will be matched, otherwise only files
     *             will be matched
     * @uses trigger_error()
     * @return bool success of opening
     * @access private
     */
    private function _streamOpen($file, $searchForDir = false)
    {
        $path = $this->initializeStream($file);
        if (!$path) {
            trigger_error('Error: Unknown phar in "' . $file . '"', E_USER_ERROR);
        }
        if (is_array($this->file = $this->extractFile($path))) {
            trigger_error($this->file[0], E_USER_ERROR);
            return false;
        }
        if ($path != $this->currentFilename) {
            if (!$searchForDir) {
                trigger_error("Cannot open '$file', is a directory", E_USER_ERROR);
                return false;
            } else {
                $this->file = '';
                return true;
            }
        }

        if (!is_null($this->file) && $this->file !== false) {
            return true;
        } else {
            return false;
        }
    }
    
    /**
     * Read the data - PHP streams API
     *
     * @param int
     * @access private
     */
    public function stream_read($count)
    {
        $ret = substr($this->file, $this->position, $count);
        $this->position += strlen($ret);
        return $ret;
    }
    
    /**
     * Whether we've hit the end of the file - PHP streams API
     * @access private
     */
    function stream_eof()
    {
        return $this->position >= $this->currentStat[7];
    }
    
    /**
     * For seeking the stream - PHP streams API
     * @param int
     * @param SEEK_SET|SEEK_CUR|SEEK_END
     * @access private
     */
    public function stream_seek($pos, $whence)
    {
        switch ($whence) {
            case SEEK_SET:
                if ($pos < 0) {
                    return false;
                }
                $this->position = $pos;
                break;
            case SEEK_CUR:
                if ($pos + $this->currentStat[7] < 0) {
                    return false;
                }
                $this->position += $pos;
                break;
            case SEEK_END:
                if ($pos + $this->currentStat[7] < 0) {
                    return false;
                }
                $this->position = $pos + $this->currentStat[7];
            default:
                return false;
        }
        return true;
    }
    
    /**
     * The current position in the stream - PHP streams API
     * @access private
     */
    public function stream_tell()
    {
        return $this->position;
    }

    /**
     * The result of an fstat call, returns mod time from creation, and file size -
     * PHP streams API
     * @uses _stream_stat()
     * @access private
     */
    public function stream_stat()
    {
        return $this->_stream_stat();
    }

    /**
     * Retrieve statistics on a file or directory within the .phar
     * @param string file/directory to stat
     * @access private
     */
    public function _stream_stat($file = null)
    {
        $std = $file ? self::processFile($file) : $this->currentFilename;
        if ($file) {
            if (isset(self::$_manifest[$this->_archiveName][$file])) {
                $this->_setCurrentFile($file);
                $isdir = false;
            } else {
                do {
                    $isdir = false;
                    if ($file == '/') {
                        break;
                    }
                    foreach (self::$_manifest[$this->_archiveName] as $path => $info) {
                        if (strpos($path, $file) === 0) {
                            if (strlen($path) > strlen($file) &&
                                  $path[strlen($file)] == '/') {
                                break 2;
                            }
                        }
                    }
                    // no files exist and no directories match this string
                    return false;
                } while (false);
                $isdir = true;
            }
        } else {
            $isdir = false; // open streams must be files
        }
        $mode = $isdir ? 0040444 : 0100444;
        // 040000 = dir, 010000 = file
        // everything is readable, nothing is writeable
        return array(
           0, 0, $mode, 0, 0, 0, 0, 0, 0, 0, 0, 0, // non-associative indices
           'dev' => 0, 'ino' => 0,
           'mode' => $mode,
           'nlink' => 0, 'uid' => 0, 'gid' => 0, 'rdev' => 0, 'blksize' => 0, 'blocks' => 0,
           'size' => $this->currentStat[7],
           'atime' => $this->currentStat[9],
           'mtime' => $this->currentStat[9],
           'ctime' => $this->currentStat[9],
           );
    }

    /**
     * Stat a closed file or directory - PHP streams API
     * @param string
     * @param int
     * @access private
     */
    public function url_stat($url, $flags)
    {
        $path = $this->initializeStream($url);
        return $this->_stream_stat($path);
    }

    /**
     * Open a directory in the .phar for reading - PHP streams API
     * @param string directory name
     * @access private
     */
    public function dir_opendir($path)
    {
        $info = @parse_url($path);
        if (!$info) {
            $info = self::parseUrl($path);
            if (!$info) {
                trigger_error('Error: "' . $path . '" is a file, and cannot be opened with opendir',
                    E_USER_ERROR);
                return false;
            }
        }
        $path = !empty($info['path']) ?
            $info['host'] . $info['path'] : $info['host'] . '/';
        $path = $this->initializeStream('phar://' . $path);
        if (isset(self::$_manifest[$this->_archiveName][$path])) {
            trigger_error('Error: "' . $path . '" is a file, and cannot be opened with opendir',
                E_USER_ERROR);
            return false;
        }
        if ($path == false) {
            trigger_error('Error: Unknown phar in "' . $file . '"', E_USER_ERROR);
            return false;
        }
        $this->fp = @fopen($this->_archiveName, "rb");
        if (!$this->fp) {
            trigger_error('Error: cannot open phar "' . $this->_archiveName . '"');
            return false;
        }
        $this->_dirFiles = array();
        foreach (self::$_manifest[$this->_archiveName] as $file => $info) {
            if ($path == '/') {
                if (strpos($file, '/')) {
                    $a = explode('/', $file);
                    $this->_dirFiles[array_shift($a)] = true;
                } else {
                    $this->_dirFiles[$file] = true;
                }
            } elseif (strpos($file, $path) === 0) {
                $fname = substr($file, strlen($path) + 1);
                if (strpos($fname, '/')) {
                    // this is a directory
                    $a = explode('/', $fname);
                    $this->_dirFiles[array_shift($a)] = true;
                } elseif ($file[strlen($path)] == '/') {
                    // this is a file
                    $this->_dirFiles[$fname] = true;
                }
            }
        }
        @fclose($this->fp);
        if (!count($this->_dirFiles)) {
            return false;
        }
        @uksort($this->_dirFiles, 'strnatcmp');
        return true;
    }

    /**
     * Read the next directory entry - PHP streams API
     * @access private
     */
    public function dir_readdir()
    {
        $ret = key($this->_dirFiles);
        @next($this->_dirFiles);
        if (!$ret) {
            return false;
        }
        return $ret;
    }

    /**
     * Close a directory handle opened with opendir() - PHP streams API
     * @access private
     */
    public function dir_closedir()
    {
        $this->_dirFiles = array();
        reset($this->_dirFiles);
        return true;
    }

    /**
     * Rewind to the first directory entry - PHP streams API
     * @access private
     */
    public function dir_rewinddir()
    {
        reset($this->_dirFiles);
        return true;
    }

    /**
     * API version of this class
     * @return string
     */
    public final function APIVersion()
    {
        return '1.1.0';
    }

    /**
     * Retrieve Phar-specific metadata for a Phar archive
     *
     * @param string $phar full path to Phar archive, or alias
     * @return null|mixed The value that was serialized for the Phar
     *                    archive's metadata
     * @throws Exception
     */
    public static function getPharMetadata($phar)
    {
        if (isset(self::$_pharFiles[$phar])) {
            $phar = self::$_pharFiles[$phar];
        }
        if (!isset(self::$_pharMapping[$phar])) {
            throw new Exception('Unknown Phar archive: "' . $phar . '"');
        }
        return self::$_pharMapping[$phar][4];
    }

    /**
     * Retrieve File-specific metadata for a Phar archive file
     *
     * @param string $phar full path to Phar archive, or alias
     * @param string $file relative path to file within Phar archive
     * @return null|mixed The value that was serialized for the Phar
     *                    archive's metadata
     * @throws Exception
     */
    public static function getFileMetadata($phar, $file)
    {
        if (!isset(self::$_pharFiles[$phar])) {
            if (!isset(self::$_pharMapping[$phar])) {
                throw new Exception('Unknown Phar archive: "' . $phar . '"');
            }
            $phar = self::$_pharMapping[$phar][0];
        }
        if (!isset(self::$_manifest[$phar])) {
            throw new Exception('Unknown Phar: "' . $phar . '"');
        }
        $file = self::processFile($file);
        if (!isset(self::$_manifest[$phar][$file])) {
            throw new Exception('Unknown file "' . $file . '" within Phar "'. $phar . '"');
        }
        return self::$_manifest[$phar][$file][6];
    }

    /**
     * @return list of supported signature algorithmns.
     */
    public static function getsupportedsignatures()
    {
        $ret = array('MD5', 'SHA-1');
        if (extension_loaded('hash')) {
            $ret[] = 'SHA-256';
            $ret[] = 'SHA-512';
        }
        return $ret;
    }
}
?><?php
}
if (!in_array('phar', stream_get_wrappers())) {
	stream_wrapper_register('phar', 'PHP_Archive');
}
if (!class_exists('Phar',0)) {
	include 'phar://'.__FILE__.'/phar.inc';
}
?><?php

/** @file phar.php
 * @ingroup Phar
 * @brief class CLICommand
 * @author  Marcus Boerger
 * @date    2007 - 2007
 *
 * Phar Command
 */

if (!extension_loaded('phar'))
{
	if (!class_exists('PHP_Archive', 0))
	{
	    echo "Neither Extension Phar nor class PHP_Archive are available.\n";
    	exit(1);
    }
    if (!in_array('phar', stream_get_wrappers()))
    {
	    stream_wrapper_register('phar', 'PHP_Archive');
    }
    if (!class_exists('Phar',0)) {
	    require 'phar://'.__FILE__.'/phar.inc';
    }
}

foreach(array("SPL", "Reflection") as $ext)
{
    if (!extension_loaded($ext))
    {
        echo "$argv[0] requires PHP extension $ext.\n";
        exit(1);
    }
}

function command_include($file)
{
    $file = 'phar://' . __FILE__ . '/' . $file;
    if (file_exists($file)) {
        include($file);
    }
}

function command_autoload($classname)
{
    command_include(strtolower($classname) . '.inc');
}

Phar::mapPhar();

spl_autoload_register('command_autoload');

new PharCommand($argc, $argv);

__HALT_COMPILER(); ?>
ˆ            pharcommand)   a:1:{s:6:"author";s:14:"Marcus Boerger";}   clicommand.incD,  x³]F¦
  ñ•)¶  )   a:1:{s:6:"author";s:14:"Marcus Boerger";}   directorygraphiterator.incô  x³]Fu  ôÎr†¶         directorytreeiterator.inc%  x³]F]  †p‹¶         pharcommand.incË¥  x³]F=   sÓ/*¶         phar.inc  x³]F)  ìk<¶         invertedregexiterator.incÖ  x³]FÕ   ICÖC¶      ÅkoÛFò»ÅZĞ•T,É–] wv¤^.w
$m¤ŸA ©¥ÄEê–¤íÀõïÌ>È]î’”{ÆÄwvŞ;¯Õë»ÃÉÉù«WäïQœP&q˜í÷Aº™ÆixBà}œnYVÈ‡]Àø‹[Ó ƒ<'oßıüVÀó¥ ,v#ä}ÀÂ2'ÿÈ(ÛR±k”Àsyqñ™ğ?ğ—1©±œK~Zèòæ6/Xä6Èã,Í3ä\  ñşĞ=M‹ ˆ³´«;Êr #³é'(Ü–x'Èıeº!Ã€mÃÇË;ëe¸ßädNÆ‚oşÈµ§k¹øv0–ùzT¦!ÊGÖkT@ÁÊ°ğ9Kc)Xq`Á:>Ãbç“ÂJMsñN.ŞY‹R”œ&Ñõõ–R;¹Ï×G¼d¾‚Ã¶ŸáU^ÁÇü“×är¤±ŒØNË˜?ø%«l½ïh:&á†_Éğ9^^¬È&‡/é@cç‰Ğ$§Hä4ÎsZøš<K.êr¶Z-=V¦ŞjÔIÿ·ôkšİ§$<[=yÏà¥Ab¨ĞIÍ:m‡©'‡r7H ›Ô¶Es„A’¬Ëœ²5ú‘/\‹ƒŒI7ÚkÈfw{`Î.¬DÈi®Şï0Êøgg°õµpÀ&«º7Ü-‡ñ
ÔHæsâM<¨‡3Ğ´Ş5Â=—ä»ïˆ¡.ÔÀ²FF·teH•IÄ†›V`dƒK¶˜·‹¦?†_½—zƒ%Æ/Rdä°`OÊÀËĞ$‹4¿“ŸóºæãôBKü†ÒÀî‚Ä[¡J¤Ÿ eqª¹îÁâ1‘‘HÄ œ+O¤5çyÔuõ¨ìõä¡•Ê”Æ­0›ÑNõİ2|µ1™XÌoÖ¹æ:÷GYAág­H!ĞÑÿ”1£€H×ò‘fPî»¡QP&à½,ˆİŸóÿ‡%,Á”ûÙ¶ùğ(åw‡¨n
Ë•5ÎÎZ‚†CÓE„hÒÚÌ4}8ˆâAãel`2g|‰2pùp§û	r>Ò¨ÍµÀÍ}Q%hØ"•9Ò¢8+½s£¼×zÙâ*5Mç„T«Å‰²ÏÒÑó¹Xr3İÆ­6µYF+şD–åÏXwjIIâÍ±¬ëò3Íà+$ôá>ß6‹ÍèÀâ´ˆüOŸÿù¯)Âtbã2
d NâªÛÅ"cDØ…V}_Cîôëı&ÑŠÚ©Ë*Ÿ¿êÔ§gEXğV7eÂKÜ¯€­¸ÎhQ²ô«Ù¸Æu…2¶Ù«}¨¤_!ÒËÏ›AQÿ©¼ı	¾æ~İ.ñ¦‡÷P@üÀh?TI^Şæ–fWL2x›Ò{ò‘F	åôŞ"N¿Â®'ØhÈ³%HêF¡Ød<¿§ĞBß2âaj_ŸÁGû¼–Ø‚M)DŠ1¹ ™^_*:='¸¢¨8Aø0²ÀZ¢Öı.(P´&ÃäL‰‹èÎf-Ùlˆ¶"³dÊÉÃoíáÄß²S‘.ØšÑCÀQƒMc¬ÅÇbµ…&OY é]Mûœ‹‘-t»à
JÁ’S\µ éFÄÅQúò?>îÚÔ@³D="²óWh12 µ^_ƒ^_ÅÿÉÌbªhgÕ›r×yl<‰µêĞ«Ã¬`/Lâ5|EÓÅñ~pìAâ…ÿ1kŒº#»Öú¿(SÀ†ÆÃFÔ& ]ßfY¢"áÿ_é·V|!°¾—d@›D3—¡—û Éñ“SQ9v!ŞhMâq’}™ä–’ %€‰n)›6Æ'–LŠ¤é(‰à~èU[³²ë°z¸ 3^ÓÁÙøó:Ìd¶BxuÈrß;{2ÃêäÔ¡/"kÉ®«ÆÅ4y&ïœÇR´ß¿´×gNÜÎTüËoïŞ™…u£ĞĞáuÆéZVš^0´h»ô.¬V:İñCUCCÁ^R5­€êŒd)Å©…7 ½ü;‹S€ùcĞI@å¾­¶;B'›˜õ*dA(‡D‚bçË’ÉP×0šÏçÜ¿Èï¿“Sœ˜¯¡ÊÌú|ç‚VÔ­°Ğ¬Ğ[4$¦ôµÉhÎ•Æ‘ö* :Züˆ÷³(‘Kf¬°>’Ÿ èç4ÊüFµÈa†/›>‚z> z´õ~Í´~î2¢é‚_A´êÂ<R¼ÆŸ½ ~@ı.‚óY°/`N5Õî³Ñ–ª‚ ¦ÂT÷¡Ï€Ò±G-İ*€£¤
G.›Š£È“ÏRO˜¹2™;Yróƒ·àİDc_ætI_[«ß§—ş0™‰p¿Æ¡BKá 
V¾G0;$3rF.áß÷ğï¯½T®$•äò¿%%?&üÔ_›`•ÄÖ8]ğ[H>CƒÇç¼ƒÿE7	ˆˆ pÔŞÀ ıøŞÂï3¶¹g´ÀXÓ"ÿğ/?Xï>xğø™p ï/F7|éüœìã4Ş—{®µ•N‹c•-àİÕ(nµ.FÔ¢€·1ÈSP¾ÄE$°b6‚æV¾OPgtÄé¯ôx­kÀAü
ÂÁn&¨Æi½›H`ò%õrë$aÃTëŠa[[#õëÍÄ½ûrÑUÊF~äôÊÒ;8È2Ğ¢Ÿê&“åÈ¿Á9Œº*05«@8{¼f¿ÅÕäØŒqZ6.‚ÚÇbfµèÆ)¯e|`GÈ ÷5œB7N»qb/µ»#*Å”³qç^KÀvë
ì;5PÖ^–êšRZ;®•ŠLˆk%+9jã'±­ª­Ğ aV¦öJ¯Î¼:¼°ûÙjºa"ä˜
î€|T`ílxpBkàS± UóşÑ64Ò•ËHWÂHˆÓa)AùÊ´Ö•èÅÅíö€K40¸8&r9Püe2|Lò§^9Ñ‘šã |WÜ3®Üa«ÌÕ›èçUÕ;*’r¯æUîªï&®¿¤À.J$_¦+“´~=`†”Ò ÕMÊh¸¬$UAW’–#	ıAOÌ^~óÆüfc¾ÀOŒQ`¡bSİ>@sØXLïh•æ§Í	‡Å+S7g|´KŒ¶şû]îãíúFË¬÷epá[:½CÆˆycÖ{õ)vAÊ{Gã·Óg]JÕñË‹•%O«6´êW8°qEâ¼ƒíúQÈ˜„AŠUºa>'÷t¡…¡³Fº0~K¤\˜÷9üíªoŞ/š¯/éPŞh‘×’ùYfÜó?%ÍŒfg¯yÆŒ¤4¸nÜr0\bÅ¹GÎ]JæÔD*¨3nk¦‚F–U“š„^[BäE£ª’Û6šø¥åYó.G
ÓŸMŒúĞ3`ÄÃÍ!åÌÀä‘ñ¤¶Ûı¼É\`Sº“&‹«›Ä0:wt:ZKch¦W'.k	èº_Åº¸ËäZâèeqÔ_Èt$ÜÎÛ7“ŠVj·%Z›Cù3ªg–nì-²˜†SÁ…Ö~¬¤-w!ÿ3Ä@äøjÃ†skcVœ]<¯ñ^'	Z»ïw˜&HpÄIp[ÿò4otÛ­yÙ½+†Êpåy³ö¬ª¢:jp:CµªcÈc4ê“™éèO' è‹“? …RÑNÂ0}fÉşá>ø 5¾L#â˜°8°½ø´ÔîÂš`·´BÔ·İØDc°»İ=çÓôz§¹mÙVïän—l0Teb»$O™BAô_—qj[ IŒ¯DVäàmÈK¾FYuŸÃ%Ğ5‘FµÂØ(ø;…ŠG
•f`J-$Üe(V¸Ã¢ô:ï÷/àÔ”K”`8t+T„'D$0ŸÌ!`Ï‚ˆ­{M„Cî † "Ô¡@¥DAÆ×[iö&›ìe÷¿¯($Ë8œuÏv&åÜ(äÉi/ß·ón[­eÁ©2’qL3.•(¨:>Ê‰JÛ5ŒÖi¡}m&ëê8ûC†Úâøß%4Õ·SÓ+FI™\ı~7Véªs€á8ŞS<ã{?ğfÃ©·ÓmWµİjóË—ã¸Ã ˆ£Ç0Zø³ñÇpäNâ±ÅîÄF¥H-–—I'ô‚{}î"ŒL»}¥¿Ÿ¶õi^ÉàæSÛnÚ@}‰˜$ìiÕ'!¡@T'b^*U²3Ø+Ûš]' &ÿŞYÛ\r­%Öx.gÎŸ_fQÖ¨7ê'GGpµ1Â\:¥µ&D©‘?te4êÀ52	)Í3¯Ä2‹Q•ÑI\@¥`´˜2À¤(ËD®£” î¹‚ï)RˆUn.4__z½¯Ğ1·o&Q$½—CÉ\ĞnÀ•3´6é“í‡ÈÁØ†èBLÌÂÀN&’È"ìT #ƒú7ı'$%ÓN»§§j ®4&säÜ÷´ÍìôúÓ¨×ÌRÃ4Qšò@Ã‚Ò%È„ºœ4S3Ab	MÚ§œBùâ°(c.µEÚğóı`h}6gÍ¬ca¢g¿ÂÄk	>ïˆE±ÌeÅÛ’:—ƒÚ*çÇø—?ğüë‰;¾ÜKX»åŸwSg8p]úÓ›>Nîo^>IO‡·şÍxêo'î¨ Ù€möôÆî5Ï{ô¦&lŸñùjœT¨~E¨sJ@GLÚt Æ¸4÷Œp!W8‡gÉ²¿ñ*¯í+^µ[[¡›ÆRp­–™Y[°¬f|Ñ;ƒfçĞÔ‘T~ˆz„™,ÛÄm(š«îîÅ^—ÏvRÇv§	uÏ³l¸„Ö´Àá”ã^ÍQmWañøÿÅêX¿;-»Ê«{ˆŒïëÔÓÄïÇz'ò 	C¶©*t–	Š ·_À%Ù™"­¦	´ëÙüj+kµ“)ñs…ä›2_‰µUŸ“d_ˆö²¢Y0½ìÿí=ıwÛ6’?'’s—r#Ëvöz÷.©İ:©›æ½$Í‹ÓëÛ:Y/-AÏ©%©Än7ÿûÍ>€ IIN»{ïü^IƒÁ|af ~ıÍr¾¼{wÿË/ï²/Ù·Ó$ål9‹q¾XÄÙd”dczd³"_-ÙkxF?\	Ÿ²q—%{úâùSÑÅ«jŒ½0«’=Éy1ã¢×$®8ƒ¿‡ÿÉöèø!`VCÙ¿»¿Ï~ûí79>•¿®x6±F•è›­¨şˆÿ½'¥„4‡‡)/Y5çâ3ÌŒåSú¾”“““/GìyÅ>&iÊ.9[•|Â¦E¾Ptåûã<+ó”c·$cy1á«rVğ
ô31¯*ŸMWÙ¸J ×Ha".D‘#èa“Å2åU1‚é¢ø^”ĞŒˆ¬½èùÛ]\$¹ËÕešŒ5Ş@ÇäbÆ«‹³×©YËóÁNz8d;q1»H²é.5°ñh´*2VVÅEÁ—<®‹ yzÈ°‡ğß¿Ãÿµû˜:|R(}úô©vÍ5ğïKö4MØ3^1õˆé'ß.ã"^ &Èˆ ı¦°‚Y¨ÑCÑèíG~àFræL?®çŒÏ19sæ?dÛ}ú×7/IÕôá¶¤•Ÿq*ğ©ƒĞ%ò›Ahdæ¾tÉLLVÈ£¥úUıK¢XÏ*6N²’Å dJµüùWI÷ã<ÏñÑÏôAÉPÖçyÉ³Q¨'Rİ,9ÑŸ>€À‡¬\òq2Å‰¢*Iş˜W,ÏÜ\eWYş1³+H¢ÀuXì.ØnË`&E|3ĞÏğ/Š#vtì{BO$=â4‰ËhØlñ!N©Å«Ÿ^¼ğ< ¾&Ç {ŠüC2AÆè'–ÅÎ¦ fô:!‰F‘l×†û¡+¾ŒÓÙ–ˆÏrÀÈ²à%i=ü­Hªùbä]ò”«6©ÙA„ÿà¯räMİ’ÚgyÆ£5ÚƒöÎEûø´@q¸a=B=Ÿ¨j·ux¿u ñ)n¶Z‚ Ëğ
¹¤Š¾rÄ‹U	2šÓp×ëNŞÀ—ŠYœ²IRÀŒsè@Ì–Lûnv;XlÚkjZò¶™2<²Ø™PÒĞ²`L³çy¿åºÊ®Áä˜(å÷”óš•²~²-&_	˜/¿û*Få<>ßÏ~89ŒÚÙ/é7ß‚ÏøõVÓ%Çæ
Å`g«–ˆ_k9B5–dËUEëVv¬ÖUOİ›m':I6¸¯.Ëq‘,É†Ğc[qMûá
"×†ëA+¢è¥(ã«Å%¸»h;An9Ÿ q-W—JŒI@r²ºKá:“” J€GYü>DùˆQ¤_Â¿¶'±À8/8xşÕ\ê¯AÉ‹Ìà¯à¦Á†‰vé¥e¿	¤y{†­æ @³ù˜ö¸"¯x}qRŒç	ìA„ÏO´€3XÀÎ¥¬öˆóÍvî„¬¿Qô—|ÅÆàÀFˆ½‹ŞE°Û‡ğH–âØ ²+[FlU"S ÖAß
¶Cªí'¸v<“0Ä˜Ií„&9L Ë+Æ‹pÉAœ?b{lÓ:†A˜B€˜ŒI.j	«NeZæ,Àö¨Ì82zD°YƒÑ;G)«Õ%tƒ†q¥ö±Æª€7_¢n‚µàP\,´$Àß‰áà¯~,âå¬u0’_YÆÅÍˆ bÓ$#ÒWÆ<hó ¬õ.·÷B0[‡ @Ëx|ÏÄ†—ÖgåªàÆ6İoÔ³°ÚmüÔ.üe?ÙÁ‰l%9¸DdĞ…«…Ä¡UëáÙ^ÿŞ&íM§£õ¸&Çª‰¼şû<ı˜g@ûwAzd2ˆ~M“Ëhw×Øà_½E9·şı¹ràÓì×è=69bÑ³_@×›Nïãş@’%‚iò©ùË_®…;¶/pÃ>ÜùK@át@1°ßA/ì"ş')ôBÉyôTÂÙj¹ÌĞCgÉ,‹a«ÉËÁîckÎIv!]2ğ¼ö~õ¸³¯¡µN~n£Nö'¼~’Úö«Ã‡0l;Úkb‚ &øÙO6klò2Çó±••º“^ñÚ Œ§³>+|(8tn•¯Pß¨Ï®³öÿû*A=MM—¹±©G(»ìŞÑ›‚½àNÇœ¹8õtLİVO$z=ì?şQƒrç¡	sN ‘ˆ8İÇ­Î#›¨®G²{}ºÛü$C l½ à4›”?ƒgå†ÎDl3ıÜı°…±
âp°Cä¡Å`¿ñI(hmĞHE~æñà4¾¡7õ-ĞX@ÄGØØ†¯A‹äÃ¸~¸bè“dQe¢wö3›¥u!Ğ
ˆı®3< \25[Sx–€U<ü‘'ƒÎ=ç¡šQ(ZHÃ›í÷à{Ê³ê·Ë€Uå—õÃ—«»(4uá®ÿ‰
ßQ<Îh\K€?Ÿ&´ú"Š2d‘’rOÁ]EËHÑrÃü„—:ÙpÖ4
 dpÊ¦ÉlUßlğ{Ã¿1¬ÕGB ÔŸÔ2~p9Ëš'6RÎöµo’z€ †„íÆt 55ÂõÅx*õööìOb÷püÜÕ’Ú6µû”üâ#ril-¢ts¹L“jpÿ]vÈşÖ²ùÛ.én˜«WÕÁöb<ç¥w(5°¾³j8¸?ü+lÚÎÙ»êıƒÁù_ñßÑ—8úù;øÛËOrø4ßİ’ˆÂPØ˜rcêªåùáû&Zøw	„¸j>út7ügs/)K^Ä84îì,JX,vÿ5’TyêæfdÁ˜›¹#ÄİAÁªØˆİ!T³EcØ;`¿§ˆdÌˆ„c5ï|b£¿mÛüİZÈ!’$7}õI‰aJÎW°îæÊêví…b/’‰ô4$ıZ°U{òa‹\‹ø¬qšÎ«Ğ¦¨·ê‘„êÔ=r9ı«å`{Ã÷„š”ÿ§É¿|/5¾_K™¬wÿµ
İ–ŒÂÒóøƒÜë‹F84-ôå§ş‚»®ˆ¾Á>¥h·…+§í¸O¯nıHIãBêé¹ÎÔŒ´Œçi·û)Çú2Á'D²$«ÃáÀ‹ù²%Gl¬z-v†o^,dr»…‰Uoübôi8hfÒğ$Æ–é	DXìkbÕ@±‰æôLUˆök	‚Ö<m’€FÏ~‰p	ˆO:šÆCˆâŸ¬×YòS_ŠÄ.§XÛÇŒl>m}U¯3„‚É.Ÿ^¹ˆrïğV1­ÂÎ	ĞA\pMt>l€öa;úãa3>Ø…Ÿîû$rSá[i»ì§@«½4¹jˆİÓ9‡­Ge¸rèæ¨1ŞÊ1(Ä&©—T2ñ
îÌ”v
ídÀĞçôú‘úø5†,µÛ+µ-©+åÄÅ>±=*¶Çº¥gæB¡jÈû&è65¤H"ÖLnVÊ„äö­™aÛSX¯%}
õ6á“ƒF’¢0NSâÂ¢¼JwY
+Ub‹­Öñ&\
¯Ê&qóËÿÁ€'ÚwâXU~†¢×Şh,I¯¬­à$6
Á:$ßı¬
åÃï¡Q(¹Ô®ON)ÿ„* § i¾à‚Ò»ÑÒ}D’tĞ¨ÿšS¯ÎE2d9 (h›>&W‹![Ä7`LÅÈ†VÈ]ŒÉ˜Y’ázÜ®ó$‹LÚéí­¶XKòDL³Å{!ß§ö{˜ˆX]%Ëcïãèht&(ÏÎDº×VÒjsï]Œİæ¼ë"E%Œ‹#´ã6"´óÈ»Ëï›¼pğÅŒ…gN›Õ5Ò
.TlÛÑõÀ×±ñ‹=¸¥İÅx1Á"Â‹¥
…Òñ¼f8¶¬C¥Ş;a^×.Ä—˜’Å^øLl³’Œ¶©¯Õ­qLË}ÿ5†uíA°¸H"´9sIzßÈ0ï•Ld)V›Ùé@Ìk^rlpPdÚMVÓ®öRhVüÜş$)Ê‘¯ûÛœ¬¥r;eº)o¬b’¯Oa2N`w«>p„ı22°½¥áIäØußÕ1ŸuùåÜÇ/´
qÑ@…Õ(ä”KF9•Ò±ŒWI!®ı“µXEáÖ`•<êª.ÏŒâñ÷à,ËkÜÙËÈEäÓU"QÆÄW¦Iy_üÓµ)vjD©_ÕŠò¿ÌÓJgg°ÕáĞyJùa=’şı$gA—å˜¹a*˜¨sFìù”í%ÈÕ‰¨é ¦ùñÕ‹¿(š)8f@ÿÌWL\J+(ô5‚}²Œ²Ô ¹À^ıøÖèäÏõß
õONÙuº%¯.PØ/ÈûpÙúŒ×ÕºõçXâàQ_¼ƒ¿cê"ó2‚í‹ÇË€/6oØã¹€ãµL;c OQ{,GE‚’%Azrƒ(QäÄÔp*94²ƒ!{H™ èßî5bÂ´Ñ³{©ô'|#š=`‡D>İ½{ş„û_ã	Æ í§R‘Ş&Ëü.ûæ”YİÕ3uI-ïäõ`8¸ÑàSÛC¨×ir6Å<„ˆ,è‘©ñwÙ»J>”.T9îlÏòñ»L `ĞÇGê{ Æ£û®RU¸z×;º¸øşù‹Ó‹‹Q´¯
„¢Ç›$úæ¸›†‡’™ZxÉb%—˜¨g´wbs ràÆ¯B~šÓ1$Rp˜ùÍØé-SQ£gÕÆ†GW'¸ÖTc<›ø”ù3êY?%­·Wa˜B«¬;O(²½Ã¯k8'ÒˆQî˜Ô5úd"#£ÛiÑ©ã°ƒÕ‡b.kèš)6L.å"Ôh»r¸Ö1{†O±Êºœ²×u )p&‡ÂÜ²hiwtİ°:TrÎN¯EIà"¾C‰Udä?r2ê“<sÜ7ßÑ-s÷MT!Ñ9(¡ G <nzÓÜšYá§è[ëøÜ#”°6%F·'ì7Ö	ô©¨•;˜Ò±“Aöqœı[m>Ø
#UYUC“ú@•š4p2<T:­Ã°¦i+7÷…Ïc™ºFfzGí5ÜÆS_c:7à<÷5¦²EOãÄ×˜*Ê=Soc¡w—¾Æ¤ï<K_ã$û Ğv_û£sİ„l´­Ó2CKéT”'…!Öl×í &§Š‹êÉj:å¸½¦r74ü8'=ªÏãôjj·ğó^RJWEÌ¥YĞa jNC¥ÕJ
åRkòéÅŞÆQûfØÖcpuŸ /–$^ï¶¹-#äLá¢ûˆ–±“Ô*¼eòÈX3‰?â5ûÕ‰w©Ÿ“¥'&™E….ORò/Êg¿<‘§ E Çà•oPQÚÚ{Ô'¿<ı°çÀ>Wi„–ÁŞ°S¶JZË[ˆ*<:U¯z¢b¤²‡_¹*±Ì—–TªçàWƒƒNÒNîÚÉdR×uÇVZÇMÎû,8ZáØ8RGgÇaoQ¦j^ä«™®±ÄSğt&7¹zĞ$+yQ‰pZ¥ÒàA@Ä­©I.ñQ‡ÇEæÉv«ÑÔKkVê%¾éy´uÔ6G¬ÆoÚH2¬ç×ÏiúyÑ1º4äyöc]³ÕßX¸ ç^Ÿ3A”I7Æ\š‰R9¾bùÀIV¬6Aõå€¸Ìó”Ç™ ‘åÊFş<e³èËxš½ÂS êHUeÙv†yâì º-@“GRëÖÔ¿h|e!´Ïñ“\AÛép«EÅ‰ğpHÈYa^¯½1#õ¯BÖë îÀ˜L™õ7|¼*JŒï«*vQh=îè¨Ú×ı ™kµ¥Ñ"27-6ÂUP†%HjüªÍ€­V±¼W.Ô0€w¤fXÛ|„ŸŠS<FŸr3‹eu£v•X¨J…˜£}Ããôu\ÍXS/¸Îù=aèÃ€A;[]"0<à<ØŠáF1ØÙ–ğ32ØKŞ'ƒ]æàÀ)¯(‰-K¨rne!}D¶E-ŸíŠëÍM«¹¢ãu±>Aİné+¶0_o5¨ƒø&«ìâ/§ŸÈ‘«~â¥XBh>ºƒÁËe¯¶\÷¯í€È×¶ Ï¹qƒme>‡)âáµD–V™©xIß#ugIù ÚßÇşO<7˜•
7bä½=vÌĞ€Ôçl$: `×8fÓĞjzhbT³XZ‘EÚ%ÒsUç##êCá©;w„ÕÁ`­¡üøx³û¢…Nmßò\<yïÜ“Z¬1R;m£nk/¡° Yy!|ò{l(CßÊ®Â›=ï{±q?Ø€\AWİâªº.ª_°w–ÂIs}@y¡ÌU¡ìL[#e.ÀòŠœ+Q’Ó¦)Ş tmPÜéj§¶9‹~H?L<=èIgIxô¡6İ»
‡×p¶ì{5e4£xQ.’şb›dÎJ”k@J-k€:‘İòl’zĞN‡¡À|(1qNC6”ªÚõ‰Á)§­%öõÌm¸ šxRtÚT¤izÉâ‰?K åNÜÂÕÜ ô.»ÁJWÂ°T]ĞF{¨ªQ°öæg¶ãecx±Õ»ƒKjpP¦ÌzINMÍµ#]“ÖUy-¯«EÒºQwiHÛ”•!ß'º&dU¤QGh§-¥Ñ5ã7«Ì;YL­˜ÑÇ¦fî“PñN:Ö®jA1Ó*ÿmÁµjj^|H"ì…WRgQI`mÒÜÛ„6`3ATbñ
0î/öVµ	Š ³ºÄ¡6p8Š¬ZÚ¬¸%ï-vKÙE&-‘İ´:Ñ‚™dì§7/˜¨!ì_½ÕF‹Ï(¢]$@5f¯}UÔ$y¼^¹Y/ç‰‡´„]‹Ú3l«dm-}Ğ[-x	½‰Z°pıçĞ¦pñëªˆÇ]f–Í‚ÜíQæ­D4”dèUï¯$¢AE 1Tr¯Îú:Ãm¡zPªo›^FA[ÊIg$êjØÆFÀ.mbtïÖ&!šËA²i¨¼–K@íÇêêŸh$ËCÍ?»©¾HÿTï½è¶ARø8Û^JÜ¼‹Fï¢]³nr»RÉ6`Ô•öÀGöZ
cJÑ»“@ÜïvÜ  +ˆE(‘ß Ø¤¨ô9†é}5šã|•Uâ1F¤;[ş˜¥°UÎ@^™Ù»4Í?òÉÈsì2X¶&çÿœ8×ø®u©‰Aq¤ØÜ[r‰¡œ#•\1&N•Nfšã’gæ…9ØIºÛQÜí6V±:Ñô@6t*Jw.S	¸t	6¶ª,úº–$vwYÈˆ	ö‹Í]‘i¨İšîŒ;”+–§µÆˆ›IÕZ7òÉZÕˆƒK¸%”;B£¢Ì†JIey®AİKĞ(DW]'|	H·±Ësä¼X$ğ.ÅO1^T‘Nxèhz`<˜ÒÏ:oª³ã;ò@‚0ôÖd ?g°ì}v×Zœˆ«ƒˆ[™<SfeÂP?;´jœD‰S-4B3eAª¡ØˆÛ¨s@¿Y7¾¨:F	¦y·—ª(úX$¦¦º{àŸ­ı´×Š30y1£JpM|GÎÍoÖ—Å&„H´ÖñÉ)ä~ˆ&ßó%H*®¡éLK a£Ñˆ¦eÕG{uuİ!¿²[oäÄ¡9áH0Wö¿£_é¦JZĞY¥¸>§ã,lq›w4t{¶§cIä,ÌÌ­m´¹Kë§eÕÀ«U~{}Ï	¸šÔÅ¸ßï£šš@v«,¯Õ>}İí©¶Ó¨é§ºnê&\³ĞícôöŠÆŞ,‰x«EEÛ!ÙØÈ¤ÖGá|ùÜnW-@]JÙ]¯ªòzVKî‰g«-åóUFáh3?U?l«	ÛDv=•`°ùBÆDN•i[uãŠ+†-2ëÙ²N9•¾õa¬
mL1ã/ovfõéK¹?İfC¨Œ“±ó¢‰nóM¢í``’z7ƒıö€ø÷ÿG?ÏQ@c16İÉZ
§•ÑùR[Xcû*j)t‹jé/géV^6U™~G§}ÚOUÆôÑ”ëä	UMŸRı9E£­¨úì[Nï­W->s}»SÉøÇÖ´‡‘©Áşt+eÌ!æECAÕñ`3]y2Ñ.˜YÁÔbÁÄ…ê©MY?2q
Z0óŒ¯‘ì$äĞ?oŞ Ê-ËÕŠzN¾@H\èN Hç•¨‡ú|›X—QMXµ3kXPÖ=sO8÷¢ª‰ÈÁÕeÙbOës9âšªå£ı}¢]´½¶·lˆ„f¤Úi®s©ˆÉÆÙĞİ^„3‡9¸½ô¶<İÔçl“.¿™
ri?R´ÁÑ˜MVLKğ¬¹bÏxee`ˆ*tñD‡R‰}N±!ş®nê©df-JæY—’	iØ\öS3¸½]=ÓBò>zÆªÙIyİ˜¬‡Eı(mb¶†âù'Ò;’º‰æ³š¢Ì${M>Áë9´åuëIF½*¼©ºÒ\UV+†õ´®‚?¢©	ıY‹Ó-)&	‚à¾™¡ˆ·Ğ3Ê“j[!Ì?5Û™×<ít·'jĞJ'-ÙåşšHÔD
{<PT´£71ŠšğÔböØF•Œ»‰zRÌ\¢ú•I37<¶»uë.ú4ÕÇS~Ñ¶>Ì…â¢ƒ‘]KRƒóıµßáĞ«Q&*oY»¢½ıÂ¶uÛvŞàVOsİjù[™°¬~„õ¡B°j‹‰ş¤ÕŸl:Ë~g{^Õ·‘×›Ìøò`}ŒyÓRª¾}«Ö]ìZwÔ5tûµ“[y¥$Ñ¥ŠgªaÈœXFÄ¥b/´eúMòÃm®É“ïb²ÍÃïşB»°˜’ŞW‰´\#bƒìsRÑÂ—?v… ĞÑ£—C5C mÂÕ[‚­R´Ğ¯§¬÷ŒÂ×5ÀªP\fi¼±’T…°P(ê¡Ã,dõ¾Hz…¢ yƒ¿¸¨’1ÅúÅ»Måİ›W# µ¼ó29šF†áü·n.…s
ŸKyw&Ju,_ÏÌ´Ò×ü‹„S£t§EàM,Go6DªÓ9dy9’V½ @”¼ˆäñ7+ ”…fÓH 0×·JV¿BÃ;A²*ÚñKÓEPñü_¤~ÒVÄâ@(¢È¡˜fõÜG¬´Šî­`1(±e–ëVÕ]rÖT×üêåm(ìÆÄº÷ûHˆ@˜Ñ›ïèô—’±ü Œ€oU$ÜmîtK! NË+_Kâ ·åbó|‘>t6ñœ8ëå…Òé`Û¥V$|ıÀNNT1eİuV/æúÎ«€¨ß’Øèlı¥'´ÁD~×	Üm,–‘ıPÅgÑKC![JX¼! V¦Ã8Úãmå
³Òí¯BAÎcÑ«‘sí‚™¨eG2Q5Å¢©­ô[÷u­ÜÜ>éÅk€÷âÕPA-hmR4ÓáDuÅT•#7[Ï“ŞÃBôÔ›túw])ZS#DØÃÍK2ÓÇÃb«‘×èHø]¼fA\"ò¯æåé[ÅøªÔ²1†v…âÌõŸ¥G‡kjıÖñkºâŞ\QS00	åãµ¸tÛz\üíoäkA¿şÙ™.¦÷9[·äkuB9[Bøƒ«†u¾síuŸ£eY¾õ-oJëq´ú›²·ë:>Tdâ^İl›uWÃÊµøG]Ö©FñvPÓ»ÕÕ	]kĞáaú8åT2¢ Õ´éJé¬ë¤yéÔ¤U†»¾»`CÚ<‚Jr5á7·ù¼Õl}ï zêá×s gĞ9eñëû!ƒ™WNA¦k…C×P™ao|EqKïÁ‡K™ÃÀTŠî´lî5ŒŞóı1Á«Û1™~¦xÊŒ|¤d
U!ß?#¹°¸©§Éla…Ïj2;¤C™ÌïšÒá˜F Ôn}zšFqşLc/­¾¶ıÄ¿
˜&e¬`¡ÑèÛ*Ÿˆ‹ëh«ŒM72FŞiwïM*}ô?É3–Õkv\cKã-bæ ³8—}
éQãı%æ/dnØÚÙ`å?q—ÿŸqáoeÁ×^èı´ç­ûÂöI«6k½s­’gôTÙĞ	]ìÖª0½1Z?ÇãÉM®ö{™—e"o1UÆ”a“Tnê·±ï^â:µFÏ;_NÖ4ë&Yûï‡Û¨Ú4ì·b×»€6İÇ]ºTĞ®ì¶ÑŞ9®aŸû[]ù&
S‹éì°uÿ ›adËp×½OğıM+úŸGô˜*C]‚{½{ş‹ç%ÄàÙ£zÓW?¾:5
MıñUoWå<Âÿ_ˆ{¹Ì¶æ%÷ãvcé{`Ğråı•®¸hş*v x]x•/ Õk=û%::Æ—ë<ùå!~2S¯ésQ¾in¬¡ñàM>bh½wœ”OZ"ÿûÖ¼ ’>8bØÌ,Â:Ã½¯Ç¤ùÇÆB³`úERí©õŞ‡HıŠÓ&dY¿ÕWÀ½Ÿ­•ŒĞ“P>ò´œû—|Ú!°Êş–dW÷O^A’²w*Å‚øG’ã\mu™Uk{TŠ+whÿ´ÙZ€ïn?ûU!uä0Ok7¬U|ßèFlÑ1\ìz$×©uÕXÓŞŒÑååôr	¾Q5D_Œş<ûâ¼HFğÅ7°Ò‚Ç¾d‡»l_=yDß›#(~Ø›¥ù%`†é±a¶ ¨W‡ ,ëƒõëÆÜÕú¨Klšuî¾İh8ÆxO·ÀÑÚˆÖåoøßW¼ÄàŒˆÈØiß½D¶+/"‘Ö vûFÒw3Qj›	ã`%zTíçÉxN×¸%ıñõ@“Zã-şiûÀë$f+šŒXô¯Z‘7›ó¸D92ÅëŠØ³‘Á‹ù¤¼ŸßEËr?İ•¾9¾û¿’AOƒ@…Ïì¯˜£6±T/4ÖÚ‹š4ö˜)°qYÈì.jˆÿİjj	iË…ÌûŞ¼}K¸Ÿ×E­T<™(˜Àc¦A] OµMzEÛœ«PÃZÄ^Ø²¦ƒÎíE¾¨`…œOqN;”¢'çf6»…«ş%z‡ºmXVe‰6•9VqmÛşËúôdS×oN
İĞ_×÷Ön:Öv^]Ö†J²½®ì©Ú±\Og}·ã¥öá^)	²ÛĞ‹'F_±jU”›tÇBN~£s‹>0]\ªHXÄ$“…£;}«CÿÂhtçx™>´M¤A£Ós"¤:Ë-Æ2ŞékL¶ò9Æôİ²Ğ&•¸3ï9°ÓVäQ~&Ã²}o|Ø!7@ç?…PÍj1>o ï0ŞªPİzVÑÒ›¡ôbvv7 É2™A|w“u[ZÅu.óı&«MÛ´RH1›Là½2c¿‘KÂ†‘;š«¥€È1¶&Zøl]/{2X>(ïaÛ‹¿’xÛ‹¯4¸q°S¤ƒ‡‡Tc•ŠâÌó|¯İJ@şXÂçì·ø£R0 nUŞ8oÓ¼x à‘Ñ–ş6ä$EÖõ#ä@Fÿğ¢PZcË/ãH‹Y\U°šSî(¹dO–‘s–âœ~d³¾ <æšL2y§¤ŒÁÏ0ìBhš¨    GBMB