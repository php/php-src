#!/usr/bin/php
<?php if (!class_exists('PHP_Archive')) {
?><?php
/**
 * PHP_Archive Class (implements .phar)
 *
 * @package PHP_Archive
 * @category PHP
 */
/**
 * PHP_Archive Class (implements .phar)
 *
 * PHAR files a singular archive from which an entire application can run.
 * To use it, simply package it using {@see PHP_Archive_Creator} and use phar://
 * URIs to your includes. i.e. require_once 'phar://config.php' will include config.php
 * from the root of the PHAR file.
 *
 * Gz code borrowed from the excellent File_Archive package by Vincent Lascaux.
 *
 * @copyright Copyright David Shafik and Synaptic Media 2004. All rights reserved.
 * @author Davey Shafik <davey@synapticmedia.net>
 * @author Greg Beaver <cellog@php.net>
 * @link http://www.synapticmedia.net Synaptic Media
 * @version $Id: Archive.php,v 1.38 2007/02/06 04:31:45 cellog Exp $
 * @package PHP_Archive
 * @category PHP
 */
 
class PHP_Archive
{
    const GZ = 0x00001000;
    const BZ2 = 0x00002000;
    const SIG = 0x00010000;
    const SHA1 = 0x0002;
    const MD5 = 0x0001;
    /**
     * Whether this archive is compressed with zlib
     *
     * @var bool
     */
    private $_compressed;
    /**
     * @var string Real path to the .phar archive
     */
    private $_archiveName = null;
    /**
     * Current file name in the phar
     * @var string
     */
    protected $currentFilename = null;
    /**
     * Length of current file in the phar
     * @var string
     */
    protected $internalFileLength = null;
    /**
     * Current file statistics (size, creation date, etc.)
     * @var string
     */
    protected $currentStat = null;
    /**
     * @var resource|null Pointer to open .phar
     */
    protected $fp = null;
    /**
     * @var int Current Position of the pointer
     */
    protected $position = 0;

    /**
     * Map actual realpath of phars to meta-data about the phar
     *
     * Data is indexed by the alias that is used by internal files.  In other
     * words, if a file is included via:
     * <code>
     * require_once 'phar://PEAR.phar/PEAR/Installer.php';
     * </code>
     * then the alias is "PEAR.phar"
     * 
     * Information stored is a boolean indicating whether this .phar is compressed
     * with zlib, another for bzip2, phar-specific meta-data, and
     * the precise offset of internal files
     * within the .phar, used with the {@link $_manifest} to load actual file contents
     * @var array
     */
    private static $_pharMapping = array();
    /**
     * Map real file paths to alias used
     *
     * @var array
     */
    private static $_pharFiles = array();
    /**
     * File listing for the .phar
     * 
     * The manifest is indexed per phar.
     * 
     * Files within the .phar are indexed by their relative path within the
     * .phar.  Each file has this information in its internal array
     *
     * - 0 = uncompressed file size
     * - 1 = timestamp of when file was added to phar
     * - 2 = offset of file within phar relative to internal file's start
     * - 3 = compressed file size (actual size in the phar)
     * @var array
     */
    private static $_manifest = array();
    /**
     * Absolute offset of internal files within the .phar, indexed by absolute
     * path to the .phar
     *
     * @var array
     */
    private static $_fileStart = array();
    /**
     * file name of the phar
     *
     * @var string
     */
    private $_basename;

    /**
     * Allows loading an external Phar archive without include()ing it
     *
     * @param string $file
     * @throws Exception
     */
    public static final function loadPhar($file)
    {
        $file = realpath($file);
        if ($file) {
            $fp = fopen($file, 'rb');
            $buffer = '';
            while (!$found && !feof($fp)) {
                $buffer .= fread($fp, 8192);
                // don't break phars
                if ($pos = strpos($buffer, '__HALT_COMPI' . 'LER();')) {
                    fclose($fp);
                    return self::_mapPhar($file, $pos);
                }
            }
            fclose($fp);
        }
    }

    /**
     * Map a full real file path to an alias used to refer to the .phar
     *
     * This function can only be called from the initialization of the .phar itself.
     * Any attempt to call from outside the .phar or to re-alias the .phar will fail
     * as a security measure.
     * @param string $file full realpath() filepath, like /path/to/go-pear.phar
     * @param string $alias alias used in opening a file within the phar
     *                      like phar://go-pear.phar/file
     * @param bool $compressed determines whether to attempt zlib uncompression
     *                         on accessing internal files
     * @param int $dataoffset the value of __COMPILER_HALT_OFFSET__
     */
    public static final function mapPhar($file, $dataoffset)
    {
        try {
            // this ensures that this is safe
            if (!in_array($file, get_included_files())) {
                die('SECURITY ERROR: PHP_Archive::mapPhar can only be called from within ' .
                    'the phar that initiates it');
            }
            self::_mapPhar($file, $dataoffset);
        } catch (Exception $e) {
            die($e->getMessage());
        }
    }

    /**
     * Sub-function, allows recovery from errors
     *
     * @param unknown_type $file
     * @param unknown_type $dataoffset
     */
    private static function _mapPhar($file, $dataoffset)
    {
        $file = realpath($file);
        if (isset(self::$_manifest[$file])) {
            return;
        }
        if (!is_array(self::$_pharMapping)) {
            self::$_pharMapping = array();
        }
        $fp = fopen($file, 'rb');
        // seek to __HALT_COMPILER_OFFSET__
        fseek($fp, $dataoffset);
        $manifest_length = unpack('Vlen', fread($fp, 4));
        $manifest = '';
        $last = '1';
        while (strlen($last) && strlen($manifest) < $manifest_length['len']) {
            $read = 8192;
            if ($manifest_length['len'] - strlen($manifest) < 8192) {
                $read = $manifest_length['len'] - strlen($manifest);
            }
            $last = fread($fp, $read);
            $manifest .= $last;
        }
        if (strlen($manifest) < $manifest_length['len']) {
            throw new Exception('ERROR: manifest length read was "' . 
                strlen($manifest) .'" should be "' .
                $manifest_length['len'] . '"');
        }
        $info = self::_unserializeManifest($manifest);
        if ($info['alias']) {
            $alias = $info['alias'];
            $explicit = true;
        } else {
            $alias = $file;
            $explicit = false;
        }
        self::$_manifest[$file] = $info['manifest'];
        $compressed = $info['compressed'];
        self::$_fileStart[$file] = ftell($fp);
        fclose($fp);
        if ($compressed & 0x00001000) {
            if (!function_exists('gzinflate')) {
                throw new Exception('Error: zlib extension is not enabled - gzinflate() function needed' .
                    ' for compressed .phars');
            }
        }
        if ($compressed & 0x00002000) {
            if (!function_exists('bzdecompress')) {
                throw new Exception('Error: bzip2 extension is not enabled - bzdecompress() function needed' .
                    ' for compressed .phars');
            }
        }
        if (isset(self::$_pharMapping[$alias])) {
            throw new Exception('ERROR: PHP_Archive::mapPhar has already been called for alias "' .
                $alias . '" cannot re-alias to "' . $file . '"');
        }
        self::$_pharMapping[$alias] = array($file, $compressed, $dataoffset, $explicit,
            $info['metadata']);
        self::$_pharFiles[$file] = $alias;
    }

    /**
     * extract the manifest into an internal array
     *
     * @param string $manifest
     * @return false|array
     */
    private static function _unserializeManifest($manifest)
    {
        // retrieve the number of files in the manifest
        $info = unpack('V', substr($manifest, 0, 4));
        $apiver = substr($manifest, 4, 2);
        $apiver = bin2hex($apiver);
        $apiver_dots = hexdec($apiver[0]) . '.' . hexdec($apiver[1]) . '.' . hexdec($apiver[2]);
        $majorcompat = hexdec($apiver[0]);
        $calcapi = explode('.', '1.0.0');
        if ($calcapi[0] != $majorcompat) {
            throw new Exception('Phar is incompatible API version ' . $apiver_dots . ', but ' .
                'PHP_Archive is API version 1.0.0');
        }
        if ($calcapi[0] === '0') {
            if ('1.0.0' != $apiver_dots) {
                throw new Exception('Phar is API version ' . $apiver_dots .
                    ', but PHP_Archive is API version 1.0.0', E_USER_ERROR);
            }
        }
        $flags = unpack('V', substr($manifest, 6, 4));
        $ret = array('compressed' => $flags & 0x00003000);
        // signature is not verified by default in PHP_Archive, phar is better
        $ret['hassignature'] = $flags & 0x00010000;
        $aliaslen = unpack('V', substr($manifest, 10, 4));
        if ($aliaslen) {
            $ret['alias'] = substr($manifest, 14, $aliaslen[1]);
        } else {
            $ret['alias'] = false;
        }
        $manifest = substr($manifest, 14 + $aliaslen[1]);
        $metadatalen = unpack('V', substr($manifest, 0, 4));
        if ($metadatalen[1]) {
            $ret['metadata'] = unserialize(substr($manifest, 4, $metadatalen[1]));
            $manifest = substr($manifest, 4 + $metadatalen[1]);
        } else {
            $ret['metadata'] = null;
            $manifest = substr($manifest, 4);
        }
        $offset = 0;
        $start = 0;
        for ($i = 0; $i < $info[1]; $i++) {
            // length of the file name
            $len = unpack('V', substr($manifest, $start, 4));
            $start += 4;
            // file name
            $savepath = substr($manifest, $start, $len[1]);
            $start += $len[1];
            // retrieve manifest data:
            // 0 = uncompressed file size
            // 1 = timestamp of when file was added to phar
            // 2 = compressed filesize
            // 3 = crc32
            // 4 = flags
            // 5 = metadata length
            $ret['manifest'][$savepath] = array_values(unpack('Va/Vb/Vc/Vd/Ve/Vf', substr($manifest, $start, 24)));
            $ret['manifest'][$savepath][3] = sprintf('%u', $ret['manifest'][$savepath][3]);
            if ($ret['manifest'][$savepath][5]) {
                $ret['manifest'][$savepath][6] = unserialize(substr($manifest, $start + 24,
                    $ret['manifest'][$savepath][5]));
            } else {
                $ret['manifest'][$savepath][6] = null;
            }
            $ret['manifest'][$savepath][7] = $offset;
            $offset += $ret['manifest'][$savepath][2];
            $start += 24 + $ret['manifest'][$savepath][5];
        }
        return $ret;
    }

    /**
     * @param string
     */
    private static function processFile($path)
    {
        if ($path == '.') {
            return '';
        }
        $std = str_replace("\\", "/", $path);
        while ($std != ($std = ereg_replace("[^\/:?]+/\.\./", "", $std))) ;
        $std = str_replace("/./", "", $std);
        if (strlen($std) > 1 && $std[0] == '/') {
            $std = substr($std, 1);
        }
        if (strncmp($std, "./", 2) == 0) {
            return substr($std, 2);
        } else {
            return $std;
        }
    }

    /**
     * Seek in the master archive to a matching file or directory
     * @param string
     */
    protected function selectFile($path, $allowdirs = true)
    {
        $std = self::processFile($path);
        if (isset(self::$_manifest[$this->_archiveName][$path])) {
            $this->_setCurrentFile($path);
            return true;
        }
        if (!$allowdirs) {
            return 'Error: "' . $path . '" is not a file in phar "' . $this->_basename . '"';
        }
        foreach (self::$_manifest[$this->_archiveName] as $file => $info) {
            if (empty($std) ||
                  //$std is a directory
                  strncmp($std.'/', $path, strlen($std)+1) == 0) {
                $this->currentFilename = $this->internalFileLength = $this->currentStat = null;
                return true;
            }
        }
        return 'Error: "' . $path . '" not found in phar "' . $this->_basename . '"';
    }

    private function _setCurrentFile($path)
    {
        $this->currentStat = array(
            2 => 0100444, // file mode, readable by all, writeable by none
            4 => 0, // uid
            5 => 0, // gid
            7 => self::$_manifest[$this->_archiveName][$path][0], // size
            9 => self::$_manifest[$this->_archiveName][$path][1], // creation time
            );
        $this->currentFilename = $path;
        $this->internalFileLength = self::$_manifest[$this->_archiveName][$path][2];
        // seek to offset of file header within the .phar
        if (is_resource(@$this->fp)) {
            fseek($this->fp, self::$_fileStart[$this->_archiveName] + self::$_manifest[$this->_archiveName][$path][7]);
        }
    }

    /**
     * Seek to a file within the master archive, and extract its contents
     * @param string
     * @return array|string an array containing an error message string is returned
     *                      upon error, otherwise the file contents are returned
     */
    public function extractFile($path)
    {
        $this->fp = @fopen($this->_archiveName, "rb");
        if (!$this->fp) {
            return array('Error: cannot open phar "' . $this->_archiveName . '"');
        }
        if (($e = $this->selectFile($path, false)) === true) {
            $data = '';
            $count = $this->internalFileLength;
            while ($count) {
                if ($count < 8192) {
                    $data .= @fread($this->fp, $count);
                    $count = 0;
                } else {
                    $count -= 8192;
                    $data .= @fread($this->fp, 8192);
                }
            }
            @fclose($this->fp);
            if (self::$_manifest[$this->_archiveName][$path][4] & self::GZ) {
                $data = gzinflate($data);
            } elseif (self::$_manifest[$this->_archiveName][$path][4] & self::BZ2) {
                $data = bzdecompress($data);
            }
            if (!isset(self::$_manifest[$this->_archiveName][$path]['ok'])) {
                if (strlen($data) != $this->currentStat[7]) {
                    return array("Not valid internal .phar file (size error {$size} != " .
                        $this->currentStat[7] . ")");
                }
                if (self::$_manifest[$this->_archiveName][$path][3] != sprintf("%u", crc32($data))) {
                    return array("Not valid internal .phar file (checksum error)");
                }
                self::$_manifest[$this->_archiveName][$path]['ok'] = true;
            }
            return $data;
        } else {
            @fclose($this->fp);
            return array($e);
        }
    }

    /**
     * Parse urls like phar:///fullpath/to/my.phar/file.txt
     *
     * @param string $file
     * @return false|array
     */
    static protected function parseUrl($file)
    {
        if (substr($file, 0, 7) != 'phar://') {
            return false;
        }
        $file = substr($file, 7);
    
        $ret = array('scheme' => 'phar');
        $pos_p = strpos($file, '.phar.php');
        $pos_z = strpos($file, '.phar.gz');
        $pos_b = strpos($file, '.phar.bz2');
        if ($pos_p) {
            if ($pos_z) {
                return false;
            }
            $ret['host'] = substr($file, 0, $pos_p + strlen('.phar.php'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif ($pos_z) {
            $ret['host'] = substr($file, 0, $pos_z + strlen('.phar.gz'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif ($pos_b) {
            $ret['host'] = substr($file, 0, $pos_z + strlen('.phar.bz2'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif (($pos_p = strpos($file, ".phar")) !== false) {
            $ret['host'] = substr($file, 0, $pos_p + strlen('.phar'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } else {
            return false;
        }
        if (!$ret['path']) {
            $ret['path'] = '/';
        }
        return $ret;
    }
    
    /**
     * Locate the .phar archive in the include_path and detect the file to open within
     * the archive.
     *
     * Possible parameters are phar://pharname.phar/filename_within_phar.ext
     * @param string a file within the archive
     * @return string the filename within the .phar to retrieve
     */
    public function initializeStream($file)
    {
        $info = @parse_url($file);
        if (!$info) {
            $info = self::parseUrl($file);
        }
        if (!$info) {
            return false;
        }
        if (!isset($info['host'])) {
            // malformed internal file
            return false;
        }
        if (!isset(self::$_pharFiles[$info['host']]) &&
              !isset(self::$_pharMapping[$info['host']])) {
            try {
                self::loadPhar($info['host']);
                // use alias from here out
                $info['host'] = self::$_pharFiles[$info['host']];
            } catch (Exception $e) {
                return false;
            }
        }
        if (!isset($info['path'])) {
            return false;
        } elseif (strlen($info['path']) > 1) {
            $info['path'] = substr($info['path'], 1);
        }
        if (isset(self::$_pharMapping[$info['host']])) {
            $this->_basename = $info['host'];
            $this->_archiveName = self::$_pharMapping[$info['host']][0];
            $this->_compressed = self::$_pharMapping[$info['host']][1];
        } elseif (isset(self::$_pharFiles[$info['host']])) {
            $this->_archiveName = $info['host'];
            $this->_basename = self::$_pharFiles[$info['host']];
            $this->_compressed = self::$_pharMapping[$this->_basename][1];
        }
        $file = $info['path'];
        return $file;
    }

    /**
     * Open the requested file - PHP streams API
     *
     * @param string $file String provided by the Stream wrapper
     * @access private
     */
    public function stream_open($file)
    {
        return $this->_streamOpen($file);
    }

    /**
     * @param string filename to opne, or directory name
     * @param bool if true, a directory will be matched, otherwise only files
     *             will be matched
     * @uses trigger_error()
     * @return bool success of opening
     * @access private
     */
    private function _streamOpen($file, $searchForDir = false)
    {
        $path = $this->initializeStream($file);
        if (!$path) {
            trigger_error('Error: Unknown phar in "' . $file . '"', E_USER_ERROR);
        }
        if (is_array($this->file = $this->extractFile($path))) {
            trigger_error($this->file[0], E_USER_ERROR);
            return false;
        }
        if ($path != $this->currentFilename) {
            if (!$searchForDir) {
                trigger_error("Cannot open '$file', is a directory", E_USER_ERROR);
                return false;
            } else {
                $this->file = '';
                return true;
            }
        }

        if (!is_null($this->file) && $this->file !== false) {
            return true;
        } else {
            return false;
        }
    }
    
    /**
     * Read the data - PHP streams API
     *
     * @param int
     * @access private
     */
    public function stream_read($count)
    {
        $ret = substr($this->file, $this->position, $count);
        $this->position += strlen($ret);
        return $ret;
    }
    
    /**
     * Whether we've hit the end of the file - PHP streams API
     * @access private
     */
    function stream_eof()
    {
        return $this->position >= $this->currentStat[7];
    }
    
    /**
     * For seeking the stream - PHP streams API
     * @param int
     * @param SEEK_SET|SEEK_CUR|SEEK_END
     * @access private
     */
    public function stream_seek($pos, $whence)
    {
        switch ($whence) {
            case SEEK_SET:
                if ($pos < 0) {
                    return false;
                }
                $this->position = $pos;
                break;
            case SEEK_CUR:
                if ($pos + $this->currentStat[7] < 0) {
                    return false;
                }
                $this->position += $pos;
                break;
            case SEEK_END:
                if ($pos + $this->currentStat[7] < 0) {
                    return false;
                }
                $this->position = $pos + $this->currentStat[7];
            default:
                return false;
        }
        return true;
    }
    
    /**
     * The current position in the stream - PHP streams API
     * @access private
     */
    public function stream_tell()
    {
        return $this->position;
    }

    /**
     * The result of an fstat call, returns mod time from creation, and file size -
     * PHP streams API
     * @uses _stream_stat()
     * @access private
     */
    public function stream_stat()
    {
        return $this->_stream_stat();
    }

    /**
     * Retrieve statistics on a file or directory within the .phar
     * @param string file/directory to stat
     * @access private
     */
    public function _stream_stat($file = null)
    {
        $std = $file ? self::processFile($file) : $this->currentFilename;
        if ($file) {
            if (isset(self::$_manifest[$this->_archiveName][$file])) {
                $this->_setCurrentFile($file);
                $isdir = false;
            } else {
                $isdir = true;
            }
        } else {
            $isdir = false; // open streams must be files
        }
        $mode = $isdir ? 0040444 : 0100444;
        // 040000 = dir, 010000 = file
        // everything is readable, nothing is writeable
        return array(
           0, 0, $mode, 0, 0, 0, 0, 0, 0, 0, 0, 0, // non-associative indices
           'dev' => 0, 'ino' => 0,
           'mode' => $mode,
           'nlink' => 0, 'uid' => 0, 'gid' => 0, 'rdev' => 0, 'blksize' => 0, 'blocks' => 0,
           'size' => $this->currentStat[7],
           'atime' => $this->currentStat[9],
           'mtime' => $this->currentStat[9],
           'ctime' => $this->currentStat[9],
           );
    }

    /**
     * Stat a closed file or directory - PHP streams API
     * @param string
     * @param int
     * @access private
     */
    public function url_stat($url, $flags)
    {
        $path = $this->initializeStream($url);
        return $this->_stream_stat($path);
    }

    /**
     * Open a directory in the .phar for reading - PHP streams API
     * @param string directory name
     * @access private
     */
    public function dir_opendir($path)
    {
        $info = @parse_url($path);
        if (!$info) {
            $info = self::parseUrl($path);
            if (!$info) {
                trigger_error('Error: "' . $path . '" is a file, and cannot be opened with opendir',
                    E_USER_ERROR);
                return false;
            }
        }
        $path = !empty($info['path']) ?
            $info['host'] . $info['path'] : $info['host'] . '/';
        $path = $this->initializeStream('phar://' . $path);
        if (isset(self::$_manifest[$this->_archiveName][$path])) {
            trigger_error('Error: "' . $path . '" is a file, and cannot be opened with opendir',
                E_USER_ERROR);
            return false;
        }
        if ($path == false) {
            trigger_error('Error: Unknown phar in "' . $file . '"', E_USER_ERROR);
            return false;
        }
        $this->fp = @fopen($this->_archiveName, "rb");
        if (!$this->fp) {
            trigger_error('Error: cannot open phar "' . $this->_archiveName . '"');
            return false;
        }
        $this->_dirFiles = array();
        foreach (self::$_manifest[$this->_archiveName] as $file => $info) {
            if ($path == '/') {
                if (strpos($file, '/')) {
                    $a = explode('/', $file);
                    $this->_dirFiles[array_shift($a)] = true;
                } else {
                    $this->_dirFiles[$file] = true;
                }
            } elseif (strpos($file, $path) === 0) {
                $fname = substr($file, strlen($path) + 1);
                if (strpos($fname, '/')) {
                    $a = explode('/', $fname);
                    $this->_dirFiles[array_shift($a)] = true;
                } elseif (strlen($file) != strlen($path)) {
                    // if the two match exactly, the path searched for was
                    // not a directory, but was a file.
                    $this->_dirFiles[$fname] = true;
                }
            }
        }
        @fclose($this->fp);
        @uksort($this->_dirFiles, 'strnatcmp');
        return true;
    }

    /**
     * Read the next directory entry - PHP streams API
     * @access private
     */
    public function dir_readdir()
    {
        $ret = key($this->_dirFiles);
        @next($this->_dirFiles);
        if (!$ret) {
            return false;
        }
        return $ret;
    }

    /**
     * Close a directory handle opened with opendir() - PHP streams API
     * @access private
     */
    public function dir_closedir()
    {
        $this->_dirFiles = array();
        reset($this->_dirFiles);
        return true;
    }

    /**
     * Rewind to the first directory entry - PHP streams API
     * @access private
     */
    public function dir_rewinddir()
    {
        reset($this->_dirFiles);
        return true;
    }

    /**
     * API version of this class
     * @return string
     */
    public final function APIVersion()
    {
        return '1.0.0';
    }

    /**
     * Retrieve Phar-specific metadata for a Phar archive
     *
     * @param string $phar full path to Phar archive, or alias
     * @return null|mixed The value that was serialized for the Phar
     *                    archive's metadata
     * @throws Exception
     */
    public static function getPharMetadata($phar)
    {
        if (isset(self::$_pharFiles[$phar])) {
            $phar = self::$_pharFiles[$phar];
        }
        if (!isset(self::$_pharMapping[$phar])) {
            throw new Exception('Unknown Phar archive: "' . $phar . '"');
        }
        return self::$_pharMapping[$phar][4];
    }

    /**
     * Retrieve File-specific metadata for a Phar archive file
     *
     * @param string $phar full path to Phar archive, or alias
     * @param string $file relative path to file within Phar archive
     * @return null|mixed The value that was serialized for the Phar
     *                    archive's metadata
     * @throws Exception
     */
    public static function getFileMetadata($phar, $file)
    {
        if (!isset(self::$_pharFiles[$phar])) {
            if (!isset(self::$_pharMapping[$phar])) {
                throw new Exception('Unknown Phar archive: "' . $phar . '"');
            }
            $phar = self::$_pharMapping[$phar][0];
        }
        if (!isset(self::$_manifest[$phar])) {
            throw new Exception('Unknown Phar: "' . $phar . '"');
        }
        $file = self::processFile($file);
        if (!isset(self::$_manifest[$phar][$file])) {
            throw new Exception('Unknown file "' . $file . '" within Phar "'. $phar . '"');
        }
        return self::$_manifest[$phar][$file][6];
    }
}
?><?php
}
if (!in_array('phar', stream_get_wrappers())) {
	stream_wrapper_register('phar', 'PHP_Archive');
}
if (!class_exists('Phar',0)) {
	include 'phar://'.__FILE__.'/phar.inc';
}
?><?php

/** @file phar.php
 * @ingroup Phar
 * @brief class CLICommand
 * @author  Marcus Boerger
 * @date    2007 - 2007
 *
 * Phar Command
 */

if (!extension_loaded('phar'))
{
	if (!class_exists('PHP_Archive', 0))
	{
	    echo "Neither Extension Phar nor class PHP_Archive are available.\n";
    	exit(1);
    }
    if (!in_array('phar', stream_get_wrappers()))
    {
	    stream_wrapper_register('phar', 'PHP_Archive');
    }
    if (!class_exists('Phar',0)) {
	    require 'phar://'.__FILE__.'/phar.inc';
    }
}

foreach(array("SPL", "Reflection") as $ext)
{
    if (!extension_loaded($ext))
    {
        echo "$argv[0] requires PHP extension $ext.\n";
        exit(1);
    }
}

function command_include($file)
{
    $file = 'phar://' . __FILE__ . '/' . $file;
    if (file_exists($file)) {
        include($file);
    }
}

function command_autoload($classname)
{
    command_include(strtolower($classname) . '.inc');
}

Phar::mapPhar();

spl_autoload_register('command_autoload');

new PharCommand($argc, $argv);

__HALT_COMPILER(); ?>
6            pharcommand       clicommand.inc?,  =tAH¤
  -åzF¶         directorygraphiterator.incô  =tAHu  ôÎr†¶         directorytreeiterator.inc%  =tAH]  †p‹¶         invertedregexiterator.incÖ  =tAHÕ   ICÖC¶         pharcommand.incw«  =tAH*!  Ÿ,ãó¶         phar.inc  =tAH)  ìk<¶      ÅkoÛFò»ÅZĞ•T,É–] wv¤^.w
$m¤ŸA ©¥ÄEê–¤íÀõïÌ>È]î’”{Æ [wvŞ;¯Õë»ÃÉÉù«WäïQœP&q˜í÷Aº™ÆixBàyœnYVÈ‡]Àøƒ[Ó ƒ<'oßıüVÀó¥ ,v#ä}ÀÂ2'ÿÈ(ÛR±k”Àëòââ2áoğ—1©±œK~Zèòæ6/Xä6Èã,Í3ä\  ñşĞ=M‹ ˆ³´«;Êr #³é'(Ü–x'Èıeº!Ã€mÃÇÃ;ëa¸ßädNÆ‚oşÈµ§k¹øv0–ùzT¦!ÊGÖkT@ÁÊ°ğ9Kc)Xq`Á:¾†Å.Î'„”šæâ\¼³¥(9M¢ëë--¤vrŸ¯,xÉ|ÿ†m?Ã£
¼‚#"ø'¯ÉåHc_b;e,cşà—¬²õ6¾£é˜„;~%ÃGäxy±z";š¾¤'B“œ"‘Ó8Ïiákò,¹¨ËÙjµôX™z«Q'ıßÒ¯ivŸVLx’ğlõä=ƒ—‰¡B'5è´¦Èİ lvHPÛÍI².sÊÖèG¾p-2&İhoL¬1 ›5í=8»° §¹z¿Ã(ãŸÁÖ×Â›¬êŞp·Æ+P#™Ï‰7ñ\ 
Î@BÓz×÷\’ï¾#†ºPË5İÒ•!@V&nZ‘.ÙbŞ.šş2üê½Ôl,1~‘"#‡€{ZP^† Y¤ùütœ×5_N/´Äo(á.H¼ªDú	R§šë(‰DêàÁ¹òDúXsG]WÊ^OªQ©LiìÙ
³íTß-£ÁW“‰Åüfk®sÏq”ô~ÖŠıO3
øñˆt-iå¾eŞË‚8Ñı9ÿXÂL¹¯‘m›/¥üîÕMa¹Ò¢ÆÙYKĞpcºˆMZ»ƒ™Æ Q<(c¼ŒLæŒ/Q.ît?#A.ÃçbBµù±¸¹/ª[¤2GZçO¥wn”÷Z[œA¥¦éœÊaµ¸1AöY:zş1WKnF#¢Û¸Õ¦6Ëh¥ÂŸÈò¢üëN-)I¼9–Õa]~¦|…„>ÜçÛf±Xœ‘ÿéó?ÿõñ# E˜Nl\FÀéC\@u»¡XdŒH»ĞŠ ïk¨ñ…;ız¿I´¢vDê²Êço‡:õéY¼ÕMG™†…ğ÷+`+®3Z”,=Æj6®q]¡ŒmöÄj_*éWˆôò³ÃfPÔ*o‚¯¹_·K¼éá=?0ÅUc’—·¹¥ÙÀ“‡¦ô|¤QB9½·ˆÓ¯°ëÀ	6òl	’zƒQE(6Y Ïï)ô„Ğ·Œx˜Ú×gğÑ>¯%6…àc“E
‘bL.@¦„×—ŠNÏ	®h#*N>Œ,°–¨u¿
­ÉÆ09Sâ"º³YK6¢­HÅ,™ròğæ­=ü‚ø[v*Ò[3zH8j°iŒµøX¬¶Ğä)4½r¡iŸs1²…n\áQ	!XrŠ«$İˆ¸8
C_şÇ—»65Ğ,QˆìüZEŒ@­×× ×WçBñ2óŸØŸªÚCõ¦Üu›'Ob­:ôê0k'Ø“x_ÑôBq¼{xá?fQwd×Zÿe
ØĞ˜Â`ØÃˆÚ ëÛ,KTä#üÿ•~kaÅGàè{i@´I4sz¹?9•cçâÖ$N'Ù—yAn)	R˜è–²icìpbÉ¤H*‘’ˆî‡^µ5+»Î «W€2ã5|‘?ÿ¨ÃLf+G‡,÷½ó±'3¨NNú"²–ìºj\L“ÇaòÎy,EûMñK{}æÄíLÅ¿üöîİ‘YX78
^ç°Ğiœ®e…Á¡ùç5 ãI‹¶KOàÂj¥Ó?T54ì%UÓ
¨ÎH–RœZxĞË¿³8õ˜?´ tàYîÛj»#t²‰Y¯B†„rHÔÉ!(v¾,™u£ù|Îı‹üş;9Å‰ùªÌ¼  ¿Ágq.hEİ
ûÍ
Í±ECbJ_›Œæ\ii¯¢£Åx?‹¹dÆ
ëÓ!ù	€~N£ÌoT‹fñ²é#¨çªG[ï×LÛá§á.#š.øD«.Ì#ÅküÙê´Ğï"8ŸûbæTSí>m©¡*j*Lu*ğ({ÔÒ­à?^–4Ù>R3aæJbî<É-‚×N|!“Ó|m]lD|Ÿ>\úÃd&"ıç	-5ƒ¨UiPøÁÄÌÈ¹„¿ïáï¯½T®$•äò¿%%?&üÔ¯r,°€Ø~ÉÁgèíøè€cğwô€ˆà	gH]ßzĞŠßáœAğ>c›{@÷‹å,òùÁrzìy÷ÁƒÿÃßÈ„}1ºáKççd§ñ¾Ü8@[é¯8QÙŞ]âVk`1ÑDİ 
xƒ<e•K\ÄA+fhnåûuF÷Aœnğ6Ï€×–œ‘1ÁÿSv3A5NëİD“/©—[‡{¥ZW;Úá¨_Ïh&î]Ø’‹F¨R6ò#W–ŞÁ@–øT#Ù˜(GÆäÎaÔU|©1ÂÙ“5û)V§&ÇnÜøÂ§eã¨}"fŠnœòFfÀgu„ºpQ¾)tÓé´(öR»ö0¢ÒX8apîµ‰l·nÏÀ¾Seíeù¡.'¥°ÙZ©È„è°L²ò¢6yÛª²
fej¯ôê<Á[Ã»•­&Bî€Ù¡àÈ§ÖÎ–Y'„±>+İªæÕ£m i¤+—‘®„‘§ÃR‚ò•i­+Ğ‹‹Ûí—h`pqxËå,uğ—Éğ1ÉŸrx<æDGj„ƒò]qÏ¸r{†­2W[¢ŸGTUWì8:¨HÊ½š|¸«¾–¸ş’»(	|™†LÒúõ€aRJƒV7)£×²’4V]IZN#<ôm21_xAúÍóKù»;1A…ŠMuñ }=`c1½£UšŸ6‡g¬Lİœñ©.1f×ú;îwq¸kL¶ëË,³Ô—Á…oéôk æYïÕÕ{8`¤Ø)oŸyLŸuUKÄ?,/Vv”<­:ĞªUáÀÆíˆóúµë÷ c)è†ùœÜ7Ò…~„ÎéÂø‘pa^åğ§«¾Q¿è»¾¤Cy™E^Kæd™qOÌWü”43š¾æ3~‹Òàºq1ÈeÀp‰­ç}8w)™S© Î¸­™
yZVMjzm	‘ªJnÛhà÷•gÍß¶)L6-0êCÏ€7w†<4–3C “SDÆ“Úfl÷#ğt$smLéNš,®FÃèÜÑéh-¡™^<º¬% §Uuq—Éµ8ÄÑËâ¨¿éH¸o&­ÔnK´6‡òTÏ,ÜØ[d1§‚­ı(XI[®Aşg<ˆYÈñÕ
¾DCÎ­MXqDtñ¼Æ{@&hí¾ßaš Á]'Ámı£Ó¼Ñm·æe7ö®*Ã•ç9ÎÚ³BªŠ:ê¨Á9vêÕª!-Ğ¨Of¦£?€ ?.Nş …RÑNÂ0}fÉşá>ø 5¾L#â˜°8°½ø´ÔîÂš`·´BÔ·İØDc°»İ=çÓôz§¹mÙVïän—l0Teb»$O™BAô_—qj[ IŒ¯DVäàmÈK¾FYuŸÃ%Ğ5‘FµÂØ(ø;…ŠG
•f`J-$Üe(V¸Ã¢ô:ï÷/àÔ”K”`8t+T„'D$0ŸÌ!`Ï‚ˆ­{M„Cî † "Ô¡@¥DAÆ×[iö&›ìe÷¿¯($Ë8œuÏv&åÜ(äÉi/ß·ón[­eÁ©2’qL3.•(¨:>Ê‰JÛ5ŒÖi¡}m&ëê8ûC†Úâøß%4Õ·SÓ+FI™\ı~7Véªs€á8ŞS<ã{?ğfÃ©·ÓmWµİjóË—ã¸Ã ˆ£Ç0Zø³ñÇpäNâ±ÅîÄF¥H-–—I'ô‚{}î"ŒL»}¥¿Ÿ¶õi^ÉàæSÛnÚ@}‰˜$ìiÕ'!¡@T'b^*U²3Ø+Ûš]' &ÿŞYÛ\r­%Öx.gÎŸ_fQÖ¨7ê'GGpµ1Â\:¥µ&D©‘?te4êÀ52	)Í3¯Ä2‹Q•ÑI\@¥`´˜2À¤(ËD®£” î¹‚ï)RˆUn.4__z½¯Ğ1·o&Q$½—CÉ\ĞnÀ•3´6é“í‡ÈÁØ†èBLÌÂÀN&’È"ìT #ƒú7ı'$%ÓN»§§j ®4&säÜ÷´ÍìôúÓ¨×ÌRÃ4Qšò@Ã‚Ò%È„ºœ4S3Ab	MÚ§œBùâ°(c.µEÚğóı`h}6gÍ¬ca¢g¿ÂÄk	>ïˆE±ÌeÅÛ’:—ƒÚ*çÇø—?ğüë‰;¾ÜKX»åŸwSg8p]úÓ›>Nîo^>IO‡·şÍxêo'î¨ Ù€möôÆî5Ï{ô¦&lŸñùjœT¨~E¨sJ@GLÚt Æ¸4÷Œp!W8‡gÉ²¿ñ*¯í+^µ[[¡›ÆRp­–™Y[°¬f|Ñ;ƒfçĞÔ‘T~ˆz„™,ÛÄm(š«îîÅ^—ÏvRÇv§	uÏ³l¸„Ö´Àá”ã^ÍQmWañøÿÅêX¿;-»Ê«{ˆŒïëÔÓÄïÇz'ò 	C¶©*t–	Š ·_À%Ù™"­¦	´ëÙüj+kµ“)ñs…ä›2_‰µUŸ“d_ˆö²¢Y0½ìÿ…PÍj1>o ï0ŞªPİzVÑÒ›¡ôbvv7 É2™A|w“u[ZÅu.óı&«MÛ´RH1›Là½2c¿‘KÂ†‘;š«¥€È1¶&Zøl]/{2X>(ïaÛ‹¿’xÛ‹¯4¸q°S¤ƒ‡‡Tc•ŠâÌó|¯İJ@şXÂçì·ø£R0 nUŞ8oÓ¼x à‘Ñ–ş6ä$EÖõ#ä@Fÿğ¢PZcË/ãH‹Y\U°šSî(¹dO–‘s–âœ~d³¾ í=ıwÛ6’?_ş
$ë.åV–íìõî]R»uR'Í{Iš§×·q²^J‚$)RKR‰İnş÷›| ’²œìî½ó{m$ó…™øİ÷«ÅêÎı¯¿¾Ã¾f?Ì’”³Õ".&ùrgÓQ’MèA’Í‹|½b¯àı0.>c“4.Köøù³Ç¢==Š×Õ"/{`Ö%{”óbÎE¯i\q÷ş“íÑ?ğ;>BÀ¬†²gŸışûïr|*2~Uñlj*Ñ7[Q?üÿ{³HJ	iS^²jÁÅg˜Ëgô}%'''_Ø³Š}LÒ”9[—|ÊfE¾Ttåû“<+ó”c·$cy1å«rVğ
ô31Ÿ¬+ŸÍÖÙ¤J ×Ha".D‘#èa“å*åKU1‚é¢ø^”ĞŒˆ¬½èùû\$¹«õ8M&o cr1çÕÅÙ«ûÔ¬åù`'=²¸˜_$Ùl—šØø4Z+«â¢à+WƒˆEĞ<=dß°ûğß¿Ãÿµû:|R(}úô©vÍ5ğïkö8MØS^1õˆé'?¬â"^"&Èˆ ı¦°‚Y¨Ñ}ÑèÍG~àFræL?®çŒÏ19sæ?dÛ}ú×7/IÕôş¶¤•Ÿq*ğ©ƒĞ%ò›Ahdæ¾tÉLLÖÈ£¥úUıK¢XÏ*6N²’Å dJµüùWI÷ã"™,ğÑ¯ôAÉPÖyÉ³Q¨'R]¯8ÑŸ>€À‡¬\ñI2Ã‰¢*Iş˜—,ÏÜ\g—Yş1³+H¢ÀuXì.ØnË`&E|=ĞÏğ/Š#vtì{BO$=â4‰ËhØlñ!N©ÅË_?÷< ¾#Ç {ŠüC2EÆè'–ÅKÎf fô:!‰F‘l×†{¢]o…ô8Îæ€3û).{ø…”3.¬IQÊ 	häÍGìw÷×e±?N²}°€»#b…tgQc ı7ŠôÇel‘T%Ogì]ô‡»ï"Rõ8PÆ?Òè Q<©8JpØ
y"N;6éG0‘UœÎ·\éyD­¿*xIf+’j±ù@Ãlù¤jÃš™pŒ—9
³‚îIí³<ãÑíÁÜå¢ı	|Z¢Ğş¸f=B=Ÿæªî¶®ï· oŠíX— À2¼Dñ5DßÅÃËu	J-›¤kÇW?¼†/ÀUÀKlš0ã:t&3`Âëİ›õššVUÛL5²Ø™ĞªÒïÒÊÃ˜fÎ‹~Ë!t”—|©é1;#PÊQ½ Y)ë'Ñrú­€ùâÇo£aT.âCñıì§“Ã¨ı’~ó-øœ_m5]‚pl®PŞÃ|Âñ+-G¨÷“lµ®hİÊÕºü2Z?É¦÷õ¸œ	)XF?ZŒ5lÅ5í‡+ˆ\®­ˆ¢™¢Œ¯—c0èl€Ür>Eo¤\•“€ää¦¬Ä^ƒ¤U<ê˜ÈòËä#F‘~ÿ2ØÏÅãLÜG©¿%/ğ~¿ì+5ìÒK«~Hó6Y[ÍA€8fÏó	m¢pE^ıôêâDºb“D´€÷\€7QV{Äùf;wBÖß(ús¾fpŸ`ç.Âx Dï¢Cø $KqlPÙ‹-#¶.‘)Pë 3È[‡!Õ~|aIbL„¤¶Ó&åãE¸ä Î±=¶iÃ Ì!ÀXÌ`:>}	«^xZæ,Â~²Ì—82º°»•¾Që(eµC7hWjão¬
lJÔM°¼ ª€OŠ–älP@b88ø‹xµkŒdÂW–qq=b'€Ø,Éˆô•1ÚöÃ<kÁxˆÌÖ!Ğ*\Æs@†Ã¥†uçY¹.¸×Àı
êYXí6~jş²ŸìàD¶’\"2èÂÕBâĞªõØ
\}i“öºÓŒÑz\‘cÕD^‡±şÌ3 €	‚» =2D¿¥É8Úİ5ösøWïéÎÁ­®\ø4ÿ-zMXôô-èzÓé}ØH²B0í@>u!?şíşF¸cû÷÷G0ìı›!?äNûôÂ.âq’B/”œ@%œ­W«¼ =t–Ì³öæ¼ì>´æœdÒ%Ïkïş·ÿ¡Zëä6ÚàÄaÂ€áç ©ía¿=¼Ã¶£½!&Ra‚Ÿıd³‚
&/ƒ0ğx²±P©;é%¿¦Àd6oà³Æ‡‚sAçVùõí€úì:k_ğ¿­ÔÓÔt•Q„²Ëî±ØîtT;eOÇÔíhõD¢×Ãşıï5(wš0ç‰ˆÓ}ØÚè<R°‰êz$»×§;ÍO2fDÀ6‹²N³iù+xVnœíL³ğ1ÓÏHÛ¯°‘ÁØƒŠzq°Cä¡Å`¿ñI(hm”M…Êñ5à4¹d2@"¾ˆøèÅALø:r¶L®0’ë‡+†>IU&z×`?³ùPZ­€Øà:ÃóÀ%3³5Å³	XÕÀÃª3è<Ğsª…Â«4¼Ù~¾§<¨~»XU~Ùlá1Ş‹Á]°‹BSîúŸ¨x'06ÁµxğóiB«/¢(C)!÷ÜU´ŒM 7ÌOxù§Ã·gÍÁ@£ B†§l–Ì×…ğ½Á¯°7ücìŒõ'õƒÌ…\Î²æù†B~‚Díkß$õ A	Û!é2 jj„ë‹ñ.T6ê+ìíÙÿÈîâ<.ø¸«%µmj÷ùÅGäÒØZDéær•&ÕàŞ»ìŞıµe+ò×]Òİ0W¯ªƒíÅdÁKïPj>`}çÔppoøØ´³wÕûoçÁG_ãèçïàoÿ=,?ÉáGCİ’ˆÂPØ˜rcêªåùáû&Zø7B\6}ºş†³¹›”%¯b/;ËÖ‹İ{…TUÎº¹ß q0¦gn
qD€G°0~jÌ¢Æ< XÉ„›]Ï4G=Ù€örÁş-d(Ê¥0}õI‰cJ	A°ôÍ•: ííZÕÈÊÒÓVĞ¯Ú“7	[çZôÿÁš¡ém–z«$I¨N$—Ó¿Z^ ¶—|Wø¦IùßqšLñËi	üÚËä¾{¯TH·d®^Ää¶Yo8X4Â© É¡(TõÜU ÄÉ¯°ABÙÚmaKDj;öÓËä?ÒŞ¸’z~®—õZ #&ã9†àí~Ë1ËL0
Ñ,Éê890c¾jÉe«Ş‹ŸaKœKY&ĞÂÅª7~1ú4<73}JxgË¼",¶”5±j åDsz¦j*Dû$A«6QÀ¤g#E8‡$Ä'M«"dñÆOÖka,	ù%‹Ç"ãË)Ö6Â1#›ÏC[_Ã«Á¡`2Ø§W.Âß;¼UNë†°¥J9á‚kj ó ğa# ´wûÔ(›óÁ.ütÏ'‘7¾u‘¶Ëq
´ÚK“Ë†Ø=^pØ“T†‡şãƒbo’zI%SØàçÌh¢`ÑFAFİqN¯¨ßa,óXûÃRİFT-%„¸Ø'¶GÍöP·ôÌ\hTyßİ¦&P‚IÄš©¬¶Qs’Û7fêmOa½‘ô)ÔÛ„OIŠFÀ8M‰‹òv*İe)¬ù‰-¶ÚÄp)¼.›ÄÍÇÿƒ‘P4ğÄ±ª–	ŒQo¼Y‘^ÙXÁIlƒMH¾ûYÊ‡/¡Q(ëÔ®ON)1…* § i¾à‚Ò»ÑÒ}DöKÔ…ô_sêÕ¹è@†, íß'¤ãj9dËøzÌåá†VÈ]ŒYšy’ázÜ®ó$«OÚéí-ÃØHòD°³Å{!ß§ö{dMĞU²\ö>FG`‚òìL¤{m%­nî¾‹±Û¼wıAä®„qq„vÃ6RÄ|x7¬}³¾˜Êm[7È7¸P±Ñ†»aÕõÀ×±ñ‹V¸¥İÅd9ÅrÌ‹•Š‘Òñ¬f8¶ªc¨Ş;aS^5ÄcÌÕb/|&öYIFûÔW†êÖ8&‚ƒ€å¾÷
ã½ö Xu¤Úœ¹$½g¤÷J&R…ÄÍì<!&<Ç›œ™“µÖ´«€½šU#q·?MŠräëş&g“ëi©pQ™nJ(«`å«S˜Œ±Äíªa¿Êloex9vİ7ÂCu$hS~A9÷ñ­B\‡4Pa5Jbå’QrGåz,ãU’Eˆkÿd#VQ¸5XEe•„ºª]£x<yÀª¼Â½½Œ]D>e%R+åR|¯”Æ?]µb÷§F”V­(3Ì<­tŞ[§”9Ö#éßO2ğtÁ™5¦RŠºdgÄÍØ^‚lˆjâšŸ_>ÿ³Ñâœ²´cùÊ¬°PTˆRk+ô‚}²Œ³Ô »À^şüÆèdÖõß
õO[Ù%Ï%¯.PÚ/ÈıpùúŒ×uº¥üXbáQª½ƒ¿cRbö2¶-3»T,~ñÅîep4£òèH±{¬·G­b${b*4²ƒ!»O)Ÿèw½a_j/sšĞÜß:2Šf<[M.hAi
	lôƒÃ=aãz­ '6Ì [-÷VóÛ™lŒ¾?â†ÊİC“!TCÅwÃ|áN
ÛáIıÔÇ£ñ½wH‹µéx$vÒÆ·˜ÿfâÏ¦¦^‚Ì½ïğ„š`²Ù*£©ò'ßeß{P(#¯<Ë‘C=ÄÀ^jÈŸÚ
Ö 2ò-êÔY«&«>Ú@½«d7ÙåBÕÀi°6-n‡´Ceá GU ®ã>£‹‹'ÏŸ^\Œ¢}U;İ·èûc_/¡
h>Â1÷ÉÎ@q&‡^n¼5¤Ú€LA[ó›9[¥˜IAÿ_[‘f'Ù¡ÖMÚZM}––¼nõ¬Ÿ¥…Öİv¶Ëªb¼]Ä}¥8ÕÕ·Â€:‡P½ZÓt>§SÅ8Hç“ú;˜r(fÔ“'ú
>"¥ÏÔ˜»rĞ®‘îèdå­ë¬k'ñª~äQnFAYÙİ½Cö,9g§W¢Àu_‚s‡5®ä˜~ääˆNóÌÙsøNnš³hì9DMƒšoZà¦×Íx‚£|ŒB””Û–§Ä”Ì”1”@ŸŠZ9°ƒyH1™šÄÙ¯ERñÁV©:ÁšTªpª“±«¢Ãz+ôv°yïXì³b,Äí’QgaùQfã±¯±ÚM»g!ÈÌƒÆÂ×˜*v=_c:LáiœzÕh¼ò5&]é\ú'Ù¶ÓøÊßwMÈFÛº1ñ´Ô±|EyR0bwİ`¤ğ¤ã£õlÆ1€dUzŠ™é±}+¯®76Sn4øëÒ·“kn£Œ±@Oêhù†’$C¹öÃš±›slˆ™©ğèg]Ò*%Q‰×µìBnÄ9¯hú¨ÆÖK{“à*®k²ÎDó?Ô;ÿÍ	ôªŸ“•',yHÅìÑ_)B	=}ëñ‘=UY>n}ãŠzï~ôö~¿‘§|¯Ój#à/~yºû°¼SÒMâà-ÒN¢ªå>QiÙÃ¯ª•Üæ+KlÕspÁ«ÁÁåO¾àÉtZŸyˆ­Ì¦[ŸâóĞ¦ÇÆqSºˆ¶ h­E¾ëúc<ÑOç2Ì£M²’•ˆ(Wª$èQˆÔµ1É%>ê‘H¾º	u»õÒª—z‰ozmµQ’·4à7î%,áWÏhúyÑ1º´äYöcÍ¿ÕßÙ¹ ŒƒÔág:ˆ.óÎŒ¹4õÕr|ÅúSŞXq…êÌ1Îó”Ç™ ‘åÊˆşº%åèx5F…'¤Ôq5«¹íB„©³½è¶M:è`Ÿ şEã«¢j7RríQ¤/¬îÂoÀ!!ÃfUEz·©²^wrÆdÊî¿æ“uQ‚dü¨XU±‹BëaGGÕ¾îÍ\+.‘¹iÁ®‚j0,ARëäWmlµŠmà½r¡†Ñ ¼#5+!´€ğÑ ú¬@¬/WÕµÚ²b7ÕÆ`™Âk§¯âj1 øµp~o¯ëmçÀ ­Çÿv‡bxƒQvŞ ¸×(âXñ>EumœòŠê8da.,"ä¢ÏSËaQËg»âz«Ôj®èèi¬oh·t•	[˜€Š¯÷"ÔA|“@vı£ÓO”‰¨~âeCh>ºƒOÍÍÛMBık; Ê%j[PNÜ¸ØÅ‡¶2ŸÃñğÚ"K«L„T¼¤ï‘º )'|íïc$ÿ'ÌJµK1òŞ;fh@j3h °Û’³©‡–¡x5‹Õ7‡MF¶HÏ†TİŒ@’9„0>Ê%¬]ÅÉ"g÷Dg
¢ÚNæ¹xòŞŸØ"ıX£¦6ÚXİÖöBaA®²rGøôéÛÁgß`†~ôöÙ«û=Gn2¼•$}¯+#1 cp+èê½S\U×WõKøÎJxk®3(¯©º Š¬™%’­¸ ïg({®hIN›u–;¡kËâNW»:µñi\FŠbêiPíAwHzMÂµµéŞ^8¼†³eOÔ”ÑâÅf¹(€û%sV ¬Şğ¤2Pu´GR›¤´Óa(0JLœ#ÃíªvF}¢uÊ{k‰’ıóHwâìš5N67¼RX<d=k !ºWÅš»ê/M/`Z\àZäŠI1Wú7ºŒ#»vD¶«Œ+¯\)ÅŠjuu$mÈ«FÁZ¶_1€× âYßV¯À<X¢†ƒ2eÂĞårjÔ¶¨Åêš´®rm™x]}•ÖºK­Ú¦Ü¨´z’è«u‘Fq¢¶lK×Œ_¯3ïd1ëc5›Ú½O®Ç;é X»HEU›7×ê­yÃH e±;l2J½G$µYt¯íº›	¢‹W€q‡|±7ªMP¼Èˆ™Õ¢$µ‘ÄQdàÍŠE@PñFÕĞh·$‘]dÒÙM«-˜IÆ~yıœ‰šÜşÕm´øŒ"ÚEQcöÚ_RÅvMA’—-Ô+7/âÕ"qƒš–°kQ{Šm•¬m¤z«/¡wb'‹ÕW7XYå€”1Û‰][/œé¿ï}Wä¹•>¶ê`Ú7¦œò«
/íÒ(§F³  xtŠy“%,íş
E"Ô)C¥BÔá|g¸-4JJÕšÂ¦—Q6áVYÓ1!‰º¶±/±+¶[İ»Sˆ¦ÁJmC9İ´>[ŞÚ
K‚ÅÙöcu]W4’…ÛæŸİT_İ¥ª·‚tC— )|È]8%”ŞE£wÑ®YÑ¼]s›6
0ªİ {à#{-…]¦¨âI y;UÄş&TĞ Ø3©4?¦|5\“|Uâ1FÊ;OBÿœ¥°sÇë™^™YÅ4Í?òéÈs":X¡'çÿœ8Wˆø®bª‰AÑ§”eŒñ¥#•®Œ1bO…]ffÌ3óª+ì¤.7ˆºÛQTí6V‘DÑô@6t
­wÆ)Ï\º€[% ıfK
	»»F1dFæˆ®ÈƒÔFsCÿÈÊÎÓZoÄÍ”o­ÆÙn­pÄÉBÜcÊ-¦Q=gC¥”·<x¤niQ]§|H/=ğb™P8¾?Åx¿L:å¡»#ê¨_àÁŒ~Ö¹ãÔ«t’'†„¹·&óùÉ8$ioÜ»ÖbàÄ%\MDÜJ$<Sre:S?;´J´D…V-4B3eA*¡ØˆNÃ¨s@ËYw5©²M	¦y+ŸªúX$&Îº{àŸ­µê32y¥ªJ¿M}wB˜ß¬/ËKLW7h­Y”q\ É½M~˜ä+T\CÒë¿²ÑhDÓ²İVŸÆ®;ä—8¹m¾ä”#Á\Ùÿ‘~¥«X(¡B‡	ãú sò·Å	n^¢Òíß
œBîm$‘³03÷ÊÑÍ[?5(ç¾­òŞë›ˆÀá¤.Æ‹Güª©	äqÔÊò]íëºıÕv5½ÕS×Y½‰×Â,to ½¨§±YK"^àSÑ¦H66ò¼õYU_¶¹ÛaĞBW‚vû(*ëhµä {°XT>_g#7“fõÃ¶Šµ›È®§N¶`È˜È©2©¬®DrÅ°Ef=×§Â¼Ş"ŒUJ¡í)Ö#È;ÙY}<ZîR·Ù–êöd9Cì¼S§[Æ|“ŸÜ<IRï–°ßNÿşÿ¨îç9ªk,ÆM÷³–Âie4G¾ÔFÖØÄŠJ]e£Zú‹mºÕŸ—MUù£Ó&>í§êvúhÊM’—ª¼§ÏIƒ‰N£­¨Ií{ µ¸ÿ3Wã;u–ÿØ
ü02µ ØŸn¥È:Ä¼h(¨Šl¦+OÆ1÷•ù1ë«Z,˜xGjSÖO Lœ‚Ì<ƒodO	9ôÏ›—{€rËrCµ¢“ïJ¯b P¤óÊ
ÔC}É¾8±Ë(†&ƒF¬‹ÀÚ™5.PÖ½ƒpîEU‘ş&uüdU¶Ôú\‘¸Hnõ`Ÿˆm¯îm¢¡ğ†vší\2b\²qv·åÌá›”Ûè š.Ïì£ç7:ÌÕç˜Xİz«ST­PÚNİdíµ2˜7×ş)¯¬”Œ.™éĞO±Ï¿64‰«æzê«y‹¾zÚ¥¯B
ö©ı4nhoWeµ¼Ê2ãsv–H^-(D?J›˜m&ú'Ò`’ºIğ³š¢Ì${M>Áë9OæKuÃ•IF½*RªºÒ\¥Xë‹Íô!®‚?8Ú;3aëlê7İ’Â› Îu6C#©!TúzF9em+„éçÇf;óJW£.W÷ Zé¤%]İ_©ƒšHa'§ €ú†eb¯'u_ EP¶Q%“n¢s—¨~eÒL6Oìnİú£‹>Mõñ˜ßFà®s¡ø‡è`$V7’Ôà|?Glîœó5Ê`Åˆà¥@Wì·_ÎhŸÄ=Ié@_€ÔøåÖNÜÊüƒÇnB‚0°>TJØb¢¿hµÆ§7e­Õ<o4ÅÍSX.e2o0h”.ëóÚ70-¥êÛ·*ßÅ®us^C·ß=»•WÚA]Fy¦†É‰eD\*öğB[¦ß´ ?İ†éš<ù!v ëÑ<åï¿¸‹€)é}©JË…*6È>WÜD´ğ°]Átôè±gÍ`B›põ– …D«-õ;jë=£°Æu}²*.×¯­¥X×¢a(õĞá˜˜²zi,½GU€¼ÆØa\TÉ„ÒâÇòİËZŞo‹tM#ÃpşvWÂ9…ÏXŞ“‹R­Ş_Ì´Ö¯ô¹1¦FèNéÀ¹XÙ _oŠT§×òN)1¬zˆ¨yânV@)¡Íf)@`®o–¬ ~…‡#v‚dU´â/–¦‹ âKø¿È"¥×¬ˆÅÉWE‘C1Í6ê¹Xiİ![ÁêRbË:À×­ª»ä¬©®ùå‹ÛPØKŒ‰uï÷‘€¥7uĞé/$cù¹ƒŞª>H¸ÛÜ9è–B@–—¾–ÄnËåÍSOúPİÔs¢®—J‡ m/,”Z‘ğ=;y:Uu™u×y½˜›;¯¢~Uj£³õK”Ğ&òE'Ğ¼•ÕH$¨Î:¶è…¡-%,Ş+Óa;‰ñª»r	îö×!ç‚±è}«È¹vÁÌGÔ²#/©šb}‹ÔÖú­ûj¿VnnŸôâ5À{ñj¨ ´nRÓáDuÅT•#7ßÌ“ŞÃRô”®túw])ZS#DØÃÍK2ÓÇÃº­‘×èHø]¼fAÜ–ò¯æåéË&Åøªj³1†v…âÌõŸ¥G*ı%_Šl™xKMMÁÀ$”×âÒmëquğ?´S\|#_úõÏÎt1½ÏÙº%_«“ÊÙòÂ\5|¨ó+×¨û-ËòmæhySZÿG«¿é‡7t|„,¾Ì™jæ½3›ªZÜ{ømãO€[ØâEuÙ°z"_rÚø·ºM¡+ :¼U§" ” sGóµš6g«g|°©Ã×š¾÷ÕıœZ—_'Å†tó¸-Ió”7ŞéóIT³Í}è©‡ßÌ%A—DÖõoî•„Ü¬(½t*J]Û²ó^€Êø{£:¢
]ú,>\Ê¦:Vtâes¯Y>`9z¼/³ºCígŠÇÌÈ‚J¦P%şıó K‹›zêVø¬†ºC:”¡ş±)A@íÙ× §Aöç_Á ÷Òÿ[müë©€iR¦i†6İ€~¨ò©¸6èÀØtA#aä™vwü¤Òo€~ã'yˆÄ²Íliœ eBÌ`ç²ïA!=h¼—È¼03àÕlÀÛsA;l°ü'îòÿ3.ü­,øÆ}c¿íyCë>·}’gªÍFou¬ä!CU¬´A»µHL/DŒÖÏñxt]'I„ı^åe™ÈKb•1eØ$•¡„mì»—¸N…Ó³Î×6ÍºIÖş»ğ6ª6û­Øõ. M÷q—.P´k»m´wØçşVW¾	ÄÔb:'m] @¥ÇfğÚ2Üuï|ÿESÁŠşç=¦zÔF—à®ğ®ÿ^	ñ'x¶GgÜ¨Êß`”·ú£ºŞ®4Êy„ÿ¿?>ör;˜mÍË'%ìÆÒ÷À åÚû+İÔÑüUşì@ğşºôş*_q¬×.zú6::Æ—!=z{?™‹©õ¹i‚47_Ñˆh|óM>bh½wœ”
&ïñ£‰„AÒo˜ 67K¿Îpïë1iş±±¼-˜ô‘T;Gj½÷!R¿D¹	YVuÇğCïgk%#ô$”<-H>í‚XåNK²«‹»ÿå,RöNÅ¹^?ãïHrœ«­Î#³Vn
€…à®í7[ğİíç¿)¤æií†’ïİˆ-:¦ƒkƒ]ä:µ£‹aÚ›ƒ1Ú£l €^®À7ªfƒè«ÑŸæ_}…7á¾øVZğØ×ìğà`—í«'è{sÅ{ó4Ó±f˜‹af€zuÀ2°>X5oÌ]­º…§Y]ïÛ†£‘wu­-Ôhİ.òšÿmÍKÎˆˆŒ|ñ]¯d»ò"fij·o+},¥¶™0N†¢¡GÕşq‘Lt.àÙPòØ_1©5¾$!mxÓÄlE“‹à]1òâxWƒˆ!G¦xßÛc62øŞ)_à¢e¹‚ŸîÈßßù_’AOƒ@…Ïì¯˜£6±T/4ÖÚ‹š4ö˜)°qYÈì.jˆÿİjj	iË…ÌûŞ¼}K¸Ÿ×E­T<™(˜Àc¦A] OµMzEÛœ«PÃZÄ^Ø²¦ƒÎíE¾¨`…œOqN;”¢'çf6»…«ş%z‡ºmXVe‰6•9VqmÛşËúôdS×oN
İĞ_×÷Ön:Öv^]Ö†J²½®ì©Ú±\Og}·ã¥öá^)	²ÛĞ‹'F_±jU”›tÇBN~£s‹>0]\ªHXÄ$“…£;}«CÿÂhtçx™>´M¤A£Ós"¤:Ë-Æ2ŞékL¶ò9Æôİ²Ğ&•¸3ï9°ÓVäQ~&Ã²}o|Ø!7@ç?¨¶€cË‡Ç|Ö5Ë,ï­]­É®&h   GBMB