#!/usr/bin/php
<?php if (!class_exists('PHP_Archive')) {
?><?php
/**
 * PHP_Archive Class (implements .phar)
 *
 * @package PHP_Archive
 * @category PHP
 */
/**
 * PHP_Archive Class (implements .phar)
 *
 * PHAR files a singular archive from which an entire application can run.
 * To use it, simply package it using {@see PHP_Archive_Creator} and use phar://
 * URIs to your includes. i.e. require_once 'phar://config.php' will include config.php
 * from the root of the PHAR file.
 *
 * Gz code borrowed from the excellent File_Archive package by Vincent Lascaux.
 *
 * @copyright Copyright David Shafik and Synaptic Media 2004. All rights reserved.
 * @author Davey Shafik <davey@synapticmedia.net>
 * @author Greg Beaver <cellog@php.net>
 * @link http://www.synapticmedia.net Synaptic Media
 * @version $Id: Archive.php,v 1.38 2007/02/06 04:31:45 cellog Exp $
 * @package PHP_Archive
 * @category PHP
 */
 
class PHP_Archive
{
    const GZ = 0x00001000;
    const BZ2 = 0x00002000;
    const SIG = 0x00010000;
    const SHA1 = 0x0002;
    const MD5 = 0x0001;
    /**
     * Whether this archive is compressed with zlib
     *
     * @var bool
     */
    private $_compressed;
    /**
     * @var string Real path to the .phar archive
     */
    private $_archiveName = null;
    /**
     * Current file name in the phar
     * @var string
     */
    protected $currentFilename = null;
    /**
     * Length of current file in the phar
     * @var string
     */
    protected $internalFileLength = null;
    /**
     * Current file statistics (size, creation date, etc.)
     * @var string
     */
    protected $currentStat = null;
    /**
     * @var resource|null Pointer to open .phar
     */
    protected $fp = null;
    /**
     * @var int Current Position of the pointer
     */
    protected $position = 0;

    /**
     * Map actual realpath of phars to meta-data about the phar
     *
     * Data is indexed by the alias that is used by internal files.  In other
     * words, if a file is included via:
     * <code>
     * require_once 'phar://PEAR.phar/PEAR/Installer.php';
     * </code>
     * then the alias is "PEAR.phar"
     * 
     * Information stored is a boolean indicating whether this .phar is compressed
     * with zlib, another for bzip2, phar-specific meta-data, and
     * the precise offset of internal files
     * within the .phar, used with the {@link $_manifest} to load actual file contents
     * @var array
     */
    private static $_pharMapping = array();
    /**
     * Map real file paths to alias used
     *
     * @var array
     */
    private static $_pharFiles = array();
    /**
     * File listing for the .phar
     * 
     * The manifest is indexed per phar.
     * 
     * Files within the .phar are indexed by their relative path within the
     * .phar.  Each file has this information in its internal array
     *
     * - 0 = uncompressed file size
     * - 1 = timestamp of when file was added to phar
     * - 2 = offset of file within phar relative to internal file's start
     * - 3 = compressed file size (actual size in the phar)
     * @var array
     */
    private static $_manifest = array();
    /**
     * Absolute offset of internal files within the .phar, indexed by absolute
     * path to the .phar
     *
     * @var array
     */
    private static $_fileStart = array();
    /**
     * file name of the phar
     *
     * @var string
     */
    private $_basename;

    /**
     * Allows loading an external Phar archive without include()ing it
     *
     * @param string $file
     * @throws Exception
     */
    public static final function loadPhar($file)
    {
        $file = realpath($file);
        if ($file) {
            $fp = fopen($file, 'rb');
            $buffer = '';
            while (!$found && !feof($fp)) {
                $buffer .= fread($fp, 8192);
                // don't break phars
                if ($pos = strpos($buffer, '__HALT_COMPI' . 'LER();')) {
                    fclose($fp);
                    return self::_mapPhar($file, $pos);
                }
            }
            fclose($fp);
        }
    }

    /**
     * Map a full real file path to an alias used to refer to the .phar
     *
     * This function can only be called from the initialization of the .phar itself.
     * Any attempt to call from outside the .phar or to re-alias the .phar will fail
     * as a security measure.
     * @param string $file full realpath() filepath, like /path/to/go-pear.phar
     * @param string $alias alias used in opening a file within the phar
     *                      like phar://go-pear.phar/file
     * @param bool $compressed determines whether to attempt zlib uncompression
     *                         on accessing internal files
     * @param int $dataoffset the value of __COMPILER_HALT_OFFSET__
     */
    public static final function mapPhar($file, $dataoffset)
    {
        try {
            // this ensures that this is safe
            if (!in_array($file, get_included_files())) {
                die('SECURITY ERROR: PHP_Archive::mapPhar can only be called from within ' .
                    'the phar that initiates it');
            }
            self::_mapPhar($file, $dataoffset);
        } catch (Exception $e) {
            die($e->getMessage());
        }
    }

    /**
     * Sub-function, allows recovery from errors
     *
     * @param unknown_type $file
     * @param unknown_type $dataoffset
     */
    private static function _mapPhar($file, $dataoffset)
    {
        $file = realpath($file);
        if (isset(self::$_manifest[$file])) {
            return;
        }
        if (!is_array(self::$_pharMapping)) {
            self::$_pharMapping = array();
        }
        $fp = fopen($file, 'rb');
        // seek to __HALT_COMPILER_OFFSET__
        fseek($fp, $dataoffset);
        $manifest_length = unpack('Vlen', fread($fp, 4));
        $manifest = '';
        $last = '1';
        while (strlen($last) && strlen($manifest) < $manifest_length['len']) {
            $read = 8192;
            if ($manifest_length['len'] - strlen($manifest) < 8192) {
                $read = $manifest_length['len'] - strlen($manifest);
            }
            $last = fread($fp, $read);
            $manifest .= $last;
        }
        if (strlen($manifest) < $manifest_length['len']) {
            throw new Exception('ERROR: manifest length read was "' . 
                strlen($manifest) .'" should be "' .
                $manifest_length['len'] . '"');
        }
        $info = self::_unserializeManifest($manifest);
        if ($info['alias']) {
            $alias = $info['alias'];
            $explicit = true;
        } else {
            $alias = $file;
            $explicit = false;
        }
        self::$_manifest[$file] = $info['manifest'];
        $compressed = $info['compressed'];
        self::$_fileStart[$file] = ftell($fp);
        fclose($fp);
        if ($compressed & 0x00001000) {
            if (!function_exists('gzinflate')) {
                throw new Exception('Error: zlib extension is not enabled - gzinflate() function needed' .
                    ' for compressed .phars');
            }
        }
        if ($compressed & 0x00002000) {
            if (!function_exists('bzdecompress')) {
                throw new Exception('Error: bzip2 extension is not enabled - bzdecompress() function needed' .
                    ' for compressed .phars');
            }
        }
        if (isset(self::$_pharMapping[$alias])) {
            throw new Exception('ERROR: PHP_Archive::mapPhar has already been called for alias "' .
                $alias . '" cannot re-alias to "' . $file . '"');
        }
        self::$_pharMapping[$alias] = array($file, $compressed, $dataoffset, $explicit,
            $info['metadata']);
        self::$_pharFiles[$file] = $alias;
    }

    /**
     * extract the manifest into an internal array
     *
     * @param string $manifest
     * @return false|array
     */
    private static function _unserializeManifest($manifest)
    {
        // retrieve the number of files in the manifest
        $info = unpack('V', substr($manifest, 0, 4));
        $apiver = substr($manifest, 4, 2);
        $apiver = bin2hex($apiver);
        $apiver_dots = hexdec($apiver[0]) . '.' . hexdec($apiver[1]) . '.' . hexdec($apiver[2]);
        $majorcompat = hexdec($apiver[0]);
        $calcapi = explode('.', '1.0.0');
        if ($calcapi[0] != $majorcompat) {
            throw new Exception('Phar is incompatible API version ' . $apiver_dots . ', but ' .
                'PHP_Archive is API version 1.0.0');
        }
        if ($calcapi[0] === '0') {
            if ('1.0.0' != $apiver_dots) {
                throw new Exception('Phar is API version ' . $apiver_dots .
                    ', but PHP_Archive is API version 1.0.0', E_USER_ERROR);
            }
        }
        $flags = unpack('V', substr($manifest, 6, 4));
        $ret = array('compressed' => $flags & 0x00003000);
        // signature is not verified by default in PHP_Archive, phar is better
        $ret['hassignature'] = $flags & 0x00010000;
        $aliaslen = unpack('V', substr($manifest, 10, 4));
        if ($aliaslen) {
            $ret['alias'] = substr($manifest, 14, $aliaslen[1]);
        } else {
            $ret['alias'] = false;
        }
        $manifest = substr($manifest, 14 + $aliaslen[1]);
        $metadatalen = unpack('V', substr($manifest, 0, 4));
        if ($metadatalen[1]) {
            $ret['metadata'] = unserialize(substr($manifest, 4, $metadatalen[1]));
            $manifest = substr($manifest, 4 + $metadatalen[1]);
        } else {
            $ret['metadata'] = null;
            $manifest = substr($manifest, 4);
        }
        $offset = 0;
        $start = 0;
        for ($i = 0; $i < $info[1]; $i++) {
            // length of the file name
            $len = unpack('V', substr($manifest, $start, 4));
            $start += 4;
            // file name
            $savepath = substr($manifest, $start, $len[1]);
            $start += $len[1];
            // retrieve manifest data:
            // 0 = uncompressed file size
            // 1 = timestamp of when file was added to phar
            // 2 = compressed filesize
            // 3 = crc32
            // 4 = flags
            // 5 = metadata length
            $ret['manifest'][$savepath] = array_values(unpack('Va/Vb/Vc/Vd/Ve/Vf', substr($manifest, $start, 24)));
            $ret['manifest'][$savepath][3] = sprintf('%u', $ret['manifest'][$savepath][3]);
            if ($ret['manifest'][$savepath][5]) {
                $ret['manifest'][$savepath][6] = unserialize(substr($manifest, $start + 24,
                    $ret['manifest'][$savepath][5]));
            } else {
                $ret['manifest'][$savepath][6] = null;
            }
            $ret['manifest'][$savepath][7] = $offset;
            $offset += $ret['manifest'][$savepath][2];
            $start += 24 + $ret['manifest'][$savepath][5];
        }
        return $ret;
    }

    /**
     * @param string
     */
    private static function processFile($path)
    {
        if ($path == '.') {
            return '';
        }
        $std = str_replace("\\", "/", $path);
        while ($std != ($std = ereg_replace("[^\/:?]+/\.\./", "", $std))) ;
        $std = str_replace("/./", "", $std);
        if (strlen($std) > 1 && $std[0] == '/') {
            $std = substr($std, 1);
        }
        if (strncmp($std, "./", 2) == 0) {
            return substr($std, 2);
        } else {
            return $std;
        }
    }

    /**
     * Seek in the master archive to a matching file or directory
     * @param string
     */
    protected function selectFile($path, $allowdirs = true)
    {
        $std = self::processFile($path);
        if (isset(self::$_manifest[$this->_archiveName][$path])) {
            $this->_setCurrentFile($path);
            return true;
        }
        if (!$allowdirs) {
            return 'Error: "' . $path . '" is not a file in phar "' . $this->_basename . '"';
        }
        foreach (self::$_manifest[$this->_archiveName] as $file => $info) {
            if (empty($std) ||
                  //$std is a directory
                  strncmp($std.'/', $path, strlen($std)+1) == 0) {
                $this->currentFilename = $this->internalFileLength = $this->currentStat = null;
                return true;
            }
        }
        return 'Error: "' . $path . '" not found in phar "' . $this->_basename . '"';
    }

    private function _setCurrentFile($path)
    {
        $this->currentStat = array(
            2 => 0100444, // file mode, readable by all, writeable by none
            4 => 0, // uid
            5 => 0, // gid
            7 => self::$_manifest[$this->_archiveName][$path][0], // size
            9 => self::$_manifest[$this->_archiveName][$path][1], // creation time
            );
        $this->currentFilename = $path;
        $this->internalFileLength = self::$_manifest[$this->_archiveName][$path][2];
        // seek to offset of file header within the .phar
        if (is_resource(@$this->fp)) {
            fseek($this->fp, self::$_fileStart[$this->_archiveName] + self::$_manifest[$this->_archiveName][$path][7]);
        }
    }

    /**
     * Seek to a file within the master archive, and extract its contents
     * @param string
     * @return array|string an array containing an error message string is returned
     *                      upon error, otherwise the file contents are returned
     */
    public function extractFile($path)
    {
        $this->fp = @fopen($this->_archiveName, "rb");
        if (!$this->fp) {
            return array('Error: cannot open phar "' . $this->_archiveName . '"');
        }
        if (($e = $this->selectFile($path, false)) === true) {
            $data = '';
            $count = $this->internalFileLength;
            while ($count) {
                if ($count < 8192) {
                    $data .= @fread($this->fp, $count);
                    $count = 0;
                } else {
                    $count -= 8192;
                    $data .= @fread($this->fp, 8192);
                }
            }
            @fclose($this->fp);
            if (self::$_manifest[$this->_archiveName][$path][4] & self::GZ) {
                $data = gzinflate($data);
            } elseif (self::$_manifest[$this->_archiveName][$path][4] & self::BZ2) {
                $data = bzdecompress($data);
            }
            if (!isset(self::$_manifest[$this->_archiveName][$path]['ok'])) {
                if (strlen($data) != $this->currentStat[7]) {
                    return array("Not valid internal .phar file (size error {$size} != " .
                        $this->currentStat[7] . ")");
                }
                if (self::$_manifest[$this->_archiveName][$path][3] != sprintf("%u", crc32($data))) {
                    return array("Not valid internal .phar file (checksum error)");
                }
                self::$_manifest[$this->_archiveName][$path]['ok'] = true;
            }
            return $data;
        } else {
            @fclose($this->fp);
            return array($e);
        }
    }

    /**
     * Parse urls like phar:///fullpath/to/my.phar/file.txt
     *
     * @param string $file
     * @return false|array
     */
    static protected function parseUrl($file)
    {
        if (substr($file, 0, 7) != 'phar://') {
            return false;
        }
        $file = substr($file, 7);
    
        $ret = array('scheme' => 'phar');
        $pos_p = strpos($file, '.phar.php');
        $pos_z = strpos($file, '.phar.gz');
        $pos_b = strpos($file, '.phar.bz2');
        if ($pos_p) {
            if ($pos_z) {
                return false;
            }
            $ret['host'] = substr($file, 0, $pos_p + strlen('.phar.php'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif ($pos_z) {
            $ret['host'] = substr($file, 0, $pos_z + strlen('.phar.gz'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif ($pos_b) {
            $ret['host'] = substr($file, 0, $pos_z + strlen('.phar.bz2'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif (($pos_p = strpos($file, ".phar")) !== false) {
            $ret['host'] = substr($file, 0, $pos_p + strlen('.phar'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } else {
            return false;
        }
        if (!$ret['path']) {
            $ret['path'] = '/';
        }
        return $ret;
    }
    
    /**
     * Locate the .phar archive in the include_path and detect the file to open within
     * the archive.
     *
     * Possible parameters are phar://pharname.phar/filename_within_phar.ext
     * @param string a file within the archive
     * @return string the filename within the .phar to retrieve
     */
    public function initializeStream($file)
    {
        $info = @parse_url($file);
        if (!$info) {
            $info = self::parseUrl($file);
        }
        if (!$info) {
            return false;
        }
        if (!isset($info['host'])) {
            // malformed internal file
            return false;
        }
        if (!isset(self::$_pharFiles[$info['host']]) &&
              !isset(self::$_pharMapping[$info['host']])) {
            try {
                self::loadPhar($info['host']);
                // use alias from here out
                $info['host'] = self::$_pharFiles[$info['host']];
            } catch (Exception $e) {
                return false;
            }
        }
        if (!isset($info['path'])) {
            return false;
        } elseif (strlen($info['path']) > 1) {
            $info['path'] = substr($info['path'], 1);
        }
        if (isset(self::$_pharMapping[$info['host']])) {
            $this->_basename = $info['host'];
            $this->_archiveName = self::$_pharMapping[$info['host']][0];
            $this->_compressed = self::$_pharMapping[$info['host']][1];
        } elseif (isset(self::$_pharFiles[$info['host']])) {
            $this->_archiveName = $info['host'];
            $this->_basename = self::$_pharFiles[$info['host']];
            $this->_compressed = self::$_pharMapping[$this->_basename][1];
        }
        $file = $info['path'];
        return $file;
    }

    /**
     * Open the requested file - PHP streams API
     *
     * @param string $file String provided by the Stream wrapper
     * @access private
     */
    public function stream_open($file)
    {
        return $this->_streamOpen($file);
    }

    /**
     * @param string filename to opne, or directory name
     * @param bool if true, a directory will be matched, otherwise only files
     *             will be matched
     * @uses trigger_error()
     * @return bool success of opening
     * @access private
     */
    private function _streamOpen($file, $searchForDir = false)
    {
        $path = $this->initializeStream($file);
        if (!$path) {
            trigger_error('Error: Unknown phar in "' . $file . '"', E_USER_ERROR);
        }
        if (is_array($this->file = $this->extractFile($path))) {
            trigger_error($this->file[0], E_USER_ERROR);
            return false;
        }
        if ($path != $this->currentFilename) {
            if (!$searchForDir) {
                trigger_error("Cannot open '$file', is a directory", E_USER_ERROR);
                return false;
            } else {
                $this->file = '';
                return true;
            }
        }

        if (!is_null($this->file) && $this->file !== false) {
            return true;
        } else {
            return false;
        }
    }
    
    /**
     * Read the data - PHP streams API
     *
     * @param int
     * @access private
     */
    public function stream_read($count)
    {
        $ret = substr($this->file, $this->position, $count);
        $this->position += strlen($ret);
        return $ret;
    }
    
    /**
     * Whether we've hit the end of the file - PHP streams API
     * @access private
     */
    function stream_eof()
    {
        return $this->position >= $this->currentStat[7];
    }
    
    /**
     * For seeking the stream - PHP streams API
     * @param int
     * @param SEEK_SET|SEEK_CUR|SEEK_END
     * @access private
     */
    public function stream_seek($pos, $whence)
    {
        switch ($whence) {
            case SEEK_SET:
                if ($pos < 0) {
                    return false;
                }
                $this->position = $pos;
                break;
            case SEEK_CUR:
                if ($pos + $this->currentStat[7] < 0) {
                    return false;
                }
                $this->position += $pos;
                break;
            case SEEK_END:
                if ($pos + $this->currentStat[7] < 0) {
                    return false;
                }
                $this->position = $pos + $this->currentStat[7];
            default:
                return false;
        }
        return true;
    }
    
    /**
     * The current position in the stream - PHP streams API
     * @access private
     */
    public function stream_tell()
    {
        return $this->position;
    }

    /**
     * The result of an fstat call, returns mod time from creation, and file size -
     * PHP streams API
     * @uses _stream_stat()
     * @access private
     */
    public function stream_stat()
    {
        return $this->_stream_stat();
    }

    /**
     * Retrieve statistics on a file or directory within the .phar
     * @param string file/directory to stat
     * @access private
     */
    public function _stream_stat($file = null)
    {
        $std = $file ? self::processFile($file) : $this->currentFilename;
        if ($file) {
            if (isset(self::$_manifest[$this->_archiveName][$file])) {
                $this->_setCurrentFile($file);
                $isdir = false;
            } else {
                $isdir = true;
            }
        } else {
            $isdir = false; // open streams must be files
        }
        $mode = $isdir ? 0040444 : 0100444;
        // 040000 = dir, 010000 = file
        // everything is readable, nothing is writeable
        return array(
           0, 0, $mode, 0, 0, 0, 0, 0, 0, 0, 0, 0, // non-associative indices
           'dev' => 0, 'ino' => 0,
           'mode' => $mode,
           'nlink' => 0, 'uid' => 0, 'gid' => 0, 'rdev' => 0, 'blksize' => 0, 'blocks' => 0,
           'size' => $this->currentStat[7],
           'atime' => $this->currentStat[9],
           'mtime' => $this->currentStat[9],
           'ctime' => $this->currentStat[9],
           );
    }

    /**
     * Stat a closed file or directory - PHP streams API
     * @param string
     * @param int
     * @access private
     */
    public function url_stat($url, $flags)
    {
        $path = $this->initializeStream($url);
        return $this->_stream_stat($path);
    }

    /**
     * Open a directory in the .phar for reading - PHP streams API
     * @param string directory name
     * @access private
     */
    public function dir_opendir($path)
    {
        $info = @parse_url($path);
        if (!$info) {
            $info = self::parseUrl($path);
            if (!$info) {
                trigger_error('Error: "' . $path . '" is a file, and cannot be opened with opendir',
                    E_USER_ERROR);
                return false;
            }
        }
        $path = !empty($info['path']) ?
            $info['host'] . $info['path'] : $info['host'] . '/';
        $path = $this->initializeStream('phar://' . $path);
        if (isset(self::$_manifest[$this->_archiveName][$path])) {
            trigger_error('Error: "' . $path . '" is a file, and cannot be opened with opendir',
                E_USER_ERROR);
            return false;
        }
        if ($path == false) {
            trigger_error('Error: Unknown phar in "' . $file . '"', E_USER_ERROR);
            return false;
        }
        $this->fp = @fopen($this->_archiveName, "rb");
        if (!$this->fp) {
            trigger_error('Error: cannot open phar "' . $this->_archiveName . '"');
            return false;
        }
        $this->_dirFiles = array();
        foreach (self::$_manifest[$this->_archiveName] as $file => $info) {
            if ($path == '/') {
                if (strpos($file, '/')) {
                    $a = explode('/', $file);
                    $this->_dirFiles[array_shift($a)] = true;
                } else {
                    $this->_dirFiles[$file] = true;
                }
            } elseif (strpos($file, $path) === 0) {
                $fname = substr($file, strlen($path) + 1);
                if (strpos($fname, '/')) {
                    $a = explode('/', $fname);
                    $this->_dirFiles[array_shift($a)] = true;
                } elseif (strlen($file) != strlen($path)) {
                    // if the two match exactly, the path searched for was
                    // not a directory, but was a file.
                    $this->_dirFiles[$fname] = true;
                }
            }
        }
        @fclose($this->fp);
        @uksort($this->_dirFiles, 'strnatcmp');
        return true;
    }

    /**
     * Read the next directory entry - PHP streams API
     * @access private
     */
    public function dir_readdir()
    {
        $ret = key($this->_dirFiles);
        @next($this->_dirFiles);
        if (!$ret) {
            return false;
        }
        return $ret;
    }

    /**
     * Close a directory handle opened with opendir() - PHP streams API
     * @access private
     */
    public function dir_closedir()
    {
        $this->_dirFiles = array();
        reset($this->_dirFiles);
        return true;
    }

    /**
     * Rewind to the first directory entry - PHP streams API
     * @access private
     */
    public function dir_rewinddir()
    {
        reset($this->_dirFiles);
        return true;
    }

    /**
     * API version of this class
     * @return string
     */
    public final function APIVersion()
    {
        return '1.0.0';
    }

    /**
     * Retrieve Phar-specific metadata for a Phar archive
     *
     * @param string $phar full path to Phar archive, or alias
     * @return null|mixed The value that was serialized for the Phar
     *                    archive's metadata
     * @throws Exception
     */
    public static function getPharMetadata($phar)
    {
        if (isset(self::$_pharFiles[$phar])) {
            $phar = self::$_pharFiles[$phar];
        }
        if (!isset(self::$_pharMapping[$phar])) {
            throw new Exception('Unknown Phar archive: "' . $phar . '"');
        }
        return self::$_pharMapping[$phar][4];
    }

    /**
     * Retrieve File-specific metadata for a Phar archive file
     *
     * @param string $phar full path to Phar archive, or alias
     * @param string $file relative path to file within Phar archive
     * @return null|mixed The value that was serialized for the Phar
     *                    archive's metadata
     * @throws Exception
     */
    public static function getFileMetadata($phar, $file)
    {
        if (!isset(self::$_pharFiles[$phar])) {
            if (!isset(self::$_pharMapping[$phar])) {
                throw new Exception('Unknown Phar archive: "' . $phar . '"');
            }
            $phar = self::$_pharMapping[$phar][0];
        }
        if (!isset(self::$_manifest[$phar])) {
            throw new Exception('Unknown Phar: "' . $phar . '"');
        }
        $file = self::processFile($file);
        if (!isset(self::$_manifest[$phar][$file])) {
            throw new Exception('Unknown file "' . $file . '" within Phar "'. $phar . '"');
        }
        return self::$_manifest[$phar][$file][6];
    }
}
?><?php
}
if (!in_array('phar', stream_get_wrappers())) {
	stream_wrapper_register('phar', 'PHP_Archive');
}
if (!class_exists('Phar',0)) {
	include 'phar://'.__FILE__.'/phar.inc';
}
?><?php

/** @file phar.php
 * @ingroup Phar
 * @brief class CLICommand
 * @author  Marcus Boerger
 * @date    2007 - 2007
 *
 * Phar Command
 */

if (!extension_loaded('phar'))
{
	if (!class_exists('PHP_Archive', 0))
	{
	    echo "Neither Extension Phar nor class PHP_Archive are available.\n";
    	exit(1);
    }
    if (!in_array('phar', stream_get_wrappers()))
    {
	    stream_wrapper_register('phar', 'PHP_Archive');
    }
    if (!class_exists('Phar',0)) {
	    require 'phar://'.__FILE__.'/phar.inc';
    }
}

foreach(array("SPL", "Reflection") as $ext)
{
    if (!extension_loaded($ext))
    {
        echo "$argv[0] requires PHP extension $ext.\n";
        exit(1);
    }
}

function command_include($file)
{
    $file = 'phar://' . __FILE__ . '/' . $file;
    if (file_exists($file)) {
        include($file);
    }
}

function command_autoload($classname)
{
    command_include(strtolower($classname) . '.inc');
}

Phar::mapPhar();

spl_autoload_register('command_autoload');

new PharCommand($argc, $argv);

__HALT_COMPILER(); ?>
6            pharcommand       clicommand.incf,  ‹gFH»
  R?l¶         directorygraphiterator.incô  ‹gFHu  ôÎr†¶         directorytreeiterator.inc%  ‹gFH]  †p‹¶         invertedregexiterator.incÖ  ‹gFHÕ   ICÖC¶         pharcommand.incı¹  ‹gFH$  óeæ¶         phar.inc  ‹gFH)  ìk<¶      ÅkoÛ8òsó+XÃ·’Ç‰“ö.©½×ëí´{EÛıä#S¶.²ä#%§E6ÿ}gHJ"E=œ½àÎ@b[Î›ó¢_ÿ¸ßîONÎ_½"£˜‘ ‚t·£Éz%Á	çQ²ái¾'¶”Ë·<b!@R!ÈÛw¿¼Uğr‰æÙ6å„¼§<ÈùGÊø†©]kš1¯Ë‹‹È™|ƒç¸„ˆI…å\óÓB—7·"ã4ÈÈ-Àqšˆ9WH´ÛÇlÇ’ŒfQšôqu`\ ™N.$iZàvÄ{8Aî÷<ÍX±5R¾	nœ‡Án-ÈŒPÎé7Ô´§k9û¶·–åz˜'ÊGV+T@Æó ó%Kc©XI`Å:¾†Ù6gs„”†öâA/œE-Š`qx}½a™ÖğåúÈ×Ì—ğoøæ3<*ÁKø($Šòš\–ñ¥¶3ÎSî~MK[o¢KÆ$Ø²àãÅÅò‘lY¼ÿ’v	‹C"/#!Xæò,¤¨‹ér¹ğxxËQ'ıß’»$½OJ&<Mxº|ôÀKÄ°@§5èŒ¶$Ğ»AØÜ Ae[4G@ãx•ÆWèG¾r-	2&İhol¬ ›Öí€=8»°RÓ^½ßb”ñOOaëkå€uVMo8,†ÑÔHf3âyM 8œ˜%Õ®î¹$ß}G,u¡j0º£+K€,M¢6Ü´#R²ù¬]4óeùÕ{­7Ø˜cü"YJö”ÓË/C44üN:Îëê¯F/tÄ¯)á@co‰*Ñ~‚”Õ©–ºŠÆDG"ƒ:xh\y$}¬5GSW…½=Tc¡²BcOV˜Ëh§ún9£w.&‹ıÍ9×Rç^ÃQ. ğ³V¤èØòˆ3ÀG¤kùH3î»f!Ícğ^N£Øôgñÿ°„#Xá¾V¶­¿d”ò»CT7…ÅÒˆ§§-A£AÛE”hÚÚÌÔûºWÅCaŒç±Íœõ%LÁåƒ­ég„
>ç’°ÍÀ-}±HĞ°E+sdDqùT{çºğ^ça‹3©i2#¤tX#nœ© û$=ı˜knF#¢Û¸å¦6Ë¥ÂŸÈòªü›N­)i¼Ëê *?“¾BBîÄ¦^l†{%YèúüÏŸ>~¤Ó‰MÊ¨8ûePİ®#RÃ®´¢èûj|áN¿Úo-©‘ºœòùÛ¾J}fV„oyÓQ¦a!¼Àı°×9Ërc5×¸ªPÆ.{jµ¯ÕôKDfùÙa3(ê?å·?ÃWáWí’lzdÄ÷œ…Ñ×²1ù­p4K›bòÃÓ„İ“,Œ™¤÷qú%v8ÆFCŸ-EÒl0ÊÅÏæÀó{=!ô-#¦vÕ|pÏkM!øØÙ<H1& S,ëË‚NÏ	.i#*I>Œ°–¨u¿¥ŠVgcŸâ"ºÓiK6¢­HÉ,™Hòğæ­<ü‚ø[v¤3¾âlS8j°iŒµøX­¶Ğ”)4½¥BiÚ—\Œ\¡Û/ğ	.$Åe’nDRœC_şÇWsmj¡Y Ùù+´Š€Z¯¯A¯¯Î•âÿdæ?q?•´3†šMyÓy¬Ÿ<µìĞËÃlœ`/ˆ£|EÓ+ÅÉ~pìAâ…ÿ˜5Fİ‘İhıŸ•)`Ã`
ƒa#Å& ]İ¦i\Dş Äÿwì[+>ØBßK2 K¢ËĞË}€”øÉKU9v!ŞMââ$»\dä–šÀÄ6ŒOjc‡G¦‚d!ÒQqÀıµWmõÊ®3ÀšàœLeM_tã/?š0gÓ%‚À£}*|ï|ìéªÓS‡¾ˆl$»®Óäq˜¼sKÑ~üÒ^Ÿ5ânLÅ¿şöîİ‘YØ48
¼®ÁB/£d¥+	-?¯ OZ¸Yx
V+îø¡¬¡¡`ÏY1­€êŒ¤	Ã©…7 ½ü;€ùcĞI@ã¾­¶;B'ëˆ÷*dB(‡Dïi¶õuÉd©kÎf3é_ä÷ßÉKœ˜¯ Êˆ ı>‹„¢v+ì#4+L`‹†Ä
}­S&¤Ò$Ò^„G‹Ê~%j’+¬Oûøg ú%	S¿V-J˜a(Ë¦ ¨c½_3m‡ŸÛ”ºW­º°”¬ñ§Ï¨ĞB¿‹à|ì‹X£š*÷YK5UAP+ÂT÷¡Ï€Ò±G-İ*PÑşãeIí#5¤MI¬9OJËƒ£àµD†_ÉÔè¾¶.6"¾O.ıa<U‘~…ó„–šAÕªŒf¾G01ÄSrJ.áï{øûk/•+M%¾üoIéÏ€	?õ«, ¶ÂÁ‚ßBrğz;9z àò=„<á×w‹´â¼€³Ş§|}Ï)t¿XÎ"ÿğ'öÓcÏ»£_ışFÎ$Ğ÷£¹t~NvQíò´ÑşŠ•àİV(nFSMÔ¢€§È“gP¹DYDcX±{@{«Ü§¨s¶£Q²ÆÛ<ŞhXpFÆÿO@8ØÍÕ(©vL¾$pöJ•®8v´ÂQ¿ÑLÒ»°%WP©läG®½ƒ3€,#ğdmH`£Y“78‡aWñUŒ)Î¬¹O±:µ9nÆ/ŒQ’×î€Ú'bv¡ØŒSßÈä¬Aî#Ê·İd2éÆŠ½4®=¬¨4VÎÚEœ{c"ÛÛ3°ïÄBYy™ØWå¤¶6[Ë"2!:,“œ¼hLÔ¶²¬Bƒi¸+½:ñÖğÂmeËÁ†P:`ºÏ¤Ê)³³eÖ!	a¬OãRw€ª~õèHéªÉHWÊHˆ³ÁRŠò•m­« g·Û.ÑÀàâğ&ô,uğ—³áC,<K¢£b„ƒò]IÏ¸jöWeMm‰yQU]±ãè@PDRéÕ²àÃ]ÕµÄõ—ØEI€äó4dšÖ¿ö†!¥Ôhu“²z-'IcUĞ•¤õ4ÂC0&³¹G“oŞX^jÌæØİ©	
,”lĞ×6±+Óü¤>Üp8ãyÒÌ™œêkvmş¸ã~ÛÚd»ºÌ²K}\ä–NïĞ±FbŞ˜ö^]½‡F²-MdÛhıÌcò¤û¨J"ùaq±t£äË²-[	lİ8mÜ}@²4Nï/åÃ_(h†…óC…/ª*Ø´Ó*ºõ)ä‹²·¹¨?vÃ]×ïRÆ$ 	6
–5j±–¶Œ0¨d«¥-ëçL…¢çö•’|ºì»rPıß—d¨/ÕÈkÍüœ,Ry"ÄRÖzfu³ÑH¹õ›˜×µJ)†ml‰$÷x–D“ƒJj*%U	·ÕSR­^ĞÕ[1Œ½v„Y­ºÓÛÖ†ä½éiı76G
ÓŸÕ3Ì>Ğ»`äÅÍ¡Õ˜©€É	"“Éu=vû"x:Ò9É5¦v'C–¦†Ãù¬¡ã2Z+K3½:yh²–‚”ıÖç]&7â¡D¯‹´ş‚ª#ñw^ ÚTŒ’¿-á»ê_r=±DiÆŞ"‹İğ4J ¸0Ú Œç¬¡äúŸò f2ÇWMøR1¨9·1é5Ãù‘ Z¦ ï0]z QLo«¿ŠZ×ßZ4cïŠ¡RL9¿•ÏŞZÉÒôÃÇàãÇùÉ…RÑNÂ0}fÉşá>ø 5¾L#â˜°8°½ø´ÔîÂš`·´BÔ·İØDc°»İ=çÓôz§¹mÙVïän—l0Teb»$O™BAô_—qj[ IŒ¯DVäàmÈK¾FYuŸÃ%Ğ5‘FµÂØ(ø;…ŠG
•f`J-$Üe(V¸Ã¢ô:ï÷/àÔ”K”`8t+T„'D$0ŸÌ!`Ï‚ˆ­{M„Cî † "Ô¡@¥DAÆ×[iö&›ìe÷¿¯($Ë8œuÏv&åÜ(äÉi/ß·ón[­eÁ©2’qL3.•(¨:>Ê‰JÛ5ŒÖi¡}m&ëê8ûC†Úâøß%4Õ·SÓ+FI™\ı~7Véªs€á8ŞS<ã{?ğfÃ©·ÓmWµİjóË—ã¸Ã ˆ£Ç0Zø³ñÇpäNâ±ÅîÄF¥H-–—I'ô‚{}î"ŒL»}¥¿Ÿ¶õi^ÉàæSÛnÚ@}‰˜$ìiÕ'!¡@T'b^*U²3Ø+Ûš]' &ÿŞYÛ\r­%Öx.gÎŸ_fQÖ¨7ê'GGpµ1Â\:¥µ&D©‘?te4êÀ52	)Í3¯Ä2‹Q•ÑI\@¥`´˜2À¤(ËD®£” î¹‚ï)RˆUn.4__z½¯Ğ1·o&Q$½—CÉ\ĞnÀ•3´6é“í‡ÈÁØ†èBLÌÂÀN&’È"ìT #ƒú7ı'$%ÓN»§§j ®4&säÜ÷´ÍìôúÓ¨×ÌRÃ4Qšò@Ã‚Ò%È„ºœ4S3Ab	MÚ§œBùâ°(c.µEÚğóı`h}6gÍ¬ca¢g¿ÂÄk	>ïˆE±ÌeÅÛ’:—ƒÚ*çÇø—?ğüë‰;¾ÜKX»åŸwSg8p]úÓ›>Nîo^>IO‡·şÍxêo'î¨ Ù€möôÆî5Ï{ô¦&lŸñùjœT¨~E¨sJ@GLÚt Æ¸4÷Œp!W8‡gÉ²¿ñ*¯í+^µ[[¡›ÆRp­–™Y[°¬f|Ñ;ƒfçĞÔ‘T~ˆz„™,ÛÄm(š«îîÅ^—ÏvRÇv§	uÏ³l¸„Ö´Àá”ã^ÍQmWañøÿÅêX¿;-»Ê«{ˆŒïëÔÓÄïÇz'ò 	C¶©*t–	Š ·_À%Ù™"­¦	´ëÙüj+kµ“)ñs…ä›2_‰µUŸ“d_ˆö²¢Y0½ìÿ…PÍj1>o ï0ŞªPİzVÑÒ›¡ôbvv7 É2™A|w“u[ZÅu.óı&«MÛ´RH1›Là½2c¿‘KÂ†‘;š«¥€È1¶&Zøl]/{2X>(ïaÛ‹¿’xÛ‹¯4¸q°S¤ƒ‡‡Tc•ŠâÌó|¯İJ@şXÂçì·ø£R0 nUŞ8oÓ¼x à‘Ñ–ş6ä$EÖõ#ä@Fÿğ¢PZcË/ãH‹Y\U°šSî(¹dO–‘s–âœ~d³¾ í=kwÛ6²Ÿ_dİ¥ÔÈ²İî=ëÔnİÔmsN’úÄi{·NÖKKÌ5ErIÊ¶ùïwfğ $e9éî½×ç´‘D`0æğó/²‹ìÁƒíO?}À>e_Î¢˜³ì"Ì'éb&Óq”LèA”Ìót™±cxF?œçŸ±I{öâù3Ñ…Ëò"Í{	`–û*åùœ‹^Ó°äşììüÛ¢àw|„€YeûÁö6ûõ×_åøT>dü¦äÉ´6ªDßlEığGüïÍETHHğ0æ+/¸ø3céŒ¾grrròÅ˜=/ÙuÇìœ³eÁ§l–§õ˜AW¾=I“"9v‹–æS³2e9/@Wœ	ŒùdY
øl¶L&e½Æ
;q™ ŠA-²˜/xR†¦‹âW</ ÛïY{Ñó×¸Hr²åyM4Ş@ÇèlÎË³“ã'Ô¬åù`3Ş±Í0ŸŸEÉlHÍlü-ó„e~–óŒ‡å `4wÙcöşû3ü÷×áSêğ^¡ôşıû~ØıI4CÖÀ¿OÙ³8bßò’©GL?ù2óp˜ 7 ôwÃ
&¾FOD£7×<¾âFræL?®æŒÏ19sæ?eÛmú×5/IÕøÉº¤•Ÿq*ğ©ƒĞò›Ahdæ3¾°ÉLL–È£…úUıK[±šU
l%a“©-¨÷Ÿ{•4q¯/¢É>ú‰>¨!îõ‹´àÉØ×G)o3Nô§ ğÇ+2>‰f8Q…°“¯Óü’¥‰½‚Ëä2I¯“ÚbyI4¸ª‘íÛÔmÙ>Ì$oúşaÀö\Oè)€¤çAGaŒš-®Â˜Z¼úáÅÇcà!às‚p ²'O¯¢)
0F?±$\p61£×	I4jÀ†uØÁyO´“Ûµ>“9àÌ¾‹‹-üBÂ—Ö$/	eHäÏÇì·—E¾}%Û ‡cb…èÎ‚Æ@úoè‹Ø"*ÏØÛàß$êq „_Óè Q8)9îà°y"Œ;6éG0Ø"YÏ×\éyŠD©Ÿå¼ 5¿åQy±»@Ãlù¤lÃší™pŒW)nfİ’Ú'iÂƒÚƒºKEûCø´ÀMòã–	ôLÕ|š«:l]Şo@Şäë±.A€ex…ÛÄ}7,–µd/a;wø¾ W/±i”ÃŒSè@»3šŞ;XlÖkjZT­39”Èb'BªJ»Kcš8_ô[É ë ¼à`KMØ	R†"ÈÍJI¿½,¦Ÿ	˜/¿ş,ÅE¸+¾Ÿ|w¸´³_Ôo¾9Ÿó›µ¦KÌ
Áz˜/cX"~£÷Êı(É–%­[Ñ±Z—GêGÉTà¾</&yD–Ñ5Æµâ÷Ã¶\®;­ˆ¢ã_.ÎA ±û–ó)Z#Åò\mcÚ )™)™ğ5h— H€GY|¢ÃşqK¿„øs¡À8w»CÊ¯AÁóì†_À®ıJ»äRÖoq‚“µÖˆö"…+rüİñÙ¡4„“D´€õœƒ5Q”[Äùf;{Bµ¿qğ·tÉ&`>ç&ÂX°‰Ş»ğHãØ ²KÖ”Ø²@¦@©ƒÆ, l†Tş:ØÂ<‘0Ä˜I¹Ó&¤%ãy¸¤°¯±=¶iÃ Ì!€G,f0›¾€ÕG+<.RNÁŸ,ÒŒ&$x·Ò6j¥(—çĞ†¥rüU÷§@ÙkÁs 
Ø¤¨IöÀAÃÁÀ¿ÎÃ,ƒÖ:
(É6_Q„ùí˜b³(!Ò—Æ<Èí‡yÖ:,‚ñ±1[‡ @Y8¹ç"€‡KëÎ“b™s#®ş
ÊYXí6~jßüE¿½ƒYkçà‘B¦‡V­‡+pó±UÚëN5FëqC†Uò·>ä7*Ì³<ººä¶tİhA|£Âú:£<  „å÷ONN^°"š'ğğÛõgàíÅsp¶g$æ¦ƒà—8:†CÃİÄ¿Êå<¯ãİ©²`àÓü—à6ÙgÁ·?ƒ*2mò§ıD‚iò¾ùó_¬„;¶'pÿ
†}r7äÏy„ÓÅÀ~Ä³ğ*Œbè…{o$ÖÉ2ËÒÄä	,dXÂÖ/Ã§V/åjßMÄ­'ŸıEÛ‹øÙíÔë³İ'º~îî%YMôR_y8¹X¸‚øİDnE_½Ê ­Öj×4JÎÄ¬°ùÈ$Tc]7Ì%¹¨-	ˆø2ÓkÄp¸8ô©¾¨ï‹S‹¬˜;FO®
ÀàÄb5³ÉlŞ`¾%>Ä¿}FX-Qé¨ÏĞâ°œÿk¡²¢¦Yj„‚Ê=Üßg3PšÖ,6–°;ÆvÇZO¤x5ìo¿U ìyhÂœH¢'L÷ik£Ó@Á¦İ¡Gò/‚ú$glµP#à(™?y)šUÁÆÑÃÇL?7Â?7‡úã ŒÉLÁˆÁ'	Xá ºd{+`¨â…á-à4¹d2J$¾yˆøèƒLø:|¸ˆn0€ë‡+††Y”&z·`D$ó‘T±Z©ÿÿ Ï ÍÌÖÔ'`ew¼Ò ó@Ïy¤fä‹1Óğfû-øód úÙş¾²ÚÂcĞ#Ü b…>Èíõ?TA_Šâm¼k	ğàç£ˆV_„’F,P{„lt°ÙÑ< 
Ù¢nÂË?ÃnX¬ØduKfÑ|™‘{Ã¿!	_?È\øÁæ¬Ú<ßPÜS¨}í›¤ ˆa;¢1m@ICp}1è‡ÂF}İ†ìdqgülö‚Ú6UùŒœƒ}2*)²±f@Âüƒ<œ­å6KkÁ“ƒí)¿ÚN–qüÛ<çŸ³EÊ+ø‡g1PL+~1É±µîÃ¡!ÌI‘Éææ660¼·Ò$šğÁ£cDUYş&ª4Ë=f°Ç$¼ñÛäµaRE©¥"‹£rğZŒ$Ü®è?†¤¶`™»("2ø—“^h27ZàüÀÀ™ŸQËÁ£ÑßÁm?eoËw§ÇÇŸâø§oáoû-?IÆEßšˆÄH8tâS[xÕôt÷1ü;b\:½¯ÿd|}_ã1œÜÃ¨(x9£6¸P© Şeş5Ñ`ÌÖŒ GL€q-›
T0Ş(®Áñ¯ÆJˆÍ°	ê=ã¨3Ú sïíïÑÓD BQ.ŒiäªOJÄĞ0¦Ä@"ˆí}wH¾v	¢Q¤éé©OBjá§Ú“ı&†ü¥2BÓKò{‹gI¨Nù,—Ó½ZN Ok²ı¡pb¢âÇ0¦øå©İ’Üä¾GÇ*Æ_0Ê_\„W2¢]<Œq*¨~énªêúq¸ãäWpI¥œô²%"µûéåõòi2\I=?Ûâ|-‘ã)ædêı<Ö¦e¢0Á(D³(©'ÀŒiÖ’Ü&>V½'5~Fš/dİH«ŞøÅèÓ°bÍ|:áIœ-Yˆ°pâ+bU@Ê‰æôLÙˆö+í-zÚ¶†¤ÂÙ·C\Û£©UÄA¼ñÓ@ƒuj˜Úù!	ÏE
—S¬m€cu>]ûª^fl
6!ı}t3á"²É[÷iÕÜË˜.¸¦:{€ ­ƒ9/_bätÎCøé‘kGŞuó-ó¸}ï§@«­8ºll»gü³Ò°wÑ Rc¼‘cP0VR/*eM˜=3rÇ,ršdhÙçèfO}üƒÛÚ7â6 ò9i$„ù6±=J¶§º¥cæB¢jÈÛ&è61;H‘D¬™*s0ŠĞ|ûö™‹İRX¯´ûêm›OHŠÀ8ÍçßÊë‰t›¥°,¬±Õ*æ„MáeÑ$nzşO£‚'UÅ…`H`Òbeo,#¹²²€“Ø(4«|øAÊÕÇ(”†l—'G”©DĞs£i¾à‚ÒCÏÖÒ}D:T
õ_sêÕ¹è@†$ 9Å2&$Ãr1b‹ğöœË0™ ­Øw!¦íæQ‚ëq¿Æ“,Gj§·³.g¥'‚Á-ÖÙ>•İ#‹®¼¦RÍdïcèht&¸Ÿ­‰t¯­¤ÕİÍw1v›õ®?ˆd¦P.Ö¦„àFŠø×Óaí›G²ğÅä‘Ïm]!ÃcCÅF+zÃªë«cãch6¸ïBäÛ7Hfä $àğÿŞf‘t[c³2½6Ëİ2x:¶ƒÑNêÒy4+ß¥»!Äšú|&Ê+dòm'Ğ.ÅšÍ³û÷‹)Fêã‘oØP¤X®/Dn…ŠãDÕ–2\a° ááJT°>—4”aBÕò`E¥7|Hˆô#–P–>ØøõÁÆ†’pø~¢ß6„lÃú»=üº!GKúòëÏV¨*ÏÑ
kôêÍ0ënOêM1ïên
OŒ¦hE,0/)Ğü°š¤æ’3èìä¬3²$†f€e±ÉÆ†.­ãùıñÑ+ Ò4Ã6ú	½ÉbŠ‡Î2•$3xçy%8XV%Ñ<2äMyUÚãT°>Á¥(¡àÜ±a˜w›Y&‚»òè~õA°öV"LØJzÈ¿GFÖVÁDÁeñ’zµî•sÍ NŠ¬J‘'(”%úFùÊö4Ê‹±«û›”Mr<UBåûÊ_¡²*•­:>‚ÉX)+ŒÑ¹ÀöY
d`[™á>Q6fÛˆ‰WáïU”$.Êk¿Ğ*„UOã`ˆ\2½*Ù_³Ø2ƒÃÊ)[‰UnVQeb7VÇ=‚ğ|òx?Yqs‹M±œZG;P6İuğƒÊ‹ğOoÖûS#*1R­¨Îˆ9ZéÌ=¶ÚYO©I¤?LÀGÒu«fñUV•«cö|Æ¶"äëH=Û|ÿêÅßŒ”ë‘sXÄUmŒç%ÄŞ@²c‰!‚¾AĞ¢A–Ñå
 °·Ø«ïßÔZe1ú‹k…ú.ÔuWÁË3ÜîgätÙŒ}Â«ò¹Ú'Ú°ÄÃ›âÄÒ&şe!”µ•>ivĞQñ‹+{+Sb ™—@GÊŞâ±3¸dcG$T¥T'#¶3bO(éüá¡3ÙEíeU´'§¿*hñ¹fOMÎë7ĞÔÑkş˜í:’eÕZ7@Oê0{lõWÖšßædeôë	ww‡÷Í…îƒ¡Éª¡â‹‡~¾°'…í0N¤~êãÇ¹‡ŞÚ¥ÅÚt<;iãZÌÿG?5Åæu§¥QÃ<új!¥­j*#AM^ôÛä‹ê eìÜÏrd_1°“²Áû¶‡‚§µW$ó}¢\›‘%ÛàR	äı Ş–²›ìr¦JÁ5Ø:-®‡´Eea§GuNKG»Çggß<qtv6¶U	ypgÜ‚/ÑñE@ó¹u Lv‚{`09ô²³L>éÔdÒHU™ßŒ(ôIcş ­Ešd‡J6­¨ky2uiZ2»Õ³~šZwëÙ.­ŠQö-nÈ+Å)(®>
Ôº‹Á)5Mës:•¹Kó4>©ï¨ƒ)GbF=y¢ÿ¨`#RÑ€s(í¹á~v0‚2×óeÒåJW9ÏÉtÊHË“˜Y½£í<TÅçìèFœóX„—`ÜáQ2L¯9¢Ó4±œ×æ,N‡(©¦Û „äƒT¸ñm3ŠZ G¨S1Ò³-`y
LDOÙ9†õ"èSR+¶7ÊTCLæÃ'aòS•|°F#fC“âA•Î6p2¼*:³Î°F{ãl?+Ä¢rt—ŞYEøÊ2Ÿ»+wÚn<óAf4.\eĞ§ÑøÖÕ˜N¹8 G®Æt ÑÑ8v6®Ñ8s5&Áê€\¸GÉ•@Ûj|ãnŒ®f²ÑöÁ†0·ê.xKÌĞP$«¸Îª•%&¨Ñ” ^(ğÕr6ãX®µ bht]›S—Îš}˜üux‚èÑtÓŒ±@ëhÅG’Š#É.£j	4Â[´t”™ÿuÈ}hB¬VFNÓµ¹5#äœ[ßE}TæNÚ›W±d“Û&šİÜ	´ù/VúLıe¼šä!•	E{¨!÷íÏÜJJUğ1æWœ[Zià¯~~Òoä)Ÿ…Ë¸ôŸò:øáÓN°Öé/ÅW?9*¶„ª1‡*ŸäØè!ôN³ÚVÏÁØ/;wºgÚ°:§ÓêaX«±³#.Ë­‡Ğ¸ßn~gcºåE.çú¬!†§sPÒƒFIÁóR¯KUiçµ]D¶Ú˜äuRQ·Ø9BuõÒr›z‰ozmµF“×"á7#F	åä7ÏiúiŞ1ºT1äyrÅ1uWëomP†"¥ù‰×ËºÆlš‰³<r|µ<×ª`E+
6ÄyšÆ<Lˆ$Uø'™bC4Ç»¨J<’¬Î‡×N»´İ@4µ™nİĞ¤ƒ+ê	ê_4¾*~ç0X%W7$}¡ÏDÚ´8ñ©¸ZÕ¹ÓáhÌHı«u®›0&SÀk>YæìŒ¯«*vQh=íè¨ÚWı ™­Ï¥:#27u9ÂUP†%HjÜ¢Í€­V±¼s_¨a4 çHÍJ3m |´¨şÕä‹¬¼UÎ1¢ÚC,{ÍÃø8,/©£Öïíç&Ú9p#h'Ës†·í†#1¼Á(;¯pxÂ(’ËxŸ"¹ªöyIur²J;©rÁ‡©•«QË¥»ÂÊ)kUWt×C¨¯ói×t––ñkˆ¯ê ¾ÉËz}¹ÕO”á©~â%4}h>ºƒ^‘š×‰ùúWz@TØTº  ÿÄ¸IÍ…¶RBˆíáÔD–Ö=áñ’¾ûêÆÁ8œğA°½1'üŸxn0+Õ†ÄÈ[[ì€í "€]kœw–è €aKv¨ZıÕ,²Ç»M	FºHÏ†Tİ÷•9„P>Ê$¬LÅÉEÊ‰Î®­™§âÉ;w
äc…šr;´²º/GCaQÙıÏ×ğİÛİƒìtPùƒ5g`ß›Giƒš9CŞ°%êò‹m»eÇf&ì@ÛÌ”7NQ©àæ¬¶Ù[q]•à®¶7­äáYgÍ†ºÖYötµU©µÆM $‚¦†¥á5´¤=&œ_›nÇÅâ1œ-ûFM55ŞQšŠ*á‰™³’ e	Š ÕŠh€º2¥=Ü$õ #ùHbb]|ÑÛÊçêDTvaKğî™­»&·¬q?GÃŞ…‹W…ÌHˆîe¾ä¶h‹ã3pmó3\«\1¹MÅ­¾n—E—¢$·Ö–íªÅÃò1{—âYu4¹z/T#oAŞO˜ËÀñÆŠV{ÃÜ[g‡ƒ2¥Ñ˜³
íÖ((ëš´.¿n™xUBWºëÅÚ¦Ü(û&ºQÙ¹e¨¶ŒQ×Œ_/çd1seN›Ò½O¾Ê9i/Øz¡nU­6Şä\‹·æea´ËpÔ¨Æ”r:HkµhßÀy6D%/ãıÅŞ¨6ŞíEJÌ,y¥íP)IE–2Ş­âxw"^îívd™ôì¦Õ¡Ş˜QÂ~xı‚‰Ââş%m´ø€[´‹¸EÙk{I67’¼2¨Z¹yf‘.­mv½Õ¾Å¶j¯­$z‹'¡7C+SÖW6Ôş¸ÂÿD}~hëzaLÿ¶õy¦F¼û VËÓîP˜û”ß”xwx—D92šy7ŠC¦˜—‚ÒP"t£Ñî/P$¢^™"1T"D]«b·†DéA©JRÔée”~Ø¥âtÀS¢®†õj‘6+£{·`òÑÔ[nn§»Ö˜ËØaI°À¼şX]`Œeñ¹ùWoªï³Ô?U® ]¶)H
Ò§TÕÛ`ü6šUÙëb·I#Ã Øõ°>ª¯¥ĞË¯<ôD:ïÇ¢ò²‚ğo|…Ò	ŸI•`bÂU‡6I—I)c~·ó‹ï“<w|Ó ÀK3_ã]Ó±ã.o•¡œüsºóÎêô ù©"-DŸrœsŒ)í«D0`Œ¹ *N3Ó;ç<1/lÄNêZš »Å;ñÑ°9°ŠQŠ¦;²¡U,¾yóDÀ¥kô°q­Ì¤¿ÒlINaw[)ú¢`ÂÀÓÑ–Ji®hÙCÙ›ó¨’a3™\‰ñF]qÌ}Léb€u¨”L—§§ÔOÃ.ªë”g°€ô)yEÏúñSˆ7ƒÅSî»õ§ŠúyÌèg…0î+¨ä±'¡îk“ù
ùÉ8±[wÜ»Öb`Å%lIDÜJ$ÚxæÎ•‰Rıl·V9&
ÇªMAÃ 4s/HÁ"ÄÓ=cêì‘rµUé©3tJ=L?_çQ‰)¹îøW—ÚñO™¼]%ö¦®Û|Ìoµ/‹KL„7h­»”q\ É#M¾œ¤ìT\CÒi¿²ñxLÓª›­.‰]uH/W0rÛlÉ)G‚Ù{ÿkú•.Ñ¢Tˆ«Ó€Ö1ô#¸yıU·}+pò™·D®†™é+w7lİÔ l"Ø¶Êz×‡1Ñà¤.Æ;ÄÜ–ª)	ä™Ú²f»Ö/¶é¶WÛiÔ´Vlcõ.f\³Ğí·ôÎ½†³
šD¼‹¯$§H662ÈÕ[W»Û`óĞBW›vÛ(*ŸYkÉAvoAª|¾L(Fn&Ëª‡mµpwÙ»
8pÁ1‘SeºZ]fgoÃ–=ëp\gœŠÿzoa¬ò¹§Xé _¯Âª3ŞÒK]Ç-õTÊB‰Ğz=^÷sMÂüxòM;]Â~ şıÿqãsÜØXŒ»ú³5ÓÊhÖşR¬áÄŠ]¿£ZºËxºÅŸ“MUzŞ’içYÔGR®’¼T…C}@ôHtmEµkË!…ÚÜZ|àŠ«‚ó÷­ò÷#Sm„ú§{)ßö1/*
:) :ÓŞOÆQıÌˆü˜•[-L¼Õƒ#•*ë·¡Lœ¼Ì¼GÀÈrhŸ7o(á–¤†hE9'ïoU"P$óŠÄCuS	]Õ³b±ˆ©Äº¬YãReí›=ç^T5é¯RÏ¿ÉŠ…ZwW€f{ÛÛD¼`}q_—°>šoh§ÙÎ&#Æ%'z‡½(gß¤ÜJ‡ètág9¿Ò³>§×ªÖkÔj…Òvâè.k¯…Á¼¹ößò²–Ò!‚ÑM9ò)tÙ×†$±Å\Oy5o‘WßvÉ+ŸÀ?µŸÄB‡ö~EVÉûˆ,3>WÏÉKaeI1‚èGi³ÒDÿFÌAR;	~RQ”™d¯È'x=¥3Ö|¡®é2É¨—BEJUWšƒ-+y±š<ÄUpG{g&êGG›òM·¤ğ&lëJ‘‘Ô"}9£Œ²¶Âôó3³±Jf;]ï@{¤ÒaKºº¿$ªŠ‚=’Hag² €ú†eÂ×†…º¼’"(ëˆ’I7Qó¹MT·0i&›'õnİò£‹>MññŒßGà®sáö÷ÑÁH¬®´S½óı±¹p–Ø(ƒ§+¼­~ ı^İ1wŞµ[MuÕ£÷D÷™„»Á­¼'î:Ñö³}fØ<Õ½úÔV;HQ3'£yãpA£lYŸ¿ƒZ)Tß¾ù6v­y½ş
ùµ,Ò’èÊÕĞ§Dk
Ä¦b´eúMíñİí}h®Ù“áèãRÍkÜ×RwaáÓ#ìwºfíËPV»[á.»ßß»@»’Ş-ÒŒ]´íçŞ›V!Ñºqúíö•‹*”U­jÅe¿Æï)´v§àîÃjhÎY½nŞÀ.@Şb¨2ÌËhBYŠ(™Ò•
t7ñåH-ïEö„†¦‘a8÷­Ä™°…ÅÍİ¡$¡|»;pâR¿ûI¤NÄ˜} ;eW<·×0ÀB
ùbt¤:—×p‰aÕ[£D±HÛ p°Jùs6‹s}K³dñ+ôØ³C$«¢±°4]^ÂÿEÒ*¾ey(ğâ(ŠŠiÖÑ}¶•Ö
{Ë[ÌJlYÅ»µC×>kj~ùò>TÄCpİá$„'>êÌÔx´ÈKÉXn Fª¢·rñî>İRlP«å¥«%q€İrq÷L—>Ã7uàëeğÒiîºÁºJ­ˆÿÂˆÍ4ª2Ğªë¼ZÌÕeQ¿_¼Ñ¹ö‹”Ğ&òQ'Ğ¼ÈÖÈ[¨Î²¹à¥!kBX¼6*TªÃ8åâí€ÅóéíïÇCNcÑKÊ‘së3ïSË4¨jŠå4RZè·îÛ[Øâ>C”4Á;ñjˆ ´îRîÓaDu…p•!7_Í“ÖÃBôôTÊtÚw]ZS#"ÙÃÌ‹ÓÆÃ2±±ÓèÈV¸M¼fÎB\ûòŸfåéû9ÅøªH´1†6…ÂÄ¶Ÿ¥GçŒ*4&[jz™xYEAÏ$”×bÒ­kquğ?´S\|'[úõOu1½ËØº'[«“ÊØrÂË5l¨ÓÍ[©»­šæ[ÍĞrfĞ~C«¿êïZÍğ{ñUÊT3ç5ãTDc¿º ®ü	¡[¬¨.VMäcN@+ÿV³ÉwãD‡µên`5B”â5îh¾µ¦ÍÙêï¬jğõ£¦†ï|›E?£ÖæËH©Cº{¨˜vó”7^"ì²IT³Õmè©‡_Í$^“D#Xİ*ñ™	XÀzi°Úºß§ç •òwFuDÑ»´Y\¸)¾ ^HF¼lîTË;,EËà:Â‹?ËûQÔn¦xÆŒ¤«d
u¢ ÚuQã¦Šº…>¨¢îØJQİÜ–B@í
ÙÕ §Bvç?A!÷’ÿ+kmüë)€iR¦jó†6İ€¾,Ó©¸àt`lºi’Áfä=m{ü$Òï€~ã'yf¥¦›Wpi¯fBÌSƒsÙ ö¯r2oşôX5+pÃú\ĞÎ+,ÿ¡½üÿ/¾òBßÙ.A}Şº/ê6ÉsÕf¥7a–òL£ªZ!sİZ$¦"Fëgx|u[%I„şÎÒ¢ˆäm·J™2lËPÂ:úİI\« êyç+#›jİ$k/¼ªMÅ~/z½‹ ¨Ó]Ü¥ë!ë¥İ:Ú9Çôs­+Sä¦ÓÙéÚ}Tél¯kŠ»ê}ˆ¯ôh
XÑÿ4 ÇTşÚèâõ
ŠWx âë·èHÕ¾úşÕ‘QMëê:»Ò(§½IZüøÔÛËî`¶5ï6œà1¤ïAË¥óWº¤ù«üÙ‚àüuáüK‹Âx®×.øöç`ÿ ßõÕÏOğ“¹˜ê<RŸ‹-è´ìææ[-Çëä#6Ö[Q¡ÊùÔ­Šå¬mIï3ø§‚v‚¾¯C¥yÆÖõtŞÔ¤İ)ÒìÁ_­ğ±T­{ \÷ı´®d‰$sªåÆÉ±]<ëİiyIÆµqw¿yFîÂ#q 6¢ñ·/yÏ–[§Áºö˜O·¨òXlá¥§ı³fk¾»ıü…Ô¾Å@­İ°,ó]£±EÇtpm°ë¾\§ÖaTc1L{sPK[”Ğ‹¬¤r6>ÿişÉ'xà‹/`¥}Êvwv†l[=Ù£ïÍ?lÍãôœÎC0C	Õa¶ ¨V‡ ,<ëƒåúÆÜÕú¨ëšeı.¿Ô—|¨[àhmAÇÚµ&¯ù¿–¼À0ˆÍÔÓ0®{êF½ˆ^Ö­·o„-]7;Åu…aIE•Bşú"š\Ğı»€gCÜcÿEx3PÄ¤ÖøŞ‡¸}àU³MÆ,ØÃKjä]ø<,CŒñ¢'¶ÅêÈà«¤|£ƒÖ]\+[¹m¯ãG£ÙÇr<$j+úôú"½Šò4Y¨ò-|P¦iÌ$Üu|	Õ,w¢j>‡B_İ§è XÃ­¨¿Ló?Â¥pMq¤4^ã„W?Áÿy‚-ÎèåtPóš66mkWZllàë€ÕjÑÙE¦‡©FŠ®vSK$î/Ü|Í¯"ü
jbüç¿ŸŒÿÂ6İ‹NFı÷›Z'òæPYĞ7Á+ŸáUÅxÕ ÛPŸ× 	ë,Ì¢+|Uã-¼nZ»Ÿ¡ NxÏ¸hö¦¥•BR´üùùqÏ–x
Å|	5i®Ì/qtHléÔF>h^È.Å2ËR¼­½*/lÚş3€ª#©‚NôZÙO{ˆäèÍ™W666/ÅÅz;øEKxÅ=(ã/…|Âó_±›ê*„>´ğ¾Ì÷ğßãÇô¬*#˜ò*F|Ç4Ê_‹ÑF¸‚ùœŞ4}õ.Ô ¡ÓhÒÔyôÉÖæ¯8îû‚±O
P b.Ç {F8˜@®!Ş?¾8xğ?’AOƒ@…Ïì¯˜£6±T/4ÖÚ‹š4ö˜)°qYÈì.jˆÿİjj	iË…ÌûŞ¼}K¸Ÿ×E­T<™(˜Àc¦A] OµMzEÛœ«PÃZÄ^Ø²¦ƒÎíE¾¨`…œOqN;”¢'çf6»…«ş%z‡ºmXVe‰6•9VqmÛşËúôdS×oN
İĞ_×÷Ön:Öv^]Ö†J²½®ì©Ú±\Og}·ã¥öá^)	²ÛĞ‹'F_±jU”›tÇBN~£s‹>0]\ªHXÄ$“…£;}«CÿÂhtçx™>´M¤A£Ós"¤:Ë-Æ2ŞékL¶ò9Æôİ²Ğ&•¸3ï9°ÓVäQ~&Ã²}o|Ø!7@ç?,ÄoÙ§ÿÆ0 —I¹ùÓat~ß   GBMB