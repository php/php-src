From de74c24d95342280266ebdac6f8dabc70ccfacab Mon Sep 17 00:00:00 2001
From: Niels Dossche <7771979+nielsdos@users.noreply.github.com>
Date: Thu, 24 Aug 2023 22:57:48 +0200
Subject: [PATCH 3/6] Patch utilities and data structure to be able to generate
 smaller lookup tables

Changed the generation script to check if everything fits in 32-bits.
And change the actual field types to 32-bits. This decreases the hash
tables in size.
---
 source/lexbor/core/shs.h             |   4 +-
 utils/lexbor/encoding/multi-byte.py  | 181 +++++++++++++++++++++++++++
 utils/lexbor/encoding/single-byte.py |   2 +-
 utils/lexbor/lexbor/LXB.py           |  12 +-
 4 files changed, 193 insertions(+), 6 deletions(-)
 create mode 100755 utils/lexbor/encoding/multi-byte.py

diff --git a/source/lexbor/core/shs.h b/source/lexbor/core/shs.h
index 7a63a07..c84dfaa 100644
--- a/source/lexbor/core/shs.h
+++ b/source/lexbor/core/shs.h
@@ -27,9 +27,9 @@ lexbor_shs_entry_t;
 
 typedef struct {
     uint32_t key;
-    void     *value;
+    uint32_t value;
 
-    size_t   next;
+    uint32_t next;
 }
 lexbor_shs_hash_t;
 
diff --git a/utils/lexbor/encoding/multi-byte.py b/utils/lexbor/encoding/multi-byte.py
new file mode 100755
index 0000000..f8af2d4
--- /dev/null
+++ b/utils/lexbor/encoding/multi-byte.py
@@ -0,0 +1,181 @@
+
+import sys, re, os
+
+# Find and append run script run dir to module search path
+ABS_PATH = os.path.dirname(os.path.abspath(__file__))
+sys.path.append("{}/../lexbor/".format(ABS_PATH))
+
+import LXB
+
+class MultiByte:
+    var_name_prefix = 'lxb_encoding_multi_index_'
+    hash_name_prefix = 'lxb_encoding_multi_hash_'
+    flat_index_typename = 'lxb_encoding_multi_index_t'
+
+    def __init__(self, dir_path, temp_file_h, temp_file_c, save_to, silent = False):
+        if not os.path.isdir(dir_path):
+            raise Exception('Directory "{}" not exit'.format(dir_path))
+
+        self.dir_path = dir_path
+        self.silent = silent
+        self.temp_file_h = temp_file_h
+        self.temp_file_c = temp_file_c
+        self.save_to = save_to
+
+    def make(self):
+        buf = []
+        externs = []
+        hash_externs = []
+        hash_buf = []
+        hash_sizes = []
+        dir_path = self.dir_path
+
+        for f in sorted(os.listdir(dir_path)):
+            f_path = os.path.join(dir_path, f)
+            if not os.path.isfile(f_path):
+                continue
+
+            print('File: {}'.format(f_path))
+
+            idx = 0
+            values = {'buffer_size': idx, 'max_size': 0}
+
+            fo = open(f_path, "rb")
+
+            for lineno, line in enumerate(fo):
+                line = line.rstrip()
+                if not line or line[:1] == b'#':
+                    continue
+
+                entries = line.split(b'\t')
+                captions = entries[-1].split(b' ', maxsplit=1)
+
+                if not captions[0]:
+                    raise Exception('Failed to get chars variant on line {}'.format(lineno))
+
+                entries.append(captions[0])
+                entries.append(captions[1] if captions[1] else b'')
+
+                entries[2] = entries[3]
+                entries[3] = len(entries[2])
+
+                idx = int(entries[0].decode('utf-8'))
+                values[idx] = entries
+
+                if values['max_size'] < idx:
+                    values['max_size'] = idx
+
+            values['buffer_len'] = len(values)
+
+            flat_name = self.make_name(f)
+            res = self.make_flat_index(flat_name, values)
+            hash_index = self.make_hash_index(flat_name, values)
+
+            buf.append(''.join(res))
+            externs.append('{};'.format(self.make_extern_name(flat_name, self.buffer_size(values))))
+            hash_buf.append(''.join(hash_index[0]))
+            hash_sizes.append(hash_index[1])
+            hash_externs.append(hash_index[2])
+
+            self.save_res(flat_name, ''.join(res), ''.join(hash_index[0]))
+
+            fo.close()
+
+        externs.append('')
+        externs += hash_externs
+
+        save_to_h = os.path.join(self.save_to, "multi.h")
+
+        lxb_temp = LXB.Temp(self.temp_file_h, save_to_h)
+        lxb_temp.pattern_append("%%EXTERNS%%", '\n'.join(externs))
+        lxb_temp.pattern_append("%%SIZES%%", '\n'.join(hash_sizes))
+        lxb_temp.build()
+        lxb_temp.save()
+
+        return [buf, externs, hash_buf, hash_sizes]
+
+    def make_name(self, filename):
+        name = re.sub("[^a-zA-Z0-9]", "_", filename)
+        name = re.sub("^index_", "", name)
+        name = re.sub("_txt$", "", name)
+
+        return name
+
+    def make_var_name(self, name):
+        return '{}{}'.format(self.var_name_prefix, name)
+
+    def make_hash_name(self, name):
+        return '{}{}'.format(self.hash_name_prefix, name)
+
+    def make_extern_name(self, name, buffer_size):
+        var_name = self.make_var_name(name) + '[{}]'.format(buffer_size)
+
+        return 'LXB_EXTERN const {} {}'.format(self.flat_index_typename, var_name)
+
+    def buffer_size(self, values):
+        return values['max_size'] + 1
+
+    def make_flat_index(self, name, values):
+        buffer_size = self.buffer_size(values)
+
+        print("Flat buffer size:", buffer_size)
+
+        res = LXB.Res(self.flat_index_typename, 
+                self.make_var_name(name) + '[{}]'.format(buffer_size), False, None, 'LXB_API')
+
+        for idx in range(0, buffer_size):
+            if idx in values:
+                entries = values[idx]
+
+                assert len(entries[2]) <= 4
+                res.append('{{{{{}}}, {}, {}}}'.format(toHex(entries[2].decode('utf-8')),
+                                                             entries[3], entries[1].decode('utf-8')))
+                res.append('/* {} */'.format(entries[4].decode('utf-8')), is_comment = True)
+            else:
+                res.append('{{0}, 0, LXB_ENCODING_ERROR_CODEPOINT}')
+                res.append('/* Not defined */', is_comment = True)
+
+        buf = res.create()
+
+        return buf
+
+    def make_hash_index(self, name, values):
+        buffer_size = self.buffer_size(values)
+        name = self.make_hash_name(name)
+
+        hash_key = LXB.HashKey(buffer_size, name, 'LXB_API')
+
+        for idx in range(0, buffer_size):
+            if idx in values:
+                entries = values[idx]
+
+                key_id = entries[1].decode('utf-8')
+
+                hash_key.append(key_id, idx)
+
+        return hash_key.create(rate = 1)
+
+    def save_res(self, filename, buf, hash_buf):
+        save_to_c = os.path.join(self.save_to, filename + ".c")
+
+        print("Save to:", save_to_c)
+
+        lxb_temp = LXB.Temp(self.temp_file_c, save_to_c)
+        lxb_temp.pattern_append("%%INDEX%%", buf)
+        lxb_temp.pattern_append("%%HASH%%", hash_buf)
+        lxb_temp.build()
+        lxb_temp.save()
+
+def toHex(s):
+    lst = []
+
+    for ch in bytes(s, 'utf-8'):
+        hv = hex(ch).replace('0x', '\\\\x')
+        lst.append("'{}'".format(hv))
+
+    return ', '.join(lst)
+
+if __name__ == "__main__":
+    sb = MultiByte("multi-byte", "tmp/multi.h", "tmp/multi.c", 
+                   "../../../source/lexbor/encoding")
+    sb.make()
diff --git a/utils/lexbor/encoding/single-byte.py b/utils/lexbor/encoding/single-byte.py
index 9a85d54..ec2023c 100755
--- a/utils/lexbor/encoding/single-byte.py
+++ b/utils/lexbor/encoding/single-byte.py
@@ -128,7 +128,7 @@ class SingleByte:
                 entries = values[idx]
                 key_id = entries[1].decode('utf-8')
 
-                hash_key.append(key_id, '(void *) {}'.format(idx + 0x80))
+                hash_key.append(key_id, idx + 0x80)
 
         return hash_key.create(rate = 1)
 
diff --git a/utils/lexbor/lexbor/LXB.py b/utils/lexbor/lexbor/LXB.py
index 3e75812..2370c66 100755
--- a/utils/lexbor/lexbor/LXB.py
+++ b/utils/lexbor/lexbor/LXB.py
@@ -94,7 +94,7 @@ class HashKey:
     def append(self, key_id, value):
         self.buffer.append([self.hash_id(int(key_id, 0)), value])
 
-    def create(self, terminate_value = '{0, NULL, 0}', rate = 2, is_const = True, data_before = None):
+    def create(self, terminate_value = '{0, 0, 0}', rate = 2, is_const = True, data_before = None):
         test = self.test(int(self.max_table_size / 1.2), int(self.max_table_size * 1.2))
 
         rate_dn = rate - 1
@@ -142,9 +142,12 @@ class HashKey:
             entry = table[idx]
 
             if entry:
+                assert entry[0] < 2**32
+                assert entry[1] < 2**32
+                assert entry[2] < 2**32
                 result.append("{{{}, {}, {}}},".format(entry[0], entry[1], entry[2]))
             else:
-                result.append("{0, NULL, 0},")
+                result.append("{0, 0, 0},")
 
             if int(idx) % rate == rate_dn:
                 result.append("\n    ")
@@ -154,9 +157,12 @@ class HashKey:
         if len(table):
             entry = table[-1]
             if entry:
+                assert entry[0] < 2**32
+                assert entry[1] < 2**32
+                assert entry[2] < 2**32
                 result.append("{{{}, {}, {}}}\n".format(entry[0], entry[1], entry[2]))
             else:
-                result.append("{0, NULL, 0}\n")
+                result.append("{0, 0, 0}\n")
 
         result.append("};")
 
-- 
2.49.0

