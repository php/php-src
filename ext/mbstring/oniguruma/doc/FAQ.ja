FAQ    2006/10/30

1. 最長マッチ

   onig_new()の中で、ONIG_OPTION_FIND_LONGESTオプション
   を使用すれば最長マッチになる。


2. スレッドセーフ

   スレッドセーフにするには、以下の(A)と(B)のどちらかを行なえば
   よい。

   (A) Oniguruma Layer

       oniguruma/regint.hの中のNOT_RUBYの部分の以下のマクロを定義する。

       USE_MULTI_THREAD_SYSTEM
       THREAD_ATOMIC_START
       THREAD_ATOMIC_END
       THREAD_PASS

       何らかの初期化/終了処理が必要であれば、以下のマクロに定義する。
       THREAD_SYSTEM_INIT
       THREAD_SYSTEM_END


   (B) Application Layer

       同時に複数のスレッドが、正規表現オブジェクトを作成する、
       または解放する、ことを行なってはならない。
       それらのオブジェクトが全く別のものであっても。

   もう少し詳しい説明は、このドキュメントの中の
   "スレッドセーフに関する補足"に書いておいた。


3. メーリングリスト

   鬼車に関するメーリングリストは存在しない。

//END



スレッドセーフに関する補足

スレッドセーフにするには、個別のアプリケーションの中で行うか、
Onigurumaライブラリの中で行うか、どちらかを選ぶことができます。
(Onigurumaを使用する側で対処するか、Onigurumaに対処させるか
どちらか片方で行う必要があるということです。)

これらの方法について、以下(A)と(B)で説明します。

マルチスレッドAPIは、それぞれのプラットフォームによっても
異なりますので、以下の説明の中で具体的に何を呼ぶのかを
書くことは無理です。実際に使用されるマルチスレッドAPIで、
対応する機能のものを指定してください。

(A) Onigurumaの中で対応する場合

oniguruma/regint.hの中のNOT_RUBYで囲まれている部分の中で
以下のマクロを定義して再コンパイルしてください。

USE_MULTI_THREAD_SYSTEM

  単に有効にすればよいです。

THREAD_ATOMIC_START
THREAD_ATOMIC_END

  THREAD_ATOMIC_STARTからTHREAD_ATOMIC_ENDで囲まれた
  プログラムのコード部分をあるスレッドが実行中に、他の
  スレッドに実行権が移動しないことを保障するものに定義
  してください。
  (名前の通り、囲まれたコード部分をスレッドアトミックに
   するという意味)

THREAD_PASS

  これを実行したスレッドから、他のスレッドに実行権を委譲
  するものに定義をしてください。(再スケジュールを呼び出す
  という意味)
  対応する機能が全くなければ、空定義にしてください。

(参考例)
Rubyの場合を例にすると、
Rubyは自分自身で独自のスレッド機能を実装しています。
その機能を使用すると、以下のように定義すればよいことに
なります。

#define USE_MULTI_THREAD_SYSTEM
#define THREAD_SYSTEM_INIT
#define THREAD_SYSTEM_END
#define THREAD_ATOMIC_START       DEFER_INTS
#define THREAD_ATOMIC_END         ENABLE_INTS
#define THREAD_PASS               rb_thread_schedule()

Rubyの場合、タイマ割り込みを使用して、スレッドの切り替えを
行っています。DEFER_INTSは割り込みハンドラの実行を一時的に
止めるためのマクロです。ENABLE_INTSマクロで割り込みハンドラ
の実行を許可します。
これによって、THREAD_ATOMIC_STARTからTHREAD_ATOMIC_END
で囲まれた部分の実行中に、他のスレッドに実行権が移動しません。


(B) アプリケーションの中で対応する場合

以下を保障するように、スレッドの実行を制御してください。

同時に複数のスレッドが、正規表現オブジェクトを作成する、または解放する、ことを
行なってはならない。それらのオブジェクトが全く別のものであっても。

onig_new(), onig_new_deluxe(), onig_free()のどれかの呼び出しを、
複数のスレッドが同時に実行することを避けてください。同時でなければ別にかまいません。

これは何故必要なのかというと、正規表現オブジェクトを作成する
過程で、内部で共通に参照するテーブルがあります。
このテーブルに対してのデータ登録処理が複数のスレッドで衝突して
異常な状態にならないために必要です。

// END
